<!DOCTYPE html>
<html lang="zh"><head><title>传输层</title><meta charset="utf-8"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=IBM Plex Mono&amp;family=Comic_Sans_MS:wght@400;700&amp;family=Comic_Sans_MS:ital,wght@0,400;0,600;1,400;1,600&amp;display=swap"/><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin="anonymous"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="og:site_name" content="😶‍🌫️ Notes"/><meta property="og:title" content="传输层"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="传输层"/><meta name="twitter:description" content="基本概念 传输层的功能 物理层、数据链路层和网络层，它们共同解决了将主机通过异构网络互联起来所面临的问题，实现了主机到主机的通信。然而在计算机网络中实际进行通信的真正实体，是位于通信两端主机中的进程。 传输层位于网络层之上、应用层之下，它为运行在不同主机上的进程之间提供逻辑通信。 传输层属于面向通信部分的最高层，同时也是用户功能中的最低层。显然，即使网络层协议不可靠（网络层协议使分组丢失、混乱或重复），传输层同样能为应用程序提供可靠的服务。 ..."/><meta property="og:description" content="基本概念 传输层的功能 物理层、数据链路层和网络层，它们共同解决了将主机通过异构网络互联起来所面临的问题，实现了主机到主机的通信。然而在计算机网络中实际进行通信的真正实体，是位于通信两端主机中的进程。 传输层位于网络层之上、应用层之下，它为运行在不同主机上的进程之间提供逻辑通信。 传输层属于面向通信部分的最高层，同时也是用户功能中的最低层。显然，即使网络层协议不可靠（网络层协议使分组丢失、混乱或重复），传输层同样能为应用程序提供可靠的服务。 ..."/><meta property="og:image:type" content="image/webp"/><meta property="og:image:alt" content="基本概念 传输层的功能 物理层、数据链路层和网络层，它们共同解决了将主机通过异构网络互联起来所面临的问题，实现了主机到主机的通信。然而在计算机网络中实际进行通信的真正实体，是位于通信两端主机中的进程。 传输层位于网络层之上、应用层之下，它为运行在不同主机上的进程之间提供逻辑通信。 传输层属于面向通信部分的最高层，同时也是用户功能中的最低层。显然，即使网络层协议不可靠（网络层协议使分组丢失、混乱或重复），传输层同样能为应用程序提供可靠的服务。 ..."/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/><meta property="og:image:url" content="https://kisgp.cn/static/og-image.png"/><meta name="twitter:image" content="https://kisgp.cn/static/og-image.png"/><meta property="og:image" content="https://kisgp.cn/static/og-image.png"/><meta property="twitter:domain" content="kisgp.cn"/><meta property="og:url" content="https://kisgp.cn/计算机基础/408/计算机网络/5_传输层"/><meta property="twitter:url" content="https://kisgp.cn/计算机基础/408/计算机网络/5_传输层"/><link rel="icon" href="../../../static/icon.png"/><meta name="description" content="基本概念 传输层的功能 物理层、数据链路层和网络层，它们共同解决了将主机通过异构网络互联起来所面临的问题，实现了主机到主机的通信。然而在计算机网络中实际进行通信的真正实体，是位于通信两端主机中的进程。 传输层位于网络层之上、应用层之下，它为运行在不同主机上的进程之间提供逻辑通信。 传输层属于面向通信部分的最高层，同时也是用户功能中的最低层。显然，即使网络层协议不可靠（网络层协议使分组丢失、混乱或重复），传输层同样能为应用程序提供可靠的服务。 ..."/><meta name="generator" content="Quartz"/><link href="../../../static/font/font-style.css" rel="stylesheet" type="text/css" spa-preserve/><link href="../../../index.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" rel="stylesheet" type="text/css" spa-preserve/><script src="../../../prescript.js" type="application/javascript" spa-preserve></script><script type="application/javascript" spa-preserve>const fetchData = fetch("../../../static/contentIndex.json").then(data => data.json())</script></head><body data-slug="计算机基础/408/计算机网络/5_传输层"><div id="quartz-root" class="page"><div id="quartz-body"><div class="left sidebar"><h2 class="page-title"><a href="../../..">😶‍🌫️ Notes</a></h2><div class="spacer mobile-only"></div><div class="search"><button class="search-button" id="search-button"><p>搜索</p><svg role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title>Search</title><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"></path><circle cx="8" cy="8" r="7"></circle></g></svg></button><div id="search-container"><div id="search-space"><input autocomplete="off" id="search-bar" name="search" type="text" aria-label="搜索些什么" placeholder="搜索些什么"/><div id="search-layout" data-preview="true"></div></div></div></div><button class="darkmode" id="darkmode"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="dayIcon" x="0px" y="0px" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35" xml:space="preserve" aria-label="暗色模式"><title>暗色模式</title><path d="M6,17.5C6,16.672,5.328,16,4.5,16h-3C0.672,16,0,16.672,0,17.5    S0.672,19,1.5,19h3C5.328,19,6,18.328,6,17.5z M7.5,26c-0.414,0-0.789,0.168-1.061,0.439l-2,2C4.168,28.711,4,29.086,4,29.5    C4,30.328,4.671,31,5.5,31c0.414,0,0.789-0.168,1.06-0.44l2-2C8.832,28.289,9,27.914,9,27.5C9,26.672,8.329,26,7.5,26z M17.5,6    C18.329,6,19,5.328,19,4.5v-3C19,0.672,18.329,0,17.5,0S16,0.672,16,1.5v3C16,5.328,16.671,6,17.5,6z M27.5,9    c0.414,0,0.789-0.168,1.06-0.439l2-2C30.832,6.289,31,5.914,31,5.5C31,4.672,30.329,4,29.5,4c-0.414,0-0.789,0.168-1.061,0.44    l-2,2C26.168,6.711,26,7.086,26,7.5C26,8.328,26.671,9,27.5,9z M6.439,8.561C6.711,8.832,7.086,9,7.5,9C8.328,9,9,8.328,9,7.5    c0-0.414-0.168-0.789-0.439-1.061l-2-2C6.289,4.168,5.914,4,5.5,4C4.672,4,4,4.672,4,5.5c0,0.414,0.168,0.789,0.439,1.06    L6.439,8.561z M33.5,16h-3c-0.828,0-1.5,0.672-1.5,1.5s0.672,1.5,1.5,1.5h3c0.828,0,1.5-0.672,1.5-1.5S34.328,16,33.5,16z     M28.561,26.439C28.289,26.168,27.914,26,27.5,26c-0.828,0-1.5,0.672-1.5,1.5c0,0.414,0.168,0.789,0.439,1.06l2,2    C28.711,30.832,29.086,31,29.5,31c0.828,0,1.5-0.672,1.5-1.5c0-0.414-0.168-0.789-0.439-1.061L28.561,26.439z M17.5,29    c-0.829,0-1.5,0.672-1.5,1.5v3c0,0.828,0.671,1.5,1.5,1.5s1.5-0.672,1.5-1.5v-3C19,29.672,18.329,29,17.5,29z M17.5,7    C11.71,7,7,11.71,7,17.5S11.71,28,17.5,28S28,23.29,28,17.5S23.29,7,17.5,7z M17.5,25c-4.136,0-7.5-3.364-7.5-7.5    c0-4.136,3.364-7.5,7.5-7.5c4.136,0,7.5,3.364,7.5,7.5C25,21.636,21.636,25,17.5,25z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="nightIcon" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100" xml:space="preserve" aria-label="亮色模式"><title>亮色模式</title><path d="M96.76,66.458c-0.853-0.852-2.15-1.064-3.23-0.534c-6.063,2.991-12.858,4.571-19.655,4.571  C62.022,70.495,50.88,65.88,42.5,57.5C29.043,44.043,25.658,23.536,34.076,6.47c0.532-1.08,0.318-2.379-0.534-3.23  c-0.851-0.852-2.15-1.064-3.23-0.534c-4.918,2.427-9.375,5.619-13.246,9.491c-9.447,9.447-14.65,22.008-14.65,35.369  c0,13.36,5.203,25.921,14.65,35.368s22.008,14.65,35.368,14.65c13.361,0,25.921-5.203,35.369-14.65  c3.872-3.871,7.064-8.328,9.491-13.246C97.826,68.608,97.611,67.309,96.76,66.458z"></path></svg></button><div class="explorer desktop-only"><button type="button" id="explorer" data-behavior="collapse" data-collapsed="collapsed" data-savestate="true" data-tree="[{&quot;path&quot;:&quot;编程语言&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;编程语言/Java&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;编程语言/JavaScript&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;编程语言/Node&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;编程语言/Rust&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;编程语言/Rust/Rust认识&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;编程语言/TypeScript&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;服务器&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;计算机基础&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;计算机基础/408&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;计算机基础/408/计算机操作系统&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;计算机基础/408/计算机网络&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;计算机基础/408/计算机组成原理&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;计算机基础/408/数据结构和算法&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;计算机基础/编译原理&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;计算机基础/软件测试&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;计算机基础/数据库系统概论&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;前端&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;前端/浏览器&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;前端/CSS&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;前端/react&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;前端/react/react学习&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;前端/rspress&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;前端/UI设计&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;阅读&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;阅读/未完成&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;Git&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;Markdown&quot;,&quot;collapsed&quot;:true}]" aria-controls="explorer-content" aria-expanded="false"><h2>探索</h2><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="explorer-content"><ul class="overflow" id="explorer-ul"><li><div class="folder-outer open"><ul style="padding-left:0;" class="content" data-folderul><li><div class="folder-outer "><ul style="padding-left:0;" class="content" data-folderul></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="编程语言"><button class="folder-button"><span class="folder-title">编程语言</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="编程语言"><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="编程语言/Java"><button class="folder-button"><span class="folder-title">Java</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="编程语言/Java"><li><a href="../../../编程语言/Java/JavaWeb复习" data-for="编程语言/Java/JavaWeb复习" title="JavaWeb复习">JavaWeb复习</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="编程语言/JavaScript"><button class="folder-button"><span class="folder-title">JavaScript</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="编程语言/JavaScript"><li><a href="../../../编程语言/JavaScript/事件循环" data-for="编程语言/JavaScript/事件循环" title="事件循环(Event Loop)">事件循环(Event Loop)</a></li><li><a href="../../../编程语言/JavaScript/JS笔记" data-for="编程语言/JavaScript/JS笔记" title="JS笔记">JS笔记</a></li><li><a href="../../../编程语言/JavaScript/Promise和Async" data-for="编程语言/JavaScript/Promise和Async" title="Promise和Async">Promise和Async</a></li><li><a href="../../../编程语言/JavaScript/utils" data-for="编程语言/JavaScript/utils" title="常用工具函数">常用工具函数</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="编程语言/Node"><button class="folder-button"><span class="folder-title">Node</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="编程语言/Node"><li><a href="../../../编程语言/Node/Express实现认证" data-for="编程语言/Node/Express实现认证" title="Express实现用户认证">Express实现用户认证</a></li><li><a href="../../../编程语言/Node/Express项目架构" data-for="编程语言/Node/Express项目架构" title="Express项目架构">Express项目架构</a></li><li><a href="../../../编程语言/Node/Mongose使用" data-for="编程语言/Node/Mongose使用" title="在 Express 中使用 Mongose">在 Express 中使用 Mongose</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="编程语言/Rust"><button class="folder-button"><span class="folder-title">Rust</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="编程语言/Rust"><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="编程语言/Rust/Rust认识"><button class="folder-button"><span class="folder-title">Rust认识</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="编程语言/Rust/Rust认识"><li><a href="../../../编程语言/Rust/Rust认识/1_环境配置" data-for="编程语言/Rust/Rust认识/1_环境配置" title="Rust 环境配置">Rust 环境配置</a></li><li><a href="../../../编程语言/Rust/Rust认识/2_cargo使用" data-for="编程语言/Rust/Rust认识/2_cargo使用" title="Cargo 使用">Cargo 使用</a></li><li><a href="../../../编程语言/Rust/Rust认识/3_变量和常量" data-for="编程语言/Rust/Rust认识/3_变量和常量" title="变量和常量">变量和常量</a></li><li><a href="../../../编程语言/Rust/Rust认识/4_基本类型" data-for="编程语言/Rust/Rust认识/4_基本类型" title="基本类型">基本类型</a></li><li><a href="../../../编程语言/Rust/Rust认识/5_所有权和借用" data-for="编程语言/Rust/Rust认识/5_所有权和借用" title="所有权和借用">所有权和借用</a></li><li><a href="../../../编程语言/Rust/Rust认识/6_复合类型" data-for="编程语言/Rust/Rust认识/6_复合类型" title="复合类型">复合类型</a></li></ul></div></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="编程语言/TypeScript"><button class="folder-button"><span class="folder-title">TypeScript</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="编程语言/TypeScript"><li><a href="../../../编程语言/TypeScript/TS笔记" data-for="编程语言/TypeScript/TS笔记" title="TS 笔记">TS 笔记</a></li></ul></div></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="服务器"><button class="folder-button"><span class="folder-title">服务器</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="服务器"><li><a href="../../../服务器/域名注册" data-for="服务器/域名注册" title="域名注册">域名注册</a></li><li><a href="../../../服务器/Cloudflare-Workers-使用" data-for="服务器/Cloudflare-Workers-使用" title="使用 Cloudflare Workers 优化 Github 文件国内访问速度">使用 Cloudflare Workers 优化 Github 文件国内访问速度</a></li><li><a href="../../../服务器/MinIO-使用" data-for="服务器/MinIO-使用" title="MinIO 使用">MinIO 使用</a></li><li><a href="../../../服务器/MongoDB-使用" data-for="服务器/MongoDB-使用" title="MongoDB 使用">MongoDB 使用</a></li><li><a href="../../../服务器/OSS-对象存储" data-for="服务器/OSS-对象存储" title="OSS 对象存储">OSS 对象存储</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="计算机基础"><button class="folder-button"><span class="folder-title">计算机基础</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="计算机基础"><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="计算机基础/408"><button class="folder-button"><span class="folder-title">408</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="计算机基础/408"><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="计算机基础/408/计算机操作系统"><button class="folder-button"><span class="folder-title">计算机操作系统</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="计算机基础/408/计算机操作系统"><li><a href="../../../计算机基础/408/计算机操作系统/1_操作系统概述" data-for="计算机基础/408/计算机操作系统/1_操作系统概述" title="操作系统概述">操作系统概述</a></li><li><a href="../../../计算机基础/408/计算机操作系统/2_进程与线程" data-for="计算机基础/408/计算机操作系统/2_进程与线程" title="进程与线程">进程与线程</a></li><li><a href="../../../计算机基础/408/计算机操作系统/3_内存管理" data-for="计算机基础/408/计算机操作系统/3_内存管理" title="内存管理">内存管理</a></li><li><a href="../../../计算机基础/408/计算机操作系统/4_文件管理" data-for="计算机基础/408/计算机操作系统/4_文件管理" title="文件管理">文件管理</a></li><li><a href="../../../计算机基础/408/计算机操作系统/5_输入输出管理" data-for="计算机基础/408/计算机操作系统/5_输入输出管理" title="I/O管理">I/O管理</a></li><li><a href="../../../计算机基础/408/计算机操作系统/6_其他" data-for="计算机基础/408/计算机操作系统/6_其他" title="其他文件">其他文件</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="计算机基础/408/计算机网络"><button class="folder-button"><span class="folder-title">计算机网络</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="计算机基础/408/计算机网络"><li><a href="../../../计算机基础/408/计算机网络/1_计算机网络体系结构" data-for="计算机基础/408/计算机网络/1_计算机网络体系结构" title="计算机网络体系结构">计算机网络体系结构</a></li><li><a href="../../../计算机基础/408/计算机网络/2_物理层" data-for="计算机基础/408/计算机网络/2_物理层" title="物理层">物理层</a></li><li><a href="../../../计算机基础/408/计算机网络/3_数据链路层" data-for="计算机基础/408/计算机网络/3_数据链路层" title="数据链路层">数据链路层</a></li><li><a href="../../../计算机基础/408/计算机网络/4_网络层" data-for="计算机基础/408/计算机网络/4_网络层" title="网络层">网络层</a></li><li><a href="../../../计算机基础/408/计算机网络/5_传输层" data-for="计算机基础/408/计算机网络/5_传输层" title="传输层">传输层</a></li><li><a href="../../../计算机基础/408/计算机网络/6_应用层" data-for="计算机基础/408/计算机网络/6_应用层" title="应用层">应用层</a></li><li><a href="../../../计算机基础/408/计算机网络/7_其他" data-for="计算机基础/408/计算机网络/7_其他" title="其他文件">其他文件</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="计算机基础/408/计算机组成原理"><button class="folder-button"><span class="folder-title">计算机组成原理</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="计算机基础/408/计算机组成原理"><li><a href="../../../计算机基础/408/计算机组成原理/1_计算机系统概述" data-for="计算机基础/408/计算机组成原理/1_计算机系统概述" title="计算机组成原理">计算机组成原理</a></li><li><a href="../../../计算机基础/408/计算机组成原理/2_数据的表示和运算" data-for="计算机基础/408/计算机组成原理/2_数据的表示和运算" title="数据的表示和运算">数据的表示和运算</a></li><li><a href="../../../计算机基础/408/计算机组成原理/3_存储系统" data-for="计算机基础/408/计算机组成原理/3_存储系统" title="存储系统">存储系统</a></li><li><a href="../../../计算机基础/408/计算机组成原理/4_指令系统" data-for="计算机基础/408/计算机组成原理/4_指令系统" title="指令系统">指令系统</a></li><li><a href="../../../计算机基础/408/计算机组成原理/5_中央处理器" data-for="计算机基础/408/计算机组成原理/5_中央处理器" title="中央处理器">中央处理器</a></li><li><a href="../../../计算机基础/408/计算机组成原理/6_总线" data-for="计算机基础/408/计算机组成原理/6_总线" title="总线">总线</a></li><li><a href="../../../计算机基础/408/计算机组成原理/7_IO系统" data-for="计算机基础/408/计算机组成原理/7_IO系统" title="I/O 系统">I/O 系统</a></li><li><a href="../../../计算机基础/408/计算机组成原理/8_其他" data-for="计算机基础/408/计算机组成原理/8_其他" title=" 其他文件"> 其他文件</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="计算机基础/408/数据结构和算法"><button class="folder-button"><span class="folder-title">数据结构和算法</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="计算机基础/408/数据结构和算法"><li><a href="../../../计算机基础/408/数据结构和算法/1_数据结构基本概念" data-for="计算机基础/408/数据结构和算法/1_数据结构基本概念" title="数据结构的基本概念">数据结构的基本概念</a></li><li><a href="../../../计算机基础/408/数据结构和算法/2_算法基本概念" data-for="计算机基础/408/数据结构和算法/2_算法基本概念" title="算法基本概念">算法基本概念</a></li><li><a href="../../../计算机基础/408/数据结构和算法/3_线性表" data-for="计算机基础/408/数据结构和算法/3_线性表" title="线性表">线性表</a></li><li><a href="../../../计算机基础/408/数据结构和算法/4_栈和队列" data-for="计算机基础/408/数据结构和算法/4_栈和队列" title="栈和队列">栈和队列</a></li><li><a href="../../../计算机基础/408/数据结构和算法/5_串" data-for="计算机基础/408/数据结构和算法/5_串" title="串">串</a></li><li><a href="../../../计算机基础/408/数据结构和算法/6_树" data-for="计算机基础/408/数据结构和算法/6_树" title="树">树</a></li><li><a href="../../../计算机基础/408/数据结构和算法/7_图" data-for="计算机基础/408/数据结构和算法/7_图" title="图">图</a></li><li><a href="../../../计算机基础/408/数据结构和算法/8_查找" data-for="计算机基础/408/数据结构和算法/8_查找" title="查找">查找</a></li><li><a href="../../../计算机基础/408/数据结构和算法/9_排序" data-for="计算机基础/408/数据结构和算法/9_排序" title="排序">排序</a></li></ul></div></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="计算机基础/编译原理"><button class="folder-button"><span class="folder-title">编译原理</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="计算机基础/编译原理"><li><a href="../../../计算机基础/编译原理/1_开始" data-for="计算机基础/编译原理/1_开始" title="开始">开始</a></li><li><a href="../../../计算机基础/编译原理/2_引论" data-for="计算机基础/编译原理/2_引论" title="引论">引论</a></li><li><a href="../../../计算机基础/编译原理/3_词法分析" data-for="计算机基础/编译原理/3_词法分析" title="词法分析">词法分析</a></li><li><a href="../../../计算机基础/编译原理/4_语法分析" data-for="计算机基础/编译原理/4_语法分析" title="语法分析">语法分析</a></li><li><a href="../../../计算机基础/编译原理/5_语义分析与中间代码生成器" data-for="计算机基础/编译原理/5_语义分析与中间代码生成器" title="语义分析与中间代码生成器">语义分析与中间代码生成器</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="计算机基础/软件测试"><button class="folder-button"><span class="folder-title">软件测试</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="计算机基础/软件测试"><li><a href="../../../计算机基础/软件测试/1_软件测试技术复习" data-for="计算机基础/软件测试/1_软件测试技术复习" title="软件测试技术复习">软件测试技术复习</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="计算机基础/数据库系统概论"><button class="folder-button"><span class="folder-title">数据库系统概论</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="计算机基础/数据库系统概论"><li><a href="../../../计算机基础/数据库系统概论/1_绪论" data-for="计算机基础/数据库系统概论/1_绪论" title="绪论">绪论</a></li><li><a href="../../../计算机基础/数据库系统概论/2_关系数据库" data-for="计算机基础/数据库系统概论/2_关系数据库" title="关系数据库">关系数据库</a></li><li><a href="../../../计算机基础/数据库系统概论/3_SQL" data-for="计算机基础/数据库系统概论/3_SQL" title="SQL">SQL</a></li><li><a href="../../../计算机基础/数据库系统概论/4_数据库安全性" data-for="计算机基础/数据库系统概论/4_数据库安全性" title="数据库安全性">数据库安全性</a></li><li><a href="../../../计算机基础/数据库系统概论/5_数据库完整性" data-for="计算机基础/数据库系统概论/5_数据库完整性" title="数据库完整性">数据库完整性</a></li><li><a href="../../../计算机基础/数据库系统概论/6_关系数据理论" data-for="计算机基础/数据库系统概论/6_关系数据理论" title="关系数据理论">关系数据理论</a></li><li><a href="../../../计算机基础/数据库系统概论/7_数据库设计" data-for="计算机基础/数据库系统概论/7_数据库设计" title="数据库设计">数据库设计</a></li><li><a href="../../../计算机基础/数据库系统概论/8_数据库编程" data-for="计算机基础/数据库系统概论/8_数据库编程" title="数据库编程">数据库编程</a></li><li><a href="../../../计算机基础/数据库系统概论/9_关系查询处理和查询优化" data-for="计算机基础/数据库系统概论/9_关系查询处理和查询优化" title="关系查询处理和查询优化">关系查询处理和查询优化</a></li><li><a href="../../../计算机基础/数据库系统概论/10_数据库恢复技术" data-for="计算机基础/数据库系统概论/10_数据库恢复技术" title="数据库恢复技术">数据库恢复技术</a></li><li><a href="../../../计算机基础/数据库系统概论/11_并发控制" data-for="计算机基础/数据库系统概论/11_并发控制" title="并发控制">并发控制</a></li></ul></div></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="前端"><button class="folder-button"><span class="folder-title">前端</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="前端"><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="前端/浏览器"><button class="folder-button"><span class="folder-title">浏览器</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="前端/浏览器"><li><a href="../../../前端/浏览器/深入了解现代网络浏览器" data-for="前端/浏览器/深入了解现代网络浏览器" title="深入了解现代网络浏览器">深入了解现代网络浏览器</a></li><li><a href="../../../前端/浏览器/CORS错误" data-for="前端/浏览器/CORS错误" title="CORS错误">CORS错误</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="前端/CSS"><button class="folder-button"><span class="folder-title">CSS</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="前端/CSS"><li><a href="../../../前端/CSS/css选择器" data-for="前端/CSS/css选择器" title="css选择器">css选择器</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="前端/react"><button class="folder-button"><span class="folder-title">react</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="前端/react"><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="前端/react/react学习"><button class="folder-button"><span class="folder-title">react学习</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="前端/react/react学习"><li><a href="../../../前端/react/react学习/1_react初体验" data-for="前端/react/react学习/1_react初体验" title="react初体验">react初体验</a></li><li><a href="../../../前端/react/react学习/2_jsx基本语法" data-for="前端/react/react学习/2_jsx基本语法" title="jsx基本语法">jsx基本语法</a></li><li><a href="../../../前端/react/react学习/3_react脚手架解析" data-for="前端/react/react学习/3_react脚手架解析" title="react脚手架解析">react脚手架解析</a></li><li><a href="../../../前端/react/react学习/4_react性能优化" data-for="前端/react/react学习/4_react性能优化" title="react性能优化">react性能优化</a></li><li><a href="../../../前端/react/react学习/5_react组件化开发" data-for="前端/react/react学习/5_react组件化开发" title="react组件化开发">react组件化开发</a></li><li><a href="../../../前端/react/react学习/6_react动画" data-for="前端/react/react学习/6_react动画" title="react动画">react动画</a></li><li><a href="../../../前端/react/react学习/7_Redux的使用" data-for="前端/react/react学习/7_Redux的使用" title="Redux的使用">Redux的使用</a></li><li><a href="../../../前端/react/react学习/8_Router的使用" data-for="前端/react/react学习/8_Router的使用" title="Router的使用">Router的使用</a></li><li><a href="../../../前端/react/react学习/9_Hook" data-for="前端/react/react学习/9_Hook" title="Hook的使用">Hook的使用</a></li></ul></div></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="前端/rspress"><button class="folder-button"><span class="folder-title">rspress</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="前端/rspress"><li><a href="../../../前端/rspress/自动生成侧边栏" data-for="前端/rspress/自动生成侧边栏" title="rspress 自动生成侧边栏">rspress 自动生成侧边栏</a></li><li><a href="../../../前端/rspress/LaTeX无法使用$$语法" data-for="前端/rspress/LaTeX无法使用$$语法" title="LaTeX无法使用$$语法">LaTeX无法使用$$语法</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="前端/UI设计"><button class="folder-button"><span class="folder-title">UI设计</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="前端/UI设计"><li><a href="../../../前端/UI设计/RefactoringUI学习" data-for="前端/UI设计/RefactoringUI学习" title="RefactoringUI学习">RefactoringUI学习</a></li></ul></div></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="阅读"><button class="folder-button"><span class="folder-title">阅读</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="阅读"><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="阅读/未完成"><button class="folder-button"><span class="folder-title">未完成</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="阅读/未完成"><li><a href="../../../阅读/未完成/解构现代化：温铁军演讲录" data-for="阅读/未完成/解构现代化：温铁军演讲录" title="解构现代化：温铁军演讲录">解构现代化：温铁军演讲录</a></li><li><a href="../../../阅读/未完成/金瓶梅词话（上下）" data-for="阅读/未完成/金瓶梅词话（上下）" title="金瓶梅词话（上下）">金瓶梅词话（上下）</a></li><li><a href="../../../阅读/未完成/思想的力量（第9版）" data-for="阅读/未完成/思想的力量（第9版）" title="思想的力量（第9版）">思想的力量（第9版）</a></li><li><a href="../../../阅读/未完成/乡土中国-生育制度-乡土重建" data-for="阅读/未完成/乡土中国-生育制度-乡土重建" title="乡土中国 生育制度 乡土重建">乡土中国 生育制度 乡土重建</a></li><li><a href="../../../阅读/未完成/制造消费者：消费主义全球史" data-for="阅读/未完成/制造消费者：消费主义全球史" title="制造消费者：消费主义全球史">制造消费者：消费主义全球史</a></li></ul></div></li><li><a href="../../../阅读/大清为何轰然倒塌" data-for="阅读/大清为何轰然倒塌" title="大清为何轰然倒塌">大清为何轰然倒塌</a></li><li><a href="../../../阅读/叫魂：1768年中国妖术大恐慌" data-for="阅读/叫魂：1768年中国妖术大恐慌" title="叫魂：1768年中国妖术大恐慌">叫魂：1768年中国妖术大恐慌</a></li><li><a href="../../../阅读/菊与刀" data-for="阅读/菊与刀" title="菊与刀">菊与刀</a></li><li><a href="../../../阅读/论语" data-for="阅读/论语" title="论语">论语</a></li><li><a href="../../../阅读/毛泽东选集" data-for="阅读/毛泽东选集" title="毛泽东选集">毛泽东选集</a></li><li><a href="../../../阅读/人民公开课：中国共产党与国家治理体系和治理能力现代化" data-for="阅读/人民公开课：中国共产党与国家治理体系和治理能力现代化" title="人民公开课：中国共产党与国家治理体系和治理能力现代化">人民公开课：中国共产党与国家治理体系和治理能力现代化</a></li><li><a href="../../../阅读/盛唐到底盛在哪儿" data-for="阅读/盛唐到底盛在哪儿" title="盛唐到底盛在哪儿">盛唐到底盛在哪儿</a></li><li><a href="../../../阅读/伊豆的舞女" data-for="阅读/伊豆的舞女" title="伊豆的舞女">伊豆的舞女</a></li><li><a href="../../../阅读/以利为利：财政关系与地方政府行为" data-for="阅读/以利为利：财政关系与地方政府行为" title="以利为利：财政关系与地方政府行为">以利为利：财政关系与地方政府行为</a></li><li><a href="../../../阅读/哲学导论讲记" data-for="阅读/哲学导论讲记" title="哲学导论讲记">哲学导论讲记</a></li><li><a href="../../../阅读/治大国若烹小鲜：基层治理与世道人心" data-for="阅读/治大国若烹小鲜：基层治理与世道人心" title="治大国若烹小鲜：基层治理与世道人心">治大国若烹小鲜：基层治理与世道人心</a></li><li><a href="../../../阅读/置身事内：中国政府与经济发展" data-for="阅读/置身事内：中国政府与经济发展" title="置身事内：中国政府与经济发展">置身事内：中国政府与经济发展</a></li><li><a href="../../../阅读/中国是部金融史" data-for="阅读/中国是部金融史" title="中国是部金融史">中国是部金融史</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="Git"><button class="folder-button"><span class="folder-title">Git</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="Git"><li><a href="../../../Git/如何删除无用分支" data-for="Git/如何删除无用分支" title="如何删除无用分支">如何删除无用分支</a></li><li><a href="../../../Git/文件.gitkeep是什么" data-for="Git/文件.gitkeep是什么" title="文件.gitkeep是什么">文件.gitkeep是什么</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="Markdown"><button class="folder-button"><span class="folder-title">Markdown</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="Markdown"><li><a href="../../../Markdown/Callouts-标注" data-for="Markdown/Callouts-标注" title="Callouts 标注">Callouts 标注</a></li><li><a href="../../../Markdown/Obsidian-教程" data-for="Markdown/Obsidian-教程" title="Obsidian 教程">Obsidian 教程</a></li><li><a href="../../../Markdown/Typora-自定义-Callouts-样式" data-for="Markdown/Typora-自定义-Callouts-样式" title="Typora 自定义 Callouts">Typora 自定义 Callouts</a></li><li><a href="../../../Markdown/Typora-自定义字体" data-for="Markdown/Typora-自定义字体" title="Typora 自定义字体">Typora 自定义字体</a></li></ul></div></li></ul></div></li><li id="explorer-end"></li></ul></div></div><div class="recent-notes desktop-only"><button type="button" id="recent" class aria-controls="recent-content" aria-expanded="true"><h3>最近</h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="recent-content" class><ul class="recent-ul"><li class="recent-li"><div class="section"><div class="desc"><h3><a href="../../../编程语言/TypeScript/TS笔记" class="internal">TS 笔记</a></h3></div><p class="meta"><time datetime="2025-01-30T09:43:20.433Z">2025/1/30</time></p></div></li><li class="recent-li"><div class="section"><div class="desc"><h3><a href="../../../编程语言/JavaScript/utils" class="internal">常用工具函数</a></h3></div><p class="meta"><time datetime="2025-01-21T06:44:35.648Z">2025/1/21</time></p></div></li><li class="recent-li"><div class="section"><div class="desc"><h3><a href="../../../编程语言/JavaScript/Promise和Async" class="internal">Promise和Async</a></h3></div><p class="meta"><time datetime="2025-01-17T09:53:43.610Z">2025/1/17</time></p></div></li><li class="recent-li"><div class="section"><div class="desc"><h3><a href="../../../编程语言/Node/Express实现认证" class="internal">Express实现用户认证</a></h3></div><p class="meta"><time datetime="2025-01-15T06:35:06.548Z">2025/1/15</time></p></div></li><li class="recent-li"><div class="section"><div class="desc"><h3><a href="../../../编程语言/JavaScript/事件循环" class="internal">事件循环(Event Loop)</a></h3></div><p class="meta"><time datetime="2025-01-14T06:46:24.480Z">2025/1/14</time></p></div></li><li class="recent-li"><div class="section"><div class="desc"><h3><a href="../../../编程语言/Node/Mongose使用" class="internal">在 Express 中使用 Mongose</a></h3></div><p class="meta"><time datetime="2025-01-13T17:45:35.421Z">2025/1/14</time></p></div></li></ul></div></div></div><div class="center"><div class="page-header"><div class="popover-hint"><nav class="breadcrumb-container" aria-label="breadcrumbs"><div class="breadcrumb-element"><a href="../../../">Home</a><p> ❯ </p></div><div class="breadcrumb-element"><a href="../../../计算机基础/">计算机基础</a><p> ❯ </p></div><div class="breadcrumb-element"><a href="../../../计算机基础/408/">408</a><p> ❯ </p></div><div class="breadcrumb-element"><a href="../../../计算机基础/408/计算机网络/">计算机网络</a><p> ❯ </p></div><div class="breadcrumb-element"><a href>传输层</a></div></nav><h1 class="article-title">传输层</h1><p show-comma="true" class="content-meta"><time datetime="2024-11-16T13:59:30.364Z">2024年11月16日</time><span>57分钟阅读</span></p><ul class="tags"><li><a href="../../../tags/计算机网络" class="internal tag-link">计算机网络</a></li></ul></div></div><article class="popover-hint"><h1 id="基本概念">基本概念<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#基本概念" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<h2 id="传输层的功能">传输层的功能<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#传输层的功能" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>物理层、数据链路层和网络层，它们共同解决了将主机通过异构网络互联起来所面临的问题，实现了主机到主机的通信。然而在计算机网络中实际进行通信的真正实体，是位于通信两端主机中的进程。</p>
<p>传输层位于网络层之上、应用层之下，它为运行在<strong>不同主机上的进程之间提供逻辑通信</strong>。</p>
<p>传输层属于面向通信部分的最高层，同时也是用户功能中的最低层。显然，即使网络层协议不可靠（网络层协议使分组丢失、混乱或重复），传输层同样能为应用程序提供可靠的服务。</p>
<p><img src="./assets/384.png" alt/></p>
<p>网络的边缘部分的两台主机使用网络的核心部分的功能进行端到端的通信时，只有主机的协议栈才有传输层，而路由器在转发分组时都只用到下三层的功能（即在<span class="text-highlight">通信子网中没有传输层，传输层只存在于通信子网以外的主机中</span>）。</p>
<p><img src="./assets/385.png" alt/></p>
<p>从网络层来说，通信的双方是两台主机，IP 数据报的首部给出了这两台主机的 IP 地址。但“<strong>两台主机之间的通信</strong>”实际上是<strong>两台主机中的应用进程之间的通信</strong>。应用进程之间的通信又称<strong>端到端的逻辑通信</strong>。</p>
<p>IP 协议虽然能把分组送到目的主机，但这个分组还停留在主机的网络层，而没有交付给主机中的进程。<strong>从传输层来看，通信的真正端点不是主机而是主机中的进程</strong>。</p>
<h2 id="两个主要协议">两个主要协议<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#两个主要协议" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p><img src="./assets/386.png" alt/></p>
<p>TCP/IP 协议族在 IP 层之上使用了两个传输协议：</p>
<ul>
<li>
<p><span class="text-highlight">面向连接的传输控制协议(TCP)</span>，采用 TCP 时，传输层向上提供的是一条<span class="text-highlight">全双工的可靠逻辑信道</span>；</p>
<p>TCP 提供面向连接的可靠服务，通信双方在传送数据之前必须<strong>先建立连接</strong>，然后基于此连接进行可靠数据传输，数据<strong>传输结束后要释放连接</strong>。</p>
<p>TCP 不提供广播或多播服务。</p>
<p>TCP 为了实现可靠数据传输，就必须增加许多措施，如确认、流量控制、计时器及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多的处理机资源。因此 TCP 主要适用于可靠性更重要的场合，如文件传输协议、超文本传输协议、远程登录等。</p>
</li>
<li>
<p><span class="text-highlight">无连接的用户数据报协议(UDP)</span>，采用 UDP 时，传输层向上提供的是一条<span class="text-highlight">不可靠的逻辑信道</span>。</p>
<p>UDP 提供无连接的不可靠服务，通信双方在传送数据之前<strong>不需要建立连接</strong>，接收方的传输层在收到 UDP 用户数据报后，<strong>无须给发送方发回任何确认</strong>。</p>
<p>UDP 在 IP 层之上仅提供两个附加服务：多路复用和对数据的错误检查。</p>
<p>IP 层知道怎样把分组投递给一台主机，但不知道怎样把它们投递给主机上的具体应用。</p>
<p>因为 UDP 比较简单，所以执行速度比较快、实时性好。使用 UDP 的应用主要包括小文件传送协议、DNS、SNMP 和实时传输协议。</p>
</li>
</ul>
<p><img src="./assets/387.png" alt/></p>
<blockquote class="callout tip" data-callout="tip">
<div class="callout-title">
                  <div class="callout-icon"></div>
                  <div class="callout-title-inner"><p>Tip</p></div>
                  
                </div>
<div class="callout-content">
<p>网络层无法同时实现两种协议（即在网络层要么只提供面向连接的服务，如虚电路：要么只提供无连接服务，如数据报，而不可能在网络层同时存在这两种方式）。</p>
</div>
</blockquote>
<p><img src="./assets/388.png" alt/></p>
<h2 id="端口">端口<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#端口" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>端口能让应用层的各种进程将其数据通过端口向下交付给传输层，以及让传输层知道应当将其报文段中的数据向上通过端口交付给应用层相应的进程。</p>
<p>端口在传输层的作用类似于 IP 地址在网络层的作用，只不过 IP 地址标识的是主机，而端口标识的是主机中的应用进程。</p>
<p>在协议栈层间的抽象的协议端口是软件端口，它与路由器或交换机上的硬件端口是完全不同的概念。硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层的各种协议进程与传输实体进行层间交互的一种地址。传输层使用的是软件端口。</p>
<hr/>
<p>应用进程通过端口号进行标识，端口号长度为 16 比特，取值范围是 0 ~ 65535。</p>
<p><span class="text-highlight">端口号只具有本地意义</span>，即<strong>端口号只标识本计算机应用层中的各进程</strong>，在因特网中<strong>不同计算机的相同端口号是没有联系的</strong>。</p>
<p>根据端口号范围可将端口分为两类：</p>
<ol>
<li>
<p><span class="text-highlight">服务器端使用的端口号</span></p>
<ul>
<li><strong>熟知端口号</strong>，数值为 0 ～ 1023，这些端口号指派给了 TCP/IP 最重要的一些应用程序，让所有的用户都知道。</li>
<li><strong>登记端口号</strong>，数值为 1024 ～ 49151，供没有熟知端口号的应用程序使用的，使用这类端口号必须在 IANA 登记，以防止重复。</li>
</ul>
</li>
<li>
<p><span class="text-highlight">客户端使用的端口号</span></p>
<p>数值为 49152 ～ 65535。因为这类端口号仅在客户进程运行时才动态地选择，所以又称<strong>短暂端口号</strong>。</p>
<p>当服务器进程收到客户进程的报文时，就知道了客户进程所使用的端口号，因而可以把数据发送给客户进程。通信结束后，刚用过的客户端口号就不复存在，这个端口号就可以供其他客户进程使用。</p>
</li>
</ol>
<p><img src="./assets/389.png" alt/></p>
<hr/>
<p>在网络中通过 IP 地址来标识和区别不同的主机，通过端口号来标识和区分一台主机中的不同应用进程，端口号拼接到 IP 地址即构成套接字(Socket)。</p>
<p>在网络中采用发送方和接收方的套接字来识别端点。套接字，实际上是一个通信端点，即</p>
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord cjk_fallback">套接字</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">oc</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">IP</span><span class="mord cjk_fallback">地址</span><span class="mord">:</span><span class="mord cjk_fallback">端口号</span></span><span class="mclose">)</span></span></span></span></span>
<p>它<strong>唯一地标识网络中的一台主机上的一个应用进程</strong>。</p>
<p>在网络通信中，主机 A 发给主机 B 的报文包含目的端口号和源端口号，源端口号是“返回地址”的一部分，即当主机 B 需要发回一个报文给主机 A 时，主机 B 到主机 A 的报文中的目的端口号便是主机 A 到主机 B 的报文中的源端口号（完全的返回地址是主机 A 的 IP 地址和源端口号）。</p>
<h2 id="复用和分用">复用和分用<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#复用和分用" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<ul>
<li><span class="text-highlight">复用</span>是指发送方<strong>不同的应用进程都可以使用同一个传输层协议传送数据</strong>。</li>
<li><span class="text-highlight">分用</span>是指接收方的<strong>传输层在剥去报文的首部后能够把这些数据正确交付到目的应用进程</strong>。</li>
</ul>
<p><img src="./assets/390.png" alt/></p>
<p><img src="./assets/391.png" alt/></p>
<blockquote class="callout tip" data-callout="tip">
<div class="callout-title">
                  <div class="callout-icon"></div>
                  <div class="callout-title-inner"><p>Tip</p></div>
                  
                </div>
<div class="callout-content">
<p>网络层也有复用和分用的功能，但网络层的复用是指发送方不同协议的数据都可被封装成 IP 数据报发送出去，分用是指接收方的网络层在剥去首部后把数据交付给相应的协议。</p>
</div>
</blockquote>
<h2 id="检错检测">检错检测<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#检错检测" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>传输层要对收到的报文（首部和数据部分）进行差错检测。</p>
<ul>
<li>对于<span class="text-highlight">TCP</span>协议，若接收方发现<span class="text-highlight">报文段</span>出错，则要求发送方<span class="text-highlight">重发</span>该报文段。</li>
<li>对于<span class="text-highlight">UDP</span>协议，若接收方发现<span class="text-highlight">数据报</span>出错，则直接<span class="text-highlight">丢弃</span>。</li>
</ul>
<p>在网络层，IP 数据报首部中的检验和字段只检验首部是否出错，而不检查数据部分。</p>
<h1 id="udp">UDP<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#udp" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<h2 id="udp-概述">UDP 概述<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#udp-概述" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>UDP 仅在 IP 层的数据报服务之上增加了两个最基本的功能：<strong>复用和分用</strong>，以及<strong>差错检测</strong>。</p>
<p>UDP 优点：</p>
<ol>
<li>UDP 无须建立连接，因此 UDP 不会引入建立连接的时延。</li>
<li>无连接状态。当某些专用服务器使用 UDP 时，一般都能支持更多的活动客户机。</li>
<li>UDP 的首部开销小。TCP 有 20B 的首部开销，而 UDP 仅有 8B 的开销。</li>
<li>UDP 没有拥塞控制，因此网络中的拥塞不会影响源主机的发送速率。</li>
<li>UDP 支持一对一、一对多、多对一和多对多的交互通信。</li>
</ol>
<p>UDP 应用场景：</p>
<ul>
<li>UDP 常用于<strong>一次性传输较少数据的网络应用</strong>，如 DNS、SNMP 等，因为对于这些应用，若采用 TCP，则将为连接创建、维护和拆除带来不小的开销。</li>
<li>UDP 也常用于<strong>多媒体应用</strong>（如 IP 电话、实时视频会议、流媒体等），显然，可靠数据传输对这些应用来说并不是最重要的，但 TCP 的拥塞控制会导致数据出现较大的延迟，这是它们不可容忍的。</li>
</ul>
<p>UDP <strong>不保证可靠交付</strong>，但这并<strong>不意味着应用对数据的要求是不可靠的</strong>，所有<strong>维护可靠性的工作可由用户在应用层来完成</strong>。应用开发者可根据应用的需求来灵活设计自己的可靠性机制。</p>
<p>UDP 是面向报文的。</p>
<ul>
<li>发送方 UDP 对应用层交下来的报文，在添加首部后就向下交付给 IP 层，一次发送一个报文，既不合并，也不拆分，而是保留这些报文的边界；</li>
<li>接收方 UDP 对 IP 层交上来 UDP 数据报，在去除首部后就原封不动地交付给上层应用进程，一次交付一个完整的报文。</li>
</ul>
<p>因此<strong>报文</strong>不可分割，是 <span class="text-highlight">UDP 数据报处理的最小单位</span>。因此，<strong>应用程序必须选择合适大小的报文</strong>，若报文太长，UDP 把它交给 IP 层后，可能会导致分片；若报文太短，UDP 把它交给 IP 层后，会使 IP 数据报的首部的相对长度太大，两者都会降低 IP 层的效率。</p>
<h2 id="udp-数据报">UDP 数据报<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#udp-数据报" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>UDP 数据报包含两部分：<strong>首部字段</strong>和<strong>用户数据字段</strong>。UDP 首部有 <span class="text-highlight">8B</span>，由 4 个字段组成，每个字段的长度都是 2B。</p>
<p>各字段意义如下：</p>
<ol>
<li><span class="text-highlight">源端口</span>：源端口号。在需要对方回信时选用，不需要时可用全 0。</li>
<li><span class="text-highlight">目的端口</span>：目的端口号。这在终点交付报文时必须使用到。</li>
<li><span class="text-highlight">长度</span>：UDP 数据报的长度（<span class="text-highlight">包括首部和数据</span>），其<strong>最小值是 8</strong>（仅有首部）。</li>
<li><span class="text-highlight">检验和</span>：检测 UDP 数据报在传输中是否有错。该字段是可选的，<strong>当源主机不想计算检验和时，则直接令该字段为全 0</strong>（若检验和计算结果恰好是 0，则该字段为全 1）。</li>
</ol>
<p><img src="./assets/397.png" alt/></p>
<p>若接收方 UDP 发现收到的报文中的<span class="text-highlight">目的端口号不正确</span>（即不存在对应于端口号的应用进程）则就丢弃该报文，并由 <span class="text-highlight">ICMP 发送“端口不可达”差错报文</span>给发送方。</p>
<h2 id="udp-检验">UDP 检验<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#udp-检验" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>在计算检验和时，要在 UDP 数据报之前增加 <strong>12B 的伪首部</strong>，伪首部并不是 UDP 的真正首部。只是在计算检验和时，临时添加在 UDP 数据报的前面，得到一个临时的 UDP 数据报。</p>
<p>检验和就是按照这个临时的 UDP 数据报来计算的。</p>
<p><span class="text-highlight">伪首部既不向下传送又不向上递交，而只是为了计算检验和</span>。</p>
<p><img src="./assets/398.png" alt/></p>
<p>UDP 计算检验和的方法和计算 IP 数据报首部检验和的方法相似。不同的是 <strong>IP 数据报的检验和只检验 IP 数据报的首部</strong>，但 <span class="text-highlight">UDP 的检验和要将首部和数据部分一起检验</span>。</p>
<p>UDP 计算检验和的方法：</p>
<ol>
<li>
<p>发送方首先把全 O 放入检验和字段并添加伪首部，然后把 UDP 数据报视为许多 16 位的字串接起来。</p>
<p>若 UDP 数据报的<strong>数据部分不是偶数个字节</strong>，则要<strong>在末尾填入一个全 0 字节，但此字节不发送</strong>。</p>
</li>
<li>
<p>然后按<strong>二进制反码计算</strong>出这些 16 位字的和，将<strong>此和的二进制反码</strong>写入检验和字段，并发送。</p>
</li>
<li>
<p>接收方把收到的 UDP 数据报加上伪首部（若不为偶数个字节，则还需要补上全 0 字节）后，按二进制反码求这些 16 位字的和。</p>
<p>当无差错时其结果应为全 1，否则就表明有差错出现，接收方就应该丢弃这个 UDP 数据报。</p>
</li>
</ol>
<p>UDP 检验和<strong>检验出 UDP 数据报是错误的</strong>，则<span class="text-highlight">可以丢弃，也可以交付给上层</span>，但是需要附上错误报告，即告诉上层这是错误的数据报。</p>
<p>通过伪首部，不仅可以检查<span class="text-highlight">源端口号、目的端口号</span>和 <span class="text-highlight">UDP 用户数据报的数据部分</span>，还可以检查 <span class="text-highlight">IP 数据报的源 IP 地址和目的地址</span>。</p>
<p>这种简单的差错检验方法的<span class="text-highlight">校错能力不强</span>，但它的好处是<strong>简单、处理速度快</strong>。</p>
<h1 id="tcp">TCP<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#tcp" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<h2 id="特点">特点<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#特点" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>TCP 是在不可靠的 IP 层之上实现的可靠的数据传输协议，它<strong>主要解决传输的可靠、有序、无丢失和不重复问题</strong>。</p>
<p>TCP 是 TCP/IP 体系中非常复杂的一个协议，主要特点如下：</p>
<ol>
<li>TCP 是面向连接的传输层协议，TCP 连接是一条逻辑连接。</li>
<li>每一条 TCP 连接<span class="text-highlight">只能有两个端点</span>，每一条<strong>TCP 连接只能是一对一</strong>的。</li>
<li>TCP 提供<span class="text-highlight">可靠交付</span>的服务，保证传送的数据<strong>无差错、不丢失、不重复且有序</strong>。</li>
<li>TCP 提供<span class="text-highlight">全双工通信</span>，允许通信双方的应用进程在任何时候都能发送数据，为此 TCP 连接的<strong>两端都设有发送缓存和接收缓存</strong>，用来临时存放双向通信的数据。
<ul>
<li>发送缓存用来暂时存放：发送应用程序传送给发送方 TCP 准备发送的数据；TCP 已发送但尚未收到确认的数据。</li>
<li>接收缓存用来暂时存放：按序到达但尚未被接收应用程序读取的数据；不按序到达的数据。</li>
</ul>
</li>
<li>TCP 是<span class="text-highlight">面向字节流</span>的，虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅视为一连串的无结构的字节流。</li>
</ol>
<p>TCP 和 UDP 在发送报文时所采用的方式完全不同。UDP 报文的长度由发送应用进程决定，而 TCP 报文的长度则根据接收方给出的窗口值和当前网络拥塞程度来决定。若应用进程传送到 TCP 缓存的数据块太长，则 TCP 就把它划分得短一些再传送；若太短，则 TCP 也可等到积累足够多的字节后再构成报文段发送出去。关于 TCP 报文的长度问题，后面会详细讨论。</p>
<blockquote class="callout tip" data-callout="tip">
<div class="callout-title">
                  <div class="callout-icon"></div>
                  <div class="callout-title-inner"><p>Tip</p></div>
                  
                </div>
<div class="callout-content">
<p>在以下的情况下，TCP 的“可靠交付”功能是必不可少的：</p>
<ol>
<li>每个 IP 数据报独立地选择路由，因此在到达目的主机时有可能出现<strong>失序</strong>。</li>
<li>由于路由选择的计算出现错误，导致 IP 数据报在互联网中转圈。最后数据报首部中的<strong>生存时间的数值下降到零</strong>。这个数据报在中途就<strong>被丢失</strong>。</li>
<li>某个路由器突然<strong>出现很大的通信量</strong>，以致路由器来不及处理到达的数据报。因此有的<strong>数据报被丢弃</strong>。</li>
</ol>
<p>所以即使假定在一个互联网中所有链路的传输都不出现差错，所有结点也都不会发生故障。在这种情况下 TCP 的“可靠交付”功能仍然不是多余的。</p>
</div>
</blockquote>
<h2 id="报文段">报文段<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#报文段" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>TCP<span class="text-highlight">传送的数据单元</span>称为<span class="text-highlight">报文段</span>。</p>
<p>TCP 报文段<strong>既可以用来运载数据，又可以用来建立连接、释放连接和应答</strong>。</p>
<p>一个 TCP 报文段分为首部和数据两部分，整个 TCP 报文段作为 IP 数据报的数据部分封装在 IP 数据报中。其首部的前 20B 是固定的。TCP 首部最短为 20B，后面有 4N 字节是根据需要而增加的选项，<span class="text-highlight">长度为 4B 的整数倍</span>。</p>
<p><img src="./assets/399.png" alt/></p>
<ol>
<li>
<p>源端口和目的端口</p>
<p>各占 2B。分别表示发送方和接收方使用的端口号。</p>
</li>
<li>
<p><span class="text-highlight">序号</span></p>
<p>占 4B，范围为 0 ～ 2^32^-1，共 2^32^个序号。</p>
<p>TCP 连接中传送的字节流中的<strong>每个字节都要按顺序编号</strong>，序号字段值指的是<strong>本报文段所发送的数据的第一个字节的序号</strong>。</p>
<p>例如，一报文段的序号字段值是 301，而携带的数据共有 100B，表明本报文段的数据的最后一个字节的序号是 400，因此下一个报文段的数据序号应从 401 开始。</p>
</li>
<li>
<p><span class="text-highlight">确认号</span></p>
<p>占 4B，是<strong>期望收到对方下一个报文段的第一个数据字节的序号</strong>。</p>
<p>若确认号为 N，则表明到序号 N-1 为止的所有数据都已正确收到。</p>
<p>例如，B 正确收到了 A 发送过来的一个报文段，其序号字段是 501，而数据长度是 200B（序号 501 ～ 700），这表明 B 正确收到了 A 发送的到序号 700 为止的数据。因此 B 期望收到 A 的下一个数据序号是 701，于是 B 在发送给 A 的确认报文段中把确认号置为 701。</p>
<p><img src="./assets/400.png" alt/></p>
</li>
<li>
<p><span class="text-highlight">数据偏移</span>（即<span class="text-highlight">首部长度</span>）</p>
<p>占 4 位，这里不是 IP 数据报分片的那个数据偏移，而是表示首部长度（首部中还有长度不确定的选项字段），它指出 TCP 报文段的<span class="text-highlight">数据起始处距离 TCP 报文段的起始处有多远</span>。</p>
<p>“数据偏移”的单位是 32 位（以 <span class="text-highlight">4B 为计算单位</span>）。因为 4 位二进制数能表示的最大值为 15，所以 TCP 首部的最大长度为 60B。</p>
<p><img src="./assets/401.png" alt/></p>
</li>
<li>
<p>保留</p>
<p>占 6 位，保留为今后使用，但目前应置为 0。</p>
</li>
<li>
<p>紧急位 URG</p>
<p>当 URG=1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送（相当于高优先级的数据）。紧急数据被插入到报文段数据的最前面，而在紧急数据后面的数据仍是普通数据，因此要与首部中的紧急指针字段配合使用。</p>
</li>
<li>
<p><span class="text-highlight">确认位 ACK</span></p>
<p>仅<strong>当 ACK=1 时确认号字段才有效</strong>。当 ACK=0 时，确认号无效。</p>
<p>TCP 规定，在<strong>连接建立后所有传送的报文段都必须把 ACK 置 1</strong>。</p>
</li>
<li>
<p>推送位 PSH（Push）</p>
<p>两个应用进程进行交互式通信时，都希望在键入一个命令后立即就能收到对方的响应，此时发送方 TCP 把 PSH 置 1，接收方 TCP 收到 PSH=1 的报文段后，就尽快交付给接收应用进程，而不再等到整个缓存都填满了后再向上交付。</p>
</li>
<li>
<p>复位位 RST(Reset)</p>
<p>当<strong>RST=1 时</strong>，表示 TCP 连接中出现严重差错（如主机崩溃等），<strong>必须释放连接</strong>，然后重新建立传输连接。此外，它还可用于拒绝一个非法的报文段。</p>
</li>
<li>
<p><strong>同步位 SYN</strong></p>
</li>
</ol>
<p>当 SYN=1 时表示这是一个连接请求或连接接受报文。</p>
<p>当 SYN=1，ACK=0 时，表明这是一个连接请求报文，若对方同意建立连接，则应在响应报文中使用 SYN=1，ACK=1。</p>
<ol start="11">
<li>
<p><strong>终止位 FIN</strong>(Finish)</p>
<p>用来释放一个连接。当 FIN=1 时，表明<strong>此报文段的发送方的数据已发送完毕</strong>，并要求释放传输连接。</p>
</li>
<li>
<p><strong>窗口</strong></p>
<p>占 2B，范围为 0 ～ 2^16^-1。</p>
<p>窗口值告诉对方，从本报文段首部中的确认号算起，<strong>接收方目前允许对方发送的数据量</strong>（<span class="text-highlight">以字节为单位</span>）。</p>
<p>接收方的数据缓存空间是有限的，因此窗口值作为接收方让发送方设置其发送窗口的依据。</p>
<p>例如，设确认号是 701，窗口字段是 1000。这表明，从 701 号算起，发送此报文段的一方还有接收 1000 字节数据（字节序号为 701 ～ 1700）的接收缓存空间。</p>
</li>
<li>
<p>检验和</p>
<p>占 2B。检验和字段<strong>检验的范围包括首部和数据两部分</strong>。</p>
<p>在计算检验和时，和 UDP 一样，要在 TCP 报文段的前面加上 12B 的伪首部（只需将 UDP 伪首部的协议字段的 17 改成 6，UDP 长度字段改成 TCP 长度，其他的和 UDP 一样）。</p>
<p><img src="./assets/402.png" alt/></p>
</li>
<li>
<p>紧急指针</p>
<p>占 2B。紧急指针仅在 URG=1 时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据在报文段数据的最前面）。也就是说，使窗口为零也可以发送紧急数据。</p>
</li>
<li>
<p>选项</p>
<p>长度可变，最长可达 40B。</p>
<p>当不使用选项时，TCP 首部长度是 20B。TCP 最初只规定了一种选项，即最大报文段长度（MaximumSegmentSize，MSS）。MSS 是 TCP 报文段中的数据字段的最大长度（注意仅仅是数据字段）。</p>
</li>
<li>
<p>填充</p>
<p>这是为了使整个首部长度是 4B 的整数倍。</p>
</li>
</ol>
<h2 id="连接管理">连接管理<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#连接管理" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>TCP 是面向连接的协议，因此每个 TCP 连接都有三个阶段：<strong>连接建立、数据传送和连接释放</strong>。</p>
<p>TCP 连接的管理就是使运输连接的建立和释放都能正常进行。</p>
<p>TCP 把连接作为最基本的抽象，每条 TCP 连接有两个端点，TCP 连接的端点不是主机，不是主机的 IP 地址，不是应用进程，也不是传输层的协议端口。TCP 连接的端口即为套接字，每一条 TCP 连接唯一地被通信的两个端点（即两个套接字）所确定。</p>
<blockquote>
<p><span class="text-highlight">同一个 IP 地址可以有多个不同的 TCP 连接</span>，而<span class="text-highlight">同一个端口号也可以出现在多个不同的 TCP 连接中</span>。</p>
</blockquote>
<p>TCP 连接的建立采用客户/服务器模式。主动发起连接建立的应用进程称为客户(Client)，而被动等待连接建立的应用进程称为服务器(Server)。</p>
<h3 id="连接的建立三次握手">连接的建立(三次握手)<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#连接的建立三次握手" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>连接的建立经历以下 3 个步骤，通常称为“<span class="text-highlight">三次握手</span>”。</p>
<p>“三报文握手”建立 TCP 连接的目的在于解决以下三个主要问题：</p>
<ul>
<li>使 TCP 双方能够确知对方的存在。</li>
<li>使 TCP 双方能够协商一些参数。</li>
<li>使 TCP 双方能够对运输实体资源进行分配和初始化。</li>
</ul>
<p>连接建立前，服务器处于 LISTEN（收听）状态，等待客户的连接请求。</p>
<p><img src="./assets/403.png" alt/></p>
<ol>
<li>
<p>客户机的 TCP 首先向服务器的 TCP 发送连接请求报文段。这个报文段的首部中的同步位 SYN=1，同时选择一个初始序号 seq=x。</p>
<p>TCP 规定，<span class="text-highlight">SYN 报文段不能携带数据，但要消耗掉一个序号</span>。这时，客户机进入 SYN-SENT（同步已发送）状态。</p>
</li>
<li>
<p>服务器的 TCP 收到连接请求报文段后，如同意建立连接，则向客户机发回确认，并为该 TCP 连接分配缓存和变量。</p>
<p>在确认报文段中，把 SYN 位和 ACK 位都置 1，确认号是 ack=x+1，同时也为自已选择一个初始序号 seq=y。</p>
<p><span class="text-highlight">确认报文段不能携带数据，但也要消耗掉一个序号</span>。这时，服务器进入 SYN-RCVD（同步收到）状态。</p>
</li>
<li>
<p>当客户机收到确认报文段后，还要向服务器给出确认，并为该 TCP 连接分配缓存和变量。</p>
<p>确认报文段的 ACK 位置 1，确认号 ack=y+1，序号 seq=x+1。<span class="text-highlight">该报文段可以携带数据，若不携带数据则不消耗序号</span>。</p>
<p>这时，客户机进入 ESTABLISHED（已建立连接）状态。当服务器收到来自客户机的确认后，也进入 ESTABLISHED 状态。</p>
</li>
</ol>
<p>成功进行以上三步后，就建立了 TCP 连接，接下来就可以传送应用层数据。<strong>TCP 提供的是全双工通信</strong>，因此通信双方的应用进程在任何时候都能发送数据。</p>
<hr/>
<blockquote class="callout tip" data-callout="tip">
<div class="callout-title">
                  <div class="callout-icon"></div>
                  <div class="callout-title-inner"><p>为什么不采用“两次握手”建立连接 </p></div>
                  
                </div>
<div class="callout-content">
<p><strong>不采用“两次握手”建立连接</strong>主要是为了<strong>防止两次握手情况下已失效的连接请求报文段突然又传送到服务器而产生错误</strong>。</p>
<p>客户 A 向服务器 B 发出 TCP  连接请求，第一个连接请求报文在网络的某个结点长时间滞留，A 超时后认为报文丢失，于是再重传一次连接请求，B 收到后建立连接。数据传输完毕后双方断开连接。而此时，前一个滞留在网络中的连接请求到达服务器 B，而 B 认为 A 又发来连接请求。此时，</p>
<ul>
<li>若使用“三次握手”，则 B 向 A 返回确认报文段，因为是一个失效的请求，所以 A 不予理睬，建立连接失败。</li>
<li>若采用的是“两次握手”，则这种情况下 B 认为传输连接已经建立，并一直等待 A 传输数据，而 A 此时并无连接请求，因此不予理睬，这样就造成了 B 的资源白白浪费。</li>
</ul>
<p><img src="./assets/404.png" alt/></p>
</div>
</blockquote>
<blockquote class="callout tip" data-callout="tip">
<div class="callout-title">
                  <div class="callout-icon"></div>
                  <div class="callout-title-inner"><p>Tip</p></div>
                  
                </div>
<div class="callout-content">
<p><img src="./assets/image-20241206233532805.png" alt="image-20241206233532805"/></p>
</div>
</blockquote>
<h3 id="连接的释放四次挥手">连接的释放(四次挥手)<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#连接的释放四次挥手" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>与 TCP 连接的<span class="text-highlight">两个进程中的任何一个都能终止该连接</span>。TCP 连接释放的过程通常称为“<span class="text-highlight">四次挥手</span>”。</p>
<p><img src="./assets/405.png" alt/></p>
<ol>
<li>
<p>客户机打算关闭连接时，向其 TCP 发送连接释放报文段，并停止发送数据，主动关闭 TCP 连接，该报文段的终止位 FIN=1，序号 seq=u，它等于前面已传送过的数据的最后一个字节的序号加 1，<strong>FIN 报文段即使不携带数据，也要消耗掉一个序号</strong>。</p>
<p>这时，客户机进入 FIN-WAIT-1（终止等待 1）状态。</p>
<p>TCP 是全双工的，即可以想象为一条 TCP 连接上有两条数据通路，发送 FIN 的一端不能再发送数据，即关闭了其中一条数据通路，但对方还可以发送数据。</p>
</li>
<li>
<p>服务器收到连接释放报文段后即发出确认，确认号 ack=u+1，序号 seq=v，等于它前面已传送过的数据的最后一个字节的序号加 1。然后服务器进入 CLOSE-WAIT（关闭等待）状态。</p>
<p><span class="text-highlight">此时，从客户机到服务器这个方向的连接就释放了</span>，TCP 连接处于半关闭状态。但<strong>服务器若发送数据，客户机仍要接收</strong>，即从服务器到客户机这个方向的连接并未关闭。</p>
<p>客户机收到来自服务器的确认后，进入 FIN-WAIT-2（终止等待 2）状态，等待服务器发出的连接释放报文段。</p>
</li>
<li>
<p>若服务器已经没有要向客户机发送的数据，就通知 TCP 释放连接，此时，其发出 FIN=1 的连接释放报文段。</p>
<p>设该报文段的序号为 w（处于半关闭状态的服务器可能又发送了一些数据），还必须重复发送上次已发送的确认号 ack=u+1。这时服务器进入 LAST-ACK（最后确认）状态。</p>
</li>
<li>
<p>客户机收到连接释放报文段后，必须发出确认，之后进入 TIME-WAIT（时间等待）状态。该报文段的确认位 ACK 置 1，确认号 ack=w+1，序号 seq=u+1。</p>
<p>服务器收到该确认报文段后就进入 CLOSED（连接关闭）状态。客户机进入 TIME-WAIT 状态后，还要经过时间等待计时器设置的时间 2MSL（Maximum Segment Lifetime，最长报文段寿命）后，才进入 CLOSED 状态。</p>
</li>
</ol>
<p>若服务器收到连接释放请求后不再发送数据，则从<strong>客户机发出 FIN 报文段时刻算起</strong>，<span class="text-highlight">客户机释放连接的最短时间为 1 RTT + 2 MSL</span>，<span class="text-highlight">服务器释放连接的最短时间为 1.5 RTT</span>。</p>
<p><img src="./assets/406.png" alt/></p>
<blockquote class="callout note" data-callout="note">
<div class="callout-title">
                  <div class="callout-icon"></div>
                  <div class="callout-title-inner"><p>Note</p></div>
                  
                </div>
<div class="callout-content">
<p>除时间等待计时器外，TCP 还设有一个保活计时器。设想 TCP 双方已建立连接，但后来客户主机突然出现故障。显然，服务器以后就不能再收到客户发来的数据。因此，应当有措施使服务器不要再白白等待下去，这个问题就可以使用保活计时器来解决。</p>
<p><img src="./assets/407.png" alt/></p>
</div>
</blockquote>
<h2 id="流量控制">流量控制<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#流量控制" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>流量控制的功能就是<span class="text-highlight">让发送方的发送速率不要太快</span>，以便让接收方来得及接收，因此可以说流量控制是一个速度匹配服务（匹配发送方的发送速率与接收方的读取速率）。</p>
<p><img src="./assets/408.png" alt/></p>
<p>TCP 利用<span class="text-highlight">滑动窗口机制</span><strong>来实现流量控制</strong>。TCP 要求发送方维持一个<strong>接收窗口(rwnd)</strong>，接收方根据当前接收缓存的大小，动态地调整接收窗口的大小，其大小反映了接收方的容量。接收方将其放在 TCP 报文段首部中的“窗口”字段，以通知发送方。</p>
<p>发送方的发送窗口不能超过接收方给出的接收窗口值，以限制发送方向网络注入报文的速率。</p>
<p>假设数据只从 A 发往 B，而 B 仅向 A 发送确认报文段，则 B 可通过设置确认报文段首部中的窗口字段来将 rwnd 通知给 A。接收方允许连续接收的能力，<strong>单位是字节</strong>。</p>
<p><img src="./assets/409.png" alt/></p>
<p>发送方 A <span class="text-highlight">总是根据最新收到的 rwnd 值来限制自已发送窗口的大小</span>，从而将未确认的数据量控制在 rwnd 大小之内，保证 A 不会使 B 的接收缓存溢出。</p>
<p>设 A 向 B 发送数据，在连接建立时，B 告诉 A：“我的接收窗口 rwnd=400”。接收方 B 进行了三次流量控制，这三个报文段都设置了 ACK=1，只有在 ACK=1 时确认号字段才有意义。第一次把窗口减到 rwnd=300，第二次又减到 rwnd=100，最后减到 rwnd=0，即不充许发送方再发送数据。这使得发送方暂停发送的状态将持续到 B 重新发出一个新的窗口值为止。</p>
<p><img src="./assets/410.png" alt/></p>
<p>TCP 为每个连接设有一个<strong>持续计时器</strong>，只要发送方收到对方的零窗口通知，就启动持续计时器。若计时器超时，就发送一个零窗口探测报文段，而对方就在确认这个探测报文段时给出现在的窗口值。若窗口仍然为零，则发送方收到确认报文段后就重新设置持续计时器。</p>
<p><img src="./assets/411.png" alt/></p>
<p>传输层和数据链路层的流量控制的区别是：</p>
<ul>
<li>传输层实现的是端到端，即两个进程之间的流量控制。传输层的滑动窗口协议的窗口大小则可以动态变化。</li>
<li>数据链路层实现的是两个中间的相邻结点之间的流量控制。此外，数据链路层的滑动窗口协议的窗口大小不能动态变化。</li>
</ul>
<h2 id="拥塞控制">拥塞控制<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#拥塞控制" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<h3 id="拥塞">拥塞<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#拥塞" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>在某段时间，若<strong>对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏</strong>，这种情况就叫作<span class="text-highlight">拥塞</span>。</p>
<blockquote class="callout note" data-callout="note">
<div class="callout-title">
                  <div class="callout-icon"></div>
                  <div class="callout-title-inner"><p>Note</p></div>
                  
                </div>
<div class="callout-content">
<p>拥塞现象是指到达通信子网中某一部分的<strong>分组数量过多</strong>，使得该部分<strong>网络来不及处理</strong>，以致这部分乃至整个网络性能下降的现象，严重时甚至导致网络通信业务陷入停顿，即出现死锁现象。</p>
</div>
</blockquote>
<p>判断网络是否进入拥塞状态的方法是，<strong>观察网络的吞吐量与网络负载的关系</strong>：</p>
<ul>
<li>若随着网络负载的增加，网络的<strong>吞吐量明显小于正常的吞吐量</strong>，则网络就可能已<strong>进入轻度拥塞状态</strong>；</li>
<li>若网络的<strong>吞吐量随着网络负载的增大而下降</strong>，则网络就可能已<strong>进入拥塞状态</strong>。</li>
</ul>
<p><img src="./assets/412.png" alt/></p>
<h3 id="拥塞控制-1">拥塞控制<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#拥塞控制-1" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p><span class="text-highlight">拥塞控制</span>是指<strong>防止过多的数据注入网络，保证网络中的路由器或链路不致过载</strong>。出现拥塞时，端点并不了解拥塞发生的细节，<strong>对通信的端点来说，拥塞往往表现为通信时延的增加</strong>。</p>
<p>拥塞控制主要解决的问题是如何获取网络中发生拥塞的信息，从而利用这些信息进行控制，以避免因拥塞而出现分组的丢失。</p>
<blockquote class="callout tip" data-callout="tip">
<div class="callout-title">
                  <div class="callout-icon"></div>
                  <div class="callout-title-inner"><p>拥塞控制与流量控制的区别 </p></div>
                  
                </div>
<div class="callout-content">
<ul>
<li>
<p><strong>拥塞控制</strong>是让网络能够承受现有的网络负荷，是一个<span class="text-highlight">全局性的过程</span>，<strong>涉及所有的主机、所有的路由器</strong>，以及与<strong>降低网络传输性能有关的所有因素</strong>。</p>
<p><img src="./assets/414.png" alt/></p>
</li>
<li>
<p><strong>流量控制</strong>往往是指点对点的通信量的控制，是个<span class="text-highlight">端到端的问题</span>（<strong>接收端控制发送端</strong>），它所要做的是<strong>抑制发送端发送数据的速率</strong>，以便使接收端来得及接收。</p>
<p><img src="./assets/413.png" alt/></p>
</li>
</ul>
<p><img src="./assets/415.png" alt/></p>
<p>拥塞控制和流量控制也有相似的地方，即它们<span class="text-highlight">都通过控制发送方发送数据的速率来达到控制效果</span>。</p>
</div>
</blockquote>
<p>拥塞控制的方法有两种：</p>
<ol>
<li>
<p><strong>开环控制</strong></p>
<p>在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。</p>
<p>这是一种静态的预防方法。一旦整个系统启动并运行，中途就不再需要修改。</p>
<p><strong>当网络的流量特征可以准确规定且性能要求可以事先获得时，适合使用开环控制</strong>。</p>
</li>
<li>
<p><strong>闭环控制</strong></p>
<p>事先不考虑有关发生拥塞的各种因素，采用监测网络系统去监视，及时检测哪里发生了拥塞，然后将拥塞信息传到合适的地方，以便调整网络系统的运行，并解决出现的问题。</p>
<p>闭环控制是基于反馈环路的概念，是一种动态的方法。</p>
<p><strong>当网络的流量特征不能准确描述或者当网络不提供资源预留时，适合使用闭环控制</strong>。<strong>因特网采用的就是闭环控制方法</strong>。</p>
</li>
</ol>
<blockquote class="callout note" data-callout="note">
<div class="callout-title">
                  <div class="callout-icon"></div>
                  <div class="callout-title-inner"><p>Note</p></div>
                  
                </div>
<div class="callout-content">
<blockquote>
<p>王道书上没有</p>
</blockquote>
<p><img src="./assets/416.png" alt/></p>
</div>
</blockquote>
<h3 id="tcp-拥塞控制方法">TCP 拥塞控制方法<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#tcp-拥塞控制方法" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>可靠传输 TCP 进行拥塞控制的算法有四种：<span class="text-highlight">慢开始</span>、<span class="text-highlight">拥塞避免</span>、<span class="text-highlight">快重传</span>和<span class="text-highlight">快恢复</span>。</p>
<p>发送方在确定发送报文段的速率时，既要考虑接收方的接收能力，又要从全局考虑不要使网络发生拥塞。因此，除了接收窗口，TCP 还要求<strong>发送方</strong>维持一个<span class="text-highlight">拥塞窗口(cwnd)</span>，其<strong>大小取决于网络的拥塞程度</strong>，并且<strong>动态地变化</strong>。</p>
<p><strong>发送方控制拥塞窗口的原则</strong>：只要网络未出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去，以提高网络的利用率。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络的分组数，以缓解网络出现的拥塞。</p>
<blockquote class="callout tip" data-callout="tip">
<div class="callout-title">
                  <div class="callout-icon"></div>
                  <div class="callout-title-inner"><p>判断网络出现拥塞的依据 </p></div>
                  
                </div>
<div class="callout-content">
<p>没有按时收到应当到达的 TCP 确认报文段而产生了超时重传。</p>
</div>
</blockquote>
<p><strong>发送窗口的上限值</strong>应取<strong>接收窗口</strong> rwnd 和<strong>拥塞窗口</strong> cwnd 中<strong>较小的一个</strong>，即</p>
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord cjk_fallback">发送窗口的上限值</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">min</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mclose">]</span></span></span></span></span>
<p><img src="./assets/417.png" alt/></p>
<blockquote>
<p>假设：</p>
<ul>
<li>数据为单方向传送，对方只传送确认报文。</li>
<li>接收方总是有足够大的缓存空间，因而发送窗口的大小由网络的拥塞程度决定，也就是不考虑接收方对发送方的流量控制。</li>
<li>以 TCP <span class="text-highlight">最大报文段长度 MSS</span>（即<strong>TCP 报文段的数据载荷部分</strong>）的个数作为讨论问题的单位，而不是以字节为单位（尽管 TCP 是面向字节流的）。</li>
</ul>
</blockquote>
<h4 id="慢开始-拥塞避免">慢开始-拥塞避免<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#慢开始-拥塞避免" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<blockquote class="callout note" data-callout="note">
<div class="callout-title">
                  <div class="callout-icon"></div>
                  <div class="callout-title-inner"><p>ssthresh 阈值 </p></div>
                  
                </div>
<div class="callout-content">
<p>为了<strong>防止 cwnd 增长过大而引起网络拥塞</strong>，还需要设置一个慢开始门限 <span class="text-highlight">ssthresh</span>（闽值）。这样，当慢开始一直把 cwnd 增大到一个规定的 ssthresh 时，然后改用拥塞避免算法。</p>
<p><img src="./assets/418.png" alt/></p>
</div>
</blockquote>
<p><span class="text-highlight">慢开始算法</span>的思路是当发送方刚开始发送数据时，因为并不清楚网络的负荷情况，若立即把大量数据注入网络，则有可能引发网络拥塞。因此<strong>先发送少量数据探测一下，若没有发生拥塞，则适当增大拥塞窗口，即由小到大逐渐增大拥塞窗口</strong>（即发送窗口）。</p>
<p>使用慢开始算法后，每经过一个传输轮次（即往返时延 RTT），<span class="text-highlight">cwnd 就会加倍</span>，即 cwnd 的值随传输轮次指数增长。</p>
<p><img src="./assets/419.png" alt/></p>
<p>慢开始的“慢”并不是指拥塞窗口 cwnd 的增长速率慢，而是指在 TCP 开始发送报文段时先设置 cwnd=1，使得发送方一开始向网络注入的报文段少（目的是试探一下网络的拥塞情况），然后逐渐增大 cwnd，这对防止网络出现拥塞是一个非常有力的措施。</p>
<blockquote class="callout tip" data-callout="tip">
<div class="callout-title">
                  <div class="callout-icon"></div>
                  <div class="callout-title-inner"><p>Tip</p></div>
                  
                </div>
<div class="callout-content">
<p>在<strong>不超过阈值</strong>的时候，每经过一个 RTT 后拥塞窗口 cwnd 就会加倍，这里的加倍本质上原拥塞窗口 cwnd 加上收到的 ACK。</p>
<blockquote>
<p>接受缓存的大小/最大段长 MSS = 接受窗口大小</p>
</blockquote>
<p>假设 MSS=1KB，接收缓存 60KB，接收缓存满了才向应用层交付。</p>





























<div class="table-container"><table><thead><tr><th style="text-align:center;"></th><th style="text-align:center;">阈值(ssthresh)</th><th style="text-align:center;">拥塞窗口(cwnd)</th><th style="text-align:center;">接收窗口(rwnd)</th><th style="text-align:center;">发送窗口(swnd)</th><th style="text-align:center;">发送数据量/接受ACK量</th></tr></thead><tbody><tr><td style="text-align:center;">RTT1</td><td style="text-align:center;"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span></td><td style="text-align:center;"><span class="text-highlight">32</span></td><td style="text-align:center;">29</td><td style="text-align:center;">29</td><td style="text-align:center;"><span class="text-highlight">29</span></td></tr><tr><td style="text-align:center;">RTT2</td><td style="text-align:center;"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span></td><td style="text-align:center;"><span class="text-highlight">61</span></td><td style="text-align:center;">60</td><td style="text-align:center;">60</td><td style="text-align:center;">60</td></tr></tbody></table></div>
</div>
</blockquote>
<hr/>
<p><span class="text-highlight">拥塞避免算法</span>的思路是<span class="text-highlight">让拥塞窗口 cwnd 缓慢增大</span>，县体做法是：<strong>每经过一个往返时延 RTT 就把发送方的拥塞窗口 cwnd</strong> <span class="text-highlight">加 1</span>，而不是加倍，使拥塞窗口 cwnd <strong>按线性规律缓慢增长</strong>，这比慢开始算法的拥塞窗口增长速率要缓慢得多。</p>
<p>“拥塞避免”也<span class="text-highlight">并非指完全能够避免拥塞</span>，而是指在拥塞避免阶段将 cwnd 值控制为按线性规律增长，<strong>使网络比较不容易出现拥塞</strong>。</p>
<p><img src="./assets/420.png" alt/></p>
<p>无论<strong>在慢开始阶段还是在拥塞避免阶段</strong>，只要发送方判断<strong>网络出现拥塞</strong><span class="text-highlight">（未按时收到确认）</span></p>
<ol>
<li>首先把慢开始门限 <span class="text-highlight">ssthresh 设置为出现拥塞时的发送方的 cwnd 值的一半</span>（但<strong>不能小于 2</strong>）</li>
<li>然后把拥塞窗口 <span class="text-highlight">cwnd 重新设置为 1</span>，<span class="text-highlight">执行慢开始算法</span>。这样做的目的是迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完。</li>
</ol>
<p><img src="./assets/421.png" alt/></p>
<p><img src="./assets/422.png" alt/></p>
<p><img src="./assets/423.png" alt/></p>
<h4 id="快重传-快恢复">快重传-快恢复<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#快重传-快恢复" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>有时个别报文段会在网络中丢失，但实际上网络并未发生拥塞。若发送方迟迟收不到确认，就会产生超时，并误认为网络发生了拥塞，这就导致发送方错误地启动慢开始算法，从而降低传输效率。</p>
<p>采用<span class="text-highlight">快重传算法可以让发送方尽早知道发生了个别报文段的丢失</span>。</p>
<p><img src="./assets/424.png" alt/></p>
<p><span class="text-highlight">快重传算法</span>是<strong>使发送方尽快（尽早）进行重传，而不等超时计时器超时再重传</strong>。这就要求：</p>
<ul>
<li>接收方不要等待自已发送数据时才进行销带确认，而要立即发送确认，即使<span class="text-highlight">收到了失序的报文段也要立即发出对已收到报文段的重复确认</span>。</li>
<li>发送方一旦连<span class="text-highlight">续收到 3 个余 ACK</span>（即重复确认），就立即重传相应的报文段，而不等该报文段的超时计时器超时再重传。</li>
</ul>
<p><img src="./assets/425.png" alt/></p>
<blockquote class="callout tip" data-callout="tip">
<div class="callout-title">
                  <div class="callout-icon"></div>
                  <div class="callout-title-inner"><p>Tip</p></div>
                  
                </div>
<div class="callout-content">
<p>TCP 规定每当比期望序号大的失序报文段到达时，就发送一个冗余 ACK，指明下一个期待字节的序号。</p>
</div>
</blockquote>
<p><span class="text-highlight">快恢复算法</span>的原理如下：当<strong>发送方连续收到 3 个冗余 ACK（重复确认）时</strong>，把慢开始门限 <span class="text-highlight">ssthresh 调整为当前 cwnd 的一半</span>（为了预防网络发生拥塞）。但此时发送方知道现在只是丢失了个别的报文段，于是不启动慢开始算法，而是<span class="text-highlight">执行快恢复算法</span>。</p>
<blockquote class="callout tip" data-callout="tip">
<div class="callout-title">
                  <div class="callout-icon"></div>
                  <div class="callout-title-inner"><p>Tip</p></div>
                  
                </div>
<div class="callout-content">
<p>因为跳过了拥塞窗口 cwnd 从 1 起始的慢开始过程，所以被称为快恢复。</p>
</div>
</blockquote>
<p><img src="./assets/426.png" alt/></p>
<h4 id="总流程">总流程<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#总流程" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p><img src="./assets/427.png" alt/></p>
<p>接收方的缓存空间总是有限的。因此，发送方发送窗口的大小由流量控制和拥塞控制共同决定。</p>
<blockquote class="callout tip" data-callout="tip">
<div class="callout-title">
                  <div class="callout-icon"></div>
                  <div class="callout-title-inner"><p>Tip</p></div>
                  
                </div>
<div class="callout-content">
<p>当题目中同时出现接收窗口(rwnd)和拥塞窗口(cwnd)时，发送方发送窗口的实际大小是由 rwnd 和 cwnd 中较小的那一个确定的。</p>
</div>
</blockquote>
<p><img src="./assets/428.png" alt/></p>
<p><img src="./assets/429.png" alt/></p>
<p><img src="./assets/430.png" alt/></p>
<p><img src="./assets/431.png" alt/></p>
<p><img src="./assets/432.png" alt/></p>
<p><img src="./assets/433.png" alt/></p>
<p><img src="./assets/434.png" alt/></p>
<h3 id="tcp-拥塞控制与网际层拥塞控制的关系">TCP 拥塞控制与网际层拥塞控制的关系*<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#tcp-拥塞控制与网际层拥塞控制的关系" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p><img src="./assets/435.png" alt/></p>
<p><img src="./assets/436.png" alt/></p>
<h2 id="可靠传输">可靠传输<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#可靠传输" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>TCP 在不可靠的 IP 层之上建立一种可靠数据传输服务。</p>
<p>TCP 提供的可靠数据传输服务保证接收方从缓存区读出的字节流与发送方发出的字节流完全一样。TCP 使用了检验、序号、确认和重传等机制来达到这一目的。其中，TCP 的检验机制与 UDP 一样。</p>
<h3 id="序号和确认">序号和确认<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#序号和确认" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p><img src="./assets/437.png" alt/></p>
<p><img src="./assets/438.png" alt/></p>
<p><img src="./assets/439.png" alt/></p>
<p><img src="./assets/440.png" alt/></p>
<p><img src="./assets/441.png" alt/></p>
<p><img src="./assets/442.png" alt/></p>
<p><img src="./assets/443.png" alt/></p>
<blockquote class="callout tip" data-callout="tip">
<div class="callout-title">
                  <div class="callout-icon"></div>
                  <div class="callout-title-inner"><p>Tip</p></div>
                  
                </div>
<div class="callout-content">
<p>TCP 使用累积确认，这看起来像是 GBN 的风格。但是，正确收到但失序的报文并不会丢弃，而是缓存起来，并且发送余 ACK 指明期望收到的下一个报文段，这是 TCP 方式和 GBN 的显著区别。</p>
<p>例如，A 发送了 N 个报文段，其中第 k 个报文段丢失，其余 N-1 个报文段正确地按序到达接收方 B。</p>
<ul>
<li>使用 GBN 时，A 需要重传分组 k，以及所有后继分组 k+1,k+2,,N。相反，TCP 却至多重传一个报文段，即报文段 k。</li>
<li>另外，TCP 中提供一个 SACK(Selective ACK)选项，即选择确认选项。使用选择确认选项时，TCP 看起来就和 SR 非常相似。因此，TCP 的差错恢复机制可视为 GBN 和 SR 协议的混合体。</li>
</ul>
</div>
</blockquote>
<h3 id="重传">重传<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#重传" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>有两种事件会导致 TCP 对报文段进行重传：<span class="text-highlight">超时</span>和<span class="text-highlight">冗余 ACK</span>。</p>
<p>TCP <span class="text-highlight">每发送一个报文段，就对这个报文段设置一个超时计时器</span>。计时器设置的重传时间到期但还未收到确认时，就要重传这一报文段。</p>
<p>因为 TCP 的下层是互联网环境，IP 数据报所选择的路由变化很大，所以传输层的往返时延的方差也很大。为了计算超时计时器的重传时间，TCP 采用一种自适应算法，它记录一个报文段发出的时间，以及收到相应确认的时间，这两个时间之差称为报文段的<strong>往返时间(Round-TripTime, RTT)</strong>。TCP 维护了 RTT 的一个<span class="text-highlight">加权平均往返时间 RTTS</span>，它会随新测量 RTT 样本值的变化而变化。</p>
<p>显然，超时计时器设置的**超时重传时间(RetransmissionTime-Out，RTO)**应<span class="text-highlight">略大于 RTTS</span>，但也不能大太多，否则当报文段丢失时，TCP 不能很快重传，导致数据传输时延大。</p>
<p><img src="./assets/444.png" alt/></p>
<p><img src="./assets/445.png" alt/></p>
<p>超时触发重传存在的一个问题是超时周期往往太长。所幸的是，发送方通常可在超时事件发生之前通过注意所谓的冗余 ACK 来较好地检测丢包情况。</p>
<p>冗余 ACK 就是再次确认某个报文段的 ACK，而发送方先前已经收到过该报文段的确认。TCP 规定当发送方收到对同一个报文段的 3 个余 ACK 时，就可以认为跟在这个被确认报文段之后的报文段已经丢失。</p>
<p>例如，发送方 A 发送了序号为 1、2、3、4、5 的 TCP 报文段，其中 2 号报文段在链路中丢失，它无法到达接收方 B。因此 3、4、5 号报文段对于 B 来说就成了失序报文段，但它们不是 B 所期望收到的下一个报文段，于是 B 就发送 3 个对 1 号报文段的冗余 ACK，表示自己期望接收 2 号报文段。当 A 收到对于 1 号报文段的 3 个见余 ACK 时，认为 2 号报文段已经丢失，这时发送方 A 可以立即对 2 号报文段执行重传，这种技术通常称为快速重传。</p>
<p>当然，冗余 ACK 还被用在拥塞控制中。</p>
<h1 id="udp-和-tcp-对比">UDP 和 TCP 对比<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#udp-和-tcp-对比" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p><img src="./assets/392.png" alt/></p>
<p><img src="./assets/393.png" alt/></p>
<p><img src="./assets/394.png" alt/></p>
<p><img src="./assets/395.png" alt/></p>
<p><img src="./assets/396.png" alt/></p></article><hr/><div class="page-footer"></div></div><div class="right sidebar"><div class="graph"><h3>关系图谱</h3><div class="graph-outer"><div id="graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:1,&quot;scale&quot;:1.1,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:60,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[],&quot;focusOnHover&quot;:false}"></div><button id="global-graph-icon" aria-label="Global Graph"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 55 55" fill="currentColor" xml:space="preserve"><path d="M49,0c-3.309,0-6,2.691-6,6c0,1.035,0.263,2.009,0.726,2.86l-9.829,9.829C32.542,17.634,30.846,17,29,17
                s-3.542,0.634-4.898,1.688l-7.669-7.669C16.785,10.424,17,9.74,17,9c0-2.206-1.794-4-4-4S9,6.794,9,9s1.794,4,4,4
                c0.74,0,1.424-0.215,2.019-0.567l7.669,7.669C21.634,21.458,21,23.154,21,25s0.634,3.542,1.688,4.897L10.024,42.562
                C8.958,41.595,7.549,41,6,41c-3.309,0-6,2.691-6,6s2.691,6,6,6s6-2.691,6-6c0-1.035-0.263-2.009-0.726-2.86l12.829-12.829
                c1.106,0.86,2.44,1.436,3.898,1.619v10.16c-2.833,0.478-5,2.942-5,5.91c0,3.309,2.691,6,6,6s6-2.691,6-6c0-2.967-2.167-5.431-5-5.91
                v-10.16c1.458-0.183,2.792-0.759,3.898-1.619l7.669,7.669C41.215,39.576,41,40.26,41,41c0,2.206,1.794,4,4,4s4-1.794,4-4
                s-1.794-4-4-4c-0.74,0-1.424,0.215-2.019,0.567l-7.669-7.669C36.366,28.542,37,26.846,37,25s-0.634-3.542-1.688-4.897l9.665-9.665
                C46.042,11.405,47.451,12,49,12c3.309,0,6-2.691,6-6S52.309,0,49,0z M11,9c0-1.103,0.897-2,2-2s2,0.897,2,2s-0.897,2-2,2
                S11,10.103,11,9z M6,51c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S8.206,51,6,51z M33,49c0,2.206-1.794,4-4,4s-4-1.794-4-4
                s1.794-4,4-4S33,46.794,33,49z M29,31c-3.309,0-6-2.691-6-6s2.691-6,6-6s6,2.691,6,6S32.309,31,29,31z M47,41c0,1.103-0.897,2-2,2
                s-2-0.897-2-2s0.897-2,2-2S47,39.897,47,41z M49,10c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S51.206,10,49,10z"></path></svg></button></div><div id="global-graph-outer"><div id="global-graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:-1,&quot;scale&quot;:0.9,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[],&quot;focusOnHover&quot;:true}"></div></div></div><div class="toc desktop-only"><button type="button" id="toc" class aria-controls="toc-content" aria-expanded="true"><h3>目录</h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="toc-content" class><ul class="overflow"><li class="depth-0"><a href="#基本概念" data-for="基本概念">基本概念</a></li><li class="depth-1"><a href="#传输层的功能" data-for="传输层的功能">传输层的功能</a></li><li class="depth-1"><a href="#两个主要协议" data-for="两个主要协议">两个主要协议</a></li><li class="depth-1"><a href="#端口" data-for="端口">端口</a></li><li class="depth-1"><a href="#复用和分用" data-for="复用和分用">复用和分用</a></li><li class="depth-1"><a href="#检错检测" data-for="检错检测">检错检测</a></li><li class="depth-0"><a href="#udp" data-for="udp">UDP</a></li><li class="depth-1"><a href="#udp-概述" data-for="udp-概述">UDP 概述</a></li><li class="depth-1"><a href="#udp-数据报" data-for="udp-数据报">UDP 数据报</a></li><li class="depth-1"><a href="#udp-检验" data-for="udp-检验">UDP 检验</a></li><li class="depth-0"><a href="#tcp" data-for="tcp">TCP</a></li><li class="depth-1"><a href="#特点" data-for="特点">特点</a></li><li class="depth-1"><a href="#报文段" data-for="报文段">报文段</a></li><li class="depth-1"><a href="#连接管理" data-for="连接管理">连接管理</a></li><li class="depth-2"><a href="#连接的建立三次握手" data-for="连接的建立三次握手">连接的建立(三次握手)</a></li><li class="depth-2"><a href="#连接的释放四次挥手" data-for="连接的释放四次挥手">连接的释放(四次挥手)</a></li><li class="depth-1"><a href="#流量控制" data-for="流量控制">流量控制</a></li><li class="depth-1"><a href="#拥塞控制" data-for="拥塞控制">拥塞控制</a></li><li class="depth-2"><a href="#拥塞" data-for="拥塞">拥塞</a></li><li class="depth-2"><a href="#拥塞控制-1" data-for="拥塞控制-1">拥塞控制</a></li><li class="depth-2"><a href="#tcp-拥塞控制方法" data-for="tcp-拥塞控制方法">TCP 拥塞控制方法</a></li><li class="depth-2"><a href="#tcp-拥塞控制与网际层拥塞控制的关系" data-for="tcp-拥塞控制与网际层拥塞控制的关系">TCP 拥塞控制与网际层拥塞控制的关系*</a></li><li class="depth-1"><a href="#可靠传输" data-for="可靠传输">可靠传输</a></li><li class="depth-2"><a href="#序号和确认" data-for="序号和确认">序号和确认</a></li><li class="depth-2"><a href="#重传" data-for="重传">重传</a></li><li class="depth-0"><a href="#udp-和-tcp-对比" data-for="udp-和-tcp-对比">UDP 和 TCP 对比</a></li></ul></div></div></div><footer class><p>Created with <a href="https://quartz.jzhao.xyz/">Quartz v4.4.0</a> © 2025</p><ul><li><a href="https://github.com/KISGP">GitHub</a></li></ul></footer></div></div></body><script type="application/javascript">function c(){let t=this.parentElement;t.classList.toggle("is-collapsed");let l=t.classList.contains("is-collapsed")?this.scrollHeight:t.scrollHeight;t.style.maxHeight=l+"px";let o=t,e=t.parentElement;for(;e;){if(!e.classList.contains("callout"))return;let n=e.classList.contains("is-collapsed")?e.scrollHeight:e.scrollHeight+o.scrollHeight;e.style.maxHeight=n+"px",o=e,e=e.parentElement}}function i(){let t=document.getElementsByClassName("callout is-collapsible");for(let s of t){let l=s.firstElementChild;if(l){l.addEventListener("click",c),window.addCleanup(()=>l.removeEventListener("click",c));let e=s.classList.contains("is-collapsed")?l.scrollHeight:s.scrollHeight;s.style.maxHeight=e+"px"}}}document.addEventListener("nav",i);window.addEventListener("resize",i);
</script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/copy-tex.min.js" type="application/javascript"></script><script type="application/javascript">
        const socket = new WebSocket('ws://localhost:3001')
        // reload(true) ensures resources like images and scripts are fetched again in firefox
        socket.addEventListener('message', () => document.location.reload(true))
      </script><script src="../../../postscript.js" type="module"></script></html>