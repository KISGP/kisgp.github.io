{"Git/删除分支":{"title":"删除分支","links":[],"tags":[],"content":"// 删除本地分支\ngit branch -d localBranchName\n \n// 删除远程分支\ngit push origin --delete remoteBranchName\n \n// 精简分支, 不会显示已远程被删除的分支\ngit fetch -p"},"Git/文件.gitkeep是什么":{"title":"文件.gitkeep是什么","links":[],"tags":[],"content":"由于占位。\n由于 Git 默认不追踪空目录，所以当项目结构中需要保留空文件夹时，可以在这些空文件夹中添加一个 .gitkeep 文件。这样，Git 就会将这个文件夹视为非空，并将其包含在版本控制中。"},"Markdown/Callouts-标注":{"title":"Callouts 标注","links":[],"tags":["Obsidian","typora"],"content":"Obsidian\n与 Typora 相比，Obsidian 的 callouts 支持的类型更多，而且 Obsidian 还可以通过插件自定义类型。\n\n\n                  \n                  Note\n                  \n                \n\ntext\n\n\n\n\n                  \n                  Abstract\n                  \n                \n\ntext\n\n\n\n\n                  \n                  Info\n                  \n                \n\ntext\n\n\n\n\n                  \n                  Todo\n                  \n                \n\ntext\n\n\n\n\n                  \n                  Tip\n                  \n                \n\ntext\n\n\n\n\n                  \n                  Success\n                  \n                \n\ntext\n\n\n\n\n                  \n                  Question\n                  \n                \n\ntext\n\n\n\n\n                  \n                  Warning\n                  \n                \n\ntext\n\n\n\n\n                  \n                  Failure\n                  \n                \n\ntext\n\n\n\n\n                  \n                  Danger\n                  \n                \n\ntext\n\n\n\n\n                  \n                  Bug\n                  \n                \n\ntext\n\n\n\n\n                  \n                  Example\n                  \n                \n\ntext\n\n\n\n\n                  \n                  Quote\n                  \n                \n\ntext\n\n\n\n\n                  \n                  NOTE\n                  \n                \n\ntext\n\n\n\n\n                  \n                  Tip\n                  \n                \n\ntext\n\n\n\n\n                  \n                  IMPORTANT\n                  \n                \n\ntext\n\n\n\n\n                  \n                  WARNING\n                  \n                \n\ntext\n\n\n\n\n                  \n                  CAUTION\n                  \n                \n\ntext\n\n\nTypora\nTypora 中的 Callouts / Github Style Alert 则是在 Typora 1.8 版本新增的特性，仅支持 5 种类型，且不支持标题和折叠以及自定义类型。\n\n\n                  \n                  NOTE\n                  \n                \n\nHighlights information that users should take into account, even when skimming.\n\n\n\n\n                  \n                  Tip\n                  \n                \n\nOptional information to help a user be more successful.\n\n\n\n\n                  \n                  IMPORTANT\n                  \n                \n\nCrucial information necessary for users to succeed.\n\n\n\n\n                  \n                  WARNING\n                  \n                \n\nCritical content demanding immediate user attention due to otential risks.\n\n\n\n\n                  \n                  CAUTION\n                  \n                \n\nNegative potential consequences of an action.\n\n"},"Markdown/Obsidian-教程":{"title":"Obsidian 教程","links":[],"tags":["Obsidian"],"content":"Obsidian 官方教程\n"},"Markdown/Typora-自定义-Callouts-样式":{"title":"Typora 自定义 Callouts","links":[],"tags":["typora"],"content":"效果\n\n\nCSS 代码\ntailwind.css.md-alert {\n  padding-top: 4px;\n  padding-bottom: 4px;\n  border-radius: 8px;\n  border-left: none;\n  border: 3px solid #dedede !important;\n}\n \n.md-alert-note {\n  background-color: #bce3ff4d;\n}\n \n.md-alert-tip {\n  background-color: #00ffc81a;\n}\n \n.md-alert-important {\n  background-color: #b38bff33;\n}\n \n.md-alert-warning {\n  background-color: #ffab0033;\n}\n \n.md-alert-caution {\n  background-color: #cf222e33;\n}\n \ndiv.md-alert&gt;p:first-child {\n  margin-top: 6px;\n  margin-bottom: 6px;\n}\ntailwind-dark.css.md-alert {\n  border: 3px solid #5f5f5f73 !important;\n}\n \n.md-alert-note {\n  background-color: #4079a128 !important;\n}\n \n.md-alert-tip {\n  background-color: #00ff551a !important;\n}\n \n.md-alert-important {\n  background-color: #9963ff1a !important;\n}\n \n.md-alert-warning {\n  background-color: #ffaa0026 !important;\n}\n \n.md-alert-caution {\n  background-color: #95020c26 !important;\n}"},"Markdown/Typora-自定义字体":{"title":"Typora 自定义字体","links":[],"tags":["typora"],"content":"效果\n\n\n使用\n```poetry\nHello world\n```\nCSS 代码\npre[lang=&quot;poetry&quot;] {\n  margin: 0;\n  padding: 0;\n  color: var(--code-neutral);\n  font-size: 2.25em;\n  font-family: Biro_Script_reduced !important;\n  background-color: transparent;\n}\n \npre[lang=&quot;poetry&quot;] .CodeMirror-cursor {\n  border-left: 1px solid black !important;\n}\n \npre[lang=&quot;poetry&quot;] .CodeMirror-gutters,\npre[lang=&quot;poetry&quot;] .CodeMirror-gutter-wrapper.CodeMirror-activeline-gutter,\npre[lang=&quot;poetry&quot;] .CodeMirror-gutter-background.CodeMirror-activeline-gutter,\npre[lang=&quot;poetry&quot;] .CodeMirror-linenumber.CodeMirror-gutter-elt.CodeMirror-linenumber-show {\n  display: none !important;\n}\n \npre[lang=&quot;poetry&quot;] .code-tooltip {\n  color: var(--code-neutral);\n  font-family: &quot;JetBrains Mono NL&quot;;\n}\npre[lang=&quot;poetry&quot;] {\n  color: var(--code-neutral);\n}\n \npre[lang=&quot;poetry&quot;] .CodeMirror-cursor {\n  border-left: 1px solid white !important;\n}"},"index":{"title":"index","links":[],"tags":[],"content":"测试 test font\n.*\\((.*)\\)\n"},"数据库/MongoDB-使用":{"title":"MongoDB 使用","links":[],"tags":[],"content":"安装\nwww.mongodb.com/zh-cn/docs/manual/tutorial/install-mongodb-on-ubuntu/\nwww.mongodb.com/zh-cn/docs/manual/tutorial/manage-mongodb-processes/\nMongoDB 和 Node.js\nwww.mongodb.com/developer/languages/javascript/node-crud-tutorial-3-3-2/"},"服务器/MinIO-使用":{"title":"MinIO 使用","links":[],"tags":[],"content":"\n安装教程：\n(文字)min-io.cn/docs/MinIO/linux/operations/installation.html\n(视频)www.youtube.com/watch\n\n下载 MinIO\n下载 RPM 包\nwget dl.min.io/server/MinIO/release/linux-amd64/archive/MinIO-20241029160148.0.0-1.x86_64.rpm -O MinIO.rpm\n \nsudo dnf install MinIO.rpm\n或者下载 DEB 包\nwget dl.min.io/server/MinIO/release/linux-amd64/archive/MinIO_20241029160148.0.0_amd64.deb -O MinIO.deb\n \nsudo dpkg -i MinIO.deb\n\n\n                  \n                  Note\n                  \n                \n\nrpm 包和 deb 包是两种 Linux 系统下最常见的安装包格式。\n\nrpm 包主要用于 RedHat 及分支如 RedHat，Centos；\ndeb 包主要用于 Debian 及分支如 Debian ，Ubuntu。\n\n\n\n检查是否安装成功\nwhich MinIO\n\n尝试 MinIO\n\n简单使用一下 MinIO\n\n创建存储位置\nmkdir ~/MinIO\n启动服务\nMinIO server ~/MinIO --console-address :9090\n如果出现下面运行结果就说明启动成功。\n\n\n--console-address :9090: 指定 MinIO 的 Web 控制台(Web UI)监听的端口，这里是 9090 端口。\n\n\n创建存储桶\n点击启动服务时的运行结果中的 WebUI 的 url 就可以进入管理页面。\n\nMinIO 会提示你需要创建一个 Bucket，点击 Create a Bucket。\n\n输入存储桶的名字\n\n创建完成\n\n测试传输是否正常\n\n\nsystemctl 启动\n创建环境变量文件\nsudo nano /etc/default/MinIO\n然后把下面的内容复制进去\n# 用户名和密码\nMinIO_ROOT_USER=MinIO\nMinIO_ROOT_PASSWORD=MinIO123\n \n# 指定 MinIO 服务器用于存储数据的目录；\nMinIO_VOLUMES=&quot;/mnt/data&quot;\n \n# 额外命令行选项\n# 设置控制台端口(WebUI)\nMinIO_OPTS=&quot;--console-address :9090&quot;\n创建用户和组\n在/usr/lib/systemd/system/minio.service中可以发现 MinIO 默认是以MinIO-user用户和组运行\n\n创建对应的用户和组\nsudo groupadd -r MinIO-user\nsudo useradd -m -d /home/MinIO-user -r -g MinIO-user MinIO-user\n对 MinIO 的挂载位置和配置文件也应该给予权限（在创建环境变量时所指定）\nchown MinIO-user:MinIO-user /mnt/data\nchown MinIO-user:MinIO-user /etc/default/MinIO\n修改 minio.service\nsudo nano /usr/lib/systemd/system/minio.service\n在默认的文件中并没有 ExecStartPre，根据官方部署教程添加\nEnvironmentFile=-/etc/default/MinIO\nExecStartPre=/bin/bash -c &quot;if [ -z \\&quot;${MinIO_VOLUMES}\\&quot; ]; then echo \\&quot;Variable MinIO_VOLUMES not set in /etc/default/MinIO\\&quot;; exit 1; fi&quot;\nExecStart=/usr/local/bin/MinIO server $MinIO_OPTS $MinIO_VOLUMES\n启动 MinIO\n此时执行下面命令启动 MinIO\nsudo systemctl start minio.service\n判断是否执行成功\nsudo systemctl status minio.service\n\nMinIO 服务不会在主机重启时自动启动。使用下面命令将进程作为主机启动的一部分启动。\nsudo systemctl enable minio.service\n设置文件永久有效链接\nMinIO 自带的文件分享不仅分享连接长而且还有时间限制。\n\n永久有效链接相当于文件公开，因此我们只需要将存储桶设置为公开即可实现获取文件永久有效链接。\n在 Web 控制台中修改存储桶的 Policy 为 Public。\n\n修改完权限后即可访问，访问链接就是 http://{MinIO地址}:{端口}/{存储桶}/{文件名}\n\n这里的端口是 MinIO 的 API 端口而不是 Web 控制台的端口\n\n如下图所示，存储位置在 test 存储桶，图片名称叫 img.png。\n\n那么访问链接就是 http://192.168.73.129:9000/test/img.png\n\n在 Node 中使用 MinIO\n创建 key\n在 MinIO 控制台中创建 key\n\n\n安装依赖\n\nwww.npmjs.com/package/minio\n\nnpm install --save minio"},"服务器/OSS-对象存储":{"title":"OSS 对象存储","links":[],"tags":["Obsidian"],"content":"阿里云对象存储 OSS\n收费模式\n对象存储OSS 价格计算器\n\n\n                  \n                  阿里云 OSS 收费模式 \n                  \n                \n\n\n\n\n在用于存储 Obsidian 的笔记以及图片（默认个人使用）的情况下，仅需关注三项：\n\n存储费用：用于存储数据\n流量费用：下载笔记用到的流量\n请求费用：修改或者同步时需要用到\n\n存储（主要）\n\n\n                  \n                  本地冗余存储和同城冗余存储 \n                  \n                \n\n主要区别在于数据冗余的范围不同。\n\n本地冗余存储：数据冗余在单个可用区内。\n同城冗余存储：数据冗余在同一地域的多个可用区内。\n\n\n\n一般选择本地冗余存储+标准即可。\n\n流量（次要）\n请求（次要）\n"},"服务器/使用-Cloudflare-Workers-优化-Github-文件国内访问":{"title":"使用 Cloudflare Workers 优化 Github 文件国内访问速度","links":[],"tags":[],"content":"为了能通过链接访问我放在 Github 上的模型文件，刚开始我是使用 jsdelivr 。但 jsdelivr 的问题是在基本上国内访问不了，必须使用代理才能正常访问。\n\n当然如果有国内服务器的话，可以不用考虑这些问题。\n\n为了国内不使用代理就能正常访问，决定使用 Cloudflare Workers 和 hunshcn/gh-proxy\n创建一个 Cloudflare Workers\n打开 Cloudflare 仪表盘\n在侧边栏选择 [Workers 和 Pages]，在创建使选择 [常见 Worker 示例] 即可。\n\n名称可以随便取一个，之后可以在管理处修改。\n设定完名称后点击部署即可。\n\n现在已经部署完成了\n\n修改 Worker 的代码\n\n下面简单说一下步骤，如果需要详细了解可以看 hunshcn/gh-proxy\n\n部署完成后，点击编辑代码进入到以下页面。\n\n把 worker.js 的代码全部删除\n打开 index.js，并把代码全部粘贴到 worker.js\n在右侧预览区会显示页面\n点击右上角部署，部署成功后就可以退出了\n\n\n\n如果已经关闭了部署成功页面，且不知道哪里编辑代码，可以在 [Workers 和 Pages] 选择刚才创建的 Worker，并点击编辑代码。\n\n\n\n查看部署情况\n在浏览器地址栏输入 名称.子域 即可访问刚才部署的页面\n\n缩短 Worker 地址\n如果前面部署时使用的是一直是默认的话，生成的地址会很长，下面提供两种方法缩短地址。\n使用自定义域名\n\n\n                  \n                  Tip\n                  \n                \n\n使用这个方法的前提是在 Cloudflare 中托管了一个域名，如果没有就只能考虑另一种方法了。\n\n\n打开你的域名管理界面，选择你需要绑定的域名\n\n在左侧边栏选择 [Workers 路由]，点击添加路由\n\n\n\n路由\n可以仿照我的设置，proxy.kisssssssss.space/*，前面的 proxy 可以随意更改，后面的 kisssssssss.space 则需要改成自己的域名\n\n\nWorker\n选择刚刚创建 Worker 即可\n\n\n\n选择完成后点击保存\n\n在 [Workers 和 Pages] 中可以发现已经更改了\n\n\n在左侧边栏选择 [DNS 记录]，点击添加记录\n\n\n点击保存，现在就可以通过自定义的域名访问了\n\n\n                  \n                  Note\n                  \n                \n\n\n\n当DNS记录没有开启代理时，Cloudflare 仅作为 DNS 解析器工作，请求直接从用户流向源服务器，不经过 Cloudflare。\n\n\n启用了代理模式，DNS查询将会解析为 Cloudflare 的 Anycast IP 地址。这意味着所有流量会先经过Cloudflare，然后再将请求转发到你的源服务器\n\n\n\n\n修改名称和子域\n修改名称\n\n修改子域\n"},"服务器/域名注册":{"title":"域名注册","links":[],"tags":[],"content":"购买域名\n找到提供域名购买的网站\n网上提供域名购买的网站有很多，可以选择在腾讯云、华为云、万网等地方购买。一般来说只要你注册的不是顶级域名，或者域名主体不是常见的名词，这些地方的价格相差不大。\n这里选择万网\n\n查询域名\n比如我想注册的域名是：kisssssssss.域名后缀，那我直接输入 kisssssssss，点击立即查询即可。\n找到合适的域名\n\n如果能找到合适的域名且该域名价格合适，可以加入清单即可。\n比价\n如果资金充裕可以跳过这个环节，直接购买\n拿 kisssssssss.space 这个域名举例最后还是选择万网购买\n\n\n万网的价格\n\n\n\n华为云的价格\n\n\n\n腾讯云的价格\n\n\n\n购买\n点击域名清单\n\n点击立即购买\n\n接下来就是确认订单了。\n国内购买域名是需要实名的，如果没有需要点击左下角创建信息模版进行认证（网站应该会有操作提示），认证是需要一定时间的但不会太久。\n\n完成认证后，点击右下角的立即购买即可。\n购买成功后会发送邮件通知，此时只是域名注册成功，还需要进行实名。不过系统会自动根据先前创建的信息模板进行实名，这一步不用我们操心。\n\n域名解析\n现在已经拥有了域名，接下来要做的就是域名解析。\n\n\n下面使用的 kisssssssss.space 是我的域名，阅读时将其替换成你的域名即可\n虽然域名解析使用的是阿里云，但是各个网站的操作差异应该不大\n\n\n点击阿里云左上角的菜单，找到云解析 DNS\n\n在页面中找到刚注册的域名，点击解析设置\n\n选择新手引导\n\n\n如果你是要\n\n将刚注册的域名绑定到服务器上，查看服务器绑定域名\n将 GithubPage 的默认链接 kisssssssss.github.io 替换成 kisssssssss.space 或者 blog.kisssssssss.space 等，查看 GithubPage 自定义域名\n\n\n服务器绑定域名\n待完善…\nGithubPage 自定义域名\n首先要有一个 github 仓库，仓库名必须是：用户名.github.io。\n\n\n\n                  \n                  Tip\n                  \n                \n\n仓库名会影响部署后的 GithubPage 的默认链接，因此如果不是这种格式，在后面设置目标域名的时候会出问题。\n假如当前的仓库名是 Blog ，那么部署后的链接是 kisssssssss.github.io/Blog/，显然 kisssssssss.github.io/Blog/ 是不符合目标域名形式的。\n\n\n\n先把 GithubPage 部署成功，再讨论自定义域名。GithubPage 如何部署这里不做描述，可自行网上搜索教程。\n\n接下来准备将 GithubPage 的默认链接 kisssssssss.github.io 替换成 blog.kisssssssss.space\n\n\n回到阿里云，按如图所示配置，修改完点击确定即可\n\n\n\n                  \n                  Tip\n                  \n                \n\n如果你是希望用 kisssssssss.space 访问，而不是通过 blog.kisssssssss.space 访问，按下图修改即可\n\n\n\n\n\n回到 GithubPage 页面，将自定义域修改为刚才的填写的 blog.kisssssssss.space，保存。\n\n如果 DNS 检查不成功，请查看阿里云的解析是否正确，如果正确请稍等一会。\n\n\n如果 blog.kisssssssss.space/ 可以正常访问，那么就说明 GithubPage 自定义域名配置成功了\n\n"},"浏览器/CORS错误":{"title":"CORS错误","links":[],"tags":[],"content":"同源策略\n同源策略(Same-Origin Policy, SOP)是浏览器的一种基本安全策略，旨在防止不同来源的网页之间相互访问数据。它限制了来自一个源的网页脚本访问或修改另一个源的内容。\n在浏览器中，同源指的是协议（如HTTP、HTTPS）、域名（如example.com）和端口（如80、443）都必须完全相同。\n同源策略只会作用于浏览器和服务器之间，而不限制服务器和服务器的通信。\n跨域资源共享\n可以使用CORS(Cross-origin resource sharing)来允许跨源访问。CORS 是一种浏览器安全机制，它允许或限制不同来源（域、协议或端口）之间的资源共享。默认情况下，浏览器出于安全考虑会阻止不同来源之间的请求，但 CORS 允许服务器明确声明哪些来源可以访问其资源。\n这个安全机制主要是用来解决跨站请求伪造(Cross-Site Request Forgery, CSRF)和数据窃取(Data Theft)等安全问题。\nCORS错误\nAccess to fetch at &#039;http://localhost:4399/login&#039; from origin &#039;http://localhost:5173&#039; has been blocked by CORS policy: Response to preflight request doesn&#039;t pass access control check: No &#039;Access-Control-Allow-Origin&#039; header is present on the requested resource. If an opaque response serves your needs, set the request&#039;s mode to &#039;no-cors&#039; to fetch the resource with CORS disabled.\n\nCORS错误解决\n一 使用代理工具\ngithub.com/Rob—W/cors-anywhere/\n二 使用 Express 创建代理服务器\nconst express = require(&#039;express&#039;);\n \nconst app = express();\n \napp.use((req, res, next) =&gt; {\n\tres.header(&#039;Access-Control-Allow-Origin&#039;, &#039;&#039;);\n\tnext();\n});\n \napp.get(&#039;/test&#039;, async (req, res) =&gt; {\n\tconst data = await (await fetch(&#039;emaxple.com/test&#039;)).json();\n\tres.send(data);\n});\n \napp.listen(3000, () =&gt; console.log(`listening on ${PORT}`));\n三 设置允许跨域访问\n本地开发时使用。例如在 Express 中直接使用 cors 中间件。"},"浏览器/react/react学习/1_react初体验":{"title":"react初体验","links":[],"tags":["react"],"content":"\nReact 是什么\nReact 是用于构建 Web 和原生交互界面的库。\nReact 的官网文档：zh-hans.react.dev/\nReact 的官网文档（旧版）：zh-hans.legacy.reactjs.org/docs/getting-started.html\nReact 的特点\n声明式编程\n\n声明式编程是目前整个大前端开发的模式：Vue、React、Flutter、SwiftUI\n它允许我们只需要维护自己的状态，当状态改变时，React 可以根据最新的状态去渲染我们的 UI 界面\n\n\n组件化开发\n\n组件化开发页面目前前端的流行趋势，我们会将复杂的界面拆分成一个个小的组件；\n如何合理的进行组件的划分和设计也是后面我会讲到的一个重点；\n\n多平台适配\n\n2013 年，React 发布之初主要是开发 Web 页面；\n2015 年，Facebook 推出了 ReactNative，用于开发移动端跨平台；\n2017 年，Facebook 推出 ReactVR，用于开发虚拟现实 Web 应用程序；\n\nReact 的开发依赖\n\n开发 React 必须依赖三个库：\n\nreact：包含 react 所必须的核心代码\nreact-dom：react 渲染在不同平台所需要的核心代码\nbabel：将 jsx 转换成 React 代码的工具\n\n\n\n对于 Vue 来说，我们只是依赖一个 vue.js 文件即可，但是 react 居然要依赖三个包。其实这三个库是各司其职的，目的就是让每一个库只单纯做自己的事情;在 React 的 0.14 版本之前是没有 react-dom 这个概念的，所有功能都包含在 react 里；\n为什么要进行拆分呢？\n原因就是 react-native。react 包中包含了 react web 和 react-native 所共同拥有的核心代码。react-dom 针对 web 和 native 所完成的事情不同：\n\nweb 端：react-dom 会将 jsx 最终渲染成真实的 DOM，显示在浏览器中\nnative 端：react-dom 会将 jsx 最终渲染成原生的控件（比如 Android 中的 Button，iOS 中的 UIButton）。\n\nBabel 和 React 的关系\n\n\nbabel 是什么呢？\nBabel ，又名 Babel.js。是目前前端使用非常广泛的编译器、转移器。\n比如当下很多浏览器并不支持 ES6 的语法，但是确实 ES6 的语法非常的简洁和方便，我们开发时希望使用它。那么编写源码时我们就可以使用 ES6 来编写，之后通过 Babel 工具，将 ES6 转成大多数浏览器都支持的 ES5 的语法。\n\n\nReact 和 Babel 的关系：\n默认情况下开发 React 其实可以不使用 babel。但是前提是我们自己使用 React.createElement 来编写源代码，它编写的代码非常的繁琐和可读性差。\n使用 Babel 了我们就可以直接编写 jsx（JavaScript XML）的语法，并且让 babel 帮助我们转换成 React.createElement。\n\n\nReact 的依赖引入\n引入方式：\n\n直接 CDN 引入\n下载后，添加本地依赖\n通过 npm 下载\n\n\n这个 crossorigin 属性的目的是为了拿到跨域脚本的错误信息\n\n// 通过cdn引用\n&lt;script src=&quot;unpkg.com/react@18/umd/react.development.js&quot; crossorigin&gt;&lt;/script&gt;\n&lt;script src=&quot;unpkg.com/react-dom@18/umd/react-dom.development.js&quot; crossorigin&gt;&lt;/script&gt;\n&lt;script src=&quot;unpkg.com/babel-standalone@6/babel.min.js&quot;&gt;&lt;/script&gt;\nHello World 小案例\n\n\n\n必须添加 type=“text/babel” ，作用是可以让 babel 解析 jsx 的语法\n\n\nReactDOM.createRoot 函数用于创建一个 React 根，之后渲染的内容会包含在这个根中。使用时需要传入一个参数（即将渲染的内容将要挂载到哪一个 HTML 元素上）\n\n\nroot.render 函数传入一个参数，即要渲染的根组件\n\n\nHello World – 组件化开发\n\n\n整个逻辑其实可以看做一个整体，那么我们就可以将其封装成一个组件：\n我们说过 root.render 参数是一个 HTML 元素或者一个组件；\n所以我们可以先将之前的业务逻辑封装到一个组件中，然后传入到 ReactDOM.render 函数中的第一个参数；\n\n\n在 React 中，如何封装一个组件呢？这里我们暂时使用类的方式封装组件：\n\n\n定义一个类（类名大写，组件的名称是必须大写的，小写会被认为是 HTML 元素），继承自 React.Component\n\n\n实现当前组件的 render 函数\nrender 当中返回的 jsx 内容，就是之后 React 会帮助我们渲染的内容\n\n\n\n\n"},"浏览器/react/react学习/2_jsx基本语法":{"title":"jsx基本语法","links":[],"tags":["react"],"content":"JSX 简介\nconst element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;\n这个有趣的标签语法既不是字符串也不是 HTML。\n它被称为 JSX，是一个 JavaScript 的语法扩展。\n我们建议在 React 中配合使用 JSX，JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式。JSX 可能会使人联想到模板语言，但它具有 JavaScript 的全部功能。\n\n来源：React 旧版文档的 JSX 简介\n更详细的内容可以查看 React 新版文档使用 JSX 标签\n\n\nJSX 用于描述我们的 UI 界面，并且其可以和 JavaScript 融合在一起使用；它不同于 Vue 中的模块语法，不需要专门学习模块语法中的一些指令（比如 v-for、v-if、v-else、v-bind）；\n为什么 React 选择了 JSX\n\nReact 认为渲染逻辑本质上与其他 UI 逻辑存在内在耦合\n\n比如 UI 需要绑定事件（button、a 原生等等）；\n比如 UI 中需要展示数据状态；\n比如在某些状态发生改变时，又需要改变 UI；\n\n\n\n他们之间是密不可分，所以 React 没有将标记分离到不同的文件中，而是将它们组合到了一起，这个地方就是组件（Component）；在这里，我们只需要知道，JSX 其实是嵌入到 JavaScript 中的一种结构语法；\nJSX 的书写规范\n\nJSX 的顶层只能有一个根元素，所以我们很多时候会在外层包裹一个 div 元素（或者使用后面学习的 Fragment）；\n为了方便阅读，我们通常在 jsx 的外层包裹一个小括号()，这样可以方便阅读，并且 jsx 可以进行换行书写；\nJSX 中的标签可以是单标签，也可以是双标签；如果是单标签，必须以/&gt;结尾；\n\nJSX 的使用\n注释\n在大括号内进行注释\n{\n  /* 注释内容  */\n}\n嵌入变量作为子元素\n\n\n情况一：当变量是 Number、String、Array 类型时，可以直接显示；\n\n\n\n当变量是 null、undefined、Boolean 类型时，内容为空；\n如果希望可以显示 null、undefined、Boolean，那么需要转成字符串；可以使用 toString 方法、和空字符串拼接，String()等方式；\n\n\n\n\n情况三：Object 对象类型不能作为子元素\n\n\n\n嵌入表达式\n\n运算表达式\n三元运算符\n执行一个函数\n\n\n绑定属性\ntitle\n&lt;h2 title={this.state.title}&gt;&lt;/h2&gt;\n\nsrc\n&lt;img title={this.state.src} /&gt;\n\nhref\n&lt;a href={this.state.href}&gt;&lt;/a&gt;\n\nclass\nReact 绑定 class 的时候，属性名是 className 而不是 class。虽然 babel 在解析的时候能正常解析但容易造成误解，而且控制台也会警告\n\n\n正确写法：\n&lt;h2 className=&quot;abs&quot;&gt;Hello,World&lt;/h2&gt;\n\n动态修改 class：\n\n\n通过模板字符串进行字符串拼接\n可以，但是阅读性差\n\n可以将 className 抽离出来\n\n\n\n通过数组进行管理\n\n\n\n通过第三方库：classnames\n后面学习框架的时候再学习\n\n\nstyle\n第一个大括号表示里面的是 js，第二个括号表示里面的是对象。\n\n{ } 不是不能放对象，只是做为子元素的时候 { } 里面不能放置对象\n\n&lt;h2 style={{ color: &quot;red&quot; }}&gt;Hello,World&lt;/h2&gt;\njs 不支持-写法，有些 css 属性需要转换成驼峰标识\n&lt;h2 style={{ fontSize: &quot;30px&quot; }}&gt;Hello,World&lt;/h2&gt;\n数据依赖\n\n\n在组件中的数据，我们可以分成两类：\n\n\n参与界面更新的数据：当数据变量时，需要更新组件渲染的内容；\n\n\n不参与界面更新的数据：当数据变量时，不需要更新将组建渲染的内容；\n\n\n\n\n\n参与界面更新的数据我们也可以称之为是参与数据流，这个数据是定义在当前对象的 state中。\n定义数据的时候，我们可以通过在构造函数中 this.state = {定义的数据}。\n当我们的数据发生变化时，我们可以调用 this.setState 来更新数据，并且通知 React 进行 update 操作；在进行 update 操作时，就会重新调用 render 函数，并且使用最新的数据，来渲染界面。\n\n如果我们不使用 this.setState 更新数据，页面是不会发生变化的，需要我们手动调用 render 函数页面才会重新渲染。\n\n事件绑定\n为什么 this == undefined\n以下面代码为例，在类中直接定义一个函数，并且将这个函数绑定到元素的 onClick 事件上，当前这个函数的 this 指向的是谁呢？\n\n显然，默认情况下是 undefined\n\n\n因为在正常的 DOM 操作中，监听点击，监听函数中的 this 其实是节点对象（比如说是 button 对象）；而且 React 并不是直接渲染成真实的 DOM，我们所编写的 button 只是一个语法糖，它的本质 React 的 Element 对象；因此在这里发生监听的时候，react 在执行函数时并没有绑定 this，默认情况下就是一个 undefined；\n&lt;button onClick={this.click}&gt;按钮&lt;/button&gt;;\n// 经过内部转化后大概相当于\nReact.createElement(&quot;button&quot;, { onClick: this.click });\n当我们按钮发生点击的时候，它就会回调传入的函数。我们传入的 this.click 只是一个引用。\n下面的代码是其执行的一个抽象过程\n// 组件⬇️\nconst APP = {\n  click: function () {\n    console.log(this);\n  },\n};\n \n// createElement⬇️\nconst config = {\n  onClick: APP.click,\n};\n \n// 点击按钮调用click⬇️\nconst click = config.onClick;\nclick();\n\n后果\n按照原来的写法onClick={this.click},在方法中是 this 值是undefined，自然也就无法调用this.setState()来重新渲染页面。\n\n解决方法\n\nbind()绑定\n\n&lt;button onClick={this.click.bind(this)}&gt;&lt;/button&gt;\n\n\n公有类字段(Public class fields)\n\n\n\n传入一个箭头函数(常用)\n\n&lt;button onClick={() =&gt; this.click()}&gt;按钮&lt;/button&gt;\n\n电影展示案例\n效果演示\n\n以下内容只是关键 js 代码，其它的如依赖引入、css 等省略不写\n::: details 实现方法 1\nclass APP extends React.Component {\n  constructor() {\n    super();\n    this.state = {\n      movies: [&quot;流浪地球2&quot;, &quot;蜘蛛侠：纵横宇宙&quot;, &quot;头脑特工队&quot;, &quot;生化危机&quot;],\n      currentIndex: 0,\n    };\n  }\n  click(index) {\n    this.setState({\n      currentIndex: index,\n    });\n  }\n  render() {\n    const { movies, currentIndex } = this.state;\n    return (\n      &lt;div&gt;\n        &lt;ul&gt;\n          {movies.map((movie, index) =&gt; {\n            return (\n              &lt;li\n                className={currentIndex === index ? &quot;active&quot; : &quot;&quot;}\n                onClick={() =&gt; {\n                  this.click(index);\n                }}\n                key={movie}\n              &gt;\n                {movie}\n              &lt;/li&gt;\n            );\n          })}\n        &lt;/ul&gt;\n      &lt;/div&gt;\n    );\n  }\n}\nconst root = ReactDOM.createRoot(document.querySelector(&quot;#root&quot;));\nroot.render(&lt;APP /&gt;);\n:::\n或者\n::: details 实现方法 2\nclass APP extends React.Component {\n  constructor() {\n    super();\n    this.state = {\n      movies: [&quot;流浪地球2&quot;, &quot;蜘蛛侠：纵横宇宙&quot;, &quot;头脑特工队&quot;, &quot;生化危机&quot;],\n      currentIndex: 0,\n    };\n  }\n  click(index) {\n    this.setState({\n      currentIndex: index,\n    });\n  }\n  render() {\n    const { movies, currentIndex } = this.state;\n \n    const liEls = movies.map((movie, index) =&gt; {\n      return (\n        &lt;li\n          className={currentIndex === index ? &quot;active&quot; : &quot;&quot;}\n          onClick={() =&gt; {\n            this.click(index);\n          }}\n          key={movie}\n        &gt;\n          {movie}\n        &lt;/li&gt;\n      );\n    });\n    return (\n      &lt;div&gt;\n        &lt;ul&gt;{liEls}&lt;/ul&gt;\n      &lt;/div&gt;\n    );\n  }\n}\nconst root = ReactDOM.createRoot(document.querySelector(&quot;#root&quot;));\nroot.render(&lt;APP /&gt;);\n:::\nJSX 条件渲染\n\nif 语句\n\nrender() {\n  let e = null;\n  if(/* 判断条件 */){\n    e = &lt;h1&gt;hhh&lt;/h1&gt;\n  }else{\n    e = (\n    &lt;ul&gt;\n      &lt;li&gt;hhhh&lt;/li&gt;\n    &lt;/ul&gt;\n    )\n  }\n  return e;\n}\n\n三元运算符\n\nrender() {\n  return (ok?&lt;button&gt;按钮&lt;/button&gt;:&lt;h1&gt;hhh&lt;/h1&gt;);\n}\n\n&amp;&amp; 逻辑与运算\n\n使用场景：当某一个值可能为 undefined 的时候，使用 &amp;&amp; 进行判断\nrender() {\n  return (\n    &lt;div&gt;\n      { friend &amp;&amp; &lt;div&gt;{friend.name}&lt;/div&gt;}\n    &lt;/div&gt;\n  );\n}\nJSX 条件渲染案例\n效果\n\n::: details 实现代码\nclass APP extends React.Component {\n  constructor() {\n    super();\n    this.state = {\n      isShow: true,\n    };\n  }\n  click() {\n    this.setState({\n      isShow: !this.state.isShow,\n    });\n  }\n  render() {\n    const { isShow } = this.state;\n    return (\n      &lt;div&gt;\n        &lt;button onClick={() =&gt; this.click()}&gt;按钮&lt;/button&gt;\n        {/* 1. */}\n        &lt;h3 class={isShow ? &quot;&quot; : &quot;show&quot;}&gt;Hello,World&lt;/h3&gt;\n        {/* 2. */}\n        {isShow &amp;&amp; &lt;h3&gt;Hello,World&lt;/h3&gt;}\n        {/* 3. */}\n        &lt;h3 style={{ display: isShow ? &quot;block&quot; : &quot;none&quot; }}&gt;Hello,World&lt;/h3&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n:::\nJSX 列表渲染\n真实开发中我们会从服务器请求到大量的数据，数据会以列表的形式存储：\n\n比如歌曲、歌手、排行榜列表的数据；\n比如商品、购物车、评论列表的数据；\n比如好友消息、动态、联系人列表的数据；\n\n在 React 中并没有像 Vue 模块语法中的v-for指令，而且需要我们通过 JavaScript 代码的方式组织数据，转成 JSX：\n\n很多从 Vue 转型到 React 的同学非常不习惯，认为 Vue 的方式更加的简洁明了；\n但是 React 中的 JSX 正是因为和 JavaScript 无缝的衔接，让它可以更加的灵活；\n另外我经常会提到 React 是真正可以提高我们编写代码能力的一种方式；\n\n如何展示列表呢？\n\n在 React 中，展示列表最多的方式就是使用数组的 map 高阶函数；\n\nclass APP extends React.Component {\n  constructor() {\n    super();\n    this.state = {\n      students: [\n        { id: 101, name: &quot;what&quot;, score: 90 },\n        { id: 102, name: &quot;why&quot;, score: 80 },\n        { id: 103, name: &quot;who&quot;, score: 70 },\n        { id: 104, name: &quot;when&quot;, score: 60 },\n      ],\n    };\n  }\n  render() {\n    const { students } = this.state;\n    return (\n      &lt;div&gt;\n        &lt;ul&gt;\n          {students.map((item) =&gt; {\n            return &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;;\n          })}\n        &lt;/ul&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n很多时候我们在展示一个数组中的数据之前，需要先对它进行一些处理：\n\n\n比如过滤掉一些内容：filter函数\n\n如只展示分数大于等于 70 的学生\n\nclass APP extends React.Component {\n  constructor() {\n    super();\n    this.state = {\n      students: [\n        { id: 101, name: &quot;what&quot;, score: 90 },\n        { id: 102, name: &quot;why&quot;, score: 80 },\n        { id: 103, name: &quot;who&quot;, score: 70 },\n        { id: 104, name: &quot;when&quot;, score: 60 },\n      ],\n    };\n  }\n  render() {\n    const { students } = this.state;\n    return (\n      &lt;div&gt;\n        &lt;ul&gt;\n          {students\n            .filter((item) =&gt; {\n              return item.score &gt;= 70;\n            })\n            .map((item) =&gt; {\n              return &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;;\n            })}\n        &lt;/ul&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\n\n比如截取数组中的一部分内容：slice函数\n\n如只展示分数大于等于 70 的两个学生\n\nclass APP extends React.Component {\n  constructor() {\n    super();\n    this.state = {\n      students: [\n        { id: 101, name: &quot;what&quot;, score: 90 },\n        { id: 102, name: &quot;why&quot;, score: 80 },\n        { id: 103, name: &quot;who&quot;, score: 70 },\n        { id: 104, name: &quot;when&quot;, score: 60 },\n      ],\n    };\n  }\n  render() {\n    const { students } = this.state;\n    return (\n      &lt;div&gt;\n        &lt;ul&gt;\n          {students\n            .filter((item) =&gt; {\n              return item.score &gt;= 70;\n            })\n            .slice(0, 2)\n            .map((item) =&gt; {\n              return &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;;\n            })}\n        &lt;/ul&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\n\n列表中的 key\n我们可以发现上述代码的返回值里面都有一个 key 属性，这个 key 属性主要就是用来提高 diff 算法的效率。\n&lt;li key={item.id}&gt;{item.name}&lt;/li&gt;\n如果不添加 key 属性的话，浏览器会报一个警告。\n\njsx 转换的本质\n实际上，jsx 仅仅只是 React.createElement(component, props, ...children) 函数的语法糖。所有的 jsx 最终都会被转换成 React.createElement 的函数调用。\n\ncreateElement\ncreateElement 需要传递三个参数：\n\ntype\n\n\n当前 ReactElement 的类型；\n如果是标签元素，那么就使用字符串表示 “div”；\n如果是组件元素，那么就直接使用组件的名称；\n\n\nconfig\n\n\n所有 jsx 中的属性都在 config 中以对象的属性和值的形式存储；\n比如传入 className 作为元素的 class；\n\n\nchildren\n\n\n存放在标签中的内容，以 children 数组的方式进行存储；\n当然，如果是多个元素呢？React 内部有对它们进行处理，处理的源码在下方\n\n经过 babel 转换后的代码\nBabel 官网查看转换结果\n\n源代码：\n&lt;div&gt;\n  &lt;h2 className={c}&gt;Title&lt;/h2&gt;\n  &lt;ul&gt;\n    &lt;li&gt;列表数据1&lt;/li&gt;\n    &lt;li&gt;列表数据1&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/div&gt;\n转换后的代码：\n/*#__PURE__*/ React.createElement(\n  &quot;div&quot;,\n  null,\n  /*#__PURE__*/ React.createElement(\n    &quot;h2&quot;,\n    {\n      className: c,\n    },\n    &quot;Title&quot;\n  ),\n  /*#__PURE__*/ React.createElement(\n    &quot;ul&quot;,\n    null,\n    /*#__PURE__*/ React.createElement(&quot;li&quot;, null, &quot;\\u5217\\u8868\\u6570\\u636E1&quot;),\n    /*#__PURE__*/ React.createElement(&quot;li&quot;, null, &quot;\\u5217\\u8868\\u6570\\u636E1&quot;)\n  )\n);\n::: tip\n代码前的注释 /*#__PURE__*/ 是用来告诉 webpack 这段代码是纯函数调用，如果这段代码没有用到可以在 tree-shaking 的时候直接删除掉。\n:::\n直接编写 jsx 代码\n下面是不使用 jsx 的情况下的代码：\nclass APP extends React.Component {\n  render() {\n    const ReactElement = React.createElement(\n      &quot;div&quot;,\n      null,\n      React.createElement(\n        &quot;h2&quot;,\n        {\n          className: &quot;header&quot;,\n        },\n        &quot;Title&quot;\n      ),\n      React.createElement(\n        &quot;ul&quot;,\n        null,\n        React.createElement(&quot;li&quot;, null, &quot;\\u5217\\u8868\\u6570\\u636E1&quot;),\n        React.createElement(&quot;li&quot;, null, &quot;\\u5217\\u8868\\u6570\\u636E1&quot;)\n      )\n    );\n    return ReactElement;\n  }\n}\nconst root = ReactDOM.createRoot(document.querySelector(&quot;#root&quot;));\nroot.render(React.createElement(APP, null));\n\n如图，我们没有通过 jsx 书写的代码界面仍然可以正常渲染，但是缺点也很明显，代码阅读性十分差。\n另外，在这样的情况下，我们自然不需要 babel 了，所以\n\ntype=&quot;text/babel&quot;可以被我们删除掉了；\n&lt;script src=&quot;../react/babel.min.js&quot;&gt;&lt;/script&gt;可以被我们删除掉了；\n\n虚拟 DOM 的创建过程\n我们通过 React.createElement 最终创建出来一个 ReactElement 对象：\n\n这个 ReactElement 对象是什么作用呢？React 为什么要创建它呢？\n\n\n可以更新的时候进行 diff 算法决定更新哪里；可以进行跨平台；\n\n\n原因是 React 利用 ReactElement 对象组成了一个 JavaScript 的对象树；JavaScript 的对象树就是虚拟 DOM（Virtual DOM）；ReactElement 最终形成的树结构就是 Virtual DOM；\n\n\njsx – 虚拟 DOM – 真实 DOM\n\n声明式编程\n虚拟 DOM 帮助我们从命令式编程转到了声明式编程的模式\nReact 官方的说法：Virtual DOM 是一种编程理念。\n\n在这个理念中，UI 以一种理想化或者说虚拟化的方式保存在内存中，并且它是一个相对简单的 JavaScript 对象\n我们可以通过 ReactDOM.render 让 虚拟 DOM 和 真实 DOM 同步起来，这个过程中叫做协调（Reconciliation）；\n\n这种编程的方式赋予了 React 声明式的 API：\n\n你只需要告诉 React 希望让 UI 是什么状态；\nReact 来确保 DOM 和这些状态是匹配的；\n你不需要直接进行 DOM 操作，就可以从手动更改 DOM、属性操作、事件处理中解放出来；\n\n购物车小案例\n效果\n\n代码：\n::: details\nclass APP extends React.Component {\n  constructor() {\n    super();\n    this.state = {\n      books,\n    };\n  }\n  format(price) {\n    return &quot;￥&quot; + price.toFixed(2);\n  }\n  getSum() {\n    return this.state.books.reduce(\n      (preValue, item) =&gt; preValue + item.count * item.price,\n      0\n    );\n  }\n  changeCount(index, count) {\n    const newBooks = [...this.state.books];\n    newBooks[index].count += count;\n    this.setState({ books: newBooks });\n  }\n  remove(index) {\n    const newBooks = [...this.state.books];\n    newBooks.splice(index, 1);\n    this.setState({ books: newBooks });\n  }\n \n  renderBooks() {\n    const { books } = this.state;\n    return (\n      &lt;div&gt;\n        &lt;table&gt;\n          &lt;thead&gt;\n            &lt;tr&gt;\n              &lt;th&gt;序号&lt;/th&gt;\n              &lt;th&gt;书籍名称&lt;/th&gt;\n              &lt;th&gt;出版日期&lt;/th&gt;\n              &lt;th&gt;价格&lt;/th&gt;\n              &lt;th&gt;购买数量&lt;/th&gt;\n              &lt;th&gt;操作&lt;/th&gt;\n            &lt;/tr&gt;\n          &lt;/thead&gt;\n          &lt;tbody&gt;\n            {books.map((item, index) =&gt; {\n              return (\n                &lt;tr&gt;\n                  &lt;td&gt;{index + 1}&lt;/td&gt;\n                  &lt;td&gt;{item.name}&lt;/td&gt;\n                  &lt;td&gt;item.date&lt;/td&gt;\n                  &lt;td&gt;{item.price}&lt;/td&gt;\n                  &lt;td&gt;\n                    &lt;button\n                      disabled={item.count &lt;= 1}\n                      onClick={() =&gt; {\n                        this.changeCount(index, -1);\n                      }}\n                    &gt;\n                      -\n                    &lt;/button&gt;\n                    {item.count}\n                    &lt;button\n                      onClick={() =&gt; {\n                        this.changeCount(index, 1);\n                      }}\n                    &gt;\n                      +\n                    &lt;/button&gt;\n                  &lt;/td&gt;\n                  &lt;td&gt;\n                    &lt;button\n                      onClick={() =&gt; {\n                        this.remove(index, 1);\n                      }}\n                    &gt;\n                      删除\n                    &lt;/button&gt;\n                  &lt;/td&gt;\n                &lt;/tr&gt;\n              );\n            })}\n          &lt;/tbody&gt;\n        &lt;/table&gt;\n        &lt;h2&gt;总价格：{this.format(this.getSum())} &lt;/h2&gt;\n      &lt;/div&gt;\n    );\n  }\n  renderBooksEmpty() {\n    return (\n      &lt;div&gt;\n        &lt;h2&gt;购物车为空&lt;/h2&gt;\n      &lt;/div&gt;\n    );\n  }\n  render() {\n    const { books } = this.state;\n    return books.length ? this.renderBooks() : this.renderBooksEmpty();\n  }\n}\nconst root = ReactDOM.createRoot(document.querySelector(&quot;#root&quot;));\nroot.render(React.createElement(APP, null));\n:::"},"浏览器/react/react学习/3_react脚手架解析":{"title":"react脚手架解析","links":[],"tags":["react"],"content":"前端工程的复杂化\n如果我们只是开发几个小的 demo 程序，那么永远不需要考虑一些复杂的问题：\n\n比如目录结构如何组织划分；\n比如如何管理文件之间的相互依赖；\n比如如何管理第三方模块的依赖；\n比如项目发布前如何压缩、打包项目；\n…\n\n现代的前端项目已经越来越复杂了：\n\n不会再是在 HTML 中引入几个 css 文件，引入几个编写的 js 文件或者第三方的 js 文件这么简单；\n比如 css 可能是使用 less、sass 等预处理器进行编写，我们需要将它们转成普通的 css 才能被浏览器解析；\n比如 JavaScript 代码不再只是编写在几个文件中，而是通过模块化的方式，被组成在成百上千个文件中，我们需要通过模块化的技术来管理它们之间的相互依赖；\n比如项目需要依赖很多的第三方库，如何更好的管理它们（比如管理它们的依赖、版本升级等）；\n\n为了解决上面这些问题，我们需要再去学习一些工具：\n\n比如 babel、webpack、gulp，配置它们转换规则、打包依赖、热更新等等一些的内容；\n脚手架的出现，就是帮助我们解决这一系列问题的；\n\n脚手架是什么呢？\n传统的脚手架指的是建筑学的一种结构：在搭建楼房、建筑物时，临时搭建出来的一个框架；\n\n编程中提到的脚手架（Scaffold），其实是一种工具，帮我们可以快速生成项目的工程化结构；\n\n每个项目作出完成的效果不同，但是它们的基本工程化结构是相似的；\n既然相似，就没有必要每次都从零开始搭建，完全可以使用一些工具，帮助我们生产基本的工程化模板；\n不同的项目，在这个模板的基础之上进行项目开发或者进行一些配置的简单修改即可；\n这样也可以间接保证项目的基本机构一致性，方便后期的维护；\n\n\n总结：脚手架让项目从搭建到开发，再到部署，整个流程变得快速和便捷；\n前端脚手架\n对于现在比较流行的三大框架都有属于自己的脚手架：\n\n\nVue 的脚手架：@vue/cli\n\n\nAngular 的脚手架：@angular/cli\n\n\nReact 的脚手架：create-react-app\n\n\n它们的作用都是帮助我们生成一个通用的目录结构，并且已经将我们所需的工程环境配置好。\n\n使用这些脚手架需要依赖什么呢？\n\n\n目前这些脚手架都是使用 node 编写的，并且都是基于 webpack 的；\n\n\n所以我们必须在自己的电脑上安装 node 环境；\n\n\n创建 React 项目\n创建 React 项目的命令如下：\ncreate-react-app 项目名称\n::: tip\n项目名称不能包含大写字母\n:::\n目录结构分析\n\n了解 PWA\n比如 chrome 浏览器，在一些网站的地址栏右边有个图标\n\n\n点击会提示是否安装应用，这就是 PWA\n\n\n在目录中\n\n\nPWA 相关的概念：\n\nPWA 全称 Progressive Web App，即渐进式 WEB 应用；\n一个 PWA 应用首先是一个网页, 可以通过 Web 技术编写出一个网页应用；\n随后添加上 App Manifest 和 Service Worker 来实现 PWA 的安装和离线等功能；\n这种 Web 存在的形式，我们也称之为是 Web App；\n\n\nPWA 解决了哪些问题呢？\n\n可以添加至主屏幕，点击主屏幕图标可以实现启动动画以及隐藏地址栏；\n实现离线缓存功能，即使用户手机没有网络，依然可以使用一些离线功能；\n实现了消息推送；\n等等一系列类似于 Native App 相关的功能；\n\n\n更多 PWA 相关的知识，可以自行去学习更多；\ndeveloper.mozilla.org/zh-CN/docs/Web/Progressive_web_apps\n编写 react 代码\n删除目录下无用文件后，目录结构如下：\n\nsrc 文件夹夹下的 index.js 是项目的入口文件,我们就是在 index.js 文件里编写 react 代码\n\n::: tip\n导入 react-dom 的时候导入的应该是 react-dom 下的 client，而不是 react-dom。虽然并不会报错，但会有一个警告。\nimport ReactDOM from &quot;react-dom&quot;; // warning\nimport ReactDOM from &quot;react-dom/client&quot;; // success\n\n:::\n\n封装组件\n将 APP 组件的内容抽离到 APP.jsx 的文件内容中，需要在 APP.jsx 导入 react 以及导出 APP 组件。\n\n::: tip\n文件后缀名也可以是 js，不一定是 jsx，但是 jsx 的代码提示会比 js 好\n:::\n\n在 index 导入 APP 组件，由于这个时候 index 里没有组件自然就不用导入 react，保留 react-dom 就行了\n\n脚手架中的 webpack\nReact 脚手架默认是基于 Webpack 来开发的；但是，我们并没有在目录结构中看到任何 webpack 相关的内容？\n原因是 React 脚手架将 webpack 相关的配置隐藏起来了（其实从 Vue CLI3 开始，也是进行了隐藏）；\n\n如果我们希望看到 webpack 的配置信息，我们可以执行一个 package.json 文件中的一个脚本：\n&quot;eject&quot;: &quot;react-scripts eject&quot;\n这个操作是不可逆的，所以在执行过程中会给与我们提示；\n\n执行后目录下会多出两个文件夹，config 和 script\n\npackage.json 也会多出各种依赖\n"},"浏览器/react/react学习/4_react性能优化":{"title":"react性能优化","links":[],"tags":["react"],"content":"React 的更新流程\nReact 在 props 或 state 发生改变时，会调用 React 的 render 方法，会创建一颗不同的树。\nReact 需要基于这两颗不同的树之间的差别来判断如何有效的更新 UI\n\nReact 是如何优化的\n\n同层节点之间相互比较，不会垮节点比较；\n不同类型的节点，产生不同的树结构；\n开发中，可以通过 key 来指定哪些节点在不同的渲染下保持稳定；\n\nkey 的优化\n我们在前面遍历列表时，总是会提示一个警告，让我们加入一个 key 属性\n\n插入数据的情况：\n\n\n情况一：在最后位置插入数据\n这种情况，有无 key 意义并不大\n\n\n情况二：在前面插入数据\n这种做法，在没有 key 的情况下，所有的子元素都需要进行修改；\n\n\n\n当子元素拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素;\n如果需要将 key 为 333 的元素插入到最前面的位置，那么 key 为 111 和 222 的元素仅仅进行位移，不需要进行任何的修改；\n\nkey 的注意事项：\n\nkey 应该是唯一的；\nkey 不要使用随机数（随机数在下一次 render 时，会重新生成一个数字）；\n使用 index 作为 key，对性能是没有影响的；\n\nshouldComponentUpdate (SCU)\n默认情况下，我们只要是修改了 App 中的数据，所有的组件都需要重新 render，进行 diff 算法，很容易浪费性能。\n事实上，很多的组件没有必须要重新调用 render；\n它们调用 render 应该有一个前提，就是依赖的数据（state、props）发生改变时，再调用自己的 render 方法；\n\n我们可以通过 shouldComponentUpdate (SCU) 方法来控制 render 方法是否被调用。\n参数:\n\n参数一：修改之后，最新的 props 属性\n参数二：修改之后，最新的 state 属性\n\nshouldComponentUpdate(nextProps,nextState){\n \n}\n返回值：\n\n返回值为 true，调用 render 方法；\n返回值为 false，不需要调用 render 方法；\n默认返回的是 true，也就是只要 state 发生改变，就会调用 render 方法；\n\nshouldComponentUpdate(nextProps,nextState){\n  return false;\n}\n使用示例：\nshouldComponentUpdate(nextProps,nextState){\n  // 判断新传入的props和以前的props是否一样\n  if(this.props.message !== nextProps.message){\n    return true;\n  }\n  return false;\n}\nPureComponent\n如果所有的类，我们都需要手动来实现 shouldComponentUpdate，那么会给我们开发者增加非常多的工作量。\n事实上 React 已经默认帮我们实现好了\n在类组件中，我们只需要将 class 继承自 PureComponent。\nimport React, { Component } from &quot;react&quot;;\nexport default class APP extends Component {\n  // ...\n}\n \n// 将导入 Component 改为导入 PureComponent\nimport React, { PureComponent } from &quot;react&quot;;\nexport default class APP extends PureComponent {\n  // ...\n}\n::: tip\nPureComponent 的本质是进行浅层比较，不会比较深层\n:::\nmemo\nPureComponent是针对类组件的 ，那么函数式组件呢？\n我们需要使用一个高阶组件 memo：将之前的函数式组件都通过 memo 函数进行一层包裹。\nmemo包裹起来的组件的特点：只有props发生变化，才会重新渲染\nfunction f() {\n  return &lt;h2&gt;f&lt;/h2&gt;\n}\n \nexport default f\n \n// 修改为\n \nimport { memo } from &quot;react&quot;;\n \nconst f = memo(function () {\n  return &lt;h2&gt;f&lt;/h2&gt;;\n});\n \nexport default f;\n "},"浏览器/react/react学习/5_react组件化开发":{"title":"react组件化开发","links":[],"tags":["react"],"content":"什么是组件化开发\n组件化是一种分而治之的思想：\n\n\n如果我们将一个页面中所有的处理逻辑全部放在一起，处理起来就会变得非常复杂，而且不利于后续的管理以及扩展。\n\n\n但如果，我们讲一个页面拆分成一个个小的功能块，每个功能块完成属于自己这部分独立的功能，那么之后整个页面的管 理和维护就变得非常容易了。\n\n\n\n我们需要通过组件化的思想来思考整个应用程序：\n\n我们将一个完整的页面分成很多个组件；\n每个组件都用于实现页面的一个功能块；\n而每一个组件又可以进行细分；\n而组件本身又可以在多个地方进行复用；\n\n\n\nReact 的组件化\n组件化是 React 的核心思想，也是我们后续的重点，前面我们封装的 App 本身就是一个组件：\n组件化提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用。\n任何的应用都会被抽象成一颗组件树。\n\n\n\n组件化思想的应用：\n有了组件化的思想，我们在之后的开发中就要充分的利用它。尽可能的将页面拆分成一个个小的、可复用的组件。这样让我们的代码更加方便组织和管理，并且扩展性也更强。\n\n\nReact 的组件相对于 Vue 更加的灵活和多样，按照不同的方式可以分成很多类组件：\n\n根据组件的定义方式，可以分为：函数组件(Functional Component )和类组件(Class Component)；\n根据组件内部是否有状态需要维护，可以分成：无状态组件(Stateless Component )和有状态组件(Stateful Component)；\n根据组件的不同职责，可以分成：展示型组件(Presentational Component)和容器型组件(Container Component)；\n\n\n\n\n这些概念有很多重叠，但是他们最主要是关注数据逻辑和 UI 展示的分离：\n\n函数组件、无状态组件、展示型组件主要关注 UI 的展示；\n类组件、有状态组件、容器型组件主要关注数据逻辑；\n当然还有很多组件的其他概念：比如异步组件、高阶组件等，我们后续再学习。\n\n类组件\n类组件的定义有如下要求：\n\n组件的名称是大写字符开头（无论类组件还是函数组件）\n类组件需要继承自 React.Component\n类组件必须实现 render 函数\n\n::: info\n在 ES6 之前，可以通过 create-react-class  模块来定义类组件，但是目前官网建议我们使用 ES6 的 class 类定义。\n:::\n使用 class 定义一个组件：\n\nconstructor 是可选的，我们通常在 constructor 中初始化一些数据；\nthis.state 中维护的就是我们组件内部的数据；\nrender()  方法是 class 组件中唯一必须实现的方法；\n\n\n如何编写一个类组件？\n\n\n导入 React.Component\n// 1.\nimport { Component } from &quot;react&quot;;\n// 2.\nimport React from &quot;react&quot;;\n\n\n类继承 Component\n根据导入的类型继承 Component\n// 1.\nimport { Component } from &quot;react&quot;;\n \nclass APP extends Component {}\n// 2.\nimport React from &quot;react&quot;;\n \nclass APP extends React.Component {}\n\n\n组件添加render函数，返回渲染内容\n根据组件内是否有状态需要维护添加constructor函数，如果使用到了constructor函数，必须调用super()\nimport { Component } from &quot;react&quot;;\nexport default class APP extends Component {\n  constructor() {\n    super();\n    this.state = {\n      message: &quot;HHH&quot;,\n    };\n  }\n  render() {\n    const { message } = this.state;\n    return &lt;h2&gt;{message}&lt;/h2&gt;;\n  }\n}\n\n\nrender 函数的返回值\n当  render  被调用时，它会检查  this.props  和  this.state  的变化并返回以下类型之一：\n\n\nReact 元素：\n通常通过 JSX 创建。\n例如，&lt;div /&gt;  会被 React 渲染为 DOM 节点，&lt;MyComponent /&gt;  会被 React 渲染为自定义组件；\n无论是  &lt;div /&gt;  还是  &lt;MyComponent /&gt;  均为 React 元素。\nrender() {\n return &lt;h2&gt;HHH&lt;/h2&gt;;\n}\n// 或者\nrender() {\n return &lt;APP/&gt;;\n}\n\n\n数组或 fragments(后续学习)：\n使得 render 方法可以返回多个元素。\nrender() {\n   return [1,2,3];\n}\n\nrender() {\n return [\n   &lt;h1&gt;H&lt;/h1&gt;,\n   &lt;h2&gt;HH&lt;/h2&gt;,\n   &lt;h3&gt;HHH&lt;/h3&gt;\n ];\n}\n\n\n\nPortals(后续学习)：\n可以渲染子节点到不同的 DOM 子树中。\n\n\n字符串或数值类型：\n它们在 DOM 中会被渲染为文本节点\nrender() {\n return &quot;Hello,world&quot;;\n}\n// 或者\nrender() {\n return 123;\n}\n\n\n布尔类型或 null 或 undefined：\n什么都不渲染。\nrender() {\n return [1,2,3];\n}\n\n\n函数组件\n函数组件是使用 function 来进行定义的函数，只是这个函数会返回和类组件中 render 函数返回一样的内容。\n\n函数组件的特点（当然，后面讲 hooks 的时候就不一样了）：\n\n没有生命周期，也会被更新并挂载，但是没有生命周期函数；\nthis 关键字不能指向组件实例（因为没有组件实例）；\n没有内部状态（state）；\n\n\n我们来定义一个函数组件：\nexport default function App() {\n  return &lt;h2&gt;HHH&lt;/h2&gt;;\n}\n\n前面的学习中主要讲解类组件，后面学习 Hooks 时，会针对函数式组件进行更多的学习。\n\n生命周期\n从创建到销毁的整个过程被称为生命周期；\nReact 组件也有自己的生命周期，了解组件的生命周期可以让我们在最合适的地方完成自己想要的功能；\n\n生命周期和生命周期函数的关系：\n\n\n生命周期是一个抽象的概念，在生命周期的整个过程，分成了很多个阶段；\n\n比如装载阶段（Mount），组件第一次在 DOM 树中被渲染的过程；\n比如更新过程（Update），组件状态发生变化，重新更新渲染的过程；\n比如卸载过程（Unmount），组件从 DOM 树中被移除的过程；\n\n\n\nReact 内部为了告诉我们当前处于哪些阶段，会对我们组件内部实现的某些函数进行回调，这些函数就是生命周期函数：\n\n比如实现 componentDidMount 函数：组件已经挂载到 DOM 上时，就会回调；\n比如实现 componentDidUpdate 函数：组件已经发生了更新时，就会回调；\n比如实现 componentWillUnmount 函数：组件即将被移除时，就会回调；\n\n\n\n我们可以在这些回调函数中编写自己的逻辑代码，来完成自己的需求功能；\n::: tip\n我们谈 React 生命周期时，主要谈的是类的生命周期，因为函数式组件是没有生命周期函数的；（后面我们可以通过 hooks 来模拟一些生命周期的回调）\n:::\n生命周期函数\n\n\n\nConstructor\n如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数。\nconstructor 中通常只做两件事情：\n\n通过给  this.state  赋值对象来初始化内部的 state；\n为事件绑定实例（this）；\n\n\ncomponentDidMount\ncomponentDidMount  在组件被渲染到 DOM（被挂载到 DOM）的时候立即调用。\ncomponentDidMount 中通常进行哪里操作呢？\n\n依赖于 DOM 的操作可以在这里进行；\n在此处发送网络请求就最好的地方；（官方建议）\n可以在此处添加一些订阅（记得要在 componentWillUnmount 取消订阅）；\n\n\ncomponentDidUpdate\ncomponentDidUpdate  会在更新后会被立即调用，首次渲染不会执行此方法。\n当组件更新后，可以在此处对 DOM 进行操作；\n\n如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求；（例如，当 props 未发生变化时，则不会执行网络请求）。\n\n\ncomponentWillUnmount\ncomponentWillUnmount  会在组件卸载及销毁之前直接调用。\n在此方法中执行必要的清理操作；\n\n例如，清除 timer，取消网络请求或清除在  componentDidMount()  中创建的订阅等\n::: tip\n每个组件都是一个实例，因此每个组件都有自己的生命周期\n:::\n\n不常用生命周期函数\ngetDerivedStateFromProps\nstate 的值在任何时候都依赖于 props 时使用；该方法返回一个对象来更新 state；\n\ngetSnapshotBeforeUpdate\n在 React 更新 DOM 之前回调的一个函数，可以获取 DOM 更新前的一些信息（比如说滚动位置），用来保存一些数据或者快照。该函数的返回值会做为componentDidUpdate的参数\n\nshouldComponentUpdate\n该函数返回 true 的时候界面会重新渲染，返回 false 则不会重新渲染\n但是我们等待讲性能优化时再来详细讲解；\n\n\n::: tip\n生命周期速查图：projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\n更详细的生命周期内容：zh-hans.react.dev/reference/react/Component\n:::\n组件嵌套\n组件之间存在嵌套关系：\n\n\n在之前的案例中，我们只是创建了一个组件 App；\n\n\n如果我们一个应用程序将所有的逻辑都放在一个组件中，那么这个组件就会变成非常的臃肿和难以维护；\n\n\n所以组件化的核心思想应该是对组件进行拆分，拆分成一个个小的组件；再将这些组件组合嵌套在一起，最终形成我们的应用程序；\n\n\n\n\n\n上面的嵌套逻辑如下，它们存在如下关系：\nApp 组件是 Header、Main、Footer 组件的父组件；\nMain 组件是 Banner、ProductList 组件的父组件；\n\n组件间的通信\n在开发过程中，我们会经常遇到需要组件之间相互进行通信：\n\n比如 App 可能使用了多个 Header，每个地方的 Header 展示的内容不同，那么我们就需要使用者传递给 Header 一些数据，让其进行展示；\n又比如我们在 Main 中一次性请求了 Banner 数据和 ProductList 数据，那么就需要传递给他们来进行展示；\n也可能是子组件中发生了事件，需要由父组件来完成某些操作，那就需要子组件向父组件传递事件；\n\n\n父传子\n\n父组件通过   属性=值   的形式来传递给子组件数据；\n子组件通过  props  参数获取父组件传递过来的数据；\n\n\n\n详细教程参考官方文档\n\n::: tip\n  constructor(props) {\n    super(props);\n  }\n这段代码的意义就算将 props 保存到内部，大概原理是this.props = props。\n如果子组件没有需要维护的数据即只是展示父组件传过来的数据，那么就不用写constructor函数，可以直接在render函数获取到 props。因为组件内部会自动保存。\n:::\n参数 propTypes\n\n\n对于传递给子组件的数据，有时候我们可能希望进行验证，特别是对于大型项目来说：\n\n\n当然，如果你项目中默认继承了 Flow 或者 TypeScript，那么直接就可以进行类型验证；但是，即使我们没有使用 Flow 或者 TypeScript，也可以通过  prop-types  库来进行参数验证；\n\n\n::: info\nFlow 是 FaceBook 开发的，最早 Vue2 进行类型限制也是用的 Flow，虽然 Vue3 已经切换到 TS\n:::\n\n从 React v15.5 开始，React.PropTypes  已移入另一个包中：prop-types  库\nnpm install --save prop-types\n使用 prop-types\n\n默认参数\n\n\nprop-types 详细介绍\n\n子传父\n某些情况，我们需要子组件向父组件传递消息：\n\n在 vue 中是通过自定义事件来完成的；\n在 React 中同样是通过 props 传递消息，只是让父组件给子组件传递一个回调函数，在子组件中调用这个函数即可；\n\n::: details APP.jsx\nimport React, { Component } from &quot;react&quot;;\nimport Child from &quot;./Child&quot;;\n \nexport default class APP extends Component {\n  constructor() {\n    super();\n    this.state = {\n      count: 100,\n    };\n  }\n  changeCount(count) {\n    this.setState({ count: this.state.count + count });\n  }\n  render() {\n    const { count } = this.state;\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;APP&lt;/h1&gt;\n        &lt;h2&gt;当前计数{count}&lt;/h2&gt;\n        &lt;Child\n          addClick={(count) =&gt; {\n            this.changeCount(count);\n          }}\n        &gt;&lt;/Child&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n:::\n::: details Child.jsx\nimport React, { Component } from &quot;react&quot;;\n \nexport class Child extends Component {\n  add(count) {\n    this.props.addClick(count);\n  }\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;button\n          onClick={() =&gt; {\n            this.add(1);\n          }}\n        &gt;\n          +1\n        &lt;/button&gt;\n        &lt;button\n          onClick={() =&gt; {\n            this.add(5);\n          }}\n        &gt;\n          +5\n        &lt;/button&gt;\n        &lt;button\n          onClick={() =&gt; {\n            this.add(10);\n          }}\n        &gt;\n          +10\n        &lt;/button&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n \nexport default Child;\n:::\n组件通信案例\n效果\n\n::: details APP.jsx\nimport React, { Component } from &quot;react&quot;;\nimport TabControl from &quot;./TabControl&quot;;\n \nexport default class APP extends Component {\n  constructor() {\n    super();\n    this.state = {\n      titles: [&quot;流行&quot;, &quot;新款&quot;, &quot;精选&quot;],\n      tabIndex: 0,\n    };\n  }\n  tabClick(tabIndex) {\n    this.setState({ tabIndex });\n  }\n  render() {\n    const { titles, tabIndex } = this.state;\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;APP&lt;/h1&gt;\n        &lt;TabControl\n          titles={titles}\n          tabIndex={tabIndex}\n          tabClick={(i) =&gt; {\n            this.tabClick(i);\n          }}\n        &gt;&lt;/TabControl&gt;\n        &lt;h2&gt;{titles[tabIndex]}&lt;/h2&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n:::\n::: details TabControl.jsx\nimport React, { Component } from &quot;react&quot;;\nimport &quot;./style.css&quot;;\nexport class TabControl extends Component {\n  change(index) {\n    this.props.tabClick(index);\n  }\n  render() {\n    const { titles, tabIndex } = this.props;\n    return (\n      &lt;div className=&quot;tab&quot;&gt;\n        {titles.map((item, index) =&gt; {\n          return (\n            &lt;div\n              className={`item ${index === tabIndex ? &quot;active&quot; : &quot;&quot;}`}\n              onClick={() =&gt; {\n                this.change(index);\n              }}\n              key={item}\n            &gt;\n              &lt;span className=&quot;text&quot;&gt;{item}&lt;/span&gt;\n            &lt;/div&gt;\n          );\n        })}\n      &lt;/div&gt;\n    );\n  }\n}\n \nexport default TabControl;\n:::\n::: details style.css\n.tab {\n  display: flex;\n  align-items: center;\n  height: 40px;\n  text-align: center;\n}\n \n.tab .item {\n  flex: 1;\n}\n \n.tab .item.active {\n  color: red;\n}\n \n.tab .item.active .text {\n  padding: 3px;\n  border-bottom: 3px solid red;\n}\n:::\n插槽(slot)\n在开发中，我们抽取了一个组件，但是为了让这个组件具备更强的通用性，我们不能将组件中的内容限制为固定的 div、span 等等这些元素。\n我们应该让使用者可以决定某一块区域到底存放什么内容。\n\n上面这种需求在 Vue 当中有一个固定的做法是通过 slot 来完成的，但是 react 没有插槽该如何实现？\n\nReact 对于这种需要插槽的情况非常灵活，有两种方案可以实现：\n\n组件的 children 子元素；\nprops 属性传递 React 元素；\n\nchildren 实现\n每个组件都可以获取到 props.children：它包含组件的开始标签和结束标签之间的内容。\n如果组件开始结束标签之间只有一个标签，则 children 是一个元素；反之有多个标签，则 children 是数组\nAPP.jsx\nimport React, { Component } from &quot;react&quot;;\nimport NavBar from &quot;./NavBar&quot;;\n \nexport default class APP extends Component {\n  render() {\n    return (\n      &lt;NavBar&gt;\n        &lt;h2&gt;1&lt;/h2&gt;\n        &lt;h2&gt;2&lt;/h2&gt;\n        &lt;h2&gt;3&lt;/h2&gt;\n      &lt;/NavBar&gt;\n    );\n  }\n}\nNavBar.jsx\nimport React, { Component } from &quot;react&quot;;\n \nexport class NavBar extends Component {\n  render() {\n    const { children } = this.props;\n    console.log(children);\n    return (\n      &lt;div&gt;\n        &lt;div&gt;{children[0]}&lt;/div&gt;\n        &lt;div&gt;{children[1]}&lt;/div&gt;\n        &lt;div&gt;{children[2]}&lt;/div&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n \nexport default NavBar;\n::: tip\n通过 children 实现的方案虽然可行，但是有一个弊端：通过索引值获取传入的元素很容易出错，不能精准的获取传入的原生\n:::\nprops 实现\n通过具体的属性名，可以让我们在传入和获取时更加的精准；\nAPP.jsx\nimport React, { Component } from &quot;react&quot;;\nimport NavBar from &quot;./NavBar&quot;;\n \nexport default class APP extends Component {\n  render() {\n    const e1 = &lt;h2&gt;HH&lt;/h2&gt;;\n    const e2 = &lt;h3&gt;HHH&lt;/h3&gt;;\n    const e3 = &lt;h4&gt;HHHH&lt;/h4&gt;;\n \n    return &lt;NavBar slot1={e1} slot2={e2} slot3={e3} /&gt;;\n  }\n}\nNavBar.jsx\nimport React, { Component } from &quot;react&quot;;\n \nexport class NavBar extends Component {\n  render() {\n    const { slot1, slot2, slot3 } = this.props;\n    return (\n      &lt;div&gt;\n        &lt;div&gt;{slot1}&lt;/div&gt;\n        &lt;div&gt;{slot2}&lt;/div&gt;\n        &lt;div&gt;{slot3}&lt;/div&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n \nexport default NavBar;\n作用域插槽\n有这么一种情况，子组件要显示一个按钮，而这个按钮的标签是由父组件决定的，按钮的内容是由子组件决定的\nAPP.jsx\nimport React, { Component } from &quot;react&quot;;\nimport NavBar from &quot;./NavBar&quot;;\n \nexport default class APP extends Component {\n  render() {\n    return (\n      &lt;NavBar\n        itemType={&lt;button&gt;Hi,world&lt;/button&gt;}\n        itemType2={(item) =&gt; &lt;button&gt;{item}&lt;/button&gt;}\n      /&gt;\n    );\n  }\n}\nNavBar.jsx\nimport React, { Component } from &quot;react&quot;;\n \nexport default class NavBar extends Component {\n  render() {\n    const { itemType, itemType2 } = this.props;\n    return (\n      &lt;div&gt;\n        {/* 1.默认情况下是Hello,world，但是现在不想用span标签，想改用button标签并且里面的内容仍是Hello,world */}\n        &lt;span&gt;Hello,world&lt;/span&gt;\n        {/* 2.现在通过props修改为button标签，但是button的内容被更改为Hi,world */}\n        {itemType}\n        {/* 3.将传入标签改为传入一个返回标签的函数即可，现在标签由父组件决定，而内容由子组件决定*/}\n        {itemType2(&quot;Hello,world&quot;)}\n      &lt;/div&gt;\n    );\n  }\n}\n非父子组件通信 - Context\n非父子组件数据的共享：\n\n在开发中，比较常见的数据传递方式是通过 props 属性自上而下（由父到子）进行传递。\n但是对于有一些场景：比如一些数据需要在多个组件中进行共享（地区偏好、UI 主题、用户登录状态、用户信息等）。\n如果我们在顶层的 App 中定义这些信息，之后一层层传递下去，那么对于一些中间层不需要数据的组件来说，是一种冗余的操作。\n\n\n在一层层传递 props 的时候，可以使用展开运算符... 来在 JSX 中传递整个 props 对象。\n// 比如给Home组件传入一个info参数\n&lt;Home {info} /&gt;\n// 在HomeProduct组件中不使用这些参数，就可以直接加上 {...this.props}\n&lt;HomeProduct {...this.props}/&gt;\n// 现在HomeProductItem就可以拿到传递的info参数\n&lt;HomeProductItem {...this.props}/&gt;\n\n属性展开\n\n\n但是，如果层级更多的话，一层层传递是非常麻烦，并且代码是非常冗余的：React 提供了一个 API：Context；\nContext 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props；\nContext 设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言；\n\n::: tip\n当然 Context 使用起来也是相当繁琐的，所以一般在开发中使用的是 redux\n:::\n\nContext 相关 API\nReact.createContext\nconst Context = React.createContext();\n\n创建一个需要共享的 Context 对象；\n如果一个组件订阅了 Context，那么这个组件会从离自身最近的那个匹配的  Provider  中读取到当前的 context 值；\ndefaultValue 是组件在顶层查找过程中没有找到对应的 Provider，那么就使用默认值\n\nContext.Provider\n&lt;ThemeContext.Provider value={/* 需要共享的值 */}&gt;\n&lt;/ThemeContext.Provider&gt;\n\n每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化；\nProvider 接收一个  value  属性，传递给消费组件；\n一个 Provider 可以和多个消费组件有对应关系；\n多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据；\n当 Provider 的  value  值发生变化时，它内部的所有消费组件都会重新渲染；\n\nClass.contextType\n将 class 上的 contextType  属性赋值为一个由  React.createContext()  创建的 Context 对象；\n这能让你使用  this.context  来消费最近 Context 上的那个值；你可以在任何生命周期中访问到它，包括 render 函数中；\nContext.Consumer\n由于在函数式组件是没有 contextType 的，因此想要在函数式组件中使用 Context 就要通过Context.Consumer（并不是说类组件不能使用Context.Consumer）。\nContext.Consumer需要函数作为子元素；这个函数接收当前的 context 值，返回一个 React 节点；\n在多个 Context 需要使用的情况下，也需要使用到这个 API。\n\n\n如何实现一个 Context\n::: info 代码目录结构\n\n:::\n创建 Context\n通过React.createContext创建 Context；比如说创建一个主题上下文：\nconst ThemeContext = React.createContext();\n通过 Context 中 Provider 属性的 value 属性为后代提供数据\n&lt;ThemeContext.Provider value={{ color: &quot;red&quot; }}&gt;\n  &lt;Home&gt;&lt;/Home&gt;\n&lt;/ThemeContext.Provider&gt;\n\n设置组件的 ContextType 为某一个 Context\nHomeInfo.contextType = ThemeContext;\n获取 Context\n\n完整代码：\n::: details theme-context.js\n一般都会把上下文抽离到单个文件中\nimport React from &quot;react&quot;;\n \nconst ThemeContext = React.createContext();\n \nexport default ThemeContext;\n:::\n::: details APP.jsx\nimport React, { Component } from &quot;react&quot;;\nimport ThemeContext from &quot;./theme-context&quot;;\nimport Home from &quot;./Home&quot;;\n \nexport default class APP extends Component {\n  render() {\n    return (\n      &lt;ThemeContext.Provider value={{ color: &quot;red&quot; }}&gt;\n        &lt;Home&gt;&lt;/Home&gt;\n      &lt;/ThemeContext.Provider&gt;\n    );\n  }\n}\n:::\n::: details Home.jsx\nimport React, { Component } from &quot;react&quot;;\nimport HomeInfo from &quot;./HomeInfo&quot;;\n \nexport default class Home extends Component {\n  render() {\n    return &lt;HomeInfo&gt;&lt;/HomeInfo&gt;;\n  }\n}\n:::\n::: details HomeInfo.jsx\nimport React, { Component } from &quot;react&quot;;\nimport ThemeContext from &quot;./theme-context&quot;;\n \nexport class HomeInfo extends Component {\n  render() {\n    console.log(this.context);\n    return &lt;div&gt;HomeInfo&lt;/div&gt;;\n  }\n}\n \nHomeInfo.contextType = ThemeContext;\n \nexport default HomeInfo;\n:::\n函数式组件如何使用 Context\n将 HomeInfo.jsx 修改为函数式组件，APP.jsx 和 Home.jsx 不用修改。\nThemeContext 里面有个 Consumer，传入一个回调函数，里面会自动执行这个回调函数并且把 value 传递进来\nimport React from &quot;react&quot;;\nimport ThemeContext from &quot;./theme-context&quot;;\n \nexport default function HomeInfo() {\n  return (\n    &lt;ThemeContext.Consumer&gt;\n      {(value) =&gt; {\n        return &lt;h2&gt;{value.color}&lt;/h2&gt;;\n      }}\n    &lt;/ThemeContext.Consumer&gt;\n  );\n}\n\n如何使用多个 Context 的数据\n在 APP.jsx 中，我们有两个 Context\nimport React, { Component } from &quot;react&quot;;\nimport ThemeContext from &quot;./theme-context&quot;;\nimport UserContext from &quot;./user-context&quot;;\n \nimport Home from &quot;./Home&quot;;\n \nexport default class APP extends Component {\n  render() {\n    return (\n      &lt;UserContext.Provider value={{ name: &quot;Hello&quot; }}&gt;\n        &lt;ThemeContext.Provider value={{ color: &quot;red&quot; }}&gt;\n          &lt;Home&gt;&lt;/Home&gt;\n        &lt;/ThemeContext.Provider&gt;\n      &lt;/UserContext.Provider&gt;\n    );\n  }\n}\nHome.jsx 是一个类组件，contextType 属性也只有一个，现在 contextType 的值是 ThemeContext；\n如果要使用 UserContext 的值，就只能通过UserContext.Consumer。\nimport React, { Component } from &quot;react&quot;;\nimport UserContext from &quot;./user-context&quot;;\nimport ThemeContext from &quot;./theme-context&quot;;\n \nexport class Home extends Component {\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;h2&gt;ThemeContext:{this.context.color}&lt;/h2&gt;\n        &lt;UserContext.Consumer&gt;\n          {(value) =&gt; {\n            return &lt;h2&gt;UserContext:{value.name}&lt;/h2&gt;;\n          }}\n        &lt;/UserContext.Consumer&gt;\n      &lt;/div&gt;\n    );\n  }\n}\nHome.contextType = ThemeContext;\n \nexport default Home;\n::: tip\n函数式组件也一样，都是通过Context.Consumer来获取多个 Context 的\n:::\n非父子组件通信 - EventBus\n需要安装一个第三方库 hy-event-store\nnpm  i hy-event-store\n\n\n具体用法还是看 github 上的介绍吧\n\nsetState 介绍\n为什么使用 setState\n开发中我们并不能直接通过修改 state 的值来让界面发生更新：\n\n因为我们修改了 state 之后，希望 React 根据最新的 State 来重新渲染界面，但是这种方式的修改 React 并不知道数据发生了变化；\nReact 并没有实现类似于 Vue2 中的 Object.defineProperty 或者 Vue3 中的 Proxy 的方式来监听数据的变化（就是说 React 不像 Vue 对数据做了劫持）；\n我们必须通过 setState 来告知 React 数据已经发生了变化；\n\n\n组件中的 setState 方法是从 Component 中继承过来的。\n\n\nsetState 的三种不同用法\n\n\n直接传入一个对象\nthis.setState({ message: &quot;HHH&quot; });\n::: tip\n在内部是通过的Object.assign对原来的state和传入的对象进行合并的。\n:::\n\n\n\n\n\n传入一个回调函数\nthis.setState((state, props) =&gt; {\n  return {\n    message: &quot;HHH&quot;,\n  };\n});\n好处：\n\n\n可以直接在函数里面进行数据的逻辑的处理\n\n\n可以获取之前的 state 和 props（内部会不会将它们传递进来），不用再写 this\n\n\n\n\n\n\n\n传入第二个参数（callback）\n如果希望在数据更新后（但此时还未调用 render 函数）立即获取到更新后的 state，那么就可以传入第二个参数(一个回调函数)，这个函数会在更新后立即调用。\nthis.setState({ message: &quot;HHH&quot; }, () =&gt; {\n  console.log(this.state.message);\n});\n\n\n\n\nsetState 异步更新\n设置 state 的初始值\nthis.state = { message: &quot;Hello,world&quot; };\n调用 setState 进行更新\nthis.setState({ message: &quot;HHH&quot; });\nconsole.log(this.state.message); // Hello,world\n更新后立即打印this.state.message，打印的值是 Hello,world 而不是更新后的值 HHH。可见 setState 是异步的操作，我们并不能在执行完 setState 之后立马拿到最新的 state 的结果\n\n为什么 setState 设计为异步\n\nsetState 设计为异步其实之前在 GitHub 上也有很多的讨论；React 核心成员（Redux 的作者）Dan Abramov 也有对应的回复，有兴趣的可以参考一下；github.com/facebook/react/issues/11527#issuecomment-360199710；\n\n\n\nsetState 设计为异步，可以显著的提升性能；\n如果每次调用 setState 都进行一次更新，那么意味着 render 函数会被频繁调用，界面重新渲染，这样效率是很低的；\n最好的办法应该是获取到多个更新，之后进行批量更新；\n\n\n如果同步更新了 state，但是还没有执行 render 函数，那么 state 和 props 不能保持同步；state 和 props 不能保持一致性，会在开发中产生很多的问题；\n\n\n\n如何获取到更新后的值\n\n\nsetState 的回调\nsetState 接受两个参数：第二个参数是一个回调函数，这个回调函数会在更新后会执行；\n\n具体使用上面 [setStated 的三种用法中] 已经介绍过了\n\n\n在生命周期函数中获取\n\n\n\n\n在 React 18 前，setState 不一定都是异步的\n::: tip\n现在 React 18 的 setState 都是异步的\n:::\n\n\n在组件生命周期或 React 合成事件中，setState 是异步；\n\n\n在 setTimeout 或者原生 dom 事件中，setState 是同步；\nsetTimeout(() =&gt; {\n  this.setState({ message: &quot;HHH&quot; });\n}, 0);\ncomponentDidMount(){\n  const b = document.getElementById(&quot;btn&quot;);\n  b.addEventListener(&#039;click&#039;,()=&gt;{\n    this.setState({ message: &quot;HHH&quot; });\n  })\n}\n\n\nReact 18 中 setState 如何同步\nimport { flushSync } from &quot;react-dom&quot;;\n \n// ……\n \nflushSync(() =&gt; {\n  this.setState({ message: &quot;HHH&quot; });\n});\nref\n获取原生 DOM\n在 React 的开发模式中，通常情况下不需要、也不建议直接操作 DOM 原生，但是某些特殊的情况，确实需要获取到 DOM 进行某些操作：\n\n管理焦点，文本选择或媒体播放；\n触发强制动画；\n集成第三方 DOM 库；\n\n使用 document.querySelector 和 document.getElementBy··· 是非常繁琐的，因为使用的时候需要保证 class 和 id 等具有唯一性；在 React 中我们可以通过 ref 获取 DOM；\n\n如何创建 ref ?\n\n\n传入字符串\n使用时通过 this.refs.传入的字符串 格式获取对应的元素；\nimport React, { PureComponent } from &quot;react&quot;;\nexport class APP extends PureComponent {\n  getNativeDOM() {\n    console.log(this.refs.dom);\n  }\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;h2 ref=&quot;dom&quot;&gt;APP&lt;/h2&gt;\n        &lt;button onClick={(e) =&gt; this.getNativeDOM()}&gt;获取 DOM&lt;/button&gt;\n      &lt;/div&gt;\n    );\n  }\n}\nexport default APP;\n:::tip\n该方法已经废弃，但还是可以使用\n:::\n\n\n传入一个对象\n对象是通过React.createRef() 方式创建出来的；\n使用时获取到创建的对象其中有一个 current 属性就是对应的元素；\nimport React, { PureComponent, createRef } from &quot;react&quot;;\n \nexport class APP extends PureComponent {\n  constructor() {\n    super();\n    this.titleRef = createRef();\n  }\n  getNativeDOM() {\n    console.log(this.titleRef.current);\n  }\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;h2 ref={this.titleRef}&gt;APP&lt;/h2&gt;\n        &lt;button onClick={(e) =&gt; this.getNativeDOM()}&gt;获取 DOM&lt;/button&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n \nexport default APP;\n\n\n传入一个函数\n该函数会在 DOM 被挂载时进行回调，这个函数会传入一个元素对象，我们可以自己保存；\n使用时，直接拿到之前保存的元素对象即可；\nimport React, { PureComponent } from &quot;react&quot;;\n \nexport class APP extends PureComponent {\n  constructor() {\n    super();\n    this.titleEl = null;\n  }\n  getNativeDOM() {\n    console.log(this.refs.dom);\n  }\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;h2 ref={(el) =&gt; (this.titleEl = el)}&gt;APP&lt;/h2&gt;\n        &lt;button onClick={(e) =&gt; this.getNativeDOM()}&gt;获取DOM&lt;/button&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n \nexport default APP;\n\n\n获取类组件实例\n跟获取原生 DOM 一样，在组件上绑定一个 ref 就行\n使用this.componentRef.current获取组件实例\n\n既然都已经获取到了组件实例，那么就可以调用组件实例上的方法，如下面代码中的this.componentRef.current.text()\nimport React, { PureComponent, createRef } from &quot;react&quot;;\n \nclass Hello extends PureComponent {\n  text() {\n    console.log(&quot;text&quot;);\n  }\n  render() {\n    return &lt;h2&gt;Hello&lt;/h2&gt;;\n  }\n}\n \nexport class APP extends PureComponent {\n  constructor() {\n    super();\n    this.componentRef = createRef();\n  }\n  getComponent() {\n    console.log(this.componentRef.current);\n    this.componentRef.current.text();\n  }\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;Hello ref={this.componentRef} /&gt;\n        &lt;button onClick={(e) =&gt; this.getComponent()}&gt;获取DOM&lt;/button&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n \nexport default APP;\n获取函数式组件的 DOM\n函数式组件是没有实例的，所以无法通过 ref 获取他们的实例：但是某些时候，我们可能想要获取函数式组件中的某个 DOM 元素；这个时候我们可以通过 React.forwardRef ，后面我们也会学习 hooks 中如何使用 ref；\n如果在函数式组件中直接传入一个 ref 属性，控制台会报警告。\n\n如何使用 forwardRef\nimport React, { PureComponent, createRef, forwardRef } from &quot;react&quot;;\n \nconst Hello = forwardRef(function (props, ref) {\n  return &lt;h2 ref={ref}&gt;Hello&lt;/h2&gt;;\n});\n \nexport class APP extends PureComponent {\n  constructor() {\n    super();\n    this.componentRef = createRef();\n  }\n  getComponent() {\n    console.log(this.componentRef.current);\n  }\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;Hello ref={this.componentRef} /&gt;\n        &lt;button onClick={(e) =&gt; this.getComponent()}&gt;获取DOM&lt;/button&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n \nexport default APP;\n受控组件和非受控组件\n在 HTML 中，表单元素如&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;等通常自己（浏览器）维护 state，并根据用户输入进行更新。\n\n这里的 state并不是指this.state，而是一个抽象的概念\n\n但在 React 中，可变状态通常保存在组件的 state 属性中，并且只能通过使用 setState() 来更新。\n如果我们将React的state作为 &lt;input&gt;、&lt;textarea&gt;等非受控组件的 “唯一数据源”；被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”；\n\ninput\n现在需要再页面上显示一个输入框，输入框有默认值 Hello，下面是实现代码：\nimport React, { PureComponent } from &quot;react&quot;;\n \nexport class APP extends PureComponent {\n  constructor() {\n    super();\n    this.state = {\n      message: &quot;Hello&quot;,\n    };\n  }\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;input type=&quot;text&quot; value={this.state.message} /&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n \nexport default APP;\n现在出现一个问题：输入框无法输入。\nwhy？因为我们给 input 添加了 value 属性，这导致 input 从非受控组件变成受控组件，即现在 input 的值只能由代码控制而不能由用户控制。\n如果现在想修改 input 的值，则需要添加 onChange\nexport class APP extends PureComponent {\n  constructor() {\n    super();\n    this.state = {\n      message: &quot;Hello&quot;,\n    };\n  }\n  change(e) {\n    this.setState({ message: e.target.value });\n  }\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;input\n          type=&quot;text&quot;\n          value={this.state.message}\n          onChange={(e) =&gt; this.change(e)}\n        /&gt;\n      &lt;/div&gt;\n    );\n  }\n}\ncheckbox\nexport default class APP extends PureComponent {\n  constructor() {\n    super();\n    this.state = {\n      isAgree: true,\n    };\n  }\n  change(e) {\n    this.setState({ isAgree: e.target.checked });\n  }\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;label for=&quot;agree&quot;&gt;\n          &lt;input type=&quot;checkbox&quot; id=&quot;agree&quot; checked={this.state.isAgree} onChange={(e)=&gt;this.change(e)}/&gt;\n          agree\n        &lt;/label&gt;\n      &lt;/div&gt;\n    );\n  }\n}\nselect\n单选\nexport default class APP extends PureComponent {\n  constructor() {\n    super();\n    this.state = {\n      choice: &quot;a&quot;,\n    };\n  }\n  change(e) {\n    this.setState({ choice: e.target.value });\n  }\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;select value={this.state.choice} onChange={(e) =&gt; this.change(e)}&gt;\n          &lt;option value=&quot;a&quot;&gt;a&lt;/option&gt;\n          &lt;option value=&quot;b&quot;&gt;b&lt;/option&gt;\n          &lt;option value=&quot;c&quot;&gt;c&lt;/option&gt;\n        &lt;/select&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n多选\nexport default class APP extends PureComponent {\n  constructor() {\n    super();\n    this.state = {\n      choice: [&quot;a&quot;],\n    };\n  }\n  change(e) {\n    const values = Array.from(e.target.selectedOptions, (item) =&gt; item.value);\n    this.setState({ choice: values });\n  }\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;select\n          multiple\n          value={this.state.choice}\n          onChange={(e) =&gt; this.change(e)}\n        &gt;\n          &lt;option value=&quot;a&quot;&gt;aaaaaaaaaaa&lt;/option&gt;\n          &lt;option value=&quot;b&quot;&gt;bbbbbbbbbbb&lt;/option&gt;\n          &lt;option value=&quot;c&quot;&gt;ccccccccccc&lt;/option&gt;\n        &lt;/select&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n高阶组件\n::: info 高阶函数\n至少满足以下条件之一：\n\n接受一个或多个函数作为输入；\n输出一个函数；\n\nJS中的filter、map、reduce都是高阶函数。\n:::\n定义\n高阶组件(Higher-Order Components)，简称为 HOC；\n\n高阶组件本身不是一个组件，而是一个函数；\n参数是一个组件，返回值也是一个组件；\n\nfunction hoc(Component) {\n  class NewComponent extends PureComponent {\n    render(){\n      return &lt;Component /&gt;\n    }\n  }\n  return NewComponent;\n}\n::: tip\n高阶组件并不是React API的一部分，它是基于React的组合特性而形成的设计模式\n:::\n高阶组件在一些React第三方库中非常常见：如redux中的connect和react-router中的withRouter。\nprops的增强\n添加新的props\nimport { PureComponent } from &quot;react&quot;;\n \nfunction enhancedInfo(OriginComponent) {\n  class NewComponent extends PureComponent {\n    constructor() {\n      super();\n      this.state = {\n        info: {\n          name: &quot;hi&quot;,\n          level: 100,\n        },\n      };\n    }\n    render() {\n      return &lt;OriginComponent {...this.state.info} /&gt;;\n    }\n  }\n  return NewComponent;\n}\n \nconst Hello = enhancedInfo(function (props) {\n  return &lt;h1&gt;{props.name},{props.level}&lt;/h1&gt;;\n});\n \nexport default class APP extends PureComponent {\n  render() {\n    return &lt;Hello /&gt;;\n  }\n}\n共享Context\nimport { PureComponent, createContext } from &quot;react&quot;;\n \nconst ThemeContext = createContext();\n \nexport default class APP extends PureComponent {\n  render() {\n    return (\n      &lt;ThemeContext.Provider value={{ color: &quot;red&quot; }}&gt;\n        &lt;Info1 /&gt;\n        &lt;Info2&gt;&lt;/Info2&gt;\n      &lt;/ThemeContext.Provider&gt;\n    );\n  }\n}\n// 直接使用Context\nclass Info1 extends PureComponent {\n  render() {\n    return (\n      &lt;ThemeContext.Consumer&gt;\n        {(value) =&gt; {\n          return &lt;h1&gt;{value.color}&lt;/h1&gt;;\n        }}\n      &lt;/ThemeContext.Consumer&gt;\n    );\n  }\n}\n// 通过高阶组件使用Context\nfunction withTheme(OriginComponent) {\n  return (props) =&gt; {\n    return (\n      &lt;ThemeContext.Consumer&gt;\n        {(value) =&gt; {\n          return &lt;OriginComponent {...value} {...props} /&gt;;\n        }}\n      &lt;/ThemeContext.Consumer&gt;\n    );\n  };\n}\nconst Info2 = withTheme(function (props) {\n  return &lt;h1&gt;{props.color}&lt;/h1&gt;;\n});\n渲染判断鉴权\nimport { PureComponent } from &quot;react&quot;;\n \nfunction loginAuth(OriginComponent) {\n  return (props) =&gt; {\n    if (true) {\n      return &lt;OriginComponent {...props} /&gt;;\n    } else {\n      return &lt;h1&gt;登录&lt;/h1&gt;;\n    }\n  };\n}\n \nconst Info = loginAuth(function () {\n  return &lt;h1&gt;info&lt;/h1&gt;;\n});\n \nexport default class APP extends PureComponent {\n  constructor() {\n    super();\n    this.state = {\n      login: false,\n    };\n  }\n  render() {\n    return &lt;Info /&gt;;\n  }\n}\n生命周期劫持\nimport { PureComponent } from &quot;react&quot;;\n \nfunction logRenderTime(OriginComponent) {\n  return class extends PureComponent {\n    UNSAFE_componentWillMount() {\n      this.start = new Date().getTime();\n    }\n    componentDidMount() {\n      this.end = new Date().getTime();\n      // 打印渲染时间\n      console.log(this.end - this.start);\n    }\n    render() {\n      return &lt;OriginComponent /&gt;;\n    }\n  };\n}\n \nconst Info = logRenderTime(function () {\n  return &lt;h1&gt;info&lt;/h1&gt;;\n});\n \nexport default class APP extends PureComponent {\n  render() {\n    return &lt;Info /&gt;;\n  }\n}\nPortals\n某些情况下，我们希望渲染的内容独立于父组件，甚至是独立于当前挂载到的DOM元素中（默认都是挂载到id为root的DOM元素上的）。\nPortal 可以将子节点渲染到存在于父组件以外的 DOM 节点：\n\n第一个参数：任何可渲染的 React 子元素；\n第二个参数：一个 DOM 元素；\n\nimport { PureComponent } from &quot;react&quot;;\nimport { createPortal } from &quot;react-dom&quot;;\n \nexport default class APP extends PureComponent {\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;root&lt;/h1&gt;\n        {createPortal(&lt;h1&gt;other&lt;/h1&gt;, document.querySelector(&quot;#other&quot;))}\n      &lt;/div&gt;\n    );\n  }\n}\n\nfragment\n在之前的开发中，一个组件中返回内容时总是包裹一个div元素，而这个div又没有实际意义。我们可以使用Fragment代替这个div，根vue的template相似。\nFragment 允许你将子列表分组，而无需向 DOM 添加额外节点；\nimport { PureComponent, Fragment } from &quot;react&quot;;\n \nexport default class APP extends PureComponent {\n  render() {\n    return (\n      &lt;Fragment&gt;\n        &lt;h1&gt;Hi&lt;/h1&gt;\n      &lt;/Fragment&gt;\n    );\n  }\n}\nReact还提供了Fragment的语法糖\nimport { PureComponent } from &quot;react&quot;;\n \nexport default class APP extends PureComponent {\n  render() {\n    return (\n      &lt;&gt;\n        &lt;h1&gt;Hi&lt;/h1&gt;\n      &lt;/&gt;\n    );\n  }\n}\n但是，如果我们需要在Fragment中添加key，那么就不能使用短语法\nStrictMode\nStrictMode 是一个用来突出显示应用程序中潜在问题的工具：\n\n与 Fragment 一样，StrictMode 不会渲染任何可见的 UI；\n它为其后代元素触发额外的检查和警告；\n严格模式检查仅在开发模式下运行，不会影响生产构建；\n\nimport React, { PureComponent } from &quot;react&quot;;\n \nexport default class APP extends PureComponent {\n  render() {\n    return (\n      &lt;React.StrictMode&gt;\n        &lt;h1&gt;Hi&lt;/h1&gt;\n      &lt;/React.StrictMode&gt;\n    );\n  }\n}\nStrictMode 可以检测什么\n\n\n识别不安全的生命周期\n\n\n使用过时的ref API\n\n\n检查意外的副作用\n组件会被调用两次；这是严格模式下故意进行的操作，让你来查看在这里写的一些逻辑代码被调用多次时，是否会产生一些副作用； 在生产环境中，是不会被调用两次的；\n在控制台中，第一行显示的是第一次调用的输出，第二行显示的是第二次调用的输出，用灰色显示与第一次区别开来（如果没有安装react插件则没有这种颜色区别）。\n\n\n\n使用废弃的findDOMNode方法\n\n\n检测过时的context API\n\n"},"浏览器/react/react学习/6_react动画":{"title":"react动画","links":[],"tags":["react"],"content":"React的过渡动画\n介绍\n在开发中，我们想要给一个组件的显示和消失添加某种过渡动画时，可以通过原生的CSS来实现这些过渡动画，但是React社区为我们提供了react-transition-group用来完成过渡动画。\nReact曾为开发者提供过动画插件 react-addons-css-transition-group，后由社区维护，形成了现在的 react transition group。\n这个库可以帮助我们方便的实现组件的入场和离场动画，使用时需要进行额外的安装。\nnpm install react-transition-group --save\n\nreact-transition-group本身非常小，不会为我们应用程序增加过多的负担。\n\n主要组件\nTransition\n该组件是一个和平台无关的组件（不一定要结合CSS），在前端开发中比较常用的是CSSTransition；\nCSSTransition\n在前端开发中，通常使用CSSTransition来完成过渡动画效果；\nCSSTransition是基于Transition组件构建的。\nCSSTransition执行过程中，有三个状态：appear、enter、exit；其中每个状态又有三类状态：\n\n第一类，开始状态：对于的类是-appear、-enter、-exit；\n第二类：执行动画：对应的类是-appear-active、-enter-active、-exit-active；\n第三类：执行结束：对应的类是-appear-done、-enter-done、-exit-done；\n\nCSSTransition常见对应的属性：\n\n\nin：触发进入或者退出状态；\n\n当in为true时，触发进入状态，会添加-enter、-enter-acitve的class开始执行动画，当动画执行结束后，会移除两个class， 并添加-enter-done的class；\n当in为false时，触发退出状态，会添加-exit、-exit-active的class开始执行动画，当动画执行结束后，会移除两个class，并添加-enter-done的class；\n\n\n\nunmountOnExit：退出后卸载组件；\n\n\nclassNames：动画class的名称；\n决定了在编写css时，对应的class名称。\n\n\ntimeout： 过渡动画的时间，最好与css里面的transition时间保持一致；\n\n\nappear：是否在初次进入添加动画（需要和in同时为true）；\n\n\nCSSTransition对应的钩子函数：\n\nonEnter：在进入动画之前被触发；\nonEntering：在应用进入动画时被触发；\nonEntered：在应用进入动画结束后被触发；\n\n\n下面代码是文字的淡入淡出的效果实现\n\nimport { PureComponent } from &quot;react&quot;;\nimport { CSSTransition } from &quot;react-transition-group&quot;;\nimport &quot;./App.css&quot;;\n \nexport default class APP extends PureComponent {\n  constructor() {\n    super();\n    this.state = {\n      isShow: true,\n    };\n  }\n  render() {\n    const { isShow } = this.state;\n    return (\n      &lt;div&gt;\n        &lt;button onClick={() =&gt; {this.setState({ isShow: !isShow });}}&gt;切换&lt;/button&gt;\n        &lt;CSSTransition classNames=&quot;foo&quot; in={isShow} unmountOnExit={true} timeout={1000} appear onEnter={() =&gt; {}}&gt;\n          &lt;h1&gt;Hello&lt;/h1&gt;\n        &lt;/CSSTransition&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n.foo-appear {\n  transform: translateX(-150px);\n}\n \n.foo-appear-active {\n  transform: translateX(0);\n  transition: transform 1s ease;\n}\n \n.foo-enter {\n  opacity: 0;\n}\n \n.foo-enter-active {\n  opacity: 1;\n  transition: opacity 1s ease;\n}\n \n.foo-exit {\n  opacity: 1;\n}\n \n.foo-exit-active {\n  opacity: 0;\n  transition: opacity 1s ease;\n}\n::: tip 解决StrictMode模式下的警告\n只需要手动设置ref，内部就不会使用findDomNode了，也就不会警告了。\n&lt;CSSTransition nodeRef={hRef} ...&gt;\n\t&lt;h1 ref={hRef}&gt;World&lt;/h1&gt;\n&lt;/CSSTransition&gt;\n:::\nSwitchTransition\nSwitchTransition可以完成两个组件之间切换的炫酷动画：\nSwitchTransition中主要有一个属性mode，有两个值：\n\nin-out：表示新组件先进入，旧组件再移除；\nout-in：表示就组件先移除，新组建再进入；\n\n使用SwitchTransition组件时，应该用CSSTransition或者Transition组件包裹你想要切换的组件，不能用SwitchTransition组件直接包裹你想要切换的组件。\nSwitchTransition里面的CSSTransition或Transition组件不再像以前那样接受in属性来判断元素是何种状态，取而代之的是 key属性；\n\n下面代码是按钮的移入移出动画效果实现\n\nimport { PureComponent } from &quot;react&quot;;\nimport { SwitchTransition, CSSTransition } from &quot;react-transition-group&quot;;\nimport &quot;./App.css&quot;;\n \nexport default class APP extends PureComponent {\n  constructor() {\n    super();\n    this.state = {\n      isLogin: true,\n    };\n  }\n  render() {\n    const { isLogin } = this.state;\n    return (\n      &lt;div&gt;\n        &lt;SwitchTransition mode=&quot;out-in&quot;&gt;\n          &lt;CSSTransition key={isLogin} classNames=&quot;login&quot; timeout={1000}&gt;\n            &lt;button onClick={(e) =&gt; this.setState({ isLogin: !isLogin })}&gt;{isLogin ? &quot;退出&quot; : &quot;登录&quot;}&lt;/button&gt;\n          &lt;/CSSTransition&gt;\n        &lt;/SwitchTransition&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n.login-enter {\n  opacity: 0;\n  transform: translateX(10px);\n}\n \n.login-enter-active {\n  opacity: 1;\n  transform: translateX(0);\n  transition: all 1s ease;\n}\n \n.login-exit {\n  opacity: 1;\n  transform: translateX(0);\n}\n \n.login-exit-active {\n  opacity: 0;\n  transform: translateX(-10px);\n  transition: all 1s ease;\n}\nTransitionGroup\n当我们有一组动画时，需要将这些CSSTransition放入到一个TransitionGroup中来完成动画。\n\n下面是列表添加和删除的动画效果实现\n\n\n在实际开发时，key应该是唯一的，下面代码的key使用index只是为了演示方便\n\nimport { PureComponent } from &quot;react&quot;;\nimport { CSSTransition, TransitionGroup } from &quot;react-transition-group&quot;;\nimport &quot;./App.css&quot;;\n \nexport default class APP extends PureComponent {\n  constructor() {\n    super();\n    this.state = {\n      books: [\n        { name: &quot;a&quot;, price: 1 },\n        { name: &quot;b&quot;, price: 2 },\n        { name: &quot;c&quot;, price: 3 },\n      ],\n    };\n  }\n  add() {\n    const books = [...this.state.books];\n    books.push({ name: &quot;d&quot;, price: 4 });\n    this.setState({ books });\n  }\n  delete() {\n    const books = [...this.state.books];\n    books.pop({ name: &quot;d&quot;, price: 4 });\n    this.setState({ books });\n  }\n  render() {\n    const { books } = this.state;\n    return (\n      &lt;div&gt;\n        &lt;button onClick={() =&gt; this.add()}&gt;add&lt;/button&gt;\n        &lt;button onClick={() =&gt; this.delete()}&gt;delete&lt;/button&gt;\n        &lt;TransitionGroup component=&quot;ul&quot;&gt;\n          {books.map((item, index) =&gt; {\n            return (\n              &lt;CSSTransition key={index} classNames=&quot;book&quot; timeout={1000}&gt;\n                &lt;li&gt;\n                  {item.name}-{item.price}\n                &lt;/li&gt;\n              &lt;/CSSTransition&gt;\n            );\n          })}\n        &lt;/TransitionGroup&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n.book-enter {\n  opacity: 0;\n  transform: translateX(50px);\n}\n \n.book-enter-active {\n  opacity: 1;\n  transform: translateX(0);\n  transition: all 1s ease;\n}\n \n.book-exit {\n  opacity: 1;\n  transform: translateX(0);\n}\n \n.book-exit-active {\n  opacity: 0;\n  transform: translateX(-10px);\n  transition: all 1s ease;\n}\nReact如何编写CSS\n在组件化中选择合适的CSS解决方案应该符合以下条件：\n\n可以编写局部css：css具备自己的具备作用域，不会随意污染其他组件内的元素；\n可以编写动态的css：可以获取当前组件的一些状态，根据状态的变化生成不同的css样式；\n支持所有的css特性：伪类、动画、媒体查询等；\n编写起来简洁方便、最好符合一贯的css风格特点；\n…\n\nReact官方并没有给出在React中统一的样式风格\n内联样式\nstyle 接受一个采用小驼峰命名属性的 JavaScript 对象，而不是 CSS 字符串；并且可以引用state中的状态来设置相关的样式；\n优点：\n\n内联样式, 样式之间不会有冲突\n可以动态获取当前state中的状态\n\n缺点：\n\n写法上都需要使用驼峰标识\n2.某些样式没有提示\n3.大量的样式, 代码混乱\n某些样式无法编写(比如伪类/伪元素)\n\nimport { PureComponent } from &quot;react&quot;;\nimport &quot;./App.css&quot;;\n \nexport default class APP extends PureComponent {\n  render() {\n    return &lt;h1 style={{ color: &quot;red&quot;, fontSize: &quot;50px&quot; }}&gt;Hello&lt;/h1&gt;;\n  }\n}\n普通的css\n编写css到一个单独的文件，之后再进行引入。\n这样的编写方式和普通的网页开发中编写方式是一致的，如果我们按照普通的网页标准去编写，那么也不会有太大的问题；\n在组件化开发中我们总是希望组件是一个独立的模块，即便是样式也只是在自己内部生效，不会相互影响； 但是普通的css都属于全局的css，样式之间会相互影响；\n这种编写方式最大的问题是样式之间会相互层叠掉；\nimport { PureComponent } from &quot;react&quot;;\nimport &quot;./App.css&quot;;\n \nexport default class APP extends PureComponent {\n  render() {\n    return &lt;h1 className=&quot;h&quot;&gt;Hello&lt;/h1&gt;;\n  }\n}\n.h{\n  color: red;\n  font-size: 50px;\n}\ncss modules\ncss modules并不是React特有的解决方案，而是所有使用了类似于webpack配置的环境下都可以使用的。\n\n如果在其他项目中使用它，那么我们需要自己来进行配置，比如配置webpack.config.js中的modules: true等。\n\nReact的脚手架已经内置了css modules的配置。我们只需将 .css/.less/.scss 等样式文件修改成 .module.css/.module.less/.module.scss 等； 然后就可以引用并且进行使用了；\ncss modules确实解决了局部作用域的问题，也是很多人喜欢在React中使用的一种方案。\n缺点：\n\n引用的类名，不能使用连接符(.home-title)，在JavaScript中是不识别的；\n所有的className都必须使用{style.className} 的形式来编写；\n不方便动态来修改某些样式，依然需要使用内联样式的方式；\n\nimport { PureComponent } from &quot;react&quot;;\nimport style from &quot;./App.module.css&quot;;\n \nexport default class APP extends PureComponent {\n  render() {\n    return &lt;h1 className={style.h}&gt;Hello&lt;/h1&gt;;\n  }\n}\n.h{\n  color: red;\n  font-size: 50px;\n}\nCSS in JS\n“CSS-in-JS” 是指一种模式，其中 CSS 由 JavaScript 生成而不是在外部文件中定义；\n::: tip\n此功能并不是 React 的一部分，而是由第三方库提供；\n:::\nCSS-in-JS通过JavaScript来为CSS赋予一些能力，包括类似于CSS预处理器一样的样式嵌套、函数定义、逻辑复用、动态修改状态等等；\n虽然CSS预处理器也具备某些能力，但是获取动态状态依然是一个不好处理的点； 所以，目前可以说CSS-in-JS是React编写CSS最为受欢迎的一种解决方案；\n目前比较流行的CSS-in-JS的库有：\n\nstyled-components\nemotion\nglamorous\n\n\nstyled-components的本质是通过函数的调用，最终创建出一个组件。这个组件会被自动添加上一个不重复的class，styled-components会给该class添加相关的样式；\n它支持类似于CSS预处理器一样的样式嵌套：\n\n支持直接子代选择器或后代选择器，并且直接编写样式；\n可以通过&amp;符号获取当前元素；\n直接伪类选择器、伪元素等；\n\n基本使用：\nimport { PureComponent } from &quot;react&quot;;\nimport { AppWrapper } from &quot;./style&quot;;\n \nexport default class APP extends PureComponent {\n  render() {\n    return (\n      &lt;AppWrapper&gt;\n        &lt;h1 className=&quot;h&quot;&gt;\n          Hello\n          &lt;i&gt;,world&lt;/i&gt;\n        &lt;/h1&gt;\n      &lt;/AppWrapper&gt;\n    );\n  }\n}\n// style.js\nimport styled from &quot;styled-components&quot;;\n \nexport const AppWrapper = styled.div`\n\tborder: 1px solid red;\n  .h {\n    color: red;\n    &amp;:hover {\n      background-color: black;\n    }\n    i{\n      font-size:20px;\n    }\n  }\n`;\n\n在模板字符串里面写css正常情况下是没有代码提示和高亮的，但可以安装vscode-styled-component这个插件来获取这些功能\n\n其它功能：\n\n\n解决动态样式\n可以使用props解决，props可以被传递给styled组件。获取props需要通过${}传入一个插值函数，props会作为该函数的参数；\nexport default class APP extends PureComponent {\n  constructor() {\n    super();\n    this.state = {\n      size: &quot;10px&quot;,\n    };\n  }\n  render() {\n    return (\n      &lt;AppWrapper size={this.state.size}&gt;\n      &lt;/AppWrapper&gt;\n    );\n  }\n}\nexport const AppWrapper = styled.div`\n  i {\n    font-size: ${(props) =&gt; props.size};\n  }\n`;\n\n\n默认值\n可以使用attrs给标签模板字符串提供属性\nexport const AppWrapper = styled.div.attrs(props=&gt;{\n  return{\n    size:props.size || &quot;10px&quot;\n  }\n})`\n\tfont-size: ${(props) =&gt; props.size};\n \n`;\n\n\ncss变量\n在一个js文件里面导出多个js常量，然后直接在样式文件导入相关的变量即可。\n\n\n共享主题\n\n\n通过定义css变量实现\n在一个js文件里面导出多个js常量，然后直接在样式文件导入相关的变量即可。\nexport const themeColor = &quot;red&quot;;\n \n\n\n或者通过ThemeProvider组件实现\nimport { ThemeProvider } from &quot;styled-components&quot;;\n...\nReactDOM.createRoot(document.getElementById(&quot;root&quot;)).render(\n  &lt;ThemeProvider theme={{ color: &quot;red&quot; }}&gt;\n    &lt;App /&gt;\n  &lt;/ThemeProvider&gt;\n);\nexport const AppWrapper = styled.div`\n  .h {\n    color: ${(props) =&gt; props.theme.color};\n  }\n`;\n\n\n\n\n样式继承\nconst wrapper = styled(AppWrapper)`\n  ...\n`\n\n\nReact如何编写less\n\n\n修改webpack配置：\n通过npm run eject暴露webpack配置，然后手动添加相关loader；\n\n\n由于修改原生的webpack配置繁琐，可以使用 craco 插件来修改：craco.js.org/docs/getting-started/\n\n\n动态添加class\n可以像编写JavaScript代码一样，通过一些逻辑来决定是否添加某些class：\nexport default class APP extends PureComponent {\n  render() {\n    const classList = [&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;];\n    return (\n      &lt;div&gt;\n        &lt;h1 className={&quot;title&quot; + (isActive ? &quot;active&quot; : &quot;&quot;)}&gt;&lt;/h1&gt;\n        &lt;h1 className={`title ${isActive ? &quot;active&quot; : &quot;&quot;}`}&gt;&lt;/h1&gt;\n        &lt;h1 className={classList.join(&quot; &quot;)}&gt;&lt;/h1&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n但当需要添加的class过多的时候，这样操作会很麻烦。因此Wimbledon可以使用第一个第三方库classnames。\nnpm i classnames\n使用方法：\nclassNames(&#039;foo&#039;, &#039;bar&#039;); // =&gt; &#039;foo bar&#039;\nclassNames(&#039;foo&#039;, { bar: true }); // =&gt; &#039;foo bar&#039;\nclassNames({ &#039;foo-bar&#039;: true }); // =&gt; &#039;foo-bar&#039;\nclassNames({ &#039;foo-bar&#039;: false }); // =&gt; &#039;&#039;\nclassNames({ foo: true }, { bar: true }); // =&gt; &#039;foo bar&#039;\nclassNames({ foo: true, bar: true }); // =&gt; &#039;foo bar&#039;\nclassNames(&#039;foo&#039;, { bar: true, duck: false }, &#039;baz&#039;, { quux: true }); // =&gt; &#039;foo bar baz quux&#039;\nclassNames(null, false, &#039;bar&#039;, undefined, 0, 1, { baz: null }, &#039;&#039;); // =&gt; &#039;bar 1&#039;"},"浏览器/react/react学习/7_Redux的使用":{"title":"Redux的使用","links":[],"tags":["react"],"content":"纯函数\n在程序设计中，若一个函数符合以下条件，那么这个函数被称为纯函数：\n\n此函数在相同的输入值时，需产生相同的输出。\n函数的输出和输入值以外的其他隐藏信息或状态无关，也和由I/O设备产生的外部输出无关。\n函数不能有语义上可观察的函数副作用，诸如“触发事件”，使输出设备输出，或更改输出值以外物件的内容等。\n\n::: tip\n在计算机科学中，副作用表示在执行一个函数时，除了返回函数值之外，还对调用函数产生了附加的影响， 比如修改了全局变量，修改参数或者改变外部的存储；\n例如：\nslice截取数组时不会对原数组进行任何操作，而是生成一个新的数组；splice：splice截取数组，会返回一个新的数组，也会对原数组进行修改；\n那么，slice就是一个纯函数，而splice函数不是一个纯函数。\n:::\n\nReact中就要求我们无论是函数还是class声明一个组件，这个组件都必须像纯函数一样，保护它们的props不被修改。\n\nRedux基本使用\n原则\n\n\n单一数据源\n整个应用程序的state被存储在一棵object tree中，并且这个object tree只存储在一个 store 中：\nRedux并没有强制让我们不能创建多个Store，但是那样做并不利于数据的维护； 单一的数据源可以让整个应用程序的state变得方便维护、追踪、修改；\n\n\nState是只读的\n唯一修改State的方法一定是触发action，不要试图在其他地方通过任何的方式来修改State；这样就确保了View或网络请求都不能直接修改state，它们只能通过action来描述自己想要如何修改state；、\n这样可以保证所有的修改都被集中化处理，并且按照严格的顺序来执行，所以不需要担心race condition（竟态）的问题；\n\n\n使用纯函数来执行修改\n通过reducer将旧state和actions联系在一起，并且返回一个新的State：\n随着应用程序的复杂度增加，我们可以将reducer拆分成多个小的reducers，分别操作不同state tree的一部分；\n所有的reducer都应该是纯函数，不能产生任何的副作用；\n\n\n定义一个store\n创建Store来存储state；\n创建store时必须创建reducer；\nconst { createStore } = require(&quot;redux&quot;);\n \nconst initialState = {\n  name: &quot;Hi&quot;,\n};\n \nfunction reducer() {\n  return initialState;\n}\n \nconst store = createStore(reducer);\n \nmodule.exports = store;\n获取state\n可以通过 store.getState 来获取当前的state；\nstore.getState()\n修改store中的数据\n通过action来修改state；\n通过dispatch来派发action；\nconst { createStore } = require(&quot;redux&quot;);\n \nconst initialState = {\n  name: &quot;Hi&quot;,\n};\n \nfunction reducer(state = initialState, action) {\n  if (action.type === &quot;change_name&quot;) {\n    return { ...state, name: action.name };\n  }\n}\n \nconst store = createStore(reducer);\n \nmodule.exports = store;\nconst store = require(&quot;./store&quot;)\n \nconst nameAction = { type: &quot;change_name&quot;, name: &quot;HHH&quot; };\nstore.dispatch(nameAction);\n\nreducer是一个纯函数，不要直接修改state；\n\n订阅store中的数据\n// 订阅\nconst unSubscribe = store.subscribe(()=&gt;{\n  console.log(&quot;订阅&quot;,store.getState());\n})\n// 取消订阅\nunSubscribe();\n动态生产action\nstore.dispatch({ type: &quot;change_name&quot;, name: &quot;HHH&quot; });\nstore.dispatch({ type: &quot;change_name&quot;, name: &quot;AAA&quot; });\nstore.dispatch({ type: &quot;change_name&quot;, name: &quot;CCC&quot; });\n如果需要多次修改store的数据，那么定义action的操作会很繁琐，而且很可能会出错。\n我们可以使用函数进行替换\nconst changeNameAction = (name) =&gt; ({\n  type: &quot;change_name&quot;,\n  name,\n});\nstore.dispatch(changeNameAction(&quot;HHH&quot;));\nstore.dispatch(changeNameAction(&quot;AAA&quot;));\nstore.dispatch(changeNameAction(&quot;CCC&quot;));\n当action生成函数过多的时候，可以将函数放在 actionCreators.js 文件中。\nRedux结构划分\n如果我们将所有的逻辑代码写到一起，那么当redux变得复杂时代码就难以维护。\n可以将代码拆分为：\n\nstore/index.js\nstore/reducer.js\nstore/actionCreators.js\nstore/constants.js\n\nRedux使用流程\n\n\n在React中使用Redux\nimport { PureComponent } from &quot;react&quot;;\nconst store = require(&quot;./store&quot;);\n \nexport default class APP extends PureComponent {\n  constructor() {\n    super();\n    this.state = {\n      counter: store.getState().counter,\n    };\n  }\n  componentDidMount() {\n    store.subscribe(() =&gt; {\n      this.setState({ counter: store.getState().counter });\n    });\n  }\n  add() {\n    store.dispatch({ type: &quot;revise&quot;, num: this.state.counter + 1 });\n  }\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;{this.state.counter}&lt;/h1&gt;\n        &lt;button onClick={(e) =&gt; this.add()}&gt;+&lt;/button&gt;\n      &lt;/div&gt;\n    );\n  }\n}\nreact-redux\nredux和react没有直接的关系，你完全可以在React, Angular, Ember, jQuery, or vanilla  JavaScript中使用Redux。\n在react中，每个页面使用redux都需要写一堆重复代码，我们可以通过将重复代码抽取成高阶的形式来简化开发。\n通常是使用react-redux插件。\nnpm install react-redux\nimport { Provider } from &quot;react-redux&quot;;\nimport store from &quot;./store&quot;;\n \nconst root = ReactDOM.createRoot(document.getElementById(&quot;root&quot;));\nroot.render(\n  &lt;Provider store={store}&gt;\n    &lt;App /&gt;\n  &lt;/Provider&gt;\n);\nimport { Connect } from &quot;react-redux&quot;;\n \nexport class APP extends PureComponent {\n  render() {\n    return (\n      &lt;div&gt;\n        {this.props.counter}\n        &lt;button onClick={() =&gt; this.props.add()}&gt;+1&lt;/button&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n \n// 将state的数据映射到props里面\nconst mapStateToProps = (state) =&gt; ({\n  counter: state.counter,\n});\n \nconst mapDispatchToProps = (dispatch) =&gt; ({\n  add(num) {\n    dispatch({ type: &quot;add&quot;, num: 1 });\n  },\n});\n \nexport default Connect(mapStateToProps, mapDispatchToProps)(APP);\nredux-thunk\n在之前的代码中，redux中保存的counter是一个本地定义的数据，我们可以直接通过同步的操作来dispatch action，state就会被立即更新。 但在真实开发中，redux中保存的很多数据可能来自服务器，我们需要进行异步的请求，再将数据保存到redux中。\n网络请求到的数据也属于我们状态管理的一部分，更好的一种方式应该是将其也交给redux来管理；\nredux中使用中间件进行异步的操作，通常使用redux-thunk插件。\n默认情况下的dispatch(action)，action是一个对象；而redux-thunk可以让dispatch的action是一个函数；该函数会被调用，并且会传给这个函数一个dispatch函数和getState函数；dispatch函数用于我们之后再次派发action； getState函数考虑到我们之后的一些操作需要依赖原来的状态，用于让我们可以获取之前的一些状态；\n\n\n安装\nnpm i redux-thunk\n\n\n在创建store时传入应用了middleware的enhance函数\nimport { createStore, applyMiddleware } from &quot;redux&quot;;\nimport thunk from &#039;react-thunk&#039;\n \nconst store = createStore(reducer,applyMiddleware(thunk));\n\n\n定义返回一个函数的action\nexport const fetchMetadataAction = () =&gt; {\n  return function (dispatch, getState) {\n    axios.get(&quot;......&quot;).then((res) =&gt; {\n      dispatch({ type: &quot;......&quot;, num: res.data });\n    });\n  };\n};\n该函数在dispatch之后会被执行；\n\n\n使用\nexport class APP extends PureComponent {\n  componentDidMount() {\n    this.props.fetchMetadata();\n  }\n}\n \nconst mapDispatchToProps = (dispatch) =&gt; ({\n  fetchMetadata() {\n    dispatch(fetchMetadataAction());\n  },\n});\n\n\nredux-devtools\n浏览器安装完redux-devtools插件后，默认情况下，我们是无法查看redux里面的数据的。\n如果需要查看，我们需要在代码中添加相应代码\n\n如何添加相关代码：\ngithub.com/reduxjs/redux-devtools/tree/main/extension#installation\n\nimport { createStore, applyMiddleware, compose } from &quot;redux&quot;;\nimport thunk from &quot;redux-thunk&quot;;\n \nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;\n \nconst store = createStore(reducer, composeEnhancers(applyMiddleware(thunk)));\nRedux模块\n\nredux给我们提供了一个combineReducers函数可以方便的让我们对多个reducer进行合并。\nimport { createStore, combineReducers } from &quot;redux&quot;;\n \nimport userReducer from &quot;./user/reducer&quot;;\nimport dataReducer from &quot;./data/reducer&quot;;\n \nconst reducer = combineReducers({\n  user: userReducer,\n  data: dataReducer,\n});\n \nconst store = createStore(reducer);\n \nexport default store;\ncombineReducers原理：\nfunction reducer(state, action) {\n  return {\n    user: userReducer(state.user,action),\n    data: dataReducer(state.data,action),\n  };\n}\nRedux Toolkit\n在前面我们学习Redux的时候应该已经发现，redux的编写逻辑过于的繁琐和麻烦。 并且代码通常分拆在多个文件中（虽然也可以放到一个文件管理，但是代码量过多，不利于管理）；\nRedux Toolkit包旨在成为编写Redux逻辑的标准方式，从而解决上面提到的问题；\n::: tip\nRedux Toolkit 只是对redux的代码进行了封装\n:::\nnpm install @reduxjs/toolkit\n核心API：\n\n\nconfigureStore\n包装createStore以提供简化的配置选项和良好的默认值。\n它可以自动组合你的 slice reducer，添加你提供的任何 Redux 中间件，redux-thunk默认包含，并启用 Redux DevTools Extension。\n\n\n createSlice：\n接受reducer函数的对象、切片名称和初始状态值，并自动生成切片reducer，并带有相应的actions。\n\n\ncreateAsyncThunk：\n接受一个动作类型字符串和一个返回承诺的函数，并生成一个pending / fulfilled / rejected 基于该承诺分派动作类型的 thunk\n\n\n重构reducer\n先对counter的reducer进行重构：\n\n\n通过createSlice创建一个slice。\n参数：\n\nname：用户标记slice的名词，在之后的redux-devtool中会显示对应的名词；\ninitialState：第一次初始化时的值；\nreducers：对象类型，可以添加函数；添加的函数类似于redux原来reducer中的一个case语句；函数的参数：state，action；\n\n\n\n导出\n\n\nimport { createSlice } from &quot;@reduxjs/toolkit&quot;;\n \nconst counterSlice = createSlice({\n  name: &quot;counter&quot;,\n  initialState: {\n    count: 0,\n  },\n  reducers: {\n    add(state, action) {},\n  },\n});\n \nexport default counterSlice.reducer;\n重构store\nconfigureStore用于创建store对象。\n参数：\n\nreducer，将slice中的reducer可以组成一个对象传入此处；\nmiddleware：可以使用参数，传入其他的中间件；\ndevTools：是否配置devTools工具，默认为true；\n\nimport { configureStore } from &quot;@reduxjs/toolkit&quot;;\n \nimport counterReducer from &quot;./features/counter&quot;;\n \nconst store = configureStore({\n  reducer: {\n    counter: counterReducer,\n  },\n});\n \nexport default store\n将RTK的store和react联系起来\n导出counter的action，导出的名字与reducers对象里面的函数名一样。\nimport { createSlice } from &quot;@reduxjs/toolkit&quot;;\n \nconst counterSlice = createSlice({\n  name: &quot;counter&quot;,\n  initialState: {\n    count: 0,\n  },\n  reducers: {\n    add(state, { payload }) {\n      state.count += payload;\n    },\n  },\n});\n \nexport const { add } = counterSlice.actions;\n \nexport default counterSlice.reducer;\nreact代码只需导入adction即可，剩下的代码和以前一样\nimport { add } from &quot;./store/features/counter.js&quot;;\n \nexport class APP extends PureComponent {\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;h1&gt; {this.props.count}&lt;/h1&gt;\n        &lt;button onClick={() =&gt; {this.props.addNum();}}&gt;+&lt;/button&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n \nconst mapDispatchToProps = (dispatch) =&gt; ({\n  addNum() {\n    dispatch(add(1));\n  },\n});\n \nexport default connect(mapStateToProps, mapDispatchToProps)(APP);\n \nRTK的异步操作\n在之前的开发中，我们通过redux-thunk中间件让dispatch中可以进行异步操作。Redux Toolkit默认已经给我们继承了Thunk相关的功能。\nimport { createAsyncThunk } from &quot;@reduxjs/toolkit&quot;;\n \nexport const fetchDataAction = createAsyncThunk(&quot;Data&quot;, async () =&gt; {\n  const res = await axios.get();\n  return res.data;\n});\n \nconst counterSlice = createSlice({\n  // 第一种写法\n  extraReducers: {\n    [fetchDataAction.pending](state, action) {},\n    [fetchDataAction.fulfilled](state, action) {},\n    [fetchDataAction.rejected](state, action) {},\n  },\n  // 第二种写法\n  extraReducers: (builder) =&gt; {\n    builder\n      .addCase(fetchDataAction.pending, (state, action) =&gt; {})\n      .addCase(fetchDataAction.fulfilled, (state, action) =&gt; {})\n      .addCase(fetchDataAction.rejected, (state, action) =&gt; {});\n  },\n});\nimport { fetchDataAction } from &quot;./store/features/counter.js&quot;;\n \nexport class APP extends PureComponent {\n  componentDidMount() {\n    this.props.fetchData();\n  }\n}\n \nconst mapDispatchToProps = (dispatch) =&gt; ({\n  fetchData() {\n    dispatch(fetchDataAction());\n  },\n});\n当请求获取到数据后需要保存，上面代码是通过extraReducers来保存，我们也可以直接在fetchDataAction保存数据。\nexport const fetchDataAction = createAsyncThunk(&quot;Data&quot;, async (extraInfo, { dispatch, getState }) =&gt; {\n  const res = await axios.get();\n  dispatch({type:&quot;...&quot;,data:res.data})\n});\n实现react-redux的connect\n定义一个上下文，用来传递store\nimport { createContext } from &quot;react&quot;;\n \nexport const StoreContext = createContext();\n实现逻辑\nimport { PureComponent } from &quot;react&quot;;\nimport { StoreContext } from &quot;./b&quot;;\n \nexport default function connect(mapStateToProps, mapDispatchToProps) {\n  return function (WrapperComponent) {\n    class NewComponent extends PureComponent {\n      constructor(props, context) {\n        super(props);\n        this.state = mapStateToProps(context.getState());\n      }\n      componentDidMount() {\n        this.unSubscribe = this.context.subscribe(() =&gt; {\n          this.setState(mapStateToProps(this.context.getState()));\n        });\n      }\n      componentWillUnmount() {\n        this.unSubscribe();\n      }\n      render() {\n        const state = mapStateToProps(this.context.getState());\n        const dispatch = mapDispatchToProps(this.context.dispatch);\n        return &lt;WrapperComponent {...this.props} {...state} {...dispatch} /&gt;;\n      }\n    }\n    NewComponent.contextType = StoreContext;\n    return NewComponent;\n  };\n}\n \n使用\nimport store from &quot;./store&quot;;\nimport { StoreContext } from &quot;./b&quot;;\n \nconst root = ReactDOM.createRoot(document.getElementById(&quot;root&quot;));\nroot.render(\n    &lt;StoreContext.Provider value={store}&gt;\n      &lt;App /&gt;\n    &lt;/StoreContext.Provider&gt;\n);\n \n打印dispatch日志\n比如我们现在有一个需求：在dispatch之前，打印一下本次的action对象，dispatch完成之后可以打印一下最新的store state；\n如果没有中间件，我们可以在派发的前后进行相关的打印。\nconst mapDispatchToProps = (dispatch) =&gt; ({\n  addNum() {\n    console.log(action);\n    dispatch(action);\n    console.log(state);\n  },\n});\n很明显，由于每一次的dispatch操作都需要在前面加上上面的逻辑代码，会导致存在大量重复的代码；\n事实上，我们可以利用一个hack一点的技术：Monkey Patching，利用它可以修改原有的程序逻辑；对代码进行如下的修改：\nfunction log(store) {\n  const next = store.dispatch;\n  function logAndDispatch(action) {\n    console.log(&quot;当前派发的action&quot;, action);\n    next(action);\n    console.log(&quot;派发之后的结果&quot;, store.getState());\n  }\n  store.dispatch = logAndDispatch;\n}\nlog(store)\n在调用dispatch的过程中，真正调用的函数其实是dispatchAndLog；\n实现redux-thunk\nredux中利用一个中间件redux-thunk可以让我们的dispatch不再只是处理对象，还可以处理函数\nfunction thunk() {\n  const next = store.dispatch;\n  function dispatchThunk(action) {\n    if (typeof action === &quot;function&quot;) {\n      action(store.dispatch,store.getState)\n    }else if(typeof action === &quot;object&quot;){\n      next(action)\n    }\n  }\n  store.dispatch = dispatchThunk;\n}\nthunk(store)\n实现applyMiddleware\nimport log from &quot;./middleware/log&quot;;\nimport thunk from &quot;./middleware/thunk&quot;;\n \nconst store = createStore(...);\n  \nlog(store);\nthunk(store);\n显然，当中间件多起来后，单个调用某个函数来合并中间件并不是特别的方便，所以我们可以封装一个函数来实现所有的中间件合并。\nexport default function applyMiddleware(store, ...fns) {\n  fns.forEach((fn) =&gt; {\n    fn(store);\n  });\n}\nimport applyMiddleware from &quot;./middleware/applyMiddleware&quot;;\nimport log from &quot;./middleware/log&quot;;\nimport thunk from &quot;./middleware/thunk&quot;;\n \nconst store = createStore(...);\n \napplyMiddleware(store, log, thunk);"},"浏览器/react/react学习/8_Router的使用":{"title":"Router的使用","links":[],"tags":["react"],"content":"认识react-router\n目前前端流行的三大框架, 都有自己的路由实现:\n\nAngular的ngRouter\nReact的ReactRouter\nVue的vue-route\n\n目前使用的是 React Router6.x 版本；\n安装React Router\nnpm install react-router-dom\n\n安装时，我们选择react-router-dom；react-router会包含一些react-native的内容，web开发并不需要；\n\n导入组件并使用\nimport { BrowserRouter,HashRouter } from &quot;react-router-dom&quot;;\n\nBrowserRouter：使用history模式；\nHashRouter：使用hash模式；\n\nconst root = ReactDOM.createRoot(...);\nroot.render(\n    &lt;BrowserRouter&gt;\n      &lt;App /&gt;\n    &lt;/BrowserRouter&gt;\n);\n路由映射配置\n\n\nRoutes：包裹所有的Route，在其中匹配一个路由\n\nRouter5.x使用的是Switch组件\n\n\n\nRoute：Route用于路径的匹配；\n\n\npath属性：用于设置匹配到的路径；\n\n\nelement属性：设置匹配到路径后，渲染的组件；\n\nRouter5.x 使用的是component属性\n\n\n\nexact：精准匹配，只有精准匹配到完全一致的路径，才会渲染对应的组件；\n\nRouter6.x 不再支持该属性\n\n\n\n\n\nimport { Routes, Route, Link } from &quot;react-router-dom&quot;;\nimport Home from &quot;./Home&quot;;\nimport About from &quot;./About&quot;;\n \nexport class APP extends PureComponent {\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;header&gt;&lt;/header&gt;\n        &lt;main&gt;\n          &lt;Routes&gt;\n            &lt;Route path=&quot;/&quot; element={&lt;Home /&gt;} /&gt;\n            &lt;Route path=&quot;/Home&quot; element={&lt;Home /&gt;} /&gt;\n            &lt;Route path=&quot;/About&quot; element={&lt;About /&gt;} /&gt;\n          &lt;/Routes&gt;\n        &lt;/main&gt;\n        &lt;footer&gt;&lt;/footer&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n路由配置和跳转\n使用Link和NavLink组件。\n通常路径的跳转是使用Link组件，最终会被渲染成a元素；\nto属性：Link中最重要的属性，用于设置跳转到的路径；\nimport { Routes, Route, Link } from &quot;react-router-dom&quot;;\nimport Home from &quot;./Home&quot;;\nimport About from &quot;./About&quot;;\n \nexport class APP extends PureComponent {\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;header&gt;\n          &lt;Link to=&#039;/Home&#039;&gt;首頁&lt;/Link&gt;\n          &lt;Link to=&#039;/About&#039;&gt;关于&lt;/Link&gt;\n        &lt;/header&gt;\n        &lt;main&gt;\n          &lt;Routes&gt;\n            &lt;Route path=&quot;/&quot; element={&lt;Home /&gt;} /&gt;\n            &lt;Route path=&quot;/Home&quot; element={&lt;Home /&gt;} /&gt;\n            &lt;Route path=&quot;/About&quot; element={&lt;About /&gt;} /&gt;\n          &lt;/Routes&gt;\n        &lt;/main&gt;\n        &lt;footer&gt;&lt;/footer&gt;\n      &lt;/div&gt;\n    );\n  }\n}\nNavLink是在Link基础之上增加了一些样式属性；\n如果我们需要再路径选中时，对应的a元素变为红，我们就要使用NavLink组件来替代Link组件。\nimport { Routes, Route, NavLink } from &quot;react-router-dom&quot;;\n \nexport class APP extends PureComponent {\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;header&gt;\n          &lt;NavLink to=&quot;/Home&quot;&gt;首頁&lt;/NavLink&gt;\n          &lt;NavLink to=&quot;/About&quot;&gt;关于&lt;/NavLink&gt;\n        &lt;/header&gt;\n        &lt;main&gt;&lt;/main&gt;\n        &lt;footer&gt;&lt;/footer&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n在默认匹配成功时，NavLink就会添加上一个动态的active class，所以我们可以直接编写样式；\n\n当热，我们也可以通过参数进行样式修改\n\nstyle：传入函数，函数接受一个对象，包含isActive属性\nclassName：传入函数，函数接受一个对象，包含isActive属性\n\n&lt;NavLink to=&quot;/Home&quot; style={({ isActive }) =&gt; ({ color: isActive ? &quot;red&quot; : &quot;&quot; })}&gt;首頁&lt;/NavLink&gt;\n&lt;NavLink to=&quot;/About&quot; className={({ isActive }) =&gt; (isActive ? &quot;active&quot; : &quot;&quot;)}&gt;关于&lt;/NavLink&gt;\nNavigate导航\nNavigate用于路由的重定向，当这个组件出现时，就会执行跳转到对应的to路径中。\n\n\n当我们未登录时进入用户页面，可以通过Navigate重定向到登录页面；\n{this.state.isLogin ? &lt;Navigate to=&quot;/Home&quot; /&gt; : &lt;button&gt;登录&lt;/button&gt;}\n\n\n在匹配到/的时候，直接跳转到/home页面；\n&lt;Route path=&quot;/&quot; element={&lt;Navigate to=&quot;/Home&quot; /&gt;} /&gt;\n\n\nNot Found页面配置\n&lt;Route path=&quot;*&quot; element={&lt;NotFound /&gt;} /&gt;\n路由的嵌套\n假设Home1和Home2是Home的子页面\nimport { PureComponent } from &quot;react&quot;;\nimport { Routes, Route, Link, Navigate } from &quot;react-router-dom&quot;;\nimport Home from &quot;./Home&quot;;\nimport About from &quot;./About&quot;;\nimport Home1 from &quot;./Home1&quot;;\nimport Home2 from &quot;./Home2&quot;;\n \nexport class APP extends PureComponent {\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;header&gt;\n          &lt;Link to=&quot;/Home&quot;&gt;首頁&lt;/Link&gt;\n          &lt;Link to=&quot;/About&quot;&gt;关于&lt;/Link&gt;\n        &lt;/header&gt;\n        &lt;main&gt;\n          &lt;Routes&gt;\n            &lt;Route path=&quot;/&quot; element={&lt;Navigate to=&quot;/Home&quot; /&gt;} /&gt;\n            &lt;Route path=&quot;/Home&quot; element={&lt;Home /&gt;}&gt;\n              &lt;Route path=&quot;/Home&quot; element={&lt;Navigate to=&quot;/Home/Home1&quot; /&gt;} /&gt;\n              &lt;Route path=&quot;/Home/Home1&quot; element={&lt;Home1 /&gt;} /&gt;\n              &lt;Route path=&quot;/Home/Home2&quot; element={&lt;Home2 /&gt;} /&gt;\n            &lt;/Route&gt;\n            &lt;Route path=&quot;/About&quot; element={&lt;About /&gt;} /&gt;\n          &lt;/Routes&gt;\n        &lt;/main&gt;\n        &lt;footer&gt;&lt;/footer&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n&lt;Outlet /&gt;组件用于在父路由元素中作为子路由的占位元素，类似于vue的&lt;router-view /&gt;。\nimport React, { PureComponent } from &quot;react&quot;;\nimport { Link, Outlet } from &quot;react-router-dom&quot;;\n \nexport class Home extends PureComponent {\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;Home&lt;/h1&gt;\n        &lt;Link to=&quot;/Home/Home1&quot;&gt;Home1&lt;/Link&gt;\n        &lt;Link to=&quot;/Home/Home2&quot;&gt;Home2&lt;/Link&gt;\n        &lt;Outlet /&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n \nexport default Home;\n手动路由的跳转\n目前我们实现的跳转主要是通过Link或者NavLink进行跳转的，实际上我们也可以通过JavaScript代码进行跳转。\n如果我们希望通过JavaScript代码逻辑进行跳转（比如点击了一个button），那么就需要获取到navigate对象。在Router6.x版本之后，我们需要通过useNavigate的Hook获取到navigate对象进行操作；\nimport { useNavigate } from &quot;react-router-dom&quot;;\n::: tip\nhook只能在个函数式组件中使用，因此在类组件中我们无法使用useNavigate\n:::\n如果我們需要在类组件中使用，那我们需要自己编写一个高阶组件\nfunction withRouter(WrapperComponent) {\n  return function (props) {\n    const navigate = useNavigate();\n    const router = { navigate };\n    return &lt;WrapperComponent {...props} router={router} /&gt;;\n  };\n}\n在组件中使用\nimport React, { PureComponent } from &quot;react&quot;;\n \nexport class Home1 extends PureComponent {\n  navigateTo() {\n    const { navigate } = this.props.router;\n    navigate(&#039;/about&#039;)\n  }\n  render() {\n    return &lt;h3&gt;Home1&lt;/h3&gt;;\n  }\n}\n \nexport default withRouter(Home1);\n路由参数传递\n传递参数有二种方式：\n\n\n动态路由的方式；\n动态路由的概念指的是路由中的路径并不会固定。我们可以使用useParams获取参数\nimport { useParams } from &quot;react-router-dom&quot;;\n明显useParams是hook，因此无法再类组件中使用，因此需要修改withRouter函数\nfunction withRouter(WrapperComponent) {\n  return function (props) {\n    const navigate = useNavigate();\n    const params = useParams();\n    const router = { navigate, params };\n    return &lt;WrapperComponent {...props} router={router} /&gt;;\n  };\n}\n如果我们将path在Route匹配时写成/About/:id，那么 /About/abc、/About/123都可以匹配到该Route，并且进行显示。\nexport class APP extends PureComponent {\n  render() {\n    return (\n      &lt;div&gt;\n          &lt;Routes&gt;\n            &lt;Route path=&quot;/About/:id&quot; element={&lt;About /&gt;} /&gt;\n          &lt;/Routes&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n获取参数\nimport React, { PureComponent } from &quot;react&quot;;\n \nexport class About extends PureComponent {\n  render() {\n    const { params } = this.props.router;\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;About&lt;/h1&gt;\n        &lt;h3&gt;id:{params.id}&lt;/h3&gt;\n      &lt;/div&gt;\n    );\n  }\n}\nexport default withRouter(About);\n\n\nsearch传递参数；\n获取查询字符串有两种方式。\n\n\nuseLocation\nimport { useLocation } from &quot;react-router-dom&quot;;\n首先修改withRouter函数\nfunction withRouter(WrapperComponent) {\n  return function (props) {\n    const navigate = useNavigate();\n    const params = useParams();\n    const location = useLocation();\n    const router = { navigate, params, location };\n    return &lt;WrapperComponent {...props} router={router} /&gt;;\n  };\n}\n打印location对象\n\n\n\n\n\n useSearchParams\nimport { useSearchParams } from &quot;react-router-dom&quot;;\n获取查询参数\nconst [searchParams, setSearchParams] = useSearchParams();\nsearchParams.get(&quot;id&quot;);\nsearchParams.get(&quot;name&quot;);\nsearchParams在获取查询参数的时候是固定的，需要把它转成普通对象。\n首先修改withRouter函数\nfunction withRouter(WrapperComponent) {\n  return function (props) {\n    const navigate = useNavigate();\n    const params = useParams();\n    const location = useLocation();\n    const [searchParams, setSearchParams] = useSearchParams();\n    const query = Object.fromEntries(searchParams);\n    const router = { navigate, params, location, query };\n    return &lt;WrapperComponent {...props} router={router} /&gt;;\n  };\n}\n\n\n\n\n路由的配置方式使用\n目前我们所有的路由定义都是直接使用Route组件，并且添加属性来完成的，但是这样的方式会让路由变得非常混乱，我们希望将所有的路由配置放到一个地方进行集中管理。\n\n在早期的时候，Router并且没有提供相关的API，我们需要借助于react-router-config完成；\n\n在Router6.x中，我们可以使用useRoutes完成相关的配置。\nimport { useRoutes } from &quot;react-router-dom&quot;;\nimport routes from &quot;./routes&quot;;\n \nfunction APP() {\n  return (\n    &lt;div&gt;\n     {useRoutes(routes)}\n    &lt;/div&gt;\n  );\n}\n配置routes\nimport Home from &quot;./Home.jsx&quot;;\nimport About from &quot;./About.jsx&quot;;\nimport { Navigate } from &quot;react-router-dom&quot;;\n \nconst routes = [\n  {\n    path: &quot;/&quot;,\n    element: &lt;Navigate to=&quot;/home&quot; /&gt;,\n  },\n  {\n    path: &quot;/home&quot;,\n    element: &lt;Home /&gt;,\n    children: [\n      {\n        path: &quot;/home/home1&quot;,\n        element: &lt;Home1 /&gt;,\n      },\n    ],\n  },\n  {\n    path: &quot;/about&quot;,\n    element: &lt;About /&gt;,\n  },\n  {\n    path: &quot;/about/:id&quot;,\n    element: &lt;About /&gt;,\n  },\n  {\n    path: &quot;*&quot;,\n    element: &lt;NotFount /&gt;,\n  },\n];\n \nexport default routes;\n懒加载\n不直接导入，使用React.lazy导入，routes数组保持不变\nimport React from &quot;react&quot;;\n \nconst About = React.lazy(() =&gt; import(&quot;./About.jsx&quot;));\n \nconst routes = [\n  {\n    path: &quot;/about&quot;,\n    element: &lt;About /&gt;,\n  },\n];\n如果我们对某些组件进行了异步加载（懒加载），那么需要使用Suspense进行包裹：\nimport { BrowserRouter } from &quot;react-router-dom&quot;;\nimport { Suspense } from &quot;react&quot;;\n \nconst root = ReactDOM.createRoot(document.getElementById(&quot;root&quot;));\nroot.render(\n  &lt;BrowserRouter&gt;\n    &lt;Suspense fallback={&lt;h1&gt;Loading...&lt;/h1&gt;}&gt;\n      &lt;App /&gt;\n    &lt;/Suspense&gt;\n  &lt;/BrowserRouter&gt;\n);"},"浏览器/react/react学习/9_Hook":{"title":"Hook的使用","links":[],"tags":["react"],"content":"Hook 和 Class 的对比\nHook 是 React 16.8 的新增特性，它可以让我们在不编写 class 的情况下使用 state 以及其他的 React 特性（比如生命周期）。\nclass 组件相对于函数式组件的优势：\n\n\nclass 组件可以定义自己的 state，用来保存组件自己内部的状态；函数式组件不可以，因为函数每次调用都会产生新的临时变量；\n\n\nclass 组件有自己的生命周期，我们可以在对应的生命周期中完成自己的逻辑；\n\n\n\n比如在 componentDidMount 中发送网络请求，并且该生命周期函数只会执行一次；函数式组件在学习 hooks 之前，如果在函数中发送网络请求，意味着每次重新渲染都会重新发送一次网络请求；\n\n\nclass 组件可以在状态改变时只会重新执行 render 函数以及我们希望重新调用的生命周期函数 componentDidUpdate 等；函数式组件在重新渲染时，整个函数都会被执行；\n\n所以，在 Hook 出现之前，对于上面这些情况我们通常都会编写 class 组件。\n但是 Class 组件存在问题：\n\n复杂组件变得难以理解，难以拆分\n组件复用状态很难\n\nHook 的出现，可以解决上面提到的这些问题，因为 Hook 可以让我们在不编写 class 的情况下使用 state 以及其他的 React 特性。\nHook 的使用场景：\n\n基本可以代替我们之前所有使用 class 组件的地方；\n旧的项目并不需要直接将所有的代码重构为 Hooks，因为它完全向下兼容，你可以渐进式的来使用它；\nHook 只能在函数组件中使用，不能在类组件，或者函数组件之外的地方使用；\n\nHook 就是 JavaScript 函数，这个函数可以帮助你钩入（hook into） React State 以及生命周期等特性；\n两个使用规则：\n\n\n只能在函数最外层调用 Hook。不要在循环、条件判断或者子函数中调用。\n\n\n只能在 React 的函数组件中调用 Hook。\n\n\n在普通函数里面不能使用 Hook，但在自定义 Hook 中可以使用 React 的 Hook。\n自定义 Hook：以 use 开头的函数\n\n\n::: tip\nHook 指的类似于 useState、 useEffect 这样的函数 。\nHooks 是对这类函数的统称。\n:::\nuseState\nimport { memo, useState } from &#039;react&#039;;\n \nfunction App() {\n\tconst [count, setCount] = useState(0);\n\treturn (\n\t\t&lt;div&gt;\n\t\t\t&lt;h1&gt;Count:{count}&lt;/h1&gt;\n\t\t\t&lt;button onClick={e =&gt; setCount(count + 1)}&gt;+&lt;/button&gt;\n\t\t\t&lt;button onClick={e =&gt; setCount(count - 1)}&gt;-&lt;/button&gt;\n\t\t&lt;/div&gt;\n\t);\n}\n \nexport default memo(App);\nuseState 会帮助我们定义一个 state 变量，useState 是一种新方法，它与 class 里面的 this.state 提供的功能完全相同。 一般来说，在函数退出后变量就会”消失”，而 state 中的变量会被 React 保留。\nuseState 接受唯一一个参数，在第一次组件被调用时使用来作为初始化值（如果没有传递参数，那么初始化值为 undefined）。\nuseState 的返回值是一个数组，我们可以通过数组的解构，来完成赋值会非常方便。\nuseEffect\nEffect Hook 可以完成一些类似于 class 中生命周期的功能。\n事实上，类似于网络请求、手动更新 DOM、一些事件的监听，都是 React 更新 DOM 的一些副作用（Side Effects），所以对于完成这些功能的 Hook 被称之为 Effect Hook；\n通过 useEffect 的 Hook，可以告诉 React 需要在渲染完成后需要执行某些操作，如网络请求或者 DOM 操作等；\nuseEffect 要求我们传入一个回调函数，无论是在 React 第一次渲染之后，还是每次更新之后，都会回调这个函数；\nimport { memo, useState, useEffect } from &#039;react&#039;;\n \nfunction App() {\n\tconst [count, setCount] = useState(0);\n\tuseEffect(() =&gt; {\n\t\tdocument.title = count;\n\t});\n\treturn (\n\t\t&lt;div&gt;\n\t\t\t&lt;h1&gt;Count :{count}&lt;/h1&gt;\n\t\t\t&lt;button onClick={e =&gt; setCount(count + 1)}&gt;+&lt;/button&gt;\n\t\t\t&lt;button onClick={e =&gt; setCount(count - 1)}&gt;-&lt;/button&gt;\n\t\t&lt;/div&gt;\n\t);\n}\n \nexport default memo(App);\n在 class 组件的编写过程中，某些副作用的代码，我们需要在 componentWillUnmount 中进行清除，比如事件总线或 Redux 中手动调用 subscribe；\nuseEffect 传入的回调函数本身可以有一个返回值，这个返回值是一个回调函数，会在组件重新渲染或者组件卸载的时候执行。\nimport { useEffect } from &#039;react&#039;;\n \nfunction App() {\n\tuseEffect(() =&gt; {\n\t\tconsole.log(&#039;订阅&#039;);\n\t\treturn () =&gt; {\n\t\t\tconsole.log(&#039;取消订阅&#039;);\n\t\t};\n\t});\n\treturn &lt;div&gt;Count&lt;/div&gt;;\n}\n::: tip 为什么要在 effect 中返回一个函数\n这是 effect 可选的清除机制。\n每个 effect 都可以返回一个清除函数，如此可以将添加和移除订阅的逻辑放在一起； 它们都属于 effect 的一部分；\n:::\n使用 Hook 的其中一个目的就是解决 class 中生命周期经常将很多的逻辑放在一起的问题。\nfunction App() {\n\tuseEffect(() =&gt; {\n\t\t// redux中的数据监听\n\t});\n\tuseEffect(() =&gt; {\n\t\t// eventBus\n\t});\n\treturn &lt;div&gt;Count&lt;/div&gt;;\n}\n当我们使用多个 Effect 时，React 将按照 Effect 声明的顺序依次调用组件中的每一个 Effect。\nEffect 性能优化\n默认情况下，useEffect 的回调函数会在每次渲染时都重新执行，但是这会导致两个问题：\n\n某些代码执行一次即可，比如网络请求、订阅和取消订阅等\n多次执行也会导致一定的性能问题；\n\nuseEffect 实际上有两个参数：\n\n执行的回调函数；\n该 useEffect 在哪些 state 发生变化时，才重新执行；（受谁的影响）\n\nfunction App() {\n\tconst [count, setCount] = useState(0);\n\tuseEffect(() =&gt; {\n\t\t// 当count发生变化时才会重新执行\n\t\tconsole.log(count);\n\t}, [count]);\n\treturn (\n\t\t&lt;div&gt;\n\t\t\t&lt;h1&gt;Count :{count}&lt;/h1&gt;\n\t\t\t&lt;button onClick={e =&gt; setCount(count + 1)}&gt;+&lt;/button&gt;\n\t\t\t&lt;button onClick={e =&gt; setCount(count - 1)}&gt;-&lt;/button&gt;\n\t\t&lt;/div&gt;\n\t);\n}\n::: tip\n如果一个函数我们不希望依赖任何的内容时，即只执行一次，也可以传入一个空的数组 []\nuseEffect(() =&gt; {\n\t// 只执行一次\n\treturn () =&gt; {\n\t\t// 组件卸载时才执行\n\t};\n}, []);\n:::\nuseContext\n在之前的开发中，我们要在组件中使用共享的 Context 有两种方式：\n\n类组件可以通过 类名.contextType = MyContext 方式，在类中获取 context；\n多个 Context 或者在函数式组件中通过 MyContext.Consumer 方式共享 context；\n\n但是多个 Context 共享时的方式会存在大量的嵌套\n&lt;div&gt;\n\t&lt;User.Consumer&gt;\n\t\t{value =&gt; {\n\t\t\treturn (\n\t\t\t\t&lt;div&gt;\n\t\t\t\t\t&lt;Theme.Consumer&gt;{value =&gt; {}}&lt;/Theme.Consumer&gt;\n\t\t\t\t&lt;/div&gt;\n\t\t\t);\n\t\t}}\n\t&lt;/User.Consumer&gt;\n&lt;/div&gt;\n我们可以使用 useContext 来替换这种操作\nfunction App() {\n\tconst user = useContext(UserContext);\n\tconst theme = useContext(ThemeContext);\n\treturn &lt;div&gt;&lt;/div&gt;;\n}\n当组件上层最近的MyContext.Provider更新时，该 Hook 会触发重新渲染，并使用最新传递给 MyContext provider 的 context value 值。\nuseReducer\nuseReducer 是 useState 的一种替代方案。\n如果 state 的处理逻辑比较复杂，我们可以通过 useReducer 来对其进行拆分；或者这次修改的 state 需要依赖之前的 state 时，也可以使用；\nuseCallback\nuseCallback 的目的是为了进行性能的优化。\nfunction App() {\n\tconst [count, setCount] = useState(0);\n\tfunction add() {\n\t\tsetCount(count + 1);\n\t}\n\treturn (\n\t\t&lt;div&gt;\n\t\t\t&lt;h1&gt;Count:{count}&lt;/h1&gt;\n\t\t\t&lt;button onClick={add}&gt;+&lt;/button&gt;\n\t\t&lt;/div&gt;\n\t);\n}\n上面代码中，当 count 更新的时候组件会重新渲染，因此add函数会重新定义。\nfunction App() {\n\tconst [count, setCount] = useState(0);\n\tconst add = useCallback(() =&gt; {\n\t\tsetCount(count + 1);\n\t});\n\treturn (\n\t\t&lt;div&gt;\n\t\t\t&lt;h1&gt;Count:{count}&lt;/h1&gt;\n\t\t\t&lt;button onClick={add}&gt;+&lt;/button&gt;\n\t\t&lt;/div&gt;\n\t);\n}\n为了函数可以重复使用而不用多次定义，我们可以使用useCallback对add函数进行包裹。此时返回的add函数在每次渲染时就不会重新定义，但传入的函数()=&gt;{setCount(count + 1)}仍然会重新定义。这样的写法是没有意义的，因此我们需要传入useCallback的第二个参数。\nconst add = useCallback(() =&gt; {\n\tsetCount(count + 1);\n}, []);\n当我们传入一个空数组[]的时候，说明不依赖任何值，因此返回的add永远是同一个值。\n从上面的代码中可以看出add函数的目标作用是将 count+1，但由于add永远是同一个值，count 只会增加一次后就不再增加了。\n以下面代码为例，foo第一次执行返回的baz1执行后输出 hello，foo第二次执行返回的baz1执行后仍然输出 hello。\nfunction foo(name) {\n\treturn function bar() {\n\t\tconsole.log(name);\n\t};\n}\nconst baz1 = foo(&#039;hello&#039;);\nbaz1(); // hello\nconst baz2 = foo(&#039;world&#039;);\nbaz1(); // hello\nbaz2(); // world\n类似，add第一次定义时 count 的值为 0，因此执行 add等同于执行setCount(0+ 1)，会将 count 修改为 1。此时重新渲染，add第二次定义，但由于useCallback传入的第二个参数是空数组，因此add不变，里面的 count 的值仍然为add第一次定义时候的值 0。即使再次执行add，也是相当于执行setCount(0+ 1)。\n\n简单来说，就是useCallback的依赖不更新的时候，由于闭包会导致传入的函数中的一些变量也不会更新。\n具体可以搜索usecallback 闭包陷阱\n\n因此当useCallback传入的函数中存在一些外面的变量的时候，需要把这些变量添加到依赖中。\nfunction App() {\n\tconst [count, setCount] = useState(0);\n\tconst add = useCallback(() =&gt; {\n\t\tsetCount(count + 1);\n\t}, [count]);\n\treturn (\n\t\t&lt;div&gt;\n\t\t\t&lt;h1&gt;Count:{count}&lt;/h1&gt;\n\t\t\t&lt;button onClick={add}&gt;+&lt;/button&gt;\n\t\t&lt;/div&gt;\n\t);\n}\n通常使用 useCallback 的目的是不希望子组件进行多次渲染，并不是为了函数进行缓存；\nconst Increment = memo(function (props) {\n\tconsole.log(&#039;Increment组件重新渲染&#039;);\n\treturn &lt;button onClick={props.addFun}&gt;Increment:+1&lt;/button&gt;;\n});\n \nfunction App() {\n\tconst [count, setCount] = useState(0);\n\tconst [message, setMessage] = useState(&#039;HHH&#039;);\n \n\tconst add = useCallback(() =&gt; {\n\t\tsetCount(count + 1);\n\t}, [count]);\n \n\treturn (\n\t\t&lt;div&gt;\n\t\t\t&lt;h1&gt;Count:{count}&lt;/h1&gt;\n\t\t\t&lt;Increment addFun={add} /&gt;\n \n\t\t\t&lt;h1&gt;Message:{message}&lt;/h1&gt;\n\t\t\t&lt;button onClick={() =&gt; setMessage(Math.random())}&gt;reverse&lt;/button&gt;\n\t\t&lt;/div&gt;\n\t);\n}\n在上面代码中，如果 add 是普通函数，当修改 Message 内容会导致 Increment 组件重新渲染，因为参数 add 函数重新定义了；如果 add 是 useCallback 返回的函数则不会有这种问题。\n所以当需要将一个函数传递给子组件时，最好使用useCallback进行优化，并将优化后的函数传递给子组件。\n\n假设 Increment 组件中除了 button 还有其它子组件，当 Count 发生变化时，Increment 组件中的其它子组件也会重新渲染，但这是没有必要的。\n为了优化这个问题，就需要当 count 变化时，传入的是同一个函数\nconst Increment = memo(function (props) {\n\tconsole.log(&#039;Increment组件重新渲染&#039;);\n\treturn (\n\t\t&lt;div&gt;\n\t\t\t&lt;button onClick={props.addFun}&gt;Increment:+1&lt;/button&gt;\n\t\t\t{/* 其它子组件 */}\n\t\t&lt;/div&gt;\n\t);\n});\n做法 1：将 count 依赖移除，但会造成闭包陷阱，这一点前面已经介绍过了\nconst add = useCallback(() =&gt; {\n\tsetCount(count + 1);\n}, []);\n做法 2：使用 useRef\nconst [count, setCount] = useState(0);\n \nconst countRef = useRef();\ncountRef.current = count;\n \nconst add = useCallback(() =&gt; {\n\tsetCount(countRef.current + 1);\n}, []);\nuseMemo\nuseMemo 实际的目的也是为了进行性能的优化。\nuseMemo 返回的也是一个记忆的值；在依赖不变的情况下，多次定义的时候，返回的值是相同的；\nfunction calculate(num) {\n\tlet total = 0;\n\tfor (let i = 0; i &lt; num; i++) {\n\t\ttotal += i;\n\t}\n\treturn total;\n}\n \nfunction App() {\n\tconst [count, setCount] = useState(0);\n \n\treturn (\n\t\t&lt;div&gt;\n\t\t\t&lt;h1&gt;计算结果:{calculate(50)}&lt;/h1&gt;\n\t\t\t&lt;h1&gt;count:{count}&lt;/h1&gt;\n\t\t\t&lt;button onClick={e =&gt; setCount(count + 1)}&gt;+&lt;/button&gt;\n\t\t&lt;/div&gt;\n\t);\n}\n当我们点击按钮的时候，calculate 会重新执行一遍，但明显没必要重新执行。我们可以使用useMemo\nfunction App() {\n\tconst [count, setCount] = useState(0);\n \n\tlet result = useMemo(() =&gt; {\n\t\treturn calculate(50);\n\t}, []);\n \n\treturn (\n\t\t&lt;div&gt;\n\t\t\t&lt;h1&gt;计算结果:{result}&lt;/h1&gt;\n\t\t\t&lt;h1&gt;count:{count}&lt;/h1&gt;\n\t\t\t&lt;button onClick={e =&gt; setCount(count + 1)}&gt;+&lt;/button&gt;\n\t\t&lt;/div&gt;\n\t);\n}\n\n进行大量的计算操作，根据是否有必要每次渲染时都重新计算，使用 useMemo 进行性能的优化；\n对子组件传递相同内容的对象时，使用 useMemo 进行性能的优化\n\nuseRef\nuseRef 返回一个 ref 对象，返回的 ref 对象在组件的整个生命周期保持不变。\n获取 DOM 元素\nfunction App() {\n\tconst h1Ref = useRef();\n\treturn (\n\t\t&lt;div&gt;\n\t\t\t&lt;h1 ref={h1Ref}&gt;Hello&lt;/h1&gt;\n\t\t\t&lt;button onClick={e =&gt; console.log(h1Ref.current)}&gt;but&lt;/button&gt;\n\t\t&lt;/div&gt;\n\t);\n}\n使用 ref 保存上一次的某一个值\n\n可以看 usecallback 的最后一部分\n\nuseImperativeHandle\n先来回顾一下 ref 和 forwardRef 的结合使用：通过 forwardRef 可以将 ref 转发到子组件，子组件拿到父组件中创建的 ref，绑定到自己的某一个元素中；\nconst Hello = memo(\n\tforwardRef((props, ref) =&gt; {\n\t\treturn &lt;input type=&#039;text&#039; ref={ref} /&gt;;\n\t})\n);\n \nfunction App() {\n\tconst h1Ref = useRef();\n\tconst inputRef = useRef();\n \n\tfunction handleDom() {\n\t\tconsole.log(inputRef.current);\n\t}\n\treturn (\n\t\t&lt;div&gt;\n\t\t\t&lt;h1 ref={h1Ref}&gt;Hello&lt;/h1&gt;\n\t\t\t&lt;Hello ref={inputRef} /&gt;\n\t\t\t&lt;button onClick={handleDom}&gt;DOM操作&lt;/button&gt;\n\t\t&lt;/div&gt;\n\t);\n}\nforwardRef 的做法本身没有什么问题，但是我们是将子组件的 DOM 直接暴露给了父组件会带来某些不可控的问题；因此我们可以通过 useImperativeHandle 暴露固定的操作。\n通过 useImperativeHandle 的 Hook，将传入的 ref 和 useImperativeHandle 第二个参数返回的对象绑定到了一起；所以在父组件中，使用 inputRef.current 时，实际上使用的是返回的对象；\nconst Hello = memo(\n\tforwardRef((props, ref) =&gt; {\n\t\tconst inputRef = useRef();\n \n\t\t// 子组件对父组件传入的ref进行处理\n\t\tuseImperativeHandle(ref, () =&gt; {\n\t\t\treturn {\n\t\t\t\tfocus() {\n\t\t\t\t\tinputRef.current.focus();\n\t\t\t\t}\n\t\t\t};\n\t\t});\n \n\t\treturn &lt;input type=&#039;text&#039; ref={inputRef} /&gt;;\n\t})\n);\n \nfunction App() {\n\tconst h1Ref = useRef();\n\tconst inputRef = useRef();\n \n\tfunction handleDom() {\n\t\tinputRef.current.focus();\n\t}\n\treturn (\n\t\t&lt;div&gt;\n\t\t\t&lt;h1 ref={h1Ref}&gt;Hello&lt;/h1&gt;\n\t\t\t&lt;Hello ref={inputRef} /&gt;\n\t\t\t&lt;button onClick={handleDom}&gt;DOM操作&lt;/button&gt;\n\t\t&lt;/div&gt;\n\t);\n}\nuseLayoutEffect\nuseLayoutEffect 看起来和 useEffect 非常的相似，事实上他们也只有一点区别而已：\n\nuseEffect 会在渲染的内容更新到 DOM 上后执行，不会阻塞 DOM 的更新；\nuseLayoutEffect 会在渲染的内容更新到 DOM 上之前执行，会阻塞 DOM 的更新；\n\nfunction App() {\n\tuseEffect(() =&gt; {\n\t\tconsole.log(&#039;useEffect&#039;); // 第三步\n\t});\n\tuseLayoutEffect(() =&gt; {\n\t\tconsole.log(&#039;useLayoutEffect&#039;); // 第二步\n\t});\n\tconsole.log(&#039;render&#039;); // 第一步\n\treturn &lt;div&gt;Hello&lt;/div&gt;;\n}\n自定义 Hook\n打印生命周期\nfunction useLogLife(name) {\n\tuseEffect(() =&gt; {\n\t\tconsole.log(name + &#039;组件创建&#039;);\n\t\treturn () =&gt; {\n\t\t\tconsole.log(name + &#039;组件销毁&#039;);\n\t\t};\n\t}, []);\n}\n \nconst Home = memo(() =&gt; {\n\tuseLogLife(&#039;Home&#039;);\n\treturn &lt;div&gt;Home&lt;/div&gt;;\n});\n \nconst About = memo(() =&gt; {\n\tuseLogLife(&#039;About&#039;);\n\treturn &lt;div&gt;About&lt;/div&gt;;\n});\n \nconst App = memo(() =&gt; {\n\tuseLogLife(&#039;APP&#039;);\n\treturn (\n\t\t&lt;div&gt;\n\t\t\tApp\n\t\t\t&lt;Home /&gt;\n\t\t\t&lt;About /&gt;\n\t\t&lt;/div&gt;\n\t);\n});\n获取 Context\nimport { UserContext, TokenContext } from &#039;./context&#039;;\n \nfunction useUserToken() {\n\tconst user = useContext(UserContext);\n\tconst token = useContext(TokenContext);\n\treturn [user, token];\n}\nconst App = memo(() =&gt; {\n\tconst [user, token] = useUserToken();\n\treturn &lt;div&gt;App&lt;/div&gt;;\n});\n获取滚动位置\nfunction useScrollPosition() {\n\tconst [scrollX, setScrollX] = useState(0);\n\tconst [scrollY, setScrollY] = useState(0);\n\tuseEffect(() =&gt; {\n\t\tfunction handle() {\n\t\t\tsetScrollX(window.scrollX);\n\t\t\tsetScrollY(window.scrollY);\n\t\t}\n\t\twindow.addEventListener(&#039;scroll&#039;, handle);\n\t\treturn () =&gt; {\n\t\t\twindow.removeEventListener(&#039;scroll&#039;, handle);\n\t\t};\n\t}, []);\n\treturn [scrollX, scrollY];\n}\n \nconst App = memo(() =&gt; {\n\tconst [scrollX, scrollY] = useScrollPosition();\n\treturn &lt;div&gt;App&lt;/div&gt;;\n});\nlocalStorage 数据存储\nfunction useLocalStorage(key) {\n\tconst [data, setData] = useState(() =&gt; {\n\t\tconst item = localStorage.getItem(key);\n\t\treturn item ? JSON.parse(item) : &#039;&#039;;\n\t});\n\tuseEffect(() =&gt; {\n\t\tlocalStorage.setItem(key, JSON.stringify(data));\n\t}, []);\n\treturn [data, setData];\n}\n \nconst App = memo(() =&gt; {\n\tconst [token, setToken] = useLocalStorage(&#039;token&#039;);\n\treturn &lt;div&gt;App&lt;/div&gt;;\n});\nuseSelector，useDispatch\n在之前的 redux 开发中，为了让组件和 redux 结合起来，我们使用了 react-redux 中的 connect。但是这种方式必须使用高阶函数结合返回的高阶组件；并且必须编写：mapStateToProps 和 mapDispatchToProps 映射的函。connect(mapStateToProps,mapDispatchToProps)(APP)\n在 Redux7.1 开始，提供了 Hook 的方式，再也不需要编写 connect 以及对应的映射函数了。\nimport { configureStore, createSlice } from &#039;@reduxjs/toolkit&#039;;\n \nconst counterSlice = createSlice({\n\tname: &#039;counter&#039;,\n\tinitialState: {\n\t\tcount: 99\n\t},\n\treducers: {\n\t\taddAction(state, { payload }) {\n\t\t\tstate.count += payload;\n\t\t}\n\t}\n});\n \nconst store = configureStore({\n\treducer: {\n\t\tcounter: counterSlice.reducer\n\t}\n});\n \nexport const { addAction } = counterSlice.actions;\n \nexport default store;\nimport store from &#039;./store&#039;;\nimport { Provider } from &#039;react-redux&#039;;\n \nconst root = ReactDOM.createRoot(document.getElementById(&#039;root&#039;));\nroot.render(\n\t&lt;Provider store={store}&gt;\n\t\t&lt;App /&gt;\n\t&lt;/Provider&gt;\n);\nimport { useSelector, useDispatch, shallowEqual } from &#039;react-redux&#039;;\nimport { addAction } from &#039;./store&#039;;\n \nconst App = memo(() =&gt; {\n\tconst { count } = useSelector(\n\t\tstate =&gt; ({\n\t\t\tcount: state.counter.count\n\t\t}),\n\t\tshallowEqual\n\t);\n \n\tconst dispatch = useDispatch();\n\tfunction add(num) {\n\t\tdispatch(addAction(num));\n\t}\n\treturn &lt;div&gt;App&lt;/div&gt;;\n});\nuseSelector 的作用是将 state 映射到组件中：\n\n参数一：将 state 映射到需要的数据中；\n参数二：可以进行比较来决定是否组件重新渲染，一般直接使用shallowEqual即可；\n\nuseId\n::: info SSR, CSR\n\n\nSSR（Server Side Rendering，服务端渲染）\n指的是页面在服务器端已经生成了完成的 HTML 页面结构，不需要浏览器解析。 早期的服务端渲染包括 PHP、JSP、ASP 等方式。\n\n\nCSR（Client Side Rendering，客户端渲染）\n我们开发的 SPA 页面通常依赖的就是客户端渲染。\n\n\n:::\n::: info SSR 同构应用\n一套代码既可以在服务端运行又可以在客户端运行，这就是同构应用。\n同构是一种 SSR 的形态，是现代 SSR 的一种表现形式。\n\n\n:::\n::: info hydration\n在进行 SSR 时，我们的页面会呈现为 HTML。但仅 HTML 不足以使页面具有交互性。例如，浏览器端 JavaScript 为零的页面不能是交互式的（没有 JavaScript 事件处理程序来响应用户操作，例如单击按钮）。\n为了使我们的页面具有交互性，除了在 Node.js 中将页面呈现为 HTML 之外，我们的 UI 框架（Vue/React/…）还在浏览器中加载和呈现页面。（它创建页面的内部表示，然后将内部表示映射到我们在 Node.js 中呈现的 HTML 的 DOM 元素。）\n这个过程称为 hydration。\nhydration 是同构的某一过程。\n:::\nuseId 是一个用于生成横跨服务端和客户端的稳定的唯一 ID 的同时避免 hydration 不匹配的 hook。\n\nuseId 是用于 react 的同构应用开发的，前端的 SPA 页面并不需要使用它；\nuseId 可以保证应用程序在客户端和服务器端生成唯一的 ID，这样可以有效的避免通过一些手段生成的 id 不一致，造成 hydration mismatch；\n\nuseTransition\n官方解释：返回一个状态值表示过渡任务的等待状态，以及一个启动该过渡任务的函数。\n告诉 react 对于某部分任务的更新优先级较低，可以稍后进行更新。\n以下面代码为例：\n通过 faker 生成一些随机人名，在页面进行展示；当输入框用来搜索人名\nimport React, { memo, useState } from &#039;react&#039;;\nimport { faker } from &#039;@faker-js/faker&#039;;\n \nconst names = [];\nfor (let i = 0; i &lt; 10000; i++) {\n\tnames[i] = faker.person.fullName();\n}\n \nconst App = memo(() =&gt; {\n\tconst [showNames, setShowNames] = useState(names);\n\tfunction change(event) {\n\t\tsetShowNames(names.filter(item =&gt; item.includes(event.target.value)));\n\t}\n\treturn (\n\t\t&lt;div&gt;\n\t\t\t&lt;input type=&#039;text&#039; onChange={change} /&gt;\n\t\t\t{showNames.map((name, index) =&gt; {\n\t\t\t\treturn &lt;li key={index}&gt;{name}&lt;/li&gt;;\n\t\t\t})}\n\t\t&lt;/div&gt;\n\t);\n});\n可以通过控制台降低 CPU 的速度\n\n此时可以明显的看到，当输入框输入内容时，不是先显示输入的内容而是会等待change函数完成后输入框才显示内容。\n正确的做法应该是立即显示输入框的内容，其它函数执行慢可以添加 loading 效果，而不是直接阻塞输入框显示内容。\nconst names = [];\nfor (let i = 0; i &lt; 1000; i++) {\n\tnames[i] = faker.person.fullName();\n}\n \nconst App = memo(() =&gt; {\n\tconst [pending, startTransition] = useTransition();\n \n\tconst [showNames, setShowNames] = useState(names);\n\tfunction change(event) {\n\t\tstartTransition(() =&gt; {\n\t\t\tsetShowNames(names.filter(item =&gt; item.includes(event.target.value)));\n\t\t});\n\t}\n\treturn (\n\t\t&lt;div&gt;\n\t\t\t&lt;input type=&#039;text&#039; onChange={change} /&gt;\n\t\t\t&lt;h2&gt;用户列表{pending &amp;&amp; &#039;：loading&#039;}&lt;/h2&gt;\n\t\t\t&lt;ul&gt;\n\t\t\t\t{showNames.map((name, index) =&gt; {\n\t\t\t\t\treturn &lt;li key={index}&gt;{name}&lt;/li&gt;;\n\t\t\t\t})}\n\t\t\t&lt;/ul&gt;\n\t\t&lt;/div&gt;\n\t);\n});\nuseDeferredValue\n官方解释：useDeferredValue 接受一个值，并返回该值的新副本，该副本将推迟到更紧急地更新之后。\nuseDeferredValue 的作用和 useTransition 是一样的效果，可以让我们的更新延迟。\nconst names = [];\nfor (let i = 0; i &lt; 100; i++) {\n\tnames[i] = faker.person.fullName();\n}\n \nconst App = memo(() =&gt; {\n\tconst [showNames, setShowNames] = useState(names);\n\tconst deferredShowName = useDeferredValue(showNames);\n \n\tfunction change(event) {\n\t\tsetShowNames(names.filter(item =&gt; item.includes(event.target.value)));\n\t}\n\treturn (\n\t\t&lt;div&gt;\n\t\t\t&lt;input type=&#039;text&#039; onChange={change} /&gt;\n\t\t\t&lt;ul&gt;\n\t\t\t\t{deferredShowName.map((name, index) =&gt; {\n\t\t\t\t\treturn &lt;li key={index}&gt;{name}&lt;/li&gt;;\n\t\t\t\t})}\n\t\t\t&lt;/ul&gt;\n\t\t&lt;/div&gt;\n\t);\n});"},"浏览器/rspress/LaTeX无法使用$$语法":{"title":"LaTeX无法使用$$语法","links":[],"tags":["rspress","博客"],"content":"LaTeX无法使用$$语法\n现象\n在使用 rspress-plugin-katex 插件时无法使用以下语法\n$$\n a \\times b\n$$\n报错：MDX compile error: Cannot read properties of undefined (reading &#039;mathFlowInside&#039;)\n\n原因\n主要原因是remark-math的版本过高，移除了对$$语法的支持。\n\n解决方法\n方法 1：降低 remark-math 版本，重写插件\n\n\n手动安装低版本remark-math\nnpm i remark-math@5\n\n\n复制rspress-plugin-katex源码\nplugin.tsimport { PresetConfigMutator } from &#039;rspress-plugin-devkit&#039;;\n \nimport remarkMath, { Options as RemarkMathOptions } from &#039;remark-math&#039;;\nimport rehypeKatex, { Options as RehypeKatexOptions } from &#039;rehype-katex&#039;;\n \nimport type { RspressPlugin } from &#039;@rspress/shared&#039;;\n \nexport interface RspressPluginKatexOptions extends RemarkMathOptions, RehypeKatexOptions {}\n \nexport function rspressPluginKatex(options: RspressPluginKatexOptions = {}): RspressPlugin{\n\tconst katexCss = require.resolve(&#039;katex/dist/katex.min.css&#039;);\n \n\treturn {\n\t\tname: &#039;rspress-plugin-katex&#039;,\n\t\tconfig(config, utils, isProd) {\n\t\t\treturn new PresetConfigMutator(config).disableMdxRs().toConfig();\n\t\t},\n\t\tglobalStyles: katexCss,\n\t\tmarkdown: {\n\t\t\tremarkPlugins: [[remarkMath, options]],\n\t\t\t// @ts-expect-error\n\t\t\trehypePlugins: [[rehypeKatex, options]]\n\t\t}\n\t};\n}\n\n\n导入组件\nrspress.config.tsimport { rspressPluginKatex } from &#039;./plugins.ts&#039;;\n \nexport default defineConfig({\n\tplugin: [rspressPluginKatex()]\n});\n\n\n方法 2：更改语法\n$$\n...\n$$\n更改为\n```math\n...\n```"},"浏览器/rspress/自动生成侧边栏":{"title":"rspress 自动生成侧边栏","links":[],"tags":["rspress","博客"],"content":"自动生成侧边栏\nrspress.config.tsimport { join } from &#039;path&#039;;\nimport { readdirSync, statSync } from &#039;fs&#039;;\n \nexport default defineConfig({\n\tthemeConfig: {\n\t\tsidebar: {\n\t\t\t&#039;/&#039;: [\n\t\t\t\t{\n\t\t\t\t\ttext: &#039;首页&#039;,\n\t\t\t\t\tlink: &#039;index&#039;\n\t\t\t\t},\n\t\t\t\t...getDirStructure(join(__dirname, &#039;docs&#039;), &#039;&#039;)\n\t\t\t]\n\t\t}\n\t}\n});\n \nfunction getDirStructure(dirPath: string, relativePath: string) {\n\tconst result: any[] = [];\n\tconst items = readdirSync(dirPath);\n \n\tfor (const item of items) {\n\t\tconst fullPath = join(dirPath, item);\n\t\tconst stat = statSync(fullPath);\n \n\t\tif (item === &#039;assets&#039; || item === &#039;public&#039;) continue;\n \n\t\tconst index = parseInt(item.split(&#039;_&#039;)[0]);\n\t\tif (stat.isDirectory()) {\n\t\t\tif (index) {\n\t\t\t\tresult[index] = {\n\t\t\t\t\ttext: item.split(&#039;_&#039;)[1],\n\t\t\t\t\tcollapsed: true,\n\t\t\t\t\titems: getDirStructure(fullPath, join(relativePath, item))\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tresult.push({\n\t\t\t\t\ttext: item,\n\t\t\t\t\tcollapsed: true,\n\t\t\t\t\titems: getDirStructure(fullPath, join(relativePath, item))\n\t\t\t\t});\n\t\t\t}\n\t\t} else if (item.includes(&#039;.md&#039;) &amp;&amp; item !== &#039;index.md&#039;) {\n\t\t\tconst link = `${relativePath}/${item}`.replace(/\\\\/g, &#039;/&#039;).replace(&#039;.md&#039;, &#039;&#039;);\n\t\t\tif (index) {\n\t\t\t\tresult[index] = link;\n\t\t\t} else {\n\t\t\t\tresult.push(link);\n\t\t\t}\n\t\t}\n\t}\n \n\treturn result.filter(item =&gt; Boolean(item));\n}"},"编程语言/Java/JavaWeb复习":{"title":"JavaWeb复习","links":[],"tags":[],"content":"Web是基于客户/服务器（C/S）的一种体系结构。主要由三部分构成：\n\nWeb服务器：提供Web页面和其他资源。\nWeb客户端：运行在客户端的一种访问Web资源的软件。\n通信协议：客户端和服务器之间采用HTTP协议进行通信。\n\nHTTP：超文本传输协议（Hypertext Transfer Protocol）是Web使用的协议，一个基于请求-响应的无状态的协议，详细规定了Web客户与服务器之间如何通信。\n\nURL、URI、URN\nWeb服务器上的资源是通过URL标识的。\nURL（Uniform Resource Locator）称为统一资源定位器，指向Internet上位于某个位置的某个HTML文件、图像文件和程序等资源。\nURL通常由4部分组成：\n\n协议名称\n所在主机的DNS名或IP地址\n可选的端口号\n资源的名称\n\n\nURI（Uniform Resource Identifier）称为统一资源标识符，是以特定语法标识一个资源的字符串。\n由模式和模式特有的部分组成，它们之间用冒号隔开，一般格式为：schema:schema-specific-part。常见模式包括：file、ftp、http、mail等。\n\nURN（Uniform Resource Name）称为统一资源名称，唯一标识一个资源但不指定如何访问资源。\n一般形式为：urn：命名空间：资源名，例如：urn:ISBN:1-930110-59-6，它唯一地标识某一本书，但它不是URL，因为它没有指定如何检索该书。\nHTML常用标签\nHTML，超文本标记语言（HyperText Markup Language）是一种用来制作超文本文档的简单标记语言。\nHTML常用标签：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n标签作用&lt;html&gt;&lt;/html&gt;限定文档的开始点和结束点&lt;head&gt;定义文档的头部。&lt;body&gt;定义文档的主体。&lt;meta&gt;提供有关页面的元信息。&lt;title&gt; 定义文档的标题。&lt;p&gt;定义段落&lt;br&gt; 插入一个简单的换行符&lt;form&gt; 创建 HTML 表单\nXML称为可扩展标记语言，相对HTML，XML具有如下一些特点：\n\n不是标记语言，不包含任何标记，允许用户自己定义标记和属性。\n侧重于对文档内容的描述，而不是文档的显示。\n对数据的描述和数据本身都包含在文档中，数据具有很大的灵活性。\n数据与显示分离。\n\n动态文档技术\nWeb文档是一种重要的Web资源，通常也称为Web页面，可分为静态文档和动态文档。\n动态文档是指文档的内容可根据需要动态生成。动态文档技术又分为服务器端动态文档技术和客户端动态文档技术。\n在服务器端动态生成Web页面有多种方法：\n\n\nCGI技术\n\n\n\n服务器扩展技术（Servlet技术）\n使服务器支持单独的可执行模块，当服务器启动时该模块就装入内存并只初始化一次。然后，就可以通过已经驻留在内存的模块副本（线程）为每个请求提供服务。这些独立的可执行的模块称为服务器扩展模块。\n在Java平台上，服务器扩展模块叫做servlet容器或Web容器，负责处理客户请求、把请求传送给Servlet并把结果返回给客户。\n\n\n动态Web页面技术（JSP技术）\n在Web页面中嵌入某种语言的脚本，然后让服务器来执行这些脚本以便生成最终发送给客户的页面。\n比如：ASP.NET，PHP，JSP\n\n\n客户端动态文档技术是在HTML页面中嵌入脚本，这些脚本是在客户机上被执行的而不是在服务器上执行的。通过&lt;script&gt;标签来使用这样的脚本。\n两者的区别是：\n\n服务器端动态文档技术的页面，是在服务器端执行的。\n客户端动态文档技术的页面，是在客户端执行的。\n\nTomcat\nTomcat安装目录的webapps目录是所有Web应用程序的根目录。\nServlet\nServlet接口是Servlet API中的基本接口，每个Servlet必须直接或间接实现该接口。\nHttpServlet抽象类用来实现针对HTTP协议的Servlet，在编写Servlet时，需要继承Httpservlet类。\n在HttpServlet类中增加了一个新的service()方法，格式如下：\nvoid service(HttpServletRequest request, HttpServletResponse response)\n在HttpServlet中针对不同的HTTP请求方法定义了不同的处理方法，如：\n\n\n处理GET请求的doGet()格式如下：\nvoid doGet(HttpServletRequest request, HttpServletResponse response)  \n\n\n如处理POST请求的方法是doPost()：\n\n\nServlet生命周期：Servlet 从创建到销毁的整个过程。\n\n\n加载到内存：使用Class.forName()方法\n实例化：调用HelloServlet()构造方法\n初始化：调用init(ServletConfig config)方法\n提供服务：调用service()方法，根据HTTP类型决定调用doGet()或doPost()方法\n销毁：调用destroy()构造方法\n\n\n常用的HTTP请求方法：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n特征GET方法POST方法资源类型静态的或动态的动态的数据类型文本文本或二进制数据数据量一般不超过255个字符没有限制可见性数据是URL的一部分，在浏览器的地址栏中对用户可见数据不是URL的一部分而是作为请求的消息体发送，在浏览器的地址栏中对用户不可见数据缓存数据可在浏览器的URL历史中缓存数据不能在浏览器的URL历史中缓存\n常用的发送HTTP请求方法：\n\n用户在浏览器的地址栏中输入URL并按回车键。\n用户在HTML页面中点击超链接。\n用户在HTML页面中填写表单并提交。\n\n在Httpservlet中处理这些请求对应的方法：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHTTP方法HttpServlet方法GETdoGet()POSTdoPost()HEADdoHead()PUTdoPut()DELETEdoDelete()OPTIONSdoOptions()TRACEdoTrace()\n\n检索请求参数\n请求参数是随请求一起发送到服务器的数据，它以“名/值”对的形式发送。\n\nPOST请求，参数在数据区。\nGET请求，参数附加在URI后面。例如：有一个URL，example.com，问号后面的内容称为查询串，代表请求参数。\n\n使用HttpServletRequest中定义的方法检索这些参数：\n\nString getParameter(String name)：获取参数，返回指定参数名的值\nString[] getParameterValues()：获取所有参数的值\n\n\n请求转发\n\n\n通过请求对象的getRequestDispatcher()得到RequestDispatcher对象，该对象称为请求转发器对象。\n格式：RequestDispatcher getRequestDispatcher(String path)。\n\n\n调用RequestDispatcher对象的forward()方法。\n格式：void forward(ServletRequest request, ServletResponse response)。\n\n\n路径以/开头，表示相对当前应用程序根目录；不以/开头，表示相对当前资源所在的目录。\n请求转发的特点：\n\n请求转发是服务器端控制权的转移，浏览器并不知情。\n使用请求转发，在客户的浏览器地址栏中不会显示转发后的资源地址。\n使用请求转发可以共享请求作用域中的数据。\n\n\n使用请求对象存储数据\n请求对象是一个作用域对象，可以在其上存储属性实现数据共享。属性包括属性名和属性值，属性名是一个字符串，属性值是一个对象。\n有关属性存储的方法有4个，定义在HttpServletRequest接口中。格式如下：\n\npublic void setAttribute(String name, Object obj)\npublic Object getAttribute(String name)\npublic void removeAttribute(String name)\npublic Enumeration getAttributeNames()\n\n\nSerevletResponse向客户发送文本数据\n调用响应对象的getWriter()方法，返回一个PrintWriter对象用于向客户发送文本数据。\n在发送响应数据之前还需通过响应对象的setContentType()设置响应的内容类型。\n\n实现响应重定向\n响应重定向：Servlet向浏览器发送一个Location响应头，告诉浏览器访问其他资源。\n响应重定向是通过响应对象的sendRedirect()实现，格式为：public void sendRedirect(String location)\n\n响应重定向与请求转发的比较：\n\n使用请求转发，浏览器地址栏不会显示转发后的地址。\n使用响应重定向，浏览器的地址栏会显示转发后的地址。\n请求转发可以共享请求作用域中的数据；响应重定向可以共享会话作用域中的数据。\n\n\n\n部署描述文件 web.xml\n用于对应用程序进行配置，初始化Web应用中所包含的组件，如Servlet等。\n\n&lt;servlet&gt;元素\n&lt;servlet&gt;元素为Web应用程序定义一个Servlet。子元素包括：\n\n\n&lt;servlet-name&gt;元素：用来定义Servlet名称，必选。\n\n\n&lt;servlet-class&gt;元素：指定Servlet类的完整名称，即需要带包的名称。\n\n\n&lt;init-param&gt;元素：定义向Servlet传递的初始化参数。\n\n\n&lt;load-on-startup&gt;元素：指定是否在Web应用程序启动时载入该Servlet。\n\n\n&lt;servlet-mapping&gt;元素：定义一个映射，它指定哪个URL模式被该Servlet处理。包含：\n\n&lt;servlet-name&gt;元素应该是使用&lt;servlet&gt;元素定义的Servlet名。\n&lt;url-pattern&gt;包含要与该Servlet关联的模式字符串。\n\n&lt;servlet-mapping&gt;\n    &lt;servlet-name&gt;helloServlet&lt;/servlet-name&gt;\n    &lt;url-pattern&gt;/helloServlet/hello/*&lt;/url-pattern&gt;\n&lt;/servlet-mapping&gt;\n\n\n\nURL请求的组成有三部分：协议与主机名、请求URI（上下文路径、Servlet路径、路径信息）、查询串\n\n@WebServlet和@WebInitParam注解，在应用程序启动时被Web容器处理，容器根据具体的属性配置将相应的类部署为Servlet。\n// 例如：为HelloServlet添加的注解\n@WebServlet(name=&quot;helloServlet&quot;,urlPatterns={&quot;/hello-servlet&quot;})\n@WebServlet注解包含多个属性，它们与web.xml中的对应元素等价。\n\nname属性：指定Servlet名称，等价于web.xml中的&lt;servlet-name&gt;元素。\nurlPatterns属性：指定一组URL映射模式，该元素等价于web.xml文件中的&lt;url-pattern&gt;元素。\nloadOnStartup属性：指定该Servlet的加载顺序，等价于web.xml文件中的&lt;load-on-startup&gt;元素。\ninitParams属性：指定Servlet的一组初始化参数，等价于&lt;init-param&gt;元素。\n\n@WebInitParam注解通常配合@WebServlet使用。\n\nname属性，指定初始化参数名，等价于&lt;param-name&gt;元素。\nvalue属性，指定初始化参数值，等价于&lt;param-value&gt;元素。\n\n\nServletConfig称为Servlet配置对象。使用该对象可以获得Servlet初始化参数、Servlet名称、ServletContext对象等。\nweb容器在创建servlet实例对象时，会自动将初始化参数封装到ServletConfig对象中，并在调用servlet的init()方法时，将ServletConfig 对象传递给servlet。\n得到ServletConfig接口对象有两种方法：\n\n覆盖Servlet的init(ServletConfig config)，然后把容器创建的ServletConfig对象保存到一个成员变量中。\n\nServletConfig config = null;\npublic void init(ServletConfig config){\n\tsuper.init(config); //调用超类的init()\n  this.config = config; \n}\n\n在Servlet中直接使用getServletConfig()获得ServletConfig对象，如下所示：\n\nServletConfig config = getServletConfig();\nServletConfig接口定义了下面4个方法：\n\nString getInitParameter(String name) \nEnumeration getInitParameterNames() \nServletContext getServletContext() \nString getServletName()\n\n\nWeb容器在启动时会加载每个Web应用程序，并为每个Web应用程序创建一个唯一的ServletContext实例对象，该对象称为Servlet上下文对象。\n使用ServletContext对象获得Web应用程序的初始化参数、它是重要的作用域对象，可实现数据共享、获得Web容器的版本等信息。\n有两种方法得到ServletContext引用：\n\n\n直接调用getServletContext()\nServletContext context = getServletContext();\n\n\n先得到ServletConfig，再调用它的getServletContext()\n ServletContext context = getServletConfig().getServletContext(); \n\n\n应用程序初始化参数应该在web.xml文件中使用&lt;context-param&gt;元素定义，\n&lt;web-app&gt;\n  &lt;context-param&gt;\n   &lt;param-name&gt;name&lt;/param-name&gt;\n   &lt;param-value&gt;value&lt;/param-value&gt;\n &lt;/context-param&gt;\n  &lt;servlet&gt;\n  // ...\n  &lt;/servlet&gt;\n&lt;/web-app&gt;\n使用ServletContext接口中的以下方法检索应用程序的初始化参数：\nString getInitParameter(String name);\nEnumeration getInitParameterNames();\nServlet上下文初始化参数和Servlet初始化参数区别：\n\nServlet上下文初始化参数是属于Web应用程序的，可以被Web应用程序的所有的Servlet和JSP页面访问。\nServlet初始化参数是属于定义它们的Servlet的，不能被Web应用程序的其他组件访问。\n\nServletContext是一个作用域对象，使用它可以存储数据，它的作用域是整个应用程序。\n\n\nvoid setAttribute(String name, Object object)\n\n\nObject getAttribute(String name)\n\n\nEnumeration getAttributeNames()\n\n\nvoid removeAttribute(String name)\n\n\n使用ServletContext接口的RequestDispatcher getRequestDispatcher(String path)也可以获得RequestDispatcher对象，实现请求转发。\n\n\n                  \n                  Tip\n                  \n                \n\n参数path表示资源路径，它必须以/开头，表示相对于Web应用的文档根目录。如果不能返回转发器对象，将返回null。\n\n\n使用ServletContext对象存储数据，与使用请求对象HttpServletRequest存储数据有什么区别：\n\n作用域：\n\nHttpServletRequest：它的作用域仅限于当前HTTP请求。当请求处理完成并响应发送给客户端后，该请求对象及其关联的数据将被销毁。\nServletContext：它代表整个Web应用程序的上下文，其作用域是全局的，对部署在同一Web应用中的所有Servlet、JSP页面都是可见的。\n\n\n生命周期：\n\nHttpServletRequest：与单个HTTP请求的生命周期相同，一旦请求结束，所绑定的数据也随之消失。\nServletContext：从Web应用程序启动直到服务器关闭，或者Web应用被卸载为止，其生命周期是最长的。\n\n\n\n\n&lt;html&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;title&gt;登录页面&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;form action=&quot;user-login&quot; method=&quot;post&quot;&gt;\n    &lt;fieldset&gt;\n      &lt;legend&gt;用户登录&lt;/legend&gt;\n      &lt;p&gt;\n        &lt;label&gt;用户名: &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;\n        &lt;/label&gt;\n      &lt;/p&gt;\n      &lt;p&gt;\n        &lt;label&gt;密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;\n        &lt;/label&gt;\n      &lt;/p&gt;\n      &lt;p&gt;\n        &lt;label&gt;&lt;input type=&quot;submit&quot; value=&quot;登录&quot; /&gt;\n          &lt;input type=&quot;reset&quot; value=&quot;取消&quot; /&gt;\n        &lt;/label&gt;\n      &lt;/p&gt;\n    &lt;/fieldset&gt;\n  &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n@WebServlet(name = &quot;LoginServlet&quot;, urlPatterns = {&quot;/user-login&quot;})\npublic class LoginServlet extends HttpServlet {\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String username = request.getParameter(&quot;username&quot;);\n        String password = request.getParameter(&quot;password&quot;);\n        response.setContentType(&quot;text/html;charset=UTF-8&quot;);\n        PrintWriter out = response.getWriter();\n        out.println(&quot;&lt;!DOCTYPE html&gt;&quot;);\n        out.println(&quot;&lt;html&gt;&lt;body&gt;&quot;);\n        if (&quot;admin&quot;.equals(username) &amp;&amp; &quot;admin&quot;.equals(password)) {\n            out.println(&quot;登录成功！欢迎您， &quot; + username);\n        } else {\n            out.println(&quot;对不起！您的用户名或密码不正确．&quot;);\n        }\n        out.println(&quot;&lt;/body&gt;&lt;/html&gt;&quot;);\n    }\n}\nJSP\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nJSP页面元素简要说明标签语法声明(JSP脚本元素)声明变量与定义方法&lt;%!  Java 声明   %&gt;小脚本(JSP脚本元素)执行业务逻辑的Java代码&lt;%  Java 代码    %&gt;表达式(JSP脚本元素)用于在JSP页面输出表达式的值&lt;%=  表达式    %&gt;指令指定转换时向容器发出的指令&lt;%@ 指令    %&gt;动作（标签）向容器提供请求时的指令&lt;jsp:标签名   /&gt;EL表达式JSP  2.0引进的表达式语言${applicationScope.email}注释用于文档注释&lt;%--  任何文本    --%&gt;\n\nJSP声明：可以包含任意数量的合法的Java声明语句。\nJSP小脚本：可以包含任意数量Java语句。在小脚本中的代码必须是合法的Java语言代码。\nJSP表达式：作为Java语言表达式的占位符。在百分号和等号之间不能有空格，而且表达式不能以分号结束。\n\n\nJSP页面生命周期\n!\n\n转换阶段：Web容器读取JSP页面对其解析，并将其转换成Java源代码。\n编译阶段：在Web容器调用Java编译器javac编译该文件。\n类的加载与实例化：Web容器调用类加载程序将页面实现类加载到内存中。\n调用jspInit()：Web容器调用jspInit()初始化Servlet实例。该方法是在任何其他方法调用之前调用的，并在页面生命期内只调用一次。\n调用_jspService()：对该页面的每次请求，容器都调用一次_jspService()，并给它传递请求和响应对象。\n调用jspDestroy()：当容器决定停止该实例提供服务时，它将调jspDestroy()，这是在Servlet实例上调用的最后一个方法，它主要用来清理jspInit()获得的资源。\n\n\n\n                  \n                  Tip\n                  \n                \n\n\n一般不需要实现jspInit()和jspDestroy() ，因为它们已经由基类实现了。但可以根据需要使用JSP的声明标签&lt;%! … %&gt;覆盖这两个方法。\n不能覆盖_jspService()，因为该方法由Web容器自动产生。\n\n\n\n\n页面转换\n容器根据下面规则将JSP页面中的元素转换成Servlet代码：\n\n所有JSP声明都转换成页面实现类的成员，它们被原样拷贝。\n所有JSP小脚本都转换成页面实现类的_jspService()的一部分，它们也被原样拷贝。小脚本中声明的变量转换成_jspService()的局部变量。小脚本中的语句转换成_jspService()中的语句。\n所有的JSP表达式都转换成为_jspService()的一部分，表达式的值使用out.print()语句输出。\n有些指令在转换阶段产生Java代码。\n所有的JSP动作都通过调用针对厂商的类来替换。\n所有表达式语言EL通过计算后使用out.write()语句输出。\n所有模板文本都成为_jspService()的一部分，模板内容使用out.write()语句输出。\n所有的JSP注释都被忽略。\n\n\nJSP声明中定义的变量和小脚本中定义的变量的不同：\n\n\n出现顺序：\n\n在JSP声明中定义的变量和方法都转换成页面实现类的成员，因此它们在页面中出现的顺序无关紧要。\n小脚本被转换成页面实现类的_jspService()方法的一部分，因此小脚本中声明的变量成为该方法的局部变量，故它们出现的顺序很重要。\n\n\n\n初始化：\n\n\nJSP声明中定义的变量被自动初始化为默认值。\n在容器实例化Servlet时被创建的并只被初始化一次，因此在JSP声明中声明的变量在多个请求中一直保持它们的值。\n\n\n小脚本中定义的变量局部变量使用之前必须明确赋值。\n对每个请求都创建和销毁一次，因此在小脚本中声明的变量在多个请求中不保持其值，而是在JSP容器每次调用_jspService()时被重新初始化。\n\n\n\n\n\nJSP组件包含：在JSP页面中包含另一个Web组件的内容或输出。\n\n\n静态包含：include指令\n将另一个文件的内容包含到当前JSP页面中，用include指令完成，语法为：&lt;%@ include file=&quot;relativeURL&quot; %&gt;。\n文件路径以/开头，是相对于Web应用程序文档根目录的路径，路径不以/开头，相对于当前JSP文件的路径。\n限制：\n\n在转换阶段不进行任何处理\n不能通过file属性值向被包含的页面传递任何参数\n被包含的页面可能不能单独编译\n\n\n\n动态包含：include动作\n在请求时将另一个页面的输出包含到主页面的输出中。该动作的格式如下：&lt;jsp:include page=&quot;relativeURL&quot; flush=&quot;true | false&quot; /&gt;\n&lt;jsp:include page=“copyright.jsp&quot; /&gt;\n// 或者                             \n&lt;%! String pageURL = &quot;copyright.jsp&quot;; %&gt;\n&lt;jsp:include page=&quot;&lt;%= pageURL %&gt;&quot; /&gt;                         \n\n\n他们之间有什么区别？\n\nJSP作用域对象\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n作用域名对应的对象作用域范围应用作用域application在整个Web应用程序有效会话作用域session在一个用户会话范围内有效请求作用域request在用户的请求和转发的请求内有效页面作用域pageContext只在当前的页面（转换单元）内有效\n\n\n应用作用域\n在Servlet中可以使用ServletContext接口的setAttribute()方法将对象存储在应用作用域中，在JSP页面中就可使用context.setAttribute访问context中数据。\nString username = request.getParameter(&quot;username&quot;);\nServletContext context = getServletContext();\ncontext.setAttribute(&quot;name&quot;, username);\n&lt;%= application.getAttribute(&quot;name&quot;) %&gt;\n\n\n会话作用域\n使用HttpSession接口的setAttribute()设置属性，在JSP页面中就可使用session.getAttribute访问session中数据。\nHttpSession session = request.getSession(true);\nsession.setAttribute(&quot;name&quot;, value);\n&lt;%= session.getAttribute(&quot;cart&quot;) %&gt;\n\n\n请求作用域\n在Servlet中使用请求对象的setAttribute()将一个对象存储到请求作用域中，然后将请求转发到JSP页面，在JSP页面中通过脚本或EL取出作用域中的对象。\nrequest.setAttribute(&quot;user&quot;, user);\nRequestDispatcher rd = request.getRequestDispatcher(&quot;/valid.jsp&quot;);\nrd.forward(request,response);\n&lt;% User user = (User) request.getAttribute(&quot;user&quot;); %&gt;\n\n\n页面作用域\n存储在页面作用域的对象只能在它们所定义的转换单元中被访问。\n&lt;% Float one = new Float(42.5);%&gt;\n&lt;% pageContext.setAttribute(&quot;foo&quot;, one); %&gt;\n静态包含中另一个页面获得一个页面作用域的属性：\n&lt;%= pageContext.getAttribute(&quot;foo&quot; ) %&gt;\n\n\nJava Beans\nJavaBeans是Java平台的组件技术，在Java Web开发中常用JavaBeans来存放数据、封装业务逻辑等，从而很好地实现业务逻辑和表示逻辑的分离，使系统具有更好的健壮性和灵活性。\n定义JavaBeans类，需要遵循的规范是：\n\nJavaBeans应该是public类，且具有无参数的public构造方法。也可以定义带参数构造方法。\n类的成员变量一般称为属性（property）。对每个属性访问权限一般定义为private。注意：属性名必须以小写字母开头。\n每个属性通常定义两个public方法，一个是访问方法（getter），一个是修改方法（setter），使用它们访问和修改JavaBeans的属性值。\n\n在JSP页面中使用JavaBeans是通过三个JSP标准动作实现，分别是：\n\n\n&lt;jsp:useBean&gt;动作\n&lt;jsp:useBean \nid=&quot;beanName&quot;\nscope=&quot;page|request|session|application&quot;\n{ class=&quot;package.class&quot; | type=&quot;package.class&quot; } // class和type至少指定一个或两个同时指定\n// 其他元素   \n&lt;/jsp:useBean&gt; \n\nid：唯一标识一个bean实例，该属性是必须的。\nscope：指定bean实例的作用域，默认值为page作用域。\nclass：指定创建bean实例的Java类\ntype：指定由id属性声明的变量的类型\n\n\n\n\n&lt;jsp:setProperty&gt;动作\n&lt;jsp:setProperty \nname=&quot;beanName&quot;\n{ \nproperty = “propertyName” value=&quot;{string | &lt;%=expression%&gt;}&quot; |\nproperty = &quot;propertyName&quot; [param=&quot;paramName&quot;]  |\nproperty = &quot;*&quot; \n} \n/&gt;\n\nname：标识一个bean实例，该实例必须是前面使用&lt;jsp:useBean&gt;动作声明的，并且name属性值必须与&lt;jsp:useBean&gt;动作中指定的一个id属性值相同，该属性是必须的。\nproperty：指定要设置值的bean实例的属性，容器将根据指定的bean的属性调用适当的setXXX()，该属性是必须的。\nvalue：为bean的属性指定新值，该属性值可以接受请求时属性表达式。\nparam：指定请求参数名，如果请求中包含指定的参数，那么使用该参数对应的值来设置bean的属性值。\n\nvalue属性和param属性都是可选的并且不能同时使用。\n\n\n&lt;jsp:getProperty&gt;动作\n&lt;jsp:getProperty name=&quot;beanName&quot; property=&quot;propertyName&quot; /&gt;\n\nname：指定bean实例名。\nproperty：指定要输出的属性名。\n\n\n\n\n如何定义一个JavaBean：\npublic class Customer {\n    // 属性声明\n    private String name;\n \n    // 构造方法的定义\n    public Customer() {}\n \n    public Customer(String name) {\n        this.name = name;\n    }\n  \n    // getter方法\n    public String getName() { return this.name; }\n \n    // setter方法\n    public void setName(String name) { this.name = name; }\n}\nMVC设计模型\nMVC（Model-View-Controller）设计模式，在这种结构中，将Web组件分为模型（Model）、视图（View）和控制器（Controller），每种组件完成各自的任务。\n\n所有请求的目标都是Servlet，它充当应用程序的控制器，Servlet分析请求并将响应所需要的数据收集到JavaBeans对象，该对象作为应用程序的模型，最后Servlet控制器将请求转发到JSP页面。这些页面使用存储在JavaBeans中的数据产生响应，该对象作为应用程序的视图。\n优点：将业务逻辑和数据访问从表示层分离出来，JSP页面不需要处理任何复杂的逻辑。节省开发的时间和费用，易于维护。\n实现MVC模式的一般步骤：\n\n定义JavaBeans存储数据\n编写Servlet处理请求\n数据结果存储在作用域中\n转发请求到JSP页面\n从JavaBeans中提取数据\n\n会话\n会话（session）是客户与服务器之间的不间断的请求—响应序列。\nWeb容器使用HttpSession表示会话对象。\n创建或返回会话使用request对象的HttpSession getSession(boolean create)方法。如果没有与当前请求关联的会话对象，当参数为true时创建一个新的会话对象，当参数为false时返回null。\nHttpSession接口中有以下两个方法：\n\npublic void setAttribute (String name, Object value)：将一个指定名称和值的属性存储到会话对象上。\npublic Object getAttribute(String name)：返回存储到会话上的指定名称的属性值，如果没有指定名称的属性，则返回null。\n\n当我们关闭客户端浏览器时，Session并没有被销毁，还保存在服务器端，只不过客户端一旦把浏览器关闭掉以后，再去开一个新的窗口，之前的SessionID就再也访问不到了，因为SessionID是保存在浏览器进程中的，浏览器一旦关掉，所对应的SessionID也就消失了。但服务器里的Session对象依然存在，当重新打开一个窗口时，服务器会针对这个新的页面，发送一个新的SessionID，这个新的SessionID跟以前那个SessionID是不一样的，两者之间没有任何关系。这样客户端就会对应一个新的session上，而服务器端原有的那个会话则一直存在，一直等到超时，服务器端的session就销毁掉了。\n如何让会话失效：\n\n\n在DD文件中设置会话超时时间。\n&lt;session-config&gt;\n\t&lt;session-timeout&gt;10&lt;/session-timeout&gt;\n&lt;/session-config&gt;\n以分钟为单位，默认情况下是30分钟。\n\n\n使用会话对象的invalidate()。\nHttpSession session = request.getSession();\nsession.invalidate();   \n\n\n\nCookie是客户访问Web服务器时，服务器在客户硬盘上存放的一小段文本信息，客户以后访问同一个Web服务器时浏览器会把它们原样发送给服务器。\nCookie类的常用方法如下：\n\npublic String getName()：返回Cookie名称，名称一旦创建不能改变。\npublic String getValue()：返回Cookie的值。\npublic void setValue(String newValue)：在Cookie创建后为它指定一个新值。\npublic void setMaxAge(int expiry)：设置Cookie在浏览器中的最长存活时间，单位为秒。\n\nCookie类的构造方法为：public Cookie(String name, String value)\n// 创建一个Cookie对象\nCookie userCookie = new Cookie(&quot;username&quot;, &quot;value&quot;); \n// 向客户端发送Cookie对象\nresponse.addCookie(userCookie);\n// 从客户端读取Cookie\nCookie[] cookies = request.getCookies();\nfor(int i = 0;i&lt;cookies.length;i++){\n\tCookie cookie = cookies[i];\n\tif(cookie.getName().equals(cookieName))\n\t\tcookieValue = cookie.getValue();\n}\n\n文件上传是指将客户端的一个或多个文件传输并存储到服务器上。\n上传文件表单的&lt;form&gt;标签中，应该\n\n指定enctype属性，值为multipart/form-data。\n指定method属性，值为post。\n提供一个&lt;input type=&quot;file&quot;&gt;的输入域用于指定上传的文件。\n\n在服务器端使用Servlet就可以得到上传的文件的内容并将其存储到服务器的特定位置。通过请求对象的下面两个方法来处理上传的文件：\n\nPart getPart(String name)：返回用name指定名称的Part对象。\nCollection&lt;Part&gt; getParts()：返回所有Part对象的一个集合。\n\nPart对象除了包含上传来的文件内容、文件名、内容类型等信息，还包含表单域的名称和值。以下是Part接口常用方法：\n\nInputStream getInputStream()：返回Part对象的输入流对象。\nString getContentType()：返回Part对象的内容类型。\nString getName()：返回Part对象的名称。\n\n从Part对象中检索上传文件的文件名：调用part对象的String getHeader(String name)方法，参数name为Content-Disposition，得到包含上传文件名的字符串，然后提取该字符串中包含文件名的子字符串，得到上传文件的文件名。\n// 从Part对象中检索上传文件的文件名\nprivate String getFilename(Part part){\n\tString fname = null;\n\tString header = part.getHeader(&quot;content-disposition&quot;);\n\tfname = header.substring(header.lastIndexOf(&quot;\\\\&quot;)+1, header.length()-1);\n\treturn fname;\n}\nJDBC\nJDBC是Java程序访问数据库的标准，由一组Java语言编写的类和接口组成，这些类和接口称为JDBC API。\nJDBC的基本功能包括：\n\n建立与数据库的连接。\n发送SQL语句。\n处理数据库操作结果。\n\n目前有多种类型的数据库，每种数据库都定义了一套API，因此需要有在程序收到JDBC请求后，将其转换成适合于数据库系统的方法调用。把完成这类转换工作的程序叫做数据库驱动程序。\n\n加载JDBC驱动程序最常用的方法是使用Class类的**forName()**静态方法，该方法的声明格式为：public static Class&lt;?&gt; forName(String className) throws ClassNotFoundException\n\n参数className为一字符串，表示的完整的驱动程序类的名称。对于不同的数据库，驱动程序的类名是不同的。\n?可以代表任何类型，Class&lt;?&gt;代表这个类型所对应的类对象。\n\n\n语句对象有两种：\n\n\nStatement对象\n通过Connection对象创建语句(Statement)对象。\nStatement stmt = conn.createStatement();\n\n\nPreparedStatement对象\n通过Connection对象创建预编译的语句(prepareStatement)对象。\nString sql = &quot;SELECT * FROM products WHERE id = ?&quot;;\nPreparedStatement pstmt = conn.prepareStatement(sql); \n\n\n区别：\n\nStatement对象：在多次执行同一个语句时效率较低\nPreparedStatement对象：如果数据库支持预编译，它可以将SQL语句传给数据库作预编译，以后每次执行这个SQL语句时，速度就可以提高很多。\n\n语句对象常用的方法有：\n\n\n执行查询语句\npublic ResultSet executeQuery(String sql) \n\n\n执行非查询语句\npublic int executeUpdate(String sql) \n\n\n释放Statement\nclose()\n\n\n\n结果集对象表示查询结果，即SELECT语句查询得到的记录集合，一般是一个记录表。\n结果集中包含多个记录行和列标题，记录行从1开始，一个Statement对象一个时刻只能打开一个ResultSet对象。\n游标是结果集的一个标志或指针。对新产生的ResultSet对象，游标指向第一行的前面，可以调用ResultSet的next()，使游标定位到下一条记录。\n\n数据库连接步骤：\n\n加载驱动程序。\n建立连接对象。\n创建语句对象。\n执行语句获得结果。\n关闭建立的对象。\n\n缺点：建立连接比较耗费时间，导致增大请求的响应时间\n\n使用数据源连接数据库的优点：\n使用数据源的技术访问数据库可以提高数据库访问效率，而且应用程序只需在启动时创建少量的连接对象即可，不需要为每个HTTP请求都创建一个连接对象，这会大大降低请求的响应时间。\n通过数据源对象如何获得连接对象：\n采用Java命名与目录接口 （Java Naming and Directory Interface，JNDI）技术来获得DataSource对象的引用。首先为要创建的对象指定一个唯一的名字，然后由对象工厂创建对象，并将该对象与唯一的名字绑定，外部程序可以通过名字来获得某个对象的访问。\n\nDAO（Data Access Object）称为数据访问对象，将数据访问实现（通常使用JDBC技术）封装在DAO类中。\nDAO设计模式可以在使用数据库的应用程序中实现业务逻辑和数据访问逻辑分离，使应用的维护变得简单。提高应用程序的灵活性。\n如何使用DAO类：\n\n定义一个DAO接口，它负责建立数据库连接。\n为每种实体的持久化操作定义一个接口。\n定义这些接口的实现类。\n\n\npublic class Product {\n    private int id;\n \n    public Product() {}\n    public Product(int id) {\n        this.id = id;\n    }\n \n    public int getId() { return id; }\n    public void setId(int id) { this.id = id; }\n}\n&lt;%@page contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;title&gt;商品查询&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;a href=&quot;product-query&quot;&gt;查询所有商品&lt;/a&gt;\n  &lt;form action =&quot;product-query&quot; method=&quot;post&quot;&gt;\n    &lt;input type =&quot;text&quot; name=&quot;productid&quot; size=&quot;15&quot;&gt;\n    &lt;input type =&quot;submit&quot; value =&quot;确定&quot;&gt;\n  &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n@WebServlet(&quot;/product-query&quot;)\npublic class ProductQueryServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    Connection dbconn = null;\n \n    public void init() {\n        String driver = &quot;com.mysql.cj.jdbc.Driver&quot;;//驱动程序类名\n        String dburl = &quot;jdbc:mysql://localhost:3306/webstore&quot;;\n        String username = &quot;root&quot;;\n        String password = &quot;root&quot;;\n      \n        try {\n          \t// 加载驱动程序\n            Class.forName(driver);\n          \t// 创建连接对象\n            dbconn = (Connection) DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/webstore?serverTimezone=GMT&amp;useSSL=false&quot;, username, password);\n        } catch (ClassNotFoundException e1) {} catch (SQLException e2) {}\n    }\n \n    public void doGet(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException {\n        try {\n            String sql = &quot;SELECT * FROM products&quot;;\n            PreparedStatement pstmt = dbconn.prepareStatement(sql);\n            ResultSet result = pstmt.executeQuery();\n            while (result.next()) {\n                result.getInt(&quot;id&quot;)\n            }\n            request.getSession().setAttribute(&quot;product&quot;, productList);\n            response.sendRedirect(&quot;/chapter02/error.jsp&quot;);\n        } catch (SQLException e) {}\n    }\n \n    public void doPost(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException {\n        String productid = request.getParameter(&quot;productid&quot;);\n        try {\n            String sql = &quot;SELECT * FROM products WHERE id = ?&quot;;\n            PreparedStatement pstmt = dbconn.prepareStatement(sql);\n            pstmt.setString(1, productid);\n            ResultSet rst = pstmt.executeQuery();\n            if (rst.next()) {\n                Product product = new Product();\n                product.setId(rst.getInt(&quot;id&quot;));\n                request.getSession().setAttribute(&quot;product&quot;, product);\n            }\n        } catch (SQLException e) {}\n    }\n \n    public void destroy() {\n        try {\n            dbconn.close();\n        } catch (Exception e) {}\n    }\n}\npublic class Customer implements Serializable {\n    private int id;\n \n    public int getId() { return id; }\n    public void setId(int id) { this.id = id; }\n}\npublic class DaoException extends Exception {\n    private static final long serialVersionUID = 19192L;\n    private String message;\n \n    public DaoException() {}\n \n    public DaoException(String message) {\n        this.message = message;\n    }\n \n    public String getMessage() {\n        return message;\n    }\n \n    public void setMessage(String message) {\n        this.message = message;\n    }\n \n    public String toString() {\n        return message;\n    }\n}\n \npublic interface Dao {\n    // 查找并返回数据源对象,静态方法，\n    public static DataSource getDataSource() {\n        DataSource dataSource = null;\n        try {\n            Context context = new InitialContext();\n            dataSource = (DataSource) context.lookup(&quot;java:comp/env/jdbc/webstoreDS&quot;);\n        } catch (NamingException ne) {}\n        return dataSource;\n    }\n \n \n    // 返回连接对象方法\n    public default Connection getConnection() throws DaoException {\n        DataSource dataSource = getDataSource();\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n        } catch (SQLException sqle) {}\n        return conn;\n    }\n}\n \npublic interface CustomerDao extends Dao {\n    //添加客户方法\n    public boolean addCustomer(Customer customer) throws DaoException;\n \n    // 按id查询客户方法\n    public Customer findById(int id) throws DaoException;\n \n    // 查询所有客户方法\n    public ArrayList&lt;Customer&gt; findAllCustomer() throws DaoException;\n}\npublic class CustomerDaoImpl implements CustomerDao {\n    // 插入一条客户记录\n    public boolean addCustomer(Customer customer)throws DaoException {\n        String sql = &quot;INSERT INTO customers VALUES(?)&quot;;\n        try (Connection conn = getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            pstmt.setInt(1, customer.getId());\n            pstmt.executeUpdate();\n            return true;\n        } catch (SQLException se) {\n            return false;\n        }\n    }\n \n    // 按id查询客户记录\n    public Customer findById(int id) throws DaoException {\n        String sql = &quot;SELECT id FROM customers WHERE id =?&quot;;\n        Customer customer = new Customer();\n        // 对资源的申请\n        try (Connection conn = getConnection();PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            pstmt.setInt(1, id);\n            try (ResultSet rst = pstmt.executeQuery()) {\n                if (rst.next()) customer.setId(rst.getInt(&quot;id&quot;));\n            }\n        } catch (SQLException se) {\n            return null;\n        }\n        return customer;\n    }\n \n    // 查询所有客户信息\n    public ArrayList&lt;Customer&gt; findAllCustomer() throws DaoException {\n        String sql = &quot;SELECT * FROM customers&quot;;\n        try (\n          Connection conn = getConnection();\n          PreparedStatement pstmt = conn.prepareStatement(sql);\n          ResultSet rst = pstmt.executeQuery()) {\n            while (rst.next()) {\n                rst.getInt(&quot;id&quot;)\n            }\n            return custList;\n        } catch (SQLException e) {\n            return null;\n        }\n    }\n}\n&lt;%@page contentType=&quot;text/html; charset=UTF-8&quot;%&gt;\n&lt;html&gt;\n  &lt;head&gt;&lt;title&gt;添加客户&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;p&gt;请输入一条客户记录&lt;/p&gt;\n  &lt;form action =&quot;addCustomer.do&quot; method =&quot;post&quot;&gt;\n    &lt;input type=&quot;text&quot; name=&quot;id&quot;&gt;\n    &lt;input type=&quot;submit&quot; value=&quot;确定&quot;&gt;\n    &lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt;\n  &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n@WebServlet(&quot;/addCustomer.do&quot;)\npublic class AddCustomerServlet extends HttpServlet {\n    public void doPost(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException {\n        CustomerDao dao = new CustomerDaoImpl();\n        Customer customer = new Customer();\n        String message = &quot;&quot;;\n        try {\n            // parseInt，解析一个字符串，返回一个整数。\n            customer.setId(Integer.parseInt(request.getParameter(&quot;id&quot;)));\n \n\t\t\t\t\t// 将传递来的字符串重新使用utf-8编码，以免产生乱码\n            customer.setName(new String(request.getParameter(&quot;cname&quot;)\n                    .getBytes(&quot;iso-8859-1&quot;), &quot;UTF-8&quot;));\n            customer.setEmail(new String(request.getParameter(&quot;email&quot;)\n                    .getBytes(&quot;iso-8859-1&quot;), &quot;UTF-8&quot;));\n \n            boolean success = dao.addCustomer(customer);\n \n            if (success) {\n                message = &quot;&lt;li&gt;成功插入一条记录！&lt;/li&gt;&quot;;\n            } else {\n                message = &quot;&lt;li&gt;插入记录错误！&lt;/li&gt;&quot;;\n            }\n        } catch (Exception e) {\n            message = &quot;&lt;li&gt;插入记录错误！&lt;/li&gt;&quot; + e;\n        }\n        request.setAttribute(&quot;result&quot;, message);\n        RequestDispatcher rd = getServletContext().getRequestDispatcher(&quot;/addCustomer.jsp&quot;);\n        rd.forward(request, response);\n    }\n}\n表达式语言\n表达式语言（Expression Language, EL）是一种可以在JSP页面中使用的数据访问语言。\n表达式语言的使用形式为：${expression}\nEL表达式如何访问\n\n\n作用域变量：\n在Servlet中使用setAttribute()将一个变量存储到某个作用域对象上，如HttpServletRequest、HttpSession及ServletContext等。在JSP页面中使用变量名即可访问：${variable_name}。\n\n\nJavaBeans对象：\n使用EL，通过点号表示法即可访问JavaBeans的属性：${employee.name}\n\n\n集合对象：\n在EL中可以访问各种集合对象的元素，集合可以是数组、List对象或Map对象。格式：${attributeName[entryName]}\n\n\nEL表达式中的隐含变量\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n变量名说 明pageContext包含JSP常规隐含对象的PageContext类型对象param包含请求参数字符串的Map对象paramValues包含请求参数字符串数组的Map对象header包含请求头字符串的Map对象headerValues包含请求头字符串数组的Map对象initParam包含Servlet上下文参数的参数名和参数值的Map对象cookie匹配Cookie域和单个对象的Map对象pageScope包含page作用域属性的Map对象requestScope包含request作用域属性的Map对象sessionScope包含session作用域属性的Map对象applicationScope包含application作用域属性的Map对象"},"编程语言/JavaScript/JS":{"title":"JS","links":[],"tags":[],"content":"JS 修改原数组\nconst list = [1,2,3,4,5];\n \nlist.forEach((item, index, self)=&gt;{\n  self[index]++;\n});\n \nconsole.log(list);// 2,3,4,5,6"},"编程语言/Rust/Rust认识/1_环境配置":{"title":"Rust 环境配置","links":[],"tags":["Rust"],"content":"Windows 上安装 Rust 需要有 C++ 环境，可以选择 GNU 和 MSVC。\n\n\n                  \n                  GNU 和 MSVC \n                  \n                \n\nGNU 和 MSVC 都是编译器工具链，它们提供一套工具和库，这些工具和库被用来构建、链接和调试应用程序。\n\nGNU: 使用的是来自 MinGW 的工具（如 GCC 等），偏向于在 Windows 上构建与 Unix 类系统兼容的二进制文件。MinGW 模拟了大量 POSIX API，使得使用 GNU 工具链的 Rust 项目更适合那些需要 Unix 类兼容性的程序。\nMSVC: MSVC（Microsoft Visual C++）是 Microsoft 提供官方编译工具链，它是 Visual Studio IDE 的一部分。使用 MSVC 编译的 Rust 程序与 Windows 系统的集成更好，能够更容易地调用 Windows 的原生 API。\n\n\n\n\n这里选择 MSVC\n\n在 rust 官网下载 rustup-init\n\n下载完成后运行rustup-init.exe，会让你选择如何安装 MSVC\n\n\n\n                  \n                  Note\n                  \n                \n\n\n\n快速安装 Visual Studio 社区版\n\n\n手动安装所需依赖\n\n如果电脑上已经有了 Visual Studio, 可以在 Visual Studio Install 中手动安装\n\n\n\n\n不安装依赖\n\n如果你不需要使用 Windows 的 C++ 工具链，而是打算使用 GNU ABI（如在 Windows 上使用 MinGW 或 WSL），可以选择此选项，不会安装额外的工具链和库。\n\n\n\n\n\n由于我电脑上没有 Visual Studio , 这里选择 1。\n安装完这些后，接下来会安装 Rust 相关内容，一路默认即可。\n\n\n\nrust-std: Rust 标准库。\nrustc: Rust 的编译器，用于将 Rust 代码编译为可执行的机器代码。\ncargo: Rust 的包管理器和构建工具，用于管理依赖、编译项目、运行测试等。\nClippy: 一个 Rust 的代码静态分析工具，用来提供代码风格和潜在错误的建议。\nrustfmt: Rust 的代码格式化工具。\nrust-docs: Rust 的文档工具。\n\n\nRust 和 Node 的一些对应关系。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRustNoderustupnvmcargonpmCargo.tomlpackage.jsonCargo.lockpackage-lock.jsonclippyeslintcargofmtprettierrustc rust-sdtnode\n"},"编程语言/Rust/Rust认识/2_cargo使用":{"title":"Cargo 使用","links":[],"tags":["Rust"],"content":"新建项目\n使 Rust 的包管理器 cargo 新建项目\ncargo new &lt;项目名&gt;\n\n\ncargo 会为我们生成基本的项目结构和配置文件\n\n运行项目\n手动运行\nrust main.rs\n运行后会生成两个文件\n\n一个是 exe 文件，包含已编译 Rust 代码的可执行程序文件。\n一个是 pdb 文件（调试符号文件），包含了程序的调试信息。\n\n\n\ncargo 运行\ncargo run\n\n\n\n从 cargo run 输出结果可以看出，cargo run 其实运行了两个指令，分别是编译和运行\n\n\n\n\n                  \n                  Tip\n                  \n                \n\ncargo 默认运行的是 debug 模式，在这个模式下 Rust 编译器不会做太多优化，以便快速编译，牺牲一些运行性能以换取更快的编译速度。\n如果我们想要运行速度更快可以使用发布模式，即在命令后面接上--release参数。\ncargo run --release\n在这个模式下 Rust 编译器会应用更多的优化技术，如循环展开、内联函数、去虚拟化等，以提高程序的运行效率。通常会导致编译时间变长，但运行速度更快。\n\n\n配置文件\n在使用 Cargo 创建项目时，会生成 Cargo.toml 和 Cargo.lock 两个重要配置文件。\n\nCargo.toml 项目配置文件: 允许开发者声明项目所需的依赖和配置，Cargo 会根据这些信息来下载、构建和链接依赖库。\nCargo.lock 依赖锁定文件: 它是一个自动生成的文件，用于锁定项目依赖的确切版本，不需要手动编辑。\n\nCargo.toml[package] # 定义了包的名称、版本、作者等信息\nname = &quot;rust&quot; \nversion = &quot;0.1.0&quot;\nedition = &quot;2021&quot;\n \n[dependencies] # 依赖\nCargo.lock# This file is automatically @generated by Cargo.\n# It is not intended for manual editing.\nversion = 3\n \n[[package]]\nname = &quot;rust&quot;\nversion = &quot;0.1.0&quot;\n修改镜像\n在$HOME/.cargo下新建config.toml\nconfig.toml# 选择的镜像源\n# 喜欢哪个用哪个吧，没有注释掉的那个就是你选择的\n#replace-with = &#039;ustc&#039;\n#replace-with = &#039;tuna&#039;\n#replace-with = &#039;sjtu&#039;\n#replace-with = &#039;rustcc&#039;\nreplace-with = &#039;aliyun&#039;\n \n# 源码地址\n[source.crates-io]\nregistry = &quot;github.com/rust-lang/crates.io-index&quot;\n \n# 镜像地址\n \n# 清华大学\n[source.tuna]\nregistry = &quot;mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git&quot;\n \n# 中国科学技术大学\n[source.ustc]\nregistry = &quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;\n \n# 上海交通大学\n[source.sjtu]\nregistry = &quot;mirrors.sjtug.sjtu.edu.cn/git/crates.io-index&quot;\n \n# rustcc社区\n[source.rustcc]\nregistry = &quot;git://crates.rustcc.cn/crates.io-index&quot;\n \n# 阿里云\n[source.aliyun]\nregistry = &quot;code.aliyun.com/rustcc/crates.io-index&quot;\n安装依赖\n在 crates.io/ 中可以查找各种 Rust 依赖，作用类似于 NPM。\n\n从依赖的介绍页面可以知道，依赖安装有自动安装和手动安装两种方式。\n"},"编程语言/Rust/Rust认识/3_变量":{"title":"3_变量","links":[],"tags":[],"content":"变量绑定\nlet a = 10;// 不可变\nlet mut b = 10;// 可变 mutable\n \nlet _c = 10;// 让 rust 编译器不要警告该变量\n变量解构\nlet (a, mut b): (bool,bool) = (true, false);// a = true,不可变; b = false，可变\n \nlet (a, b, c, d, e);\n(a, b) = (1, 2);\n \n// _ 代表匹配一个值，但是我们不关心具体的值是什么，因此没有使用一个变量名而是使用了 _\n// .. 表示忽略多个值\n[c, .., d, _] = [1, 2, 3, 4, 5];\n变量遮蔽\nRust 允许声明相同的变量名，在后面声明的变量会遮蔽掉前面声明的。\nfn main() {\n    let x = 5;\n    let x = x + 1;\n    {\n        let x = x * 2;\n        println!(&quot;{}&quot;, x); // 12\n    }\n    println!(&quot;{}&quot;, x); // 6\n}\n常量\n常量使用 const 关键字而不是 let 关键字来声明\nconst MAX_POINTS: u32 = 100_000;"},"编程语言/Rust/Rust认识/4_类型":{"title":"4_类型","links":["编程语言/计算机基础/计算机组成原理/2_数据的表示和运算"],"tags":[],"content":"\n\n                  \n                  Tip\n                  \n                \n\nRust 编译器可以根据变量的值和上下文中的使用方式来自动推导出变量的类型，但在它无法推导出变量类型时，需要手动去给予一个类型标注。\n\n\n数值类型\n基本类型\n有符号整数：i8, i16, i32, i64, isize\n无符号整数：u8, u16, u32, u64, usize\n\nisize、usize 的位数则视架构而定，在 32 位架构上为 32 位，在 64 位架构上为 64 位，适合用于表示内存地址、数组索引等需要根据系统架构来决定大小的场景。\n\n浮点数：f32, f64\n\n\n                  \n                  Note\n                  \n                \n\n有符号/无符号整数，浮点数的具体内容可以查看 数据的表示和运算。\n\n\n\n\n                  \n                  Warning\n                  \n                \n\n浮点数类型是基于二进制实现的，因此某些数字无法精确表示（例如 0.1）。\nfn main() {\n\tlet abc: (f32, f32, f32) = (0.1, 0.2, 0.3);\n\tlet xyz: (f64, f64, f64) = (0.1, 0.2, 0.3);\n\tprintln!(&quot;0.1 + 0.2: {:x}&quot;, (abc.0 + abc.1).to_bits());// 0.1 + 0.2: 3e99999a\n\tprintln!(&quot;0.3: {:x}&quot;, (abc.2).to_bits());// 0.3: 3e99999a\n\t\n  println!(&quot;0.1 + 0.2: {:x}&quot;, (xyz.0 + xyz.1).to_bits());// 0.1 + 0.2: 3fd3333333333334\n\tprintln!(&quot;0.3: {:x}&quot;, (xyz.2).to_bits());// 0.3: 3fd3333333333333\n}\n\n\nNaN\nNaN (Not a Number)是浮点数的一种特殊值，表示一个无效或无法定义的数值结果。它常见于浮点数运算中，如零除以零、无效的平方根等情况。NaN 不等于任何值，包括自己。可以使用 is_nan() 等方法，可以用来判断一个数值是否是 NaN 。\nfn main() {\n   let x: f64 = 0.0 / 0.0; // 结果是 NaN\n   let y: f64 = f64::sqrt(-1.0); // 结果是 NaN\n \n   println!(&quot;{}&quot;, x.is_nan()); // true\n   println!(&quot;{}&quot;, y.is_nan()); // true\n \n   println!(&quot;x == x: {}&quot;, x == x); // x == x: false\n   println!(&quot;x == NaN: {}&quot;, x == y); // x == NaN: false\n}\n序列\n序列(Range)用来生成连续的数值。序列只允许用于数字或字符类型。\nfn main() {\n    for i in 1..5 {\n        println!(&quot;{}&quot;, i); // 1 ...... 4\n    }\n    for i in 1..=5 {\n        println!(&quot;{}&quot;, i);// 1 ...... 5\n    }\n    for i in &#039;a&#039;..=&#039;z&#039; {\n        println!(&quot;{}&quot;, i);// a ...... z\n    }\n}\n单元类型\n单元类型即 () ，其唯一的值也是 ()，通常表示“没有值”或“什么都没有”。\n很多时候，Rust 中的函数如果没有返回值，它的返回类型就是单元类型 ()。即使函数没有显式返回 ()，Rust 也会隐式地认为它返回了 ()。\nfn main() {\n   let a = (); // 单元类型的值\n   println!(&quot;{:?}&quot;, a); // 输出：()\n   \n   // 一个没有返回值的函数\n   let result = do_nothing();\n   println!(&quot;{:?}&quot;, result); // 输出：()\n}\n \nfn do_nothing() -&gt; () {\n   // 什么都不做，隐式返回单元类型 ()\n}\n使用场景：\n\n函数返回值：函数如果不需要返回任何有意义的结果，可以显式返回 ()。例如，很多 Rust 中的事件处理函数、回调函数、或者某些状态修改函数通常返回 ()，表示操作已经完成但没有结果。\n占位符：有时，() 用作占位符，表示某个地方没有具体的值或没有需要关注的数据。\n\n语句和表达式\n语句是执行某个操作的代码块，它通常没有返回值。它告诉程序去做某件事，但不产生一个可以进一步操作的值。\nlet x = 5;  // 这是一个语句，x 被赋值为 5\n \nprintln!(&quot;Hello, world!&quot;); // 这是一个语句，调用了 println 函数\n \nif x &gt; 5 {\n    println!(&quot;x is greater than 5&quot;);\n} // 这是一个语句，控制条件执行\n表达式是产生一个值的代码块。它可以被计算出一个值，并且这个值可以被赋值、返回或者传递给其他表达式。\n5 // 这是一个表达式，返回 5\n&quot;hello&quot; // 这是一个表达式，返回字符串 &quot;hello&quot;\n3 + 4 // 这是一个表达式，返回 7\n \nfn add(x: i32, y: i32) -&gt; i32 {\n    x + y // 这里的 `x + y` 是一个表达式，返回计算结果\n}\n \nlet x = if condition { 5 } else { 10 }; // 这是一个表达式，条件结果决定了 x 的值\n\n\n                  \n                  Important\n                  \n                \n\n表达式没有 ; 结尾，; 结尾的是语句。\n\n\n函数\n函数是一段封装好的代码块，用来执行特定的任务。函数接收输入（参数）、执行一系列操作，并可能返回一个值。\nfn add(x: i32, y: i32) -&gt; i32 {\n    x + y // 返回 x 和 y 的和\n}\n \nfn main() {\n    let result = add(5, 3); // 调用函数\n    println!(&quot;The result is {}&quot;, result); // 输出结果 8\n}\n\n\n                  \n                  Tip\n                  \n                \n\nRust 不关心我们在哪里定义了函数，只要有定义即可。\n函数的参数可以有多个，并且每个参数都要指定类型。参数是函数外部传入的值，它们的作用域仅限于函数体内。\n\n\n字符串\n切片\n**切片(Slice)**是一个对数组或向量的一部分的引用。切片允许你借用数组或向量的一部分，而不需要复制数据。\nfn main() {\n    let s = String::from(&quot;hello world&quot;);\n \n    let hello = &amp;s[0..5]; // 索引位置是 [0, 5)\n    let world = &amp;s[6..11]; // 索引位置是 [6, 11)\n}\n\n;;"},"计算机基础/数据库系统概论/10_数据库恢复技术":{"title":"数据库恢复技术","links":[],"tags":["数据库"],"content":"事务的基本概念\n事务\n事务(Transaction)是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。\n事务和程序是两个概念：在关系数据库中，一个事务可以是一条SQL语句，一组SQL语句或整个程序，一个程序通常包含多个事务。\n事务是恢复和并发控制的基本单位。\n事务的ACID特性\n事务的ACID特性：\n\n\n原子性（Atomicity）\n事务是数据库的逻辑工作单位，事务中包括的诸操作要么都做，要么都不做。\n\n\n一致性（Consistency）\n事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。\n一致性状态：数据库中只包含成功事务提交的结果。\n不一致状态：数据库系统运行中发生故障，有些事务尚未完成就被迫中断。这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态。\n\n\n隔离性（Isolation）\n一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能互相干扰。\n\n\n持续性（Durability ）\n持续性也称永久性，一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其执行结果有任何影响。\n\n\n保证事务ACID特性是事务处理的任务。\n破坏事务ACID特性的因素：\n\n\n多个事务并行运行时，不同事务的操作交叉执行\n数据库管理系统必须保证多个事务的交叉运行不影响这些事务的隔离性\n\n\n事务在运行过程中被强行停止\n数据库管理系统必须保证被强行终止的事务对数据库和其他事务没有任何影响\n\n\n数据库恢复概述\n故障是不可避免的。\n故障的影响：运行事务非正常中断，影响数据库中数据的正确性；破坏数据库，全部或部分丢失数据。\n数据库管理系统必须具有把数据库从错误状态恢复到某一已知的正确状态(亦称为一致状态或完整状态)的功能，这就是数据库的恢复管理系统对故障的对策。\n恢复子系统是数据库管理系统的一个重要组成部分。\n恢复技术是衡量系统优劣的重要指标。\n故障的种类\n各类故障，对数据库的影响有两种可能性\n\n数据库本身被破坏；\n数据库没有被破坏，但数据可能不正确，这是由于事务的运行被非正常终止造成的；\n\n事务内部的故障\n事务内部的故障\n\n有的是可以通过事务程序本身发现的；\n有的是非预期的，不能由事务程序处理的；\n\n事务内部更多的故障是非预期的，是不能由应用程序处理的。例如，运算溢出，并发事务发生死锁而被选中撤销该事务，违反了某些完整性限制而被终止等。\n以后，事务故障仅指这类非预期的故障。\n事务故障意味着事务没有达到预期的终点，即数据库可能处于不正确状态。\n事务撤消（UNDO）：恢复程序在不影响其它事务运行的情况下，强行回滚出故障的事务，即撤销该事务已经作出的任何对数据库的修改，使得该事务象根本没有启动一样。\n系统故障\n系统故障称为软故障，是指造成系统停止运转的任何事件，使得系统要重新启动。 例如：特定类型的硬件错误（如CPU故障），操作系统故障，数据库管理系统代码错误，系统断电。\n\n\n发生系统故障时，一些尚未完成的事务的结果可能已送入物理数据库，造成数据库可能处于不正确状态。\n恢复策略：系统重新启动时，恢复程序让所有非正常终止的事务回滚，强行撤消（UNDO）所有未完成事务。\n\n\n发生系统故障时，有些已完成的事务可能有一部分甚至全部留在缓冲区，尚未写回到磁盘上的物理数据库中，系统故障使得这些事务对数据库的修改部分或全部丢失\n恢复策略：系统重新启动时，恢复程序需要重做（REDO）所有已提交的事务。\n\n\n介质故障\n介质故障称为硬故障，指外存故障。例如：磁盘损坏，磁头碰撞，瞬时强磁场干扰。\n介质故障破坏数据库或部分数据库，并影响正在存取这部分数据的所有事务。介质故障比前两类故障的可能性小得多，但破坏性大得多。\n计算机病毒\n一种人为的故障或破坏，是一些恶作剧者研制的一种计算机程序，可以繁殖和传播，造成对计算机系统包括数据库的危害。\n计算机病毒是数据库系统的主要威胁。\n数据库一旦被破坏仍要用恢复技术把数据库加以恢复。\n恢复的实现技术\n恢复操作的基本原理：冗余，即利用存储在系统别处的冗余数据来重建数据库中已被破坏或不正确的那部分数据。\n一个大型数据库产品，恢复子系统的代码要占全部代码的10%以上。\n恢复机制涉及的关键问题：\n\n如何建立冗余数据\n如何利用这些冗余数据实施数据库恢复\n\n数据转储\n转储是指数据库管理员定期地将整个数据库复制到磁带、磁盘或其他存储介质上保存起来的过程。\n备用的数据文本称为后备副本(backup)或后援副本。\n数据库遭到破坏后可以将后备副本重新装入，重装后备副本只能将数据库恢复到转储时的状态，要想恢复到故障发生时的状态，必须重新运行自转储以后的所有更新事务。\n\n例：\n\n系统在T_a时刻停止运行事务，进行数据库转储，在T_b时刻转储完毕，得到T_b时刻的数据库一致性副本。\n系统运行到T_f时刻发生故障。\n为恢复数据库，首先由数据库管理员重装数据库后备副本，将数据库恢复至T_b时刻的状态重新运行自T_b～T_f时刻的所有更新事务，把数据库恢复到故障发生前的一致状态。\n\n转储是十分耗费时间和资源的，不能频繁进行。\n转储可以分为：\n\n\n静态转储\n在系统中无运行事务时进行的转储操作。\n转储开始时数据库处于一致性状态，转储期间不允许对数据库的任何存取、修改活动，得到的一定是一个数据一致性的副本。\n转储必须等待正运行的用户事务结束，新的事务必须等转储结束。\n优点：实现简单\n缺点：降低了数据库的可用性\n\n\n动态转储\n转储操作与用户事务并发进行，转储期间允许对数据库进行存取或修改。\n优点：不用等待正在运行的用户事务结束，不会影响新事务的运行\n缺点：不能保证副本中的数据正确有效\n利用动态转储得到的副本进行故障恢复，需要把动态转储期间各事务对数据库的修改活动登记下来，建立日志文件。后备副本加上日志文件就能把数据库恢复到某一时刻的正确状态。\n\n\n转储还可以分为：\n\n海量转储：每次转储全部数据库\n增量转储：只转储上次转储后更新过的数据\n\n海量转储与增量转储比较：从恢复角度看，使用海量转储得到的后备副本进行恢复往往更方便。\n如果数据库很大，事务处理又十分频繁，则增量转储方式更实用更有效。\n\n登记日志文件\n日志文件是用来记录事务对数据库的更新操作的文件。\n格式\n日志文件的格式：\n\n\n以记录为单位的日志文件\n各个事务的开始标记，各个事务的结束标记，各个事务的所有更新操作均作为日志文件中的一个日志记录。\n每个日志记录的内容包括：\n\n事务标识（标明是哪个事务）\n操作类型（插入、删除或修改）\n操作对象（记录ID、Block NO.）\n更新前数据的旧值（对插入操作而言，此项为空值）\n更新后数据的新值（对删除操作而言, 此项为空值）\n\n\n\n以数据块为单位的日志文件\n每条日志记录的内容包括：\n\n事务标识\n被更新的数据块\n\n\n\n作用\n用途：进行事务故障恢复，进行系统故障恢复，协助后备副本进行介质故障恢复。\n具体作用：\n\n\n事务故障恢复和系统故障恢复必须用日志文件。\n\n\n在动态转储方式中必须建立日志文件，后备副本和日志文件结合起来才能有效地恢复数据库。\n\n\n在静态转储方式中，也可以建立日志文件。\n当数据库毁坏后可重新装入后援副本把数据库恢复到转储结束时刻的正确状态。利用日志文件，把已完成的事务进行重做处理。对故障发生时尚未完成的事务进行撤销处理，不必重新运行那些已完成的事务程序就可把数据库恢复到故障前某一时刻的正确状态。\n\n\n\n登记日志文件\n为保证数据库是可恢复的，登记日志文件时必须遵循两条原则：\n\n\n登记的次序严格按并发事务执行的时间次序\n\n\n必须先写日志文件，后写数据库\n写日志文件操作：把表示这个修改的日志记录写到日志文件中；\n写数据库操作：把对数据的修改写到数据库中；\n\n\n为什么要先写日志文件：因为写数据库和写日志文件是两个不同的操作，在这两个操作之间可能发生故障\n\n如果先写了数据库修改，而在日志文件中没有登记下这个修改，则以后就无法恢复这个修改了。\n如果先写日志，但没有修改数据库，按日志文件恢复时只不过是多执行一次不必要的UNDO操作，并不会影响数据库的正确性。\n\n恢复策略\n事务故障的恢复\n事务故障：事务在运行至正常终止点前被终止。\n恢复方法：由恢复子系统利用日志文件撤消此事务已对数据库进行的修改。\n事务故障的恢复由系统自动完成，对用户是透明的，不需要用户干预。\n恢复步骤：\n\n反向扫描文件日志（即从最后向前扫描日志文件），查找该事务的更新操作。\n对该事务的更新操作执行逆操作，即将日志记录中“更新前的值” 写入数据库。\n继续反向扫描日志文件，查找该事务的其他更新操作，并做同样处理。\n如此处理下去，直至读到此事务的开始标记，事务故障恢复就完成了。\n\n系统故障的恢复\n系统故障造成数据库不一致状态的原因：\n\n未完成事务对数据库的更新可能已写入数据库\n已提交事务对数据库的更新可能还留在缓冲区没来得及写入数据库\n\n恢复方法：\n\n撤销故障发生时未完成的事务\n重做已完成的事务\n\n系统故障的恢复由系统在重新启动时自动完成，不需要用户干预。\n恢复步骤：\n\n正向扫描日志文件（即从头扫描日志文件）\n对撤销队列事务进行撤销处理\n对重做队列事务进行重做处理\n\n介质故障的恢复\n恢复方法是重装数据库，然后重做已完成的事务。\n恢复步骤：\n\n\n装入最新的后备数据库副本(离故障发生时刻最近的转储副本) ，使数据库恢复到最近一次转储时的一致性状态。\n对于静态转储的数据库副本，装入后数据库即处于一致性状态。\n对于动态转储的数据库副本，还须同时装入转储时刻的日志文件副本，利用恢复系统故障的方法（即REDO+UNDO），才能将数据库恢复到一致性状态。\n\n\n装入有关的日志文件副本(转储结束时刻的日志文件副本) ，重做已完成的事务。\n首先扫描日志文件，找出故障发生时已提交的事务的标识，将其记入重做队列。\n然后正向扫描日志文件，对重做队列中的所有事务进行重做处理。即将日志记录中“更新后的值”写入数据库。\n\n\n介质故障的恢复需要数据库管理员介入。\n数据库管理员的工作：重装最近转储的数据库副本和有关的各日志文件副本，执行系统提供的恢复命令。\n具有检查点的恢复技术\n利用日志技术恢复数据库时，有两个问题：\n\n搜索整个日志将耗费大量的时间\n重做处理浪费了大量时间\n\n为了解决这些问题，出现了具有检查点的恢复技术。\n具有检查点的恢复技术：\n\n\n在日志文件中增加检查点记录（checkpoint）\n内容包括：建立检查点时刻所有正在执行的事务清单，这些事务最近一个日志记录的地址。\n\n\n增加重新开始文件\n内容包括：记录各个检查点记录在日志文件中的地址。\n\n\n恢复子系统在登录日志文件期间动态地维护日志\n\n\n\n动态维护日志文件的方法：周期性地建立检查点，保存数据库状态。\n具体步骤是：\n\n将当前日志缓冲区中的所有日志记录写入磁盘的日志文件上\n在日志文件中写入一个检查点记录\n将当前数据缓冲区的所有数据记录写入磁盘的数据库中\n把检查点记录在日志文件中的地址写入一个重新开始文件\n\n恢复子系统可以定期或不定期地建立检查点，保存数据库状态\n\n定期：按照预定的一个时间间隔，如每隔一小时建立一个检查点。\n不定期：按照某种规则，如日志文件已写满一半建立一个检查点。\n\n使用检查点方法可以改善恢复效率。\n当事务T在一个检查点之前提交，T对数据库所做的修改已写入数据库。写入时间是在这个检查点建立之前或在这个检查点建立之时 。那么在进行恢复处理时，就没有必要对事务T执行重做操作。\n\n\n\nT1：在检查点之前提交\nT2：在检查点之前开始执行，在检查点之后故障点之前提交\nT3：在检查点之前开始执行，在故障点时还未完成\nT4：在检查点之后开始执行，在故障点之前提交\nT5：在检查点之后开始执行，在故障点时还未完成\n\nT3和T5在故障发生时还未完成，所以予以撤销。\nT2和T4在检查点之后才提交，它们对数据库所做的修改在故障发生时可能还在缓冲区中，尚未写入数据库，所以要重做。\nT1在检查点之前已提交，所以不必执行重做操作。\n\n系统使用检查点方法进行恢复的步骤：\n\n\n从重新开始文件中找到最后一个检查点记录在日志文件中的地址，由该地址在日志文件中找到最后一个检查点记录。\n\n\n由该检查点记录得到检查点建立时刻所有正在执行的事务清单ACTIVE-LIST。\n建立两个事务队列：UNDO-LIST，REDO-LIST。把ACTIVE-LIST暂时放入UNDO-LIST队列，REDO-LIST队列暂为空。\n\n\n从检查点开始正向扫描日志文件，直到日志文件结束。\n如有新开始的事务T_i，把T_i暂时放入UNDO-LIST队列。\n如有提交的事务T_j，把T_j从UNDO-LIST队列移到REDO-LIST队列；直到日志文件结束。\n\n\n对UNDO-LIST中的每个事务执行UNDO操作，对REDO-LIST中的每个事务执行REDO操作。\n\n\n数据库镜像\n介质故障是对系统影响最为严重的一种故障，严重影响数据库的可用性。由于介质故障恢复比较费时，为了预防介质故障，数据库管理员必须周期性地转储数据库。\n提高数据库可用性的解决方案：数据库镜像\n\n数据库管理系统自动把整个数据库或其中的关键数据复制到另一个磁盘上\n数据库管理系统自动保证镜像数据与主数据的一致性，每当主数据库更新时，数据库管理系统自动把更新后的数据复制过去。\n\n\n出现介质故障时，可由镜像磁盘继续提供使用，同时数据库管理系统自动利用镜像磁盘数据进行数据库的恢复，不需要关闭系统和重装数据库副本。\n\n没有出现故障时，可用于并发操作。一个用户对数据加排他锁修改数据，其他用户可以读镜像数据库上的数据，而不必等待该用户释放锁。\n频繁地复制数据自然会降低系统运行效率，因此在实际应用中用户往往只选择对关键数据和日志文件镜像，而不是对整个数据库进行镜像。"},"计算机基础/数据库系统概论/11_并发控制":{"title":"并发控制","links":[],"tags":["数据库"],"content":"允许多个用户同时使用的数据库系统称为多用户数据库系统。例如飞机定票数据库系统，银行数据库系统。它们的特点是在同一时刻并发运行的事务数可达数百上千个 。\n多事务执行方式：\n\n\n事务串行执行\n每个时刻只有一个事务运行，其他事务必须等到这个事务结束以后方能运行。\n不能充分利用系统资源，发挥数据库共享资源的特点。\n\n\n\n交叉并发方式\n在单处理机系统中，事务的并行执行是这些并行事务的并行操作轮流交叉运行。\n单处理机系统中的并行事务并没有真正地并行运行，但能够减少处理机的空闲时间，提高系统的效率。\n\n\n\n同时并发方式\n多处理机系统中，每个处理机可以运行一个事务，多个处理机可以同时运行多个事务，实现多个事务真正的并行运行。\n最理想的并发方式，但受制于硬件环境。\n\n\n并发控制概述\n事务是并发控制的基本单位。\n并发控制机制的任务：\n\n对并发操作进行正确调度\n保证事务的隔离性\n保证数据库的一致性\n\n\n例：飞机订票系统中的一个活动序列：\n\n甲售票点(事务T1)读出某航班的机票余额A，设A=16；\n乙售票点(事务T2)读出同一航班的机票余额A，也为16；\n甲售票点卖出一张机票，修改余额A为15，把A写回数据库；\n乙售票点也卖出一张机票，修改余额A为15，把A写回数据库；\n\n结果明明卖出两张机票，数据库中机票余额只减少1 。\n这种由并发操作引起的情况称为数据库的不一致性。在并发操作情况下，对T1、T2两个事务的操作序列的调度是随机的。\n\n并发操作带来的数据不一致性包括：\n\n\n丢失修改\n两个事务T1和T2读入同一数据并修改，T2的提交结果破坏了T1提交的结果，导致T1的修改被丢失。\n上面飞机订票例子就属此类。\n\n\n不可重复读\n事务T1读取数据后，事务T2执行更新操作，使T1无法再现前一次读取结果。\n不可重复读包括三种情况：\n\n事务T1读取某一数据后，事务T2对其做了修改，当事务T1再次读该数据时，得到与前一次不同的值。\n事务T1按一定条件从数据库中读取了某些数据记录后，事务T2删除了其中部分记录，当T1再次按相同条件读取数据时，发现某些记录消失了。\n事务T1按一定条件从数据库中读取某些数据记录后，事务T2插入了一些记录，当T1再次按相同条件读取数据时，发现多了一些记录。\n\n后两种不可重复读有时也称为幻影现象。\n\n\n读“脏”数据\n事务T1修改某一数据，并将其写回磁盘。事务T2读取同一数据后，T1由于某种原因被撤销。\n这时T1已修改过的数据恢复原值，T2读到的数据就与数据库中的数据不一致，T2读到的数据就为“脏”数据，即不正确的数据。\n\n\n产生这三类数据不一致性的主要原因就是并发操作破坏了事务的隔离性。\n并发控制机制就是要用正确的方式调度并发操作，使一个用户事务的执行不受其他事务的干扰，从而避免造成数据的不一致性。\n对数据库的应用有时允许某些不一致性，可以降低对一致性的要求以减少系统开销。\n并发控制的主要技术有：\n\n封锁\n时间戳\n乐观控制法\n多版本并发控制\n\n封锁\n封锁就是事务T在对某个数据对象（例如表、记录等）操作之前，先向系统发出请求，对其加锁。\n加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其它的事务不能更新此数据对象。\n封锁是实现并发控制的一个非常重要的技术。\n一个事务对某个数据对象加锁后究竟拥有什么样的控制由封锁的类型决定。\n基本封锁类型：\n\n\n排它锁（Exclusive Locks，简记为X锁）\n又称为写锁。\n若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。\n保证其他事务在T释放A上的锁之前不能再读取和修改A。\n\n\n共享锁（Share Locks，简记为S锁）\n又称为读锁。\n若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其它事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。\n保证其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。\n\n\n\n\n最左边一列表示事务T1已经获得的数据对象上的锁的类型，其中横线表示没有加锁。最上面一行表示另一事务T2对同一数据对象发出的封锁请求。\nT2的封锁请求能否被满足用矩阵中的Y和N表示，\n\nY表示事务T2的封锁要求与T1已持有的锁相容，封锁请求可以满足\nN表示T2的封锁请求与T1已持有的锁冲突，T2的请求被拒绝\n\n封锁协议\n在运用X锁和S锁对数据对象加锁时，需要约定一些规则，这些规则为封锁协议。 例如：何时申请X锁或S锁，持锁时间，何时释放。\n对封锁方式规定不同的规则，就形成了各种不同的封锁协议，它们分别在不同的程度上为并发操作的正确调度提供一定的保证。\n三级封锁协议：\n\n\n一级封锁协议\n事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。\n一级封锁协议可防止丢失修改，并保证事务T是可恢复的。\n在一级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，所以它不能保证可重复读和不读“脏”数据。\n\n\n二级封锁协议\n一级封锁协议的基础上增加事务T在读取数据R之前必须先对其加S锁，读完后即可释放S锁。\n可以防止丢失修改和读“脏”数据，但由于读完数据后即可释放S锁，所以它不能保证可重复读。\n\n\n三级封锁协议\n一级封锁协议的基础上增加事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。\n可防止丢失修改、读脏数据和不可重复读。\n\n\n三级协议的主要区别在于什么操作需要申请封锁以及何时释放锁（即持锁时间）。\n不同的封锁协议使事务达到的一致性级别不同，封锁协议级别越高，一致性程度越高。\n\n活锁和死锁\n封锁技术可以有效地解决并行操作的一致性问题，但也带来死锁和活锁等问题。\n活锁\n事务T1封锁了数据R，事务T2又请求封锁R，于是T2等待。T3也请求封锁R，当T1释放了R上的封锁之后系统首先批准了T3的请求，T2仍然等待。T4又请求封锁R，当T3释放了R上的封锁之后系统又批准了T4的请求……\nT2有可能永远等待，这就是活锁的情形。\n采用先来先服务的策略来避免活锁。当多个事务请求封锁同一数据对象时，按请求封锁的先后次序对这些事务排队，该数据对象上的锁一旦释放，首先批准申请队列中第一个事务获得锁。\n死锁\n事务T1封锁了数据R1，T2封锁了数据R2。T1又请求封锁R2，因T2已封锁了R2，于是T1等待T2释放R2上的锁。接着T2又申请封锁R1，因T1已封锁了R1，T2也只能等待T1释放R1上的锁。\n这样T1在等待T2，而T2又在等待T1，T1和T2两个事务永远不能结束，形成死锁。\n解决死锁的两类方法：\n\n\n死锁的预防\n产生死锁的原因是两个或多个事务都已封锁了一些数据对象，然后又都请求对已为其他事务封锁的数据对象加锁，从而出现死等待。\n预防死锁的发生就是要破坏产生死锁的条件。\n预防死锁的方法：\n\n\n一次封锁法\n要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行。\n存在的问题：\n\n\n降低系统的并发度\n\n\n难于事先精确确定封锁对象\n数据库中数据是不断变化的，原来不要求封锁的数据，在执行过程中可能会变成封锁对象。\n\n\n\n\n顺序封锁法\n预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁。\n存在的问题：\n\n\n维护成本\n数据库系统中封锁的数据对象极多，并且不断地变化，要维护这样的资源的封锁顺序非常困难，成本很高。\n\n\n难以实现\n事务的封锁请求可以随着事务的执行而动态地决定，很难事先确定每一个事务要封锁哪些对象，因此也就很难按规定的顺序去施加封锁。\n\n\n\n\n\n\n死锁的诊断与解除\n死锁的诊断：\n\n\n超时法\n如果一个事务的等待时间超过了规定的时限，就认为发生了死锁。\n优点：实现简单。\n缺点：有可能误判死锁；时限若设置得太长，死锁发生后不能及时发现。\n\n\n等待图法\n用事务等待图动态反映所有事务的等待情况。\n并发控制子系统周期性地（比如每隔数秒）生成事务等待图，检测事务。如果发现图中存在回路，则表示系统中出现了死锁。\n事务等待图是一个有向图G=(T，U)，T为结点的集合，每个结点表示正运行的事务，U为边的集合，每条边表示事务等待的情况。若T1等待T2，则T1，T2之间划一条有向边，从T1指向T2。\n\n\n\n\n\n解除死锁：选择一个处理死锁代价最小的事务，将其撤消，释放此事务持有的所有的锁，使其它事务能继续运行下去。\n\n\n并发调度的可串行性\n数据库管理系统对并发事务不同的调度可能会产生不同的结果。\n可串行化调度\n多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同，称这种调度策略为可串行化调度。\n可串行性是并发事务正确调度的准则。按照这个准则，一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度。\n\n例：\n现在有两个事务，分别包含下列操作：\n\n事务T1：读B；A=B+1；写回A\n事务T2：读A；B=A+1；写回B\n\n现给出对这两个事务不同的调度策略\n\n\n\n\n\n\n\n\n冲突可串行化调度\n冲突操作是指不同的事务对同一数据的读写操作和写写操作，除了读写和写写操作，其他操作是不冲突操作。\n不同事务的冲突操作和同一事务的两个操作是不能交换的。\n一个调度Sc在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度Sc’，如果Sc’是串行的，称调度Sc是冲突可串行化的调度。\n\n若一个调度是冲突可串行化，则一定是可串行化的调度。可用这种方法判断一个调度是否是冲突可串行化的。\n冲突可串行化调度是可串行化调度的充分条件，不是必要条件。还有不满足冲突可串行化条件的可串行化调度。\n\n两段锁协议\n数据库管理系统普遍采用两段锁协议的方法实现并发调度的可串行性，从而保证调度的正确性。\n两段锁协议：指所有事务必须分两个阶段对数据项加锁和解锁\n\n在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁。\n在释放一个封锁之后，事务不再申请和获得任何其他封锁。\n\n“两段”锁的含义：事务分为两个阶段\n\n\n第一阶段是获得封锁，也称为扩展阶段\n事务可以申请获得任何数据项上的任何类型的锁，但是不能释放任何锁。\n\n\n第二阶段是释放封锁，也称为收缩阶段\n事务可以释放任何数据项上的任何类型的锁，但是不能再申请任何锁。\n\n\n事务遵守两段锁协议是可串行化调度的充分条件，而不是必要条件。\n若并发事务都遵守两段锁协议，则对这些事务的任何并发调度策略都是可串行化的。若并发事务的一个调度是可串行化的，不一定所有事务都符合两段锁协议。\n两段锁协议与防止死锁的一次封锁法的区别：\n\n一次封锁法要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行，因此一次封锁法遵守两段锁协议。\n两段锁协议并不要求事务必须一次将所有要使用的数据全部加锁，因此遵守两段锁协议的事务可能发生死锁。\n\n封锁的粒度\n封锁对象的大小称为封锁粒度。\n封锁的对象：逻辑单元，物理单元。\n封锁粒度与系统的并发度和并发控制的开销密切相关。\n\n封锁的粒度越大，数据库所能够封锁的数据单元就越少，并发度就越小，系统开销也越小。\n封锁的粒度越小，并发度较高，但系统开销也就越大。\n\n选择封锁粒度应该同时考虑封锁开销和并发度两个因素，适当选择封锁粒度。例如：\n\n需要处理多个关系的大量元组的用户事务：以数据库为封锁单位\n需要处理大量元组的用户事务：以关系为封锁单元\n需要处理少量元组的用户事务：以元组为封锁单位\n\n多粒度封锁\n多粒度封锁是在一个系统中同时支持多种封锁粒度供不同的事务选择。\n多粒度树：以树形结构来表示多级封锁粒度；根结点是整个数据库，表示最大的数据粒度；叶结点表示最小的数据粒度。\n\n多粒度封锁中允许多粒度树中的每个结点被独立地加锁。对一个结点加锁意味着这个结点的所有后裔结点也被加以同样类型的锁。\n在多粒度封锁中一个数据对象可能以两种方式封锁：\n\n显式封锁：直接加到数据对象上的封锁\n隐式封锁：是该数据对象没有独立加锁，是由于其上级结点加锁而使该数据对象加上了锁\n\n显式封锁和隐式封锁的效果是一样的。\n系统检查封锁冲突时，不仅要检查显式封锁，还要检查隐式封锁。\n对某个数据对象加锁，系统要检查\n\n\n该数据对象有无显式封锁与之冲突\n\n\n所有上级结点\n检查本事务的显式封锁是否与该数据对象上的隐式封锁冲突：(由上级结点已加的封锁造成的）。\n\n\n所有下级结点\n看上面的显式封锁是否与本事务的隐式封锁（将加到下级结点的封锁）冲突。\n\n\n意向锁\n引进意向锁目的是提高对某个数据对象加锁时系统的检查效率。\n如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁。\n对任一结点加基本锁，必须先对它的上层结点加意向锁。例如，对任一元组加锁时，必须先对它所在的数据库和关系加意向锁 。\n常用的意向锁：\n\n\n意向共享锁 (Intent Share Lock，简称IS锁)\n如果对一个数据对象加IS锁，表示它的后裔结点拟（意向）加S锁。\n例如：事务T1要对R1中某个元组加S锁，则要首先对关系R1和数据库加IS锁。\n\n\n意向排它锁 (Intent Exclusive Lock，简称IX锁)\n如果对一个数据对象加IX锁，表示它的后裔结点拟（意向）加X锁。\n例如：事务T1要对R1中某个元组加X锁，则要首先对关系R1和数据库加IX锁 。\n\n\n共享意向排它锁 (Share Intent Exclusive Lock，简称SIX锁)\n如果对一个数据对象加SIX锁，表示对它加S锁，再加IX锁。\n例：对某个表加SIX锁，则表示该事务要读整个表（所以要对该表加S锁），同时会更新个别元组（所以要对该表加IX锁）。\n\n\n\n锁的强度是指它对其他锁的排斥程度。一个事务在申请封锁时以强锁代替弱锁是安全的，反之则不然。\n\n具有意向锁的多粒度封锁方法，申请封锁时应该按自上而下的次序进行，释放封锁时则应该按自下而上的次序进行。\n具有意向锁的多粒度封锁方法，提高了系统的并发度，减少了加锁和解锁的开销，在实际的数据库管理系统产品中得到广泛应用。"},"计算机基础/数据库系统概论/1_绪论":{"title":"绪论","links":[],"tags":["数据库"],"content":"数据库系统概述\n数据库的 4 个基本概念\n\n\n数据（Data）\n数据是数据库中存储的基本对象。数据的含义称为数据的语义，数据与其语义是不可分的。\n定义：描述事物的符号记录。\n种类：数字、文字、图形、图像、音频、视频（可以经过数字化后存入计算机）。\n\n\n\n数据库（Database，DB）\n数据库是长期储存在计算机内、有组织的、可共享的大量数据的集合。数据库具有永久存储、有组织、可共享三个特点。\n基本特征：\n\n数据按一定的数据模型组织、描述和储存\n可为各种用户共享\n冗余度较小\n数据独立性较高\n易扩展\n\n\n\n\n数据库管理系统（DataBase Managerment System，DBMS）\n数据库管理系统是位于用户与操作系统之间的一层数据管理软件。与操作系统一样是计算机的基础软件，是一个大型复杂的软件系统。\n主要功能：\n\n\n数据定义功能\n用户通过 DBMS 提供的数据定义语言（Data Definition Language，DDL）可以方便地对数据库中的数据对象进行定义。\n\n\n数据组织、存储和管理\nDBMS 要分类组织、存储和管理各种数据。要确定组织数据的文件结构和存取方式，实现数据之间的联系。\n数据组织和存储的基本目标：\n\n提高存储空间利用率和方便存取\n提供多种存取方法提高存取效率\n\n\n\n数据操纵功能\n用户通过 DBMS 提供的数据操纵语言（Data Manipulation Language，DML）操纵数据，实现对数据库的基本操作 （查询、插入、删除和修改等）。\n\n\n数据库的事务管理和运行管理\n\n数据库在建立、运行和维护时由数据库管理系统统一管理和控制\n保证数据的安全性、完整性、多用户对数据的并发使用\n发生故障后的系统恢复\n\n\n\n数据库的建立和维护功能\n\n数据库初始数据的装载和转换\n数据库转储、恢复功能\n数据库的重组织\n性能监视、分析等\n\n\n\n\n\n\n数据库系统（Database System，DBS）\n数据库系统的构成：\n\n\n数据库\n\n\n数据库管理系统\n\n\n应用程序\n\n\n数据库管理员\n\n\n\n\n\n数据管理技术的产生和发展\n\n\n人工管理阶段\n20 世纪 50 年代中之前\n特点：\n\n数据不保存\n应用程序管理数据\n数据不共享\n数据不具有独立性\n\n缺点：数据的逻辑结构或物理结构发生变化后，必须对应用程序作相应的修改，数据完全依赖于应用程序，称之为数据缺乏独立性，加重了程序员的负担。\n\n\n\n文件系统阶段\n20 世纪 50 年代末—60 年代中\n特点：\n\n数据可以长期保存\n有文件系统管理数据\n\n缺点：\n\n数据共享性差，冗余度大\n数据独立性差\n\n\n\n\n数据库系统阶段\n20 世纪 60 年代末—现在\n特点：\n\n数据结构化\n数据的共享性高，冗余度低，易扩充\n数据的独立性高\n数据右 DBMS 统一管理和控制\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n人工管理阶段文件系统阶段数据库系统阶段应用背景科学计算科学计算、数据管理大规模数据管理硬件背景无直接存取存储设备磁盘、磁鼓大容量磁盘、磁盘阵列软件背景没有操作系统有文件系统有数据库管理系统处理方式批处理联机实时处理，批处理联机实时处理、分布处理、批处理数据的管理者用户（程序员）文件系统数据库管理系统数据面向的对象某一应用程序某一应用现实世界（部门、企业、国家）数据的共享程度无共享，冗余度极大共享性差，冗余度大共享性高，冗余度小数据的独立性不独立，完全依赖于应用程序独立性差具有高度的物理独立性和一定的逻辑独立性数据的结构化无结构记录内有结构，整体无结构整体结构化，用数据模型描述数据的控制能力应用程序自己控制应用程序自己控制由据库管理系统提供数据安全性、完整性、并发控制和恢复能力\n数据库系统的特点\n\n\n数据结构化\n整体数据的结构化是数据库的主要特征之一，也是数据库系统与文件系统的本质区别。\n整体结构化：\n\n不再仅仅针对某一个应用，而是面向全组织\n不仅数据内部结构化，整体是结构化的，数据之间具有联系\n数据记录可以变长\n数据的最小存取单位是数据项\n\n\n\n数据的共享性高，冗余度低且易扩充\n\n可以减少数据冗余，节约存储空间\n避免数据之间的不相容性与不一致性\n使系统易于扩充\n\n\n\n数据独立性高\n数据独立性是借助数据库管理数据的一个显著优点。\n数据独立性包括：\n\n物理独立性：用户的应用程序与数据库中数据的物理存储是相互独立的。即当数据的物理存储改变了，应用程序不用改变。\n逻辑独立性：用户的应用程序与数据库的逻辑结构是相互独立的。即数据的逻辑结构改变了，应用程序不用改变。\n\n\n\n数据由数据库管理系统统一管理和控制\n\n\n数据的安全性保护\n保护数据以防止不合法的使用造成的数据的泄密和破坏。\n\n\n数据的完整性检查\n保证数据的正确性、有效性和相容性。\n\n\n并发控制\n对多用户的并发操作加以控制和协调，防止相互干扰而得到错误的结果。\n\n\n数据库恢复\n将数据库从错误状态恢复到某一已知的正确状态。\n\n\n\n\n数据模型\n数据模型是对现实世界数据特征的抽象。通俗地讲数据模型就是现实世界的模拟。\n数据模型是数据库系统的核心和基础。\n\n数据模型应满足三方面要求：\n\n能比较真实地模拟现实世界\n容易为人所理解\n便于在计算机上实现\n\n两类数据模型\n根据模型应用的不同目的，数据模型分为两类（两个不同的层次）：\n\n\n概念模型\n也称信息模型，它是按用户的观点来对数据和信息建模，主要用于数据库设计。\n\n\n逻辑模型和物理模型\n\n逻辑模型主要包括网状模型、层次模型、关系模型、面向对象数据模型、对象关系数据模型、半结构化数据模型等。按计算机系统的观点对数据建模，主要用于 DBMS 实现。\n物理模型是对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法，或在磁盘或磁带上的存储方式和存取方法，是面向计算机系统的。\n\n\n\n概念模型\n概念模型是现实世界到机器世界的一个中间层次，表现为：\n\n概念模型用于信息世界的建模\n现实世界到信息世界的第一层抽象\n数据库设计人员进行数据库设计的有力工具\n数据库设计人员和用户之间进行交流的语言\n\n\n概念模型的基本要求：\n\n较强的语义表达能力\n能够方便直接地表达应用中的各种语义知识\n简单、清晰、易于用户理解\n\n信息世界中的基本概念\n\n\n实体（Entity）\n客观存在并可相互区别的事物称为实体。可以是具体的人、事、物或抽象的概念。\n\n\n属性（Attribute）\n实体所具有的某一特性称为属性。一个实体可以由若干个属性来刻画。\n\n\n码（Key）\n唯一标识实体的属性集称为码。\n\n\n域（Domain）\n域是一组具有相同数据类型的值的集合。属性的取值范围来自某个域。\n\n\n实体型（Entity Type）\n用实体名及其属性名集合来抽象和刻画同类实体称为实体型。\n\n\n实体集（Entity Set）\n同一类型实体的集合称为实体集。\n\n\n联系（Relationship）\n现实世界中，事物内部以及事物之间的联系在信息世界中反映为实体（型）内部的联系和实体（型）之间的联系。\n\n实体内部的联系：通常指组成实体的各属性之间的联系。\n实体之间的联系：通常指不同实体集之间的联系。\n\n两个实体之间之间一对一、一对多和多对多的联系。\n两个以上的实体之间也存在一对一、一对多和多对多的联系。\n同一个实体集内的各实体之间也可以存在一对一、一对多和多对多的联系。\n\n\n\n\n\n概念模型的表示方法\n实体-联系方法（Entity-Relationship Approach），该方法用 E-R 图来描述概念模型。E-R 方法也被称为 E-R 模型。\nE-R 图提供了表示是实体型、属性和联系的方法。\n\n实体型：用矩形表示。\n属性：用椭圆形表示。\n联系：用菱形表示。\n\n\n数据模型的组成要素\n数据模型通常由数据结构、数据操作、数据的完整性约束条件三部分组成。\n\n\n数据结构\n描述数据库的组成对象，以及对象之间的联系。\n数据结构是对系统静态特性的描述。描述的内容有两类：\n\n与对象的类型、内容、性质有关；\n与数据之间联系有关；\n\n\n\n\n数据操作\n对数据库中各种对象（型）的实例（值）允许执行的操作的集合，包括操作及有关的操作规则。\n主要有查询和更新（包括插入、删除、修改）两大类操作。\n数据操作是对系统动态特性的描述。\n\n\n\n数据的完整性约束条件\n数据的完整性约束条件是一组完整性规则的集合。\n完整性规则：给定的数据模型中数据及其联系所具有的制约和依存规则。\n::: info 数据模型对完整性约束条件的定义\n\n反映和规定必须遵守的基本的通用的完整性约束条件。\n提供定义完整性约束条件的机制，以反映具体应用所涉及的数据必须遵守的特定的语义约束条件。\n\n:::\n\n\n常用的数据模型\n\n层次模型（Hierarchical Model）\n网状模型（Network Model）\n关系模型（Relational Model)）\n面向对象数据模型（Object Oriented Data Model）\n对象关系数据模型（Object Relational Data Model）\n半结构化数据模型（SemistrutureData Model）\n\n\n其中，层次模型和网状模型是非关系模型\n\n层次模型\n层次模型是数据库系统中最早出现的数据模型。层次模型用树形结构来表示各类实体以及实体间的联系，如行政机构和家族关系等。\n\n\n层次模型的数据结构\n满足：\n\n\n有且只有一个结点没有双亲结点，这个结点称为根结点；\n\n\n根以外的其它结点有且只有一个双亲结点；\n\n\n在层次模型中，每个结点表示一个记录类型，每个记录类型可包含若干个字段，记录类型之间的联系用结点之间的连线（有向边）表示。\n特点：\n\n只有一个双亲结点\n只能处理一对多的实体联系\n每个记录类型可以定义一个排序字段，也称为码字段\n任何记录值只有按其路径查看时，才能显出它的全部意义\n没有一个子女记录值能够脱离双亲记录值而独立存在\n\n\n\n\n\n\n层次模型的数据操纵\n主要有查询、插入、删除、更新。进行操作时要满足层次模型的完整性约束条件。\n\n\n层次模型的完整性约束条件\n\n无相应的双亲结点值就不能插入子女结点值\n删除双亲结点值时，删除相应的子女结点\n更新操作时，应更新所有相应记录，以保证数据的一致性\n\n\n\n层次模型的优点：\n\n数据结构比较简单清晰\n查询效率高，性能优于关系模型，不低于网状模型\n提供了良好的完整性支持\n\n\n\n层次模型的缺点：\n\n结点之间的多对多联系表示不自然\n对插入和删除操作的限制多，应用程序的编写比较复杂\n查询子女结点必须通过双亲结点\n层次命令趋于程序化\n\n\n\n\n网状模型\n网状数据库系统采用网状模型作为数据的组织方式。网状模型是一种比层次模型更具普遍性的结构。\n\n\n网状模型的数据结构\n满足：\n\n允许一个以上的结点无双亲；\n一个结点可以有多于一个的双亲；\n\n网状模型的表示方法与层次数据模型相同。\n::: info 网状模型与层次模型的区别\n\n网状模型允许多个结点没有双亲结点\n网状模型允许结点有多个双亲结点\n网状模型允许两个结点之间有多种联系（复合联系）\n网状模型可以更直接地描述现实世界\n层次模型实际上是网状模型的一个特例\n\n:::\n可以使用网状模型间接表示多对多联系，方法是将多对多联系直接分解成一对多联系。例如学生与课程之间是多对多联系。\n\n\n\n网状模型的数据操纵与完整性约束\n网状数据库系统对数据操纵加了一些限制，提供了一定的完整性约束。\n\n支持记录码（码：唯一标识记录的数据项的集合）\n一个联系中双亲记录与子女记录之间是一对多联系\n支持双亲记录和子女记录之间某些约束条件\n\n\n\n网状模型的优点\n\n能够更为直接地描述现实世界，如一个结点可以有多个双亲\n具有良好的性能，存取效率较高\n\n\n\n网状模型的缺点\n\n结构比较复杂，，不利于最终用户掌握\n语言复杂，用户不容易使用\n记录之间联系是通过存取路径实现的，用户必须了解系统结构的细节\n\n\n\n\n关系模型\n关系数据库系统采用关系模型作为数据的组织方式。\n\n\n关系模型的数据结构\n\n\n关系（Relation）\n一个关系对应通常说的一张表。\n\n\n元组（Tuple）\n表中的一行即为一个元组。\n\n\n属性（Attribute）\n表中的一列即为一个属性，给每一个属性起一个名称即属性名。\n\n\n码（Key）\n也称码键。表中的某个属性组，它可以唯一确定一个元组。\n\n\n域（Domain）\n是一组具有相同数据类型的值的集合。属性的取值范围来自某个域。\n\n\n分量\n元组中的一个属性值。\n\n\n关系模式\n对关系的描述，一般表示为：关系名（属性 1，属性 2，…，属性 n），例如：学生（学号，姓名，年级）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n关系术语一般表格的术语关系名表名关系模式表头（表格的描述）关系（一张）二维表元组记录或行属性列属性名列名属性值列值分量一条记录中的一个列值非规范关系表中有表（大表中嵌有小表）\n\n\n关系必须是规范化的，即关系关系满足一定的规范条件。\n最基本的规范条件：关系的每一个分量必须是一个不可分的数据项，不允许表中还有表。\n\n\n\n关系模型的数据操纵与完整性约束\n关系模型的数据操作是集合操作，操作对象和操作结果都是关系。\n关系模型的数据操纵主要包括查询、插入、删除和更新数据。这些数据操作必须满足关系的完整性约束条件。\n关系的完整性约束条件包括：\n\n实体完整性\n参照完整性\n用户定义的完整性\n\n\n\n关系模型的优点：\n\n建立在严格的数学概念的基础上\n概念单一\n\n实体和各类联系都用关系来表示\n对数据的检索结果也是关系\n\n\n关系模型的存取路径对用户透明\n\n具有更高的数据独立性，更好的安全保密性\n简化了程序员的工作和数据库开发建立的工作\n\n\n\n\n\n关系模型的缺点：\n\n查询效率往往不如格式化数据模型\n为提高性能，必须对用户的查询请求进行优化，增加了开发数据库管理系统的难度\n\n\n\n数据库系统的结构\n\n从开发人员角度看，数据库系统通常采用三级模式结构，是数据库系统内部的系统结构。\n从数据库最终用户角度看，数据库系统的结构分为：单用户结构、主从式结构、分布式结构、客户-服务器、浏览器-应用服务器／数据库服务器多层结构等。\n\n数据库系统模式的概念\n\n型（Type）：对某一类数据的结构和属性的说明；\n值（Value）：是型的一个具体赋值；\n模式（Schema）：数据库中全体数据的逻辑结构和特征的描述，仅涉及型的描述，不涉及具体值。\n实例（Instance）：模式的一个具体值，同一个模式可以有很多实例，实例随数据库中的数据的更新而变动。\n\n数据库系统的三级模式结构\n数据库系统的三级模式结构是模式、外模式、内模式。\n\n\n\n模式\n模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。\n模式处于数据库系统模式结构的中间层，与数据的物理存储细节和硬件环境无关，与具体的应用程序、开发工具及高级程序设计语言无关。\n一个数据库只有一个模式。\n\n数据库模式是全局逻辑结构是数据库的中心与关键，独立于数据库的其他层次。设计数据库模式结构时应首先确定数据库的逻辑模式。\n\n\n\n\n外模式\n外模式也称子模式或用户模式，是数据库用户（包括程序员和最终用户）使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。\n\n\n外模式通常是模式的子集，一个数据库可以有多个外模式；\n\n\n同一外模式也可以为某一用户的多个应用系统所使用，但一个应用只能使用一个外模式；\n\n\n\n数据库的外模式面向具体的应用程序，定义在逻辑模式之上，独立于存储模式和存储设备。当应用需求发生较大变化，相应外模式不能满足其视图要求时，该外模式就得做相应改动。\n\n\n\n\n内模式\n内模式也称存储模式，是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式。\n一个数据库只有一个内模式。\n\n数据库的内模式依赖于它的全局逻辑结构，独立于数据库的用户视图（外模式），独立于具体的存储设备。它将全局逻辑结构中所定义的数据结构及其联系按照一定的物理存储策略进行组织，以达到较好的时间与空间效率。\n\n\n\n数据库的二级映像功能与数据独立性\n数据库系统的三级模式是对数据的三个抽象级别。\n二级映象在数据库管理系统内部实现这三个抽象层次的联系和转换，分别是：\n\n\n模式／内模式映像\n模式／内模式映象定义了数据全局逻辑结构与存储结构之间的对应关系。\n映象定义通常包含在模式描述中。\n模式／内模式映象是唯一的。\n\n\n外模式／模式映像\n模式描述的是数据的全局逻辑结构，外模式描述的是数据的局部逻辑结构，同一个模式可以有任意多个外模式。\n对于每一个外模式，数据库系统都有一个外模式／模式映象，定义外模式与模式之间的对应关系。\n映象定义通常包含在各自外模式的描述中。\n\n\n数据库的二级映像保证了数据库外模式的稳定性，从底层保证了应用程序的稳定性，除非应用需求本身发生变化，否则应用程序一般不需要修改。\n数据库系统的组成\n数据库系统一般由数据库、数据库管理系统（及其开发工具）、应用程序、数据库管理员构成。\n\n\n硬件平台及数据库\n硬件资源的要求：\n\n足够大的内存（放系统）\n足够的大的磁盘或磁盘阵列等设备（放数据）\n较高的通道能力（提高数据传送率）\n\n\n\n软件\n数据库系统的软件主要包括：\n\nDBMS（数据库管理系统）\n操作系统（支持 DBMS）\n高级语言及编译系统（开发程序）\n应用开发工具\n数据库应用系统\n\n\n\n人员\n主要包括：\n\n\n数据库管理员\n职责：决定数据库中的信息内容和结构，决定数据库的存储结构和存取策略，定义数据的安全性要求和完整性约束条件，监控数据库的使用和运行，数据库的改进和重组。\n\n\n系统分析员\n职责：负责应用系统的需求分析和规范说明，与用户及数据库管理员结合，确定系统的硬软件配置，参与数据库系统的概要设计。\n\n\n数据库设计人员\n职责：参加用户需求调查和系统分析，确定数据库中的数据，设计数据库各级模式。\n\n\n应用程序员\n职责：设计和编写应用系统的程序模块，进行调试和安装。\n\n\n最终用户\n通过应用系统的用户接口使用数据库。\n\n\n\n\n"},"计算机基础/数据库系统概论/2_关系数据库":{"title":"关系数据库","links":[],"tags":["数据库"],"content":"关系数据结构及形式化定义\n关系\n关系模型：\n\n数据结构：关系\n逻辑结构：二维表\n建立在集合代数的基础上y\n\n域\n域是一组具有相同数据类型的值的集合。例如整数、实数、指定长度的字符串集合等。\n\n笛卡尔积\n给定一组域D_1,D_2,D_3,\\cdots,D_n，允许其中某些域是相同的。D_1,D_2,D_3,\\cdots,D_n的笛卡尔积为\nD_1\\times D_2\\times D_3\\times \\cdots\\times D_n=\\{ (d_1,d_2,d_3,\\cdots,d_n)|d_i\\in D_i,i=1,2,\\cdots,n \\}\n\n表示的是所有域的所有取值的一个组合。\n::: info 相关概念\n\n\n元组（Tuple）：笛卡尔积中每一个元素(d_1,d_2,d_3,\\cdots,d_n)叫作一个n元组（n-tuple）或简称元组。\n\n\n分量（Component）：笛卡尔积元素(d_1,d_2,d_3,\\cdots,d_n)中的每一个值d_i叫作一个分量。\n\n\n基数（Cardinal number）：若D_i(i=1,2,\\cdots,n)为有限集，其基数m_i(i=1,2,\\cdots,n)的值为D_i的值的个数，则D_1\\times D_2\\times  \\cdots\\times D_n的基数为\nM=\\prod_{i=1}^{n}m_i\n\n\n\n:::\n笛卡尔积可表示为一张二维表，表中的每行对应一个元组，表中的每列对应一个域。\n\n\n\n在上图中，\n\n(张清玫，计算机专业，李勇)、(张清玫，计算机专业，刘晨)等都是元组；\n张清玫、计算机专业、李勇、刘晨等都是分量。\n\n关系\nD_1\\times D_2\\times  \\cdots\\times D_n的子集叫做在域D_1,D_2,\\cdots,D_n上的关系，表示为R(D_1,D_2,\\cdots,D_n)。\n\nR：关系名；\nn：关系的目或度；\n\n关系是一个二维表，表的每行对应一个元组（通常用t表示），表的每列对应一个域。\n当n=1时，称该关系为单元关系或一元关系；当n=2时，称该关系为二元关系；\n由于域可以相同，为了加以区分，必须对每列起一个名字，称为属性。n目关系必有n个属性。\n若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为候选码。候选码的诸属性称为主属性。不包含在任何侯选码中的属性称为非主属性或非码属性。\n若关系模式的所有属性组是这个关系模式的候选码，称为全码。若一个关系有多个候选码，则选定其中一个为主码。\n::: tip\n笛卡尔积的某个子集才有实际含义。\n:::\n三类关系：\n\n\n基本关系（基本表或基表）\n实际存在的表，是实际存储数据的逻辑表示。\n\n\n查询表\n查询结果对应的表。\n\n\n视图表\n由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据。\n\n\n\n基本关系的性质：\n\n\n列是同质的\n每一列中的分量是同一类型的数据，来自同一个域。\n\n\n不同的列可出自同一个域\n其中的每一列称为一个属性，不同的属性要给予不同的属性名。\n\n\n列的顺序无所谓,\n列的次序可以任意交换。\n\n\n任意两个元组的候选码不能相同\n\n\n行的顺序无所谓\n即行的次序可以任意交换。\n\n\n分量必须取原子值\n即每一个分量必须是不可分的数据项。这是规范条件中最基本的一条。\n\n\n\n关系模式\n关系数据库中，关系模式是型，关系是值。\n关系模式是对关系的描述，关系是元组的集合。\n关系模式可以形式化地表示为：R（U，D，DOM，F）\n\nR：关系名\nU：组成该关系的属性名集合\nD：U中属性所来自的域\nDOM：属性向域的映象集合\nF：属性间数据的依赖关系的集合\n\n关系模式通常可以简记为R (U) 或R (A1，A2，…，An)\n\nR：关系名\nAn：属性名\n\n关系是关系模式在某一时刻的状态或内容，关系模式和关系往往笼统称为关系，通过上下文加以区别\n\n关系模式是静态的、稳定的。\n关系是动态的、随时间不断变化的。\n\n关系数据库\n关系数据库：在一个给定的应用领域中，所有关系的集合构成一个关系数据库。\n关系数据库的型：也称关系数据库模式，是对关系数据库的描述。\n关系数据库的值：关系模式在某一时刻对应的关系的集合，通常称为关系数据库。\n关系模型的存储结构\n有的关系数据库管理系统中一个表对应一个操作系统文件，将物理数据组织交给操作系统完成。\n有的关系数据库管理系统从操作系统那里申请若干个大的文件，自己划分文件空间，组织表、索引等存储结构，并进行存储管理。\n关系操作\n常用的关系操作\n\n查询：选择、投影、连接、除、并、差、交、笛卡尔积。其中选择、投影、并、差、笛卡尔积是5种基本操作。\n更新：插入、删除、修改\n\n关系操作的特点：操作的对象和结果都是集合，一次一集合的方式。\n关系数据库语言的分类\n\n\n关系代数语言\n用对关系的运算来表达查询要求。代表：ISBL\n\n\n关系演算语言\n用谓词来表达查询要求。\n\n\n元组关系演算语言\n谓词变元的基本对象是元组变量。代表：APLHA，QUEL。\n\n\n域关系演算语言\n谓词变元的基本对象是域变量。代表：QBE。\n\n\n\n\n具有关系代数和关系演算双重特点的语言\n代表：SQL。\n\n\n关系的完整性\n关系模型中有三类完整性约束：实体完整性，参照完整性，用户定义的完整性。\n其中，实体完整性和参照完整性是关系模型必须满足的完整性约束条件，称为关系的两个不变性。\n实体完整性\n若属性A是基本关系R的主属性，则属性A不能取空值。空值就是“不知道”或“不存在”或“无意义”的值。\n\n\n实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。\n\n\n现实世界中的实体是可区分的，即它们具有某种唯一性标识。\n\n\n关系模型中以主码作为唯一性标识。\n\n\n主码中的属性即主属性不能取空值。\n主属性取空值，就说明存在某个不可标识的实体，即存在不可区分的实体，这与第2点相矛盾，因此这个规则称为实体完整性。\n\n\n参照完整性\n关系间的引用\n在关系模型中实体及实体间的联系都是用关系来描述的，自然存在着关系与关系间的引用。\n\n外码\n设F是基本关系R的一个或一组属性，但不是关系R的码。如果F与基本关系S的主码Ks相对应，则称F是R的外码。\n\n基本关系R称为参照关。\n基本关系S称为被参照关系或目标关系。\n\n\n\n关系R和S不一定是不同的关系；\n目标关系S的主码Ks和参照关系的外码F必须定义在同一个（或一组）域上；\n外码并不一定要与相应的主码同名。当外码与相应的主码属于不同关系时，往往取相同的名 字，以便于识别；\n\n参照完整性规则\n若属性（或属性组）F是基本关系R的外码，它与基本关系S的主码Ks相对应（基本关系R和S不一定是不同的关系），则对于R中每个元组在F上的值必须为：\n\n或者取空值（F的每个属性值均为空值）\n或者等于S中某个元组的主码值\n\n\n\n用户定义的完整性\n针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求。\n关系模型应提供定义和检验这类完整性的机制，以便用统一的系统的方法处理它们，而不需由应用程序承担这一功能。\n关系代数\n关系代数是一种抽象的查询语言，它用对关系的运算来表达查询。\n关系代数的运算对象是关系，运算结果亦为关系。\n关系代数的运算按运算符的符的不同可分为传统的集合运算和专门的关系运算。\n\n传统的集合运算\n\n\n并\n关系R和S具有相同的目n（即两个关系都有n个属性），相应的属性取自同一个域。\n表示为：R\\cup S = \\{t|t\\in R\\vee t\\in S\\}\n\n\n\n差\n关系R和S具有相同的目n，相应的属性取自同一个域。\n表示为：R-S = \\{t|t\\in R\\vee t\\notin S\\}\n\n\n\n交\n关系R和S具有相同的目n，相应的属性取自同一个域。\n表示为：R\\cap S = \\{t|t\\in R\\wedge t\\in S\\}\n\n\n\n笛卡尔积\n严格地讲应该是广义的笛卡尔积。\nR：n目关系，k_1个元组\nS：m目关系，k_2个元组\nR与S的笛卡尔积表示为：\n\n\n\n\n专门的关系运算\n相关记号说明\n\n\nR，t\\inR，t[A_i]\n设关系模式为R(A_1，A_2，…，A_n)，它的一个关系设为R，t\\inR表示t是R的一个元组，t[A_i]则表示元组t中相应于属性A_i的一个分量。\n\n\nA，t[A]，\\overline{A}\n若A={A_{i1}，A_{i2}，…，A_{ik}}，其中A_{i1}，A_{i2}，…，A_{ik}是A_1，A_2，…，A_n中的一部分，则A称为属性列或属性组。\nt[A]=(t[A_{i1}]，t[A_{i2}]，…，t[A_{ik}])表示元组t在属性列A上诸分量的集合。\n\\overline{A}则表示{A_1，A_2，…，A_n}中去掉{A_{i1}，A_{i2}，…，A_{ik}}后剩余的属性组。\n\n\n{\\stackrel\\frown{t_r t_s}}\nR为n目关系，S为m目关系。\nt_r\\in R，t_s\\in S，{\\stackrel\\frown{t_r t_s}}称为元组的连接。\n{\\stackrel\\frown{t_r t_s}}是一个n + m列的元组，前n个分量为R中的一个n元组，后m个分量为S中的一个m元组。\n\n\n象集Z_x\n给定一个关系R(X，Z)，X和Z为属性组。当t[X]=x时，x在R中的象集为：Zx=\\{t[Z]|t\\in R, t[X]=x\\}\n它表示R中属性组X上值为x的诸元组在Z上分量的集合。\n\n\n\n\n\n\n选择\n选择又称为限制。\n在关系R中选择满足给定条件的诸元组\n记作：\\sigma F(R) = \\{t|t\\in R∧F(t)=‘真’\\}\nF：选择条件，是一个逻辑表达式，取值为“真”或“假”，基本形式为：X_1\\theta Y_1。\\theta表示比较运算符。\n\n\n\n投影\n关系R上的投影是从R中选择出若干属性列组成新的关系。\n记作：\\prod_A(R)=\\{t[A]|t\\in R\\}，A是R的属性列\n投影之后不仅取消了原关系中的某些列，而且还可能取消某些元组（避免重复行）。\n\n\n\n连接\n连接也称为\\theta连接。\n它是从两个关系的笛卡尔积中选取属性间满足一定条件的元组。\n\n连接运算从R和S的广义笛卡尔积R\\timesS中选取R关系在A属性组上的值与S关系在B属性组上的值满足比较关系θ的元组。\n\n常用连接运算：\n\n\n等值连接\n\\theta为“=”的连接运算称为等值连接。\n\n\n\n自然连接\n自然连接是一种特殊的等值连接。两个关系中进行比较的分量必须是相同的属性组，在结果中把重复的属性列去掉。\nR和S具有相同的属性组B。\n\n\n\n\n\n悬浮元组：两个关系R和S在做自然连接时，关系R中某些元组有可能在S中不存在公共属性上值相等的元组，从而造成R中这些元组在操作时被舍弃了，这些被舍弃的元组称为悬浮元组。\n外连接：如果把悬浮元组也保存在结果关系中，而在其他属性上填空值(Null)，就叫做外连接。左外连接是只保留左边关系R中的悬浮元组，右外连接是只保留右边关系S中的悬浮元组。\n\n\n除\n给定关系R (X，Y)和S (Y，Z)，其中X，Y，Z为属性组。R中的Y与S中的Y可以有不同的属性名，但必须出自相同的域集。\nR与S的除运算得到一个新的关系P(X)，P是R中满足下列条件的元组在X属性列上的投影：元组在X上分量值x的象集Yx包含S在Y上投影的集合。\n记作：R\\div S=\\{tr[X]|t_r\\in R\\wedge \\prod _Y(S)\\subseteq Y_x\\}，其中Y_x是x在R中的象集，x=t_r[X]\n\n\n\n"},"计算机基础/数据库系统概论/3_SQL":{"title":"SQL","links":[],"tags":["数据库"],"content":"SQL概述\n发展\n结构化查询语言（Structured Query Language，SQL）是关系数据库的标准语言。\n\n目前，没有一个数据库系统能够支持SQL标准的所有概念和特性。\n特点\n\n\n综合统一\n集数据定义语言（DDL），数据操纵语言（DML），数据控制语言（DCL）功能于一体。\n可以独立完成数据库生命周期中的全部活动。\n用户数据库投入运行后，可根据需要随时逐步修改模式，不影响数据库的运行。\n数据操作符统一。\n\n\n高度非过程化\n无须了解存取路径，存取路径的选择以及SQL的操作过程由系统自动完成。\n\n\n面向集合的操作方式\n非关系数据模型采用面向记录的操作方式，操作对象是一条记录。\nSQL采用集合操作方式，操作对象，查找结果，一次插入、删除、更新操作的对象可以是元组的集合。\n\n\n以同一种语法结构提供多种使用方式\nSQL是独立的语言，能够独立地用于联机交互的使用方式。\nSQL又是嵌入式语言，能够嵌入到高级语言（例如C，C++，Java）程序中，供程序员设计程序时使用。\n\n\n语言简洁，易学易用\nSQL功能极强，完成核心功能只用了9个动词。\n\n\n\n基本概念\nSQL支持关系数据库三级模式结构。\n\n基本表：基本表是本身独立存在的表，一个关系就对应一个基本表，一个或多个基本表对应一个存储文件，一个表可以带若干索引。\n存储文件：存储文件的逻辑结构组成了关系数据库的内模式；存储文件的物理结构对用户是隐蔽的。\n视图：视图是从一个或几个基本表导出的表。它本身不独立存储在数据库中，即数据库中只存放视图的定义而不存放视图对应的数据。视图是一个虚表。用户可以在视图上再定义视图。\n学生-课程数据库\n学生表：Student(Sno,Sname,Ssex,Sage,Sdept)\n课程表：Course(Cno,Cname,Cpno,Ccredit)\n学生选课表：SC(Sno,Cno,Grade)\n\n\n\n数据定义\nSQL的数据定义功能：模式定义、表定义、视图和索引的定义。\n\n现代关系数据库管理系统提供了一个层次化的数据库对象命名机制。\n\n一个关系数据库管理系统的实例中可以建立多个数据库；\n一个数据库中可以建立多个模式；\n一个模式下通常包括多个表、视图和索引等数据库对象；\n\n数据类型\nSQL中域的概念用数据类型来实现。定义表的属性时需要指明其数据类型及长度。\n选用哪种数据类型，一般从两方面考虑：\n\n取值范围\n要做哪些运算\n\n\n模式的定义与删除\n定义模式实际上定义了一个命名空间，在这个空间中可以定义该模式包含的数据库对象，例如基本表、视图、索引等。\n在SQL中，模式定义语句：\nCREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt;;\n::: tip\n如果没有指定&lt;模式名&gt;，则&lt;模式名&gt;隐含为&lt;用户名&gt;\n:::\n用户可以在创建模式的同时在这个模式定义中进一步创建基本表、视图，定义授权。\nCREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt;[&lt;表定义子句&gt;|&lt;视图定义子句&gt;|&lt;授权定义子句&gt;];\n\n例：为用户ZHANG创建了一个模式TEST，并且在其中定义一个表TAB1\nCREATE SCHEMA TEST AUTHORIZATION ZHANG \nCREATE TABLE TAB1( COL1 SMALLINT, \n                   COL2 INT,\n                   COL3 CHAR(20),\n                   COL4 NUMERIC(10,3),\n                   COL5 DECIMAL(5,2)\n                  );\n\n在SQL中，删除模式语句：\nDROP SCHEMA &lt;模式名&gt; &lt;CASCADE|RESTRICT&gt;\nCASCADE和RESTRICT必须二选一。\n\n\nCASCADE（级联）\n删除模式的同时把该模式中所有的数据库对象全部删除。\n\n\nRESTRICT（限制）\n如果该模式中定义了下属的数据库对象（如表、视图等），则拒绝该删除语句的执行。仅当该模式中没有任何下属的对象时才能执行。\n\n\n基本表的定义、删除与修改\n定义表，格式如下：\nCREATE TABLE &lt;表名&gt; ( &lt;列名&gt; &lt;数据类型&gt; [&lt;列级完整性约束条件&gt;]\n      \t\t\t\t\t\t\t[,&lt;列名&gt; &lt;数据类型&gt; [&lt;列级完整性约束条件&gt;]]\n                   \t... \n\t\t\t\t\t\t\t\t\t\t[,&lt;表级完整性约束条件&gt;]);\n\n&lt;表名&gt;：所要定义的基本表的名字；\n&lt;列名&gt;：组成该表的各个属性（列）；\n&lt;列级完整性约束条件&gt;：涉及相应属性列的完整性约束条件；\n&lt;表级完整性约束条件&gt;：涉及一个或多个属性列的完整性约束条件；\n\n\n\n\n删除表，格式如下：\nDROP TABLE &lt;表名&gt; [RESTRICT| CASCADE];\n\n\nRESTRICT：删除表是有限制的。\n欲删除的基本表不能被其他表的约束所引用，如果存在依赖该表的对象，则此表不能被删除。\n\n\nCASCADE：删除该表没有限制。\n在删除基本表的同时，相关的依赖对象一起删除。\n\n\n默认是RESTRICT。\n\n\n修改表，格式如下：\nALTER TABLE &lt;表名&gt;\n[ ADD[COLUMN] &lt;新列名&gt; &lt;数据类型&gt; [完整性约束] ]\n[ ADD &lt;表级完整性约束&gt;]\n[ DROP [ COLUMN ] &lt;列名&gt; [CASCADE|RESTRICT] ]\n[ DROP CONSTRAINT &lt;完整性约束名&gt; [RESTRICT|CASCADE] ]\n[ ALTER COLUMN &lt;列名&gt; &lt;数据类型&gt; ] ;\n\n\n&lt;表名&gt;：要修改的基本表；\n\n\nADD子句：用于增加新列、新的列级完整性约束条件和新的表级完整性约束条件；\n\n\nDROP COLUMN子句：用于删除表中的列；\n如果指定了CASCADE短语，则自动删除引用了该列的其他对象；\n如果指定了RESTRICT短语，则如果该列被其他对象引用，关系数据库管理系统将拒绝删除该列；\n\n\nDROP CONSTRAINT子句：用于删除指定的完整性约束条件；\n\n\nALTER COLUMN子句：用于修改原有的列定义，包括修改列名和数据类型；\n\n\n\n::: tip\n不管基本表中原来是否已有数据，新增加的列一律为空值 。\n:::\n模式与表\n每一个基本表都属于某一个模式，一个模式包含多个基本表。\n定义基本表所属模式一般有三种方法：\n\n\n在表名中明显地给出模式名\nCREATE TABLE &quot;S-T&quot;.Student(......);  -- 模式名为 S-T\n\n\n在创建模式语句中同时创建表\n\n\n设置所属的模式\n\n\n创建基本表（其他数据库对象也一样）时，若没有指定模式，系统根据搜索路径来确定该对象所属的模式。\n::: info\n显示当前的搜索路径：SHOW search_path; \n设置搜索路径：SET search_path TO &quot;S-T&quot;, PUBLI;\n但以上两条命令是用于在 PostgreSQL 中的，在 MySQL 中，没有像 PostgreSQL 中的模式搜索路径概念。\nMySQL 主要依赖于当前所选的数据库来确定表和对象的搜索范围，而不是像 PostgreSQL 那样使用模式搜索路径。在 MySQL 中，会话使用的数据库（也就是当前默认数据库）会决定在查询时默认使用的模式。\n在 MySQL 中，\n\n查看当前会话所使用的默认数据库：SELECT DATABASE();\n查看当前数据库中所有的模式（也被称为数据库）：SHOW DATABASES;\n\n:::\n索引的建立与删除\n数据库索引是一种数据结构，用于提高数据库表中数据的检索速度。索引类似于书中的目录，可以快速指导数据库引擎到达包含特定数据的行，而无需扫描整个表。它们是数据库性能优化的关键组成部分。\n建立索引的目的是加快查询速度。\n关系数据库管理系统中常见索引：\n\n顺序文件上的索引\nB+树索引\n散列（hash）索引\n位图索引\n\n索引一般是由数据库管理员或表的属主（即建立表的人）建立的。维护索引则是由关系数据库管理系统自动完成。\n关系数据库管理系统自动选择合适的索引作为存取路径，用户不能显式地选择索引。\n\n建立索引，格式：\nCREATE [UNIQUE] [CLUSTERED] INDEX &lt;索引名&gt; ON &lt;表名&gt; (&lt;列名&gt;[&lt;次序&gt;][,&lt;列名&gt;[&lt;次序&gt;]]...);\n\n索引：可以建立在该表的一列或多列上，各列名之间用逗号分隔；\n&lt;表名&gt;：要建索引的基本表的名字；\n&lt;次序&gt;：指定索引值的排列次序，升序：ASC，降序：DESC，默认值：ASC；\nUNIQUE：此索引的每一个索引值只对应唯一的数据记录\nCLUSTER：表示要建立的索引是聚簇索引\n\n::: warning\n上面的格式是在 Microsoft SQL Server 的 T-SQL 中使用的语法。\n:::\n\n::: info 聚簇索引\n聚簇索引（Clustered Index）是一种特殊类型的索引，其顺序与表的物理顺序一致。\n这意味着表的数据行实际上按照聚簇索引的顺序进行存储，而不是存储在表的其他位置。因此，聚簇索引决定了表的物理排序方式。\nInnoDB是MySQL的默认存储引擎之一，它支持聚簇索引。因此当你在MYSQL数据库的表上定义主键时，InnoDB会默认使用主键作为聚簇索引。如果没有定义主键，InnoDB会选择第一个唯一非空索引作为聚簇索引。\n:::\n::: tip MYSQL建立索引\n在MYSQL中，建立索引的格式是：\nCREATE [UNIQUE] [FULLTEXT|SPATIAL] INDEX &lt;索引名&gt; ON &lt;表名&gt; (&lt;列名&gt; [(length)] [ASC | DESC], ...);\n\n\nlength: 对于文本列，可以指定索引的前缀长度。\n\n\nASC | DESC: 可选项，表示升序或降序排序，默认是升序。\n\n\nFULLTEXT|SPATIAL 是用于创建特殊类型索引的关键字。\nFULLTEXT 索引用于全文搜索。它允许你执行针对文本数据的全文搜索，而不仅仅是简单的字符串匹配。这对于需要在大量文本数据中进行自然语言搜索的场景非常有用。\nSPATIAL 索引用于处理空间数据类型，例如地理信息系统中的地理坐标。它允许你执行空间查询，如范围搜索、邻近搜索等。\n\n\n:::\n\n修改索引，格式：\nALTER INDEX &lt;旧索引名&gt; RENAME TO &lt;新索引名&gt;\n\n\n删除索引，格式：\n\n数据字典\n数据字典是关系数据库管理系统内部的一组系统表，它记录了数据库中所有定义信息：\n\n关系模式定义\n视图定义\n索引定义\n完整性约束定义\n各类用户对数据库的操作权限\n统计信息等\n\n关系数据库管理系统在执行SQL的数据定义语句时，实际上就是在更新数据字典表中的相应信息。\n数据查询\n查询的一般格式为：\nSELECT [ALL|DISTINCT] &lt;目标列表达式&gt;[,&lt;目标列表达式&gt;]...\nFROM &lt;表名或视图名&gt;[,&lt;表名或视图名&gt; ]...| (SELECT 语句) [AS]&lt;别名&gt;\n[ WHERE &lt;条件表达式&gt; ]\n[ GROUP BY &lt;列名1&gt; [ HAVING &lt;条件表达式&gt; ] ]\n[ ORDER BY &lt;列名2&gt; [ ASC|DESC ] ];\n\nSELECT子句：指定要显示的属性列；\nFROM子句：指定查询对象（基本表或视图）；\nWHERE子句：指定查询条件；\nGROUP BY子句：对查询结果按指定列的值分组，该属性列值相等的元组为一个组。通常会在每组中作用聚集函数；\nHAVING短语：只有满足指定条件的组才予以输出；\nORDER BY子句：对查询结果表按指定列值的升序或降序排序；\n\n单表查询\n单表查询是查询仅涉及一个表的查询。\n选择表中的若干列\n\n\n查询指定列\n在SELECT子句的&lt;目标列表达式&gt;中指定要查询的属性列。\n\n\n\n查询全部列\n可以在SELECT关键字后面列出所有列名，或者将&lt;目标列表达式&gt;指定为*。\n\n\n\n查询经过计算的值\nSELECT子句的&lt;目标列表达式&gt;不仅可以为表中的属性列，也可以是算术表达式，字符串常量，函数。\n\n\n\n选择表中的若干元组\n\n\n消除取值重复的行\n如果想去掉结果表中的重复行，必须指定DISTINCT，如果没有指定DISTINCT关键词，则默认为ALL。\n\n\n\n查询满足条件的元组\n\n\n\n比较大小\n\n\n\n确定范围\n\n\n\n确定集合\n\n\n\n字符匹配\n&lt;匹配串&gt;可以是一个完整的字符串，也可以含有通配符%和_。\n% （百分号）：代表任意长度（长度可以为0）的字符串。例如a%b表示以a开头，以b结尾的任意长度的字符串。\n_ （下横线）：代表任意单个字符。例如a_b表示以a开头，以b结尾的长度为3的任意字符串。\n\n如果要查询的字符串本身就含有%或者_，这时就需要使用ESCAPE ‘&lt;换码字符&gt;’短语对通配符进行转义。ESCAPE ’＼’ 表示’＼‘为换码字符。\n\n\n\n涉及空值的查询\n“IS”不能用“=”代替\n\n\n\n多重条件查询\nAND和OR来连接多个查询条件，AND的优先级高于OR，但可以用括号改变优先级。\n\n\n\n\n\nORDER BY子句\nORDER BY子句可以对查询结果按一个或多个属性列进行排序。\n\n::: tip\n对于空值，排序时显示的次序由具体系统实现来决定。\n:::\n聚集函数\n为了方便用户，增强检索功能，sql提供了许多聚集函数：\n\nCOUNT(*)：统计元组个数\nCOUNT( [DISTINCT|ALL] &lt;列名&gt;)：统计一列中值的个数\nSUM( [DISTINCT|ALL] &lt;列名&gt;)：计算一列值的总和（此列必须为数值型）\nAVG( [DISTINCT|ALL] &lt;列名&gt;)：计算一列值的平均值（此列必须为数值型）\nMAX( [DISTINCT|ALL] &lt;列名&gt;)：求一列中的最大值\nMIN( [DISTINCT|ALL] &lt;列名&gt;)：求一列中的最小值\n\n\n当聚焦函数遇到空值时，除COUNT(*)外，都跳过空值，只处理非空值。\n::: tip\n聚焦函数只能用于SELECT子句和GROUP BY中的HAVING子句。\n:::\nGROUP BY子句\nGROUP BY子句将查询结果按某一列或多列的值分组，值相等的为一组。\n对查询结果分组的目的是为了细化聚集函数的作用对象。如果未对查询结果分组，聚集函数将作用于整个查询结果；对查询结果分组后，聚集函数将分别作用于每个组。\n\n\n::: tip HAVING短语与WHERE子句的区别\n\n作用对象不同。\nWHERE子句作用于基表或视图，从中选择满足条件的元组。\nHAVING短语作用于组，从中选择满足条件的组。\n\n:::\n连接查询\n同时涉及两个以上的表的查询称为连接查询。\n连接查询的WHERE子句中用来连接两个表的条件称为连接条件或连接谓词，一般格式为：\n[&lt;表名1&gt;.]&lt;列名1&gt; &lt;比较运算符&gt; [&lt;表名2&gt;.]&lt;列名2&gt;\n[&lt;表名1&gt;.]&lt;列名1&gt; BETWEEN[&lt;表名2&gt;.]&lt;列名2&gt; AND [&lt;表名2&gt;.]&lt;列名3&gt;\n连接谓词中的列名称为连接字段。连接条件中的各连接字段类型必须是可比的，但名字不必相同。\n等值与非等值连接查询\n连接运算符为=时，称为等值连接；不为=则称为非等值连接。\n\n::: tip\n在上面例子中，SELECT子句和WHERE子句中的属性名前都加上了表名前缀，这是为了避免混淆。\n如果属性名在参加连接的歌表中是唯一的，则可以省略表名前缀。\n:::\n上面查询例子的几种可能的执行过程：\n\n\n嵌套循环法\n首先在表1中找到第一个元组，然后从头开始扫描表2，逐一查找满足连接件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组。\n表2全部查找完后，再找表1中第二个元组，然后再从头开始扫描表2，逐一查找满足连接条件的元组，找到后就将表1中的第二个元组与该元组拼接起来，形成结果表中一个元组。\n重复上述操作，直到表1中的全部元组都处理完毕。\n\n\n排序合并法\n常用于=连接。\n首先按连接属性对表1和表2排序。\n对表1的第一个元组，从头开始扫描表2，顺序查找满足连接条件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组。当遇到表2中第一条大于表1连接字段值的元组时，对表2的查询不再继续。\n找到表1的第二条元组，然后从刚才的中断点处继续顺序扫描表2，查找满足连接条件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组。直接遇到表2中大于表1连接字段值的元组时，对表2的查询不再继续。\n重复上述操作，直到表1或表2中的全部元组都处理完毕为止。\n\n\n索引连接\n对表2按连接字段建立索引。\n对表1中的每个元组，依次根据其连接字段值查询表2的索引，从中找到满足条件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组。\n\n\n若在等值连接中把目标中重复的属性列去掉则为自然连接。（例如上面例子的查询结果中学号重复了）\n\n一条SQL语句可以同时完成选择和连接查询，这时WHERE子句是由连接谓词和选择谓词组成的复合条件。\n\n自身连接\n连接操作不仅可以在两个表之间进行，也可以是一个表与其自己进行连接，成为表的自身连接。\n需要给表起别名以示区别。\n由于所有属性名都是同名属性，因此必须使用别名前缀。\n\n外连接\n外连接与普通连接的区别\n\n普通连接操作只输出满足连接条件的元组\n外连接操作以指定表为连接主体，将主体表中不满足连接条件的元组一并输出\n\n左外连接：列出左边关系中所有的元组；\n右外连接：列出右边关系中所有的元组；\n多表连接\n两个以上的表进行连接称为多表连接。\n\n嵌套查询\n一个SELECT-FROM-WHERE语句称为一个查询块。\n将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询。\n\nSQL语言允许多层嵌套查询，即一个子查询中还可以嵌套其他子查询。\n在子查询中不能使用ORDER BY子句。\n\n\n不相关子查询：子查询的查询条件不依赖于父查询\n由里向外逐层处理。即每个子查询在上一级查询处理之前求解，子查询的结果用于建立其父查询的查找条件。\n\n\n相关子查询：查询的查询条件依赖于父查询\n首先取外层查询中表的第一个元组，根据它与内层查询相关的属性值处理内层查询，若WHERE子句返回值为真，则取此元组放入结果表，然后再取外层表的下一个元组。\n重复这一过程，直至外层表全部检查完为止。\n\n\n带有IN谓词的子查询\n\n带有比较运算符的子查询\n带有比较运算符的子查询是指父查询与子查询之间用比较运算符进行连接。\n当能确切知道内层查询返回单值时，可用比较运算符。\n\n\n带有ANY（SOME）或ALL谓词的子查询\n子查询返回单值的时候可以用比较运算符，但返回多值时要用ANY（有的系统是SOME）或ALL。\n\n&gt; ANY：大于子查询结果中的某个值\n&gt; ALL：大于子查询结果中的所有值\n&lt; ANY：小于子查询结果中的某个值\n&lt; ALL：小于子查询结果中的所有值\n&gt;= ANY：大于等于子查询结果中的某个值\n&gt;= ALL：大于等于子查询结果中的所有值\n⇐ ANY：小于等于子查询结果中的某个值\n⇐ ALL：小于等于子查询结果中的所有值\n= ANY：等于子查询结果中的某个值\n= ALL：等于子查询结果中的所有值（通常没有实际意义）\n!=（或&lt;&gt;）ANY：不等于子查询结果中的某个值\n!=（或&lt;&gt;）ALL：不等于子查询结果中的任何一个值\n\n\n带有EXISTS谓词的子查询\nEXISTS代表存在量词 \\exists\n带有EXISTS谓词的子查询不返回任何数据，只产生逻辑真值true或逻辑假值false。\n\n若内层查询结果非空，则外层的WHERE子句返回真值；\n若内层查询结果为空，则外层的WHERE子句返回假值；\n\nNOT EXISTS\n\n若内层查询结果非空，则外层的WHERE子句返回假值\n若内层查询结果为空，则外层的WHERE子句返回真值\n\n::: tip\n由EXISTS引出的子查询，其目标列表达式通常都用 * ，因为带EXISTS的子查询只返回真值或假值，给出列名无实际意义。\n:::\n\n不同形式的查询间的替换\n\n一些带EXISTS或NOT EXISTS谓词的子查询不能被其他形式的子查询等价替换；\n所有带IN谓词、比较运算符、ANY和ALL谓词的子查询都能用带EXISTS谓词的子查询等价替换；\n\n\n用EXISTS/NOT EXISTS实现全称量词。\nSQL语言中没有全称量词 \\forall，可以把带有全称量词的谓词转换为等价的带有存在量词的谓词，(\\forall x)P\\equiv \\neg (\\exists x(\\neg P))\n\n\n用EXISTS/NOT EXISTS实现逻辑蕴涵。\nSQL语言中没有蕴涵逻辑运算，可以利用谓词演算将逻辑蕴涵谓词等价转换为 p\\to q\\equiv \\neg p \\vee q\n\n\n集合查询\n集合操作的种类\n\n并操作 UNION\n交操作 INTERSECT\n差操作 EXCEPT\n\n::: tip\n参加集合操作的各查询结果的列数必须相同，对应项的数据类型也必须相同。\n:::\n\n::: tip\n\nUNION：将多个查询结果合并起来时，系统自动去掉重复元组\nUNION ALL：将多个查询结果合并起来时，保留重复元组\n\n:::\n::: tip\nMySQL只支持UNION，不支持INTERSECT和EXCEPT。\nINTERSECT和EXCEPT在PostgreSQL和Oracle等数据库系统中支持。\n:::\n基于派生表的查询\n子查询不仅可以出现在WHERE子句中，还可以出现在FROM子句中，这时子查询生成的临时派生表(derived table)成为主查询的查询对象。\n\n如果子查询中没有聚集函数，派生表可以不指定属性列，子查询SELECT子句后面的列名为其默认属性。\n\n通过FORM生成派生表的时候，AS关键字可以省略，但别名不能省略。\n\n数据更新\n插入数据\n\n\n插入元组\n格式：\nINSERT INTO &lt;表名&gt; [(&lt;属性列1&gt;[,&lt;属性列2 &gt;...)] VALUES (&lt;常量1&gt; [,&lt;常量2&gt;]...);\n\n\nINTO子句\n指定要插入数据的表名及属性列。\n属性列的顺序可与表定义中的顺序不一致。若没有指定属性列，表示要插入的是一条完整的元组，且属性列属性与表定义中的顺序一致；若指定部分属性列，则插入的元组在其余属性列上取空值。\n\n\nVALUES子句\n提供的值必须与INTO子句匹配，如值的个数和值的类型。\n\n\n\n\n\n插入子查询结果\n格式：\nINSERT INTO &lt;表名&gt;  [(&lt;属性列1&gt; [,&lt;属性列2&gt;...)] 子查询;\n\n\n\n修改数据\n修改操作又称为更新操作。\n格式：\nUPDATE &lt;表名&gt; SET &lt;列名&gt;=&lt;表达式&gt;[,&lt;列名&gt;=&lt;表达式&gt;]... [WHERE &lt;条件&gt;];\n功能：\n\n修改指定表中满足WHERE子句条件的元组\nSET子句给出&lt;表达式&gt;的值用于取代相应的属性列\n如果省略WHERE子句，表示要修改表中的所有元组\n\n三种修改方式：\n\n修改某一个元组的值\n修改多个元组的值\n带子查询的修改语句\n\n\n删除数据\n格式：\nDELETE FROM &lt;表名&gt; [WHERE &lt;条件&gt;];\n删除指定表中满足WHERE子句条件的元组。如果没有WHERE子句，则表示要删除表中的全部元组，表的定义仍在字典中。\n::: tip\nDELETE FROM只是删除表中数据并不是删除表，如果要删除表则是DROP。\n:::\n三种删除方式：\n\n删除某一个元组的值\n删除多个元组的值\n带子查询的删除语句\n\n\n空值的处理\n空值是一个很特殊的值，含有不确定性。对关系运算带来特殊的问题，需要做特殊的处理。\n空值的产生\n\n判断一个属性的值是否为空值，用IS NULL或IS NOT NULL来表示。\n\n空值的约束条件：\n\n有NOT NULL约束条件的不能取空值\n加了UNIQUE限制的属性不能取空值\n码属性不能取空值\n\n空值的运算和比较：\n\n\n空值与另一个值（包括另一个空值）的算术运算的结果为空值。\n\n\n空值与另一个值（包括另一个空值）的比较运算的结果为UNKNOWN。有了UNKNOWN后，传统二值（TRUE，FALSE）逻辑就扩展成了三值逻辑。\n\n\n\n\n视图\n视图是虚表，是从一个或几个基本表（或视图）导出的表。\n数据库中只存放视图的定义，不存放视图对应的数据，这些数据仍然存放在原来的基本表中。\n基表中的数据发生变化，从视图中查询出的数据也随之改变。\n定义视图\n建立视图\n格式：\nCREATE VIEW &lt;视图名&gt;  [(&lt;列名&gt;  [,&lt;列名&gt;]...)] AS &lt;子查询&gt; [WITH CHECK OPTION];\n\n\nWITH CHECK OPTION：表示对视图进行UPDATE，INSERT和DELETE操作时要保证更新、插入或删除的行满足视图定义中的谓词条件（即子查询中的条件表达式）。\n\n\n子查询：可以是任意的SELECT语句，是否可以含有ORDER BY子句和DISTINCT短语，则决定具体系统的实现。\n\n\n列名：只有全部省略或全部指定。\n全部省略：代表各个属性列名由子查询中SELECT目标列中的诸字段组成。\n需要明确指定视图的所有列名的情况：某个目标列是聚集函数或列表达式、多表连接时选出了几个同名列作为视图的字段、需要在视图中为某个列启用新的更合适的名字。\n\n\n关系数据库管理系统执行CREATE VIEW语句时只是把视图定义存入数据字典，并不执行其中的SELECT语句。\n在对视图查询时，按视图的定义从基本表中将数据查出。\n\n定义IS_Student视图时加上了WITH CHECK OPTION子句，表示对该视图进行插入、修改和删除操作时，关系数据库管理系统会自动加上Sdept=&#039;IS&#039;的条件。\n若一个视图是从单个基本表导出的，并且只是去掉了基本表的某些行和某些列，但保留了主码，我们称这类视图为行列子集视图。\n\n\n基于多个基表的视图\n\n\n\n基于视图的视图\n\n\n\n带表达式的视图\n\n\n\n分组视图\n\n\n\n删除视图\n格式：\nDROP VIEW &lt;视图名&gt;[CASCADE];\n该语句从数据字典中删除指定的视图定义。如果该视图上还导出了其他视图，使用CASCADE级联删除语句，可以把该视图和由它导出的所有视图一起删除。\n删除基表时，由该基表导出的所有视图定义都必须显式地使用DROP VIEW语句删除。\n查询视图\n从用户角度来看查询视图与查询基本表相同。\n关系数据库管理系统实现视图查询的方法：视图消解法（View Resolution）\n\n进行有效性检查\n转换成等价的对基本表的查询\n执行修正后的查询\n\n\n有些情况下，视图消解法不能生成正确的查询。\n更新视图\n\n更新视图的限制：一些视图是不可更新的，因为对这些视图的更新不能唯一地有意义地转换成对相应基本表的更新。\n目前，各个数据库管理系统一般都只允许对行列子集视图进行更新，对其他类型视图的更新不同系统有不同限制。\n一个不允许更新的视图上定义的视图也不允许更新。\n::: tip 不可更新的视图和不允许更新的视图是两个不同的概念\n“不可更新的视图”和”不允许更新的视图”这两个概念在数据库中有些微妙的区别。\n\n\n不可更新的视图\n这指的是某些视图，它们不能被更新，无法执行对其进行插入、更新或删除操作。这可能是因为视图的定义包含了使其不可更新的元素，比如包含以下情况：\n\n聚合函数\nDISTINCT 关键字\n在视图中使用了 GROUP BY 子句\n\n这些情况都可能导致视图不支持直接的更新操作，因为它们使得无法明确地确定如何更新视图，或者更新可能会影响多个源表格，导致歧义。\n\n\n不允许更新的视图\n这种情况下，视图可能本身是可以更新的，但数据库管理员或视图的创建者可能出于安全性考虑或者为了确保数据的完整性明确地禁止了对视图的更新操作。\n管理员可能认为某些视图不应该被修改，即使它们实际上可能支持更新操作。\n\n\n在数据库中，不可更新的视图是由其定义所决定的，而不允许更新的视图是通过权限设置或安全策略来实现的。\n:::\n视图的作用\n\n视图能够简化用户的操作\n视图使用户能以多种角度看待同一数据\n视图对重构数据库提供了一定程度的逻辑独立性\n视图能够对机密数据提供安全保护\n适当的利用视图可以更清晰的表达查询\n"},"计算机基础/数据库系统概论/4_数据库安全性":{"title":"数据库安全性","links":[],"tags":["数据库"],"content":"数据库的安全性是指保护数据库以防止不合法使用所造成的数据泄露、更改或破坏 。\n系统安全保护措施是否有效是数据库系统主要的性能指标之一\n数据库安全性概述\n数据库的不安全因素：\n\n非授权用户对数据库的恶意存取和破坏\n数据库中重要或敏感的数据被泄露\n安全环境的脆弱性\n\n\n1985年美国国防部（DoD）正式颁布《DoD可信计算机系统评估准则》（简称TCSEC或DoD85）。ITSEC，CTCPEC，FC都是建立在TCSEC概念上的评估准则。\n1993年，CTCPEC、FC、TCSEC和ITSEC联合行动，解决原标准中概念和技术上的差异，称为CC项目。目前CC已基本取代了TCSEC，成为评估信息产品安全性的主要标准。\n\n1991年4月美国国家计算机安全中心颁布了《可信计算机系统评估标准关于可信数据库系统的解释》（Trusted Database Interpretation，TDI），它将TCSEC扩展到数据库管理系统。\nTDI中定义了数据库管理系统的设计与实现中需满足和用以进行安全性级别评估的标准。\nTCSEC/TDI，从四个方面来描述安全性级别划分的指标：安全策略、责任、保证、文档。\n\nCC提出国际公认的表述信息技术安全性的结构，即把信息产品的安全要求分为\n\n安全功能要求\n安全保证要求\n\nCC文本组成\n\n简介和一般模型\n安全功能要求\n安全保证要求\n\n\n数据库安全性控制\n非法使用数据库的情况：\n\n编写合法程序绕过数据库管理系统及其授权机制\n直接或编写应用程序执行非授权操作\n通过多次合法查询数据库从中推导出一些保密数据\n\n计算机系统中，安全措施是一级一级层层设置\n\n系统根据用户标识鉴定用户身份，合法用户才准许进入计算机系统\n数据库管理系统还要进行存取控制，只允许用户执行合法操作\n操作系统有自己的保护措施\n数据以密码形式存储到数据库中\n\n\n下图是数据库安全保护的一个存取控制流程\n\n首先，数据库管理系统对提出SQL访问请求的数据库用户进行身份鉴别，防止不可信用户使用系统。\n然后，在SQL处理层进行自主存取控制和强制存取控制，进一步可以进行推理控制。还可以对用户访问行为和系统关键操作进行审计，对异常用户行为进行简单入侵检测。\n\n\n数据库安全性控制的常用方法：\n\n用户标识和鉴定\n存取控制\n视图\n审计\n数据加密\n\n用户标识和鉴定\n用户身份鉴别是数据库管理系统提供的最外层安全保护措施。\n每个用户在系统中都有一个用户标识，用户标识由用户名和用户标识号组成，用户标识号在系统整个生命周期内唯一。\n常用的用户身份鉴别的方法：\n\n\n静态口令鉴别\n静态口令一般由用户自己设定，这些口令是静态不变的\n\n\n动态口令鉴别\n口令是动态变化的，每次鉴别时均需使用动态产生的新口令登录数据库管理系统，即采用一次一密的方法\n\n\n生物特征鉴别\n通过生物特征进行认证的技术，生物特征如指纹、虹膜和掌纹等\n\n\n智能卡鉴别\n智能卡是一种不可复制的硬件，内置集成电路的芯片，具有硬件加密功能\n\n\n存取控制\n存取控制机制组成：\n\n\n定义用户权限，并将用户权限登记到数据字典中\n用户对某一数据对象的操作权力称为权限。\nDBMS提供适当的语言来定义用户权限，存放在数据字典中，称做安全规则或授权规则。\n\n\n合法权限检查\n用户发出存取数据库操作请求，DBMS查找数据字典，进行合法权限检查。\n\n\n用户权限定义和合法权检查机制一起组成了数据库管理系统的存取控制子系统。\n常用存取控制方法：\n\n\n自主存取控制（Discretionary Access Control，简称DAC）\n用户对不同的数据对象有不同的存取权限，不同的用户对同一对象也有不同的权限，用户还可将其拥有的存取权限转授给其他用户。\n\n\n强制存取控制（Mandatory Access Control，简称MAC）\n每一个数据对象被标以一定的密级，每一个用户也被授予某一个级别的许可证。对于任意一个对象，只有具有合法许可证的用户才可以存取。\n\n\n自主存取控制方法\n通过SQL的GRANT语句和REVOKE语句实现。\n用户权限是由数据对象和操作类型组成的，定义用户存取权限就是定义用户可以在哪些数据库对象上进行哪些类型的操作。\n定义存取权限称为授权。\n\n授权\nGRANT\n将对指定操作对象的指定操作权限授予指定的用户。\n格式：\nGRANT &lt;权限&gt;[,&lt;权限&gt;]... \n\t\t\t ON &lt;对象类型&gt; &lt;对象名&gt;[,&lt;对象类型&gt; &lt;对象名&gt;]…\n       TO &lt;用户&gt;[,&lt;用户&gt;]...\n       [WITH GRANT OPTION];\n发出GRANT：\n\n数据库管理员\n数据库对象创建者（即属主Owner）\n拥有该权限的用户\n\n按受权限的用户：\n\n一个或多个具体用户\nPUBLIC（即全体用户）\n\n如果指定了WITH GRANT OPTION子句，则获得权限的用户可以把获得的权限再授予其它用户；如果没有指定，则获得权限的用户只能使用，不能传播权限。\nSQL标准不允许循环授权。\n\n\nREVOKE\n授予的权限可以由数据库管理员或其他授权者用REVOKE语句收回。\n格式：\nREVOKE &lt;权限&gt;[,&lt;权限&gt;]... \n    ON &lt;对象类型&gt; &lt;对象名&gt;[,&lt;对象类型&gt;&lt;对象名&gt;]…\n    FROM &lt;用户&gt;[,&lt;用户&gt;]...[CASCADE | RESTRICT];\n\nCASCADE（级联）： 使用 CASCADE 意味着不仅会撤销指定的权限，还会撤销其他对象上的相关权限。比如，如果一个用户被授予对表的访问权限，而该表又被视图或其他对象所使用，使用 CASCADE 将会撤销对表和依赖对象的访问权限。\nRESTRICT（限制）： 相反，RESTRICT 确保只有在没有依赖对象依赖正在撤销的权限时才执行 REVOKE 操作。如果存在依赖对象，撤销将失败，以防止对可能影响这些依赖对象的权限进行意外移除。\n\n\n数据库管理员：拥有所有对象的所有权限，可以根据实际情况不同的权限授予不同的用户。\n用户：拥有自己建立的对象的全部的操作权限，可以使用GRANT把权限授予其他用户。\n被授权的用户：如果具有“继续授权”的许可，可以把获得的权限再授予其他用户。所有授予出去的权力在必要时又都可用REVOKE语句收回。\n创建数据库模式的权限\n由数据库管理员在创建用户时实现。\n格式：\nCREATE USER &lt;username&gt; [WITH] [DBA|RESOURCE|CONNECT];\n\n\n只有系统的超级用户才有权创建一个新的数据库用户；\n\n\n新创建的数据库用户有三种权限：CONNECT、RESOURCE和DBA；\n\n如没有指定创建的新用户的权限，默认该用户拥有CONNECT权限。拥有CONNECT权限的用户不能创建新用户，不能创建模式，也不能创建基本表，只能登录数据库；\n拥有RESOURCE权限的用户能创建基本表和视图，成为所创建对象的属主。但不能创建模式，不能创建新的用户\n拥有DBA权限的用户是系统中的超级用户，可以创建新的用户、创建模式、创建基本表和视图等；DBA拥有对所有数据库对象的存取权限，还可以把这些权限授予一般用户\n\n\n\n\n::: tip\nCREATE USER不是SQL标准，各个系统的实现相差甚远。\n:::\n数据库角色\n数据库角色是被命名的一组与数据库操作相关的权限，角色是权限的集合。\n可以为一组具有相同权限的用户创建一个角色，使用角色可以简化授权的过程。\n\n\n角色的创建\nCREATE ROLE &lt;角色名&gt; \n\n\n给角色授权\nGRANT &lt;权限&gt;[,&lt;权限&gt;]... ON &lt;对象类型&gt;对象名 TO &lt;角色&gt;[,&lt;角色&gt;]...\n\n\n将一个角色授予其他的角色或用户\nGRANT  &lt;角色1&gt;[,&lt;角色2&gt;]... TO &lt;角色3&gt;[,&lt;用户1&gt;]... [WITH ADMIN OPTION]\n\n\n角色权限的收回\nREVOKE &lt;权限&gt;[,&lt;权限&gt;]... ON &lt;对象类型&gt; &lt;对象名&gt; FROM &lt;角色&gt;[,&lt;角色&gt;]...\n\n\n\n强制存取控制方法\n强制存取控制是为了保证更高程度的安全性，适用于对数据有严格而固定密级分类的部门，如军事部门和政府部门等。\n\n在强制存取控制中，数据库管理系统所管理的全部实体被分为\n\n\n主体\n系统中的活动实体\n例如：数据库管理系统所管理的实际用户，代表用户的各进程\n\n\n客体\n系统中的被动实体，受主体操纵\n例如：文件、基本表、索引、视图\n\n\n\n对于主体和客体，DBMS为它们每个实例（值）指派一个敏感度标记。敏感度标记分成若干级别：\n\n绝密（Top Secret，TS）\n机密（Secret，S）\n可信（Confidential，C）\n公开（Public，P）\n\n主体的敏感度标记称为许可证级别（Clearance Level）\n客体的敏感度标记称为密级（Classification Level）\n\n强制存取控制规则：\n\n仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体\n仅当主体的许可证级别小于或等于客体的密级时，该主体才能写相应的客体\n\n强制存取控制是对数据本身进行密级标记，无论数据如何复制，标记与数据是一个不可分的整体，只有符合密级标记要求的用户才可以操纵数据。\n较高安全性级别提供的安全保护要包含较低级别的所有保护，实现强制存取控制时要首先实现自主存取控制。\n自主存取控制与强制存取控制共同构成数据库管理系统的安全机制。\n\n先进行自主存取控制检查，通过自主存取控制检查的数据对象再由系统进行强制存取控制检查，只有通过强制存取控制检查的数据对象方可存取。\n视图机制\n通过视图机制把要保密的数据对无权存取这些数据的用户隐藏起来，对数据提供一定程度的安全保护。\n视图机制间接地实现支持存取谓词的用户权限定义。\n\n审计\n审计功能把用户对数据库的所有操作自动记录下来放入审计日志中。审计员利用审计日志监控数据库中的各种行为，找出非法存取数据的人、时间和内容。\n审计功能是可选的。\n\n审计事件\n\n\n服务器事件\n审计数据库服务器发生的事件。\n\n\n系统权限\n对系统拥有的结构或模式对象进行操作的审计，要求该操作的权限是通过系统权限获得的。\n\n\n语句事件\n对SQL语句，如DDL、DML、DQL及DCL语句的审计。\n\n\n模式对象事件\n对特定模式对象上进行的SELECT或DML操作的审计。\n\n\n\n审计功能\n提供多种审计查阅方式，提供多套审计规则，提供审计分析和报表功能，提供审计日志管理功能，提供查询审计设置及审计记录信息的专门视图。\n\n审计一般可以分为：\n\n\n用户级审计\n任何用户可设置的审计，主要是用户针对自己创建的数据库表和视图进行审计。\n\n\n系统级审计\n只能由数据库管理员设置，用来监测成功或失败的登录要求、监测授权和收回操作以及其他数据库级权限下的操作。\n\n\nAUDIT语句：设置审计功能\nNOAUDIT语句：取消审计功能\n\n数据加密\n数据加密是防止数据库中数据在存储和传输中失密的有效手段。\n加密的基本思想：根据一定的算法将原始数据—明文变换为不可直接识别的格式­—密文。\n加密方法：\n\n\n存储加密\n\n\n透明存储加密\n内核级加密保护方式，对用户完全透明。\n将数据在写到磁盘时对数据进行加密，授权用户读取数据时再对其进行解密。数据库的应用程序不需要做任何修改，只需在创建表语句中说明需加密的字段即可。\n性能较好，安全完备性较高。\n\n\n非透明存储加密\n通过多个加密函数实现\n\n\n\n\n传输加密\n\n\n链路加密\n在链路层进行加密，对传输信息的报文和报头均加密\n\n\n端到端加密\n在发送端加密，接收端解密。只加密报文不加密报头。所需密码设备数量相对较少，容易被非法监听者发现并从中获取敏感信息。\n\n\n\n\n\n其他安全性保护\n\n\n推理控制\n处理强制存取控制未解决的问题，可以避免用户利用能够访问的数据推知更高密级的数据。\n常用方法：基于函数依赖的推理控制，基于敏感关联的推理控制。\n\n\n隐蔽信道\n处理强制存取控制未解决的问题。\n\n\n数据隐私保护\n描述个人控制其不愿他人知道或他人不便知道的个人数据的能力。\n范围很广：数据收集、数据存储、数据处理和数据发布等各个阶段\n\n"},"计算机基础/数据库系统概论/5_数据库完整性":{"title":"数据库完整性","links":[],"tags":["数据库"],"content":"数据库的完整性是指：\n\n\n数据的正确性\n数据是符合现实世界语义，反映了当前实际状况的。\n\n\n数据的相容性\n数据库同一对象在不同关系表中的数据是符合逻辑的。\n\n\n数据的完整性和安全性是两个不同概念：\n\n\n数据的完整性\n防止数据库中存在不符合语义的数据，也就是防止数据库中存在不正确的数据。\n防范对象：不合语义的、不正确的数据\n\n\n数据的安全性\n保护数据库 防止恶意的破坏和非法的存取。\n防范对象：非法用户和非法操作\n\n\n为维护数据库的完整性，数据库管理系统必须：\n\n提供定义完整性约束条件的机制\n提供完整性检查的方法\n违约处理\n\n实体完整性\n定义\n关系模型的实体完整性在CREATE TABLE中用PRIMARY KEY定义。\n单属性构成的码有两种说明方法：\n\n\n定义为列级约束条件\n\n\n\n定义为表级约束条件\n\n\n\n对多个属性构成的码只有一种说明方法：\n\n\n定义为表级约束条件\n\n\n\n实体完整性检查和违约处理\n插入或对主码列进行更新操作时，关系数据库管理系统按照实体完整性规则自动进行检查。包括：\n\n检查主码值是否唯一，如果不唯一则拒绝插入或修改\n检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改\n\n检查记录中主码值是否唯一的一种方法是进行全表扫描，依次判断表中每一条记录的主码值与将插入记录上的主码值（或者修改的新主码值）是否相同。\n表扫描的缺点是十分耗时，为避免对基本表进行全表扫描，关系数据库管理系统一般都在主码上自动建立一个索引，例如下图的B+树索引。\n\n参照完整性\n定义\n关系模型的参照完整性在CREATE TABLE中用FOREIGN KEY短语定义哪些列为外码，用REFERENCES短语指明这些外码参照哪些表的主码。\n\n参照完整性检查和违约处理\n一个参照完整性将两个表中的相应元组联系起来。\n对被参照表和参照表进行增删改操作时有可能破坏参照完整性，必须进行检查。\n\n例如，对表SC和Student有四种可能破坏参照完整性的情况：\n\n\nSC表中增加一个元组，\n该元组的Sno属性的值在表Student中找不到一个元组，其Sno属性的值与之相等。\n\n\n修改SC表中的一个元组，\n修改后该元组的Sno属性的值在表Student中找不到一个元组，其Sno属性的值与之相等。\n\n\n从Student表中删除一个元组，\n造成SC表中某些元组的Sno属性的值在表Student中找不到一个元组，其Sno属性的值与之相等。\n\n\n修改Student表中一个元组的Sno属性，\n造成SC表中某些元组的Sno属性的值在表Student中找不到一个元组，其Sno属性的值与之相等。\n\n\n\n\n参照完整性违约处理\n\n\n拒绝（NO ACTION）执行\n不允许该操作执行，该策略一般设置为默认策略。\n\n\n级联（CASCADE）操作\n当删除或修改被参照表的一个元组造成了与参照表的不一致，则删除或修改参照表中的所有造成不一致的元组。\n\n\n设置为空值（SET-NULL）\n当删除或修改被参照表的一个元组时造成了不一致，则将参照表中的所有造成不一致的元组的对应属性设置为空值。\n\n\n对于参照完整性，除了应该定义外码，还应定义外码列是否允许空值。\n\n用户定义的完整性\n用户定义的完整性是针对某一具体应用的数据必须满足的语义要求。\n关系数据库管理系统提供了定义和检验用户定义完整性的机制，不必由应用程序承担。\n属性上的约束条件\n在CREATE TABLE时定义属性上的约束条件有：\n\n列值非空（NOT NULL）\n列值唯一（UNIQUE）\n检查列值是否满足一个条件表达式（CHECK）\n\n\n插入元组或修改属性的值时，关系数据库管理系统检查属性上的约束条件是否被满足，如果不满足则操作被拒绝执行。\n元组上的约束条件\n在CREATE TABLE时可以用CHECK短语定义元组上的约束条件，即元组级的限制。\n同属性值限制相比，元组级的限制可以设置不同属性之间的取值的相互约束条件。\n\n插入元组或修改属性的值时，关系数据库管理系统检查元组上的约束条件是否被满足，如果不满足则操作被拒绝执行。\n完整性约束命名字句\nSQL在CREATE TABLE语句中提供了完整性约束命名子句CONSTRAINT，用来对完整性约束条件命名。从而可以灵活增加删除一个完整性约束条件。\n\n完整性约束命名子句：\nCONSTRAINT &lt;完整性约束条件名&gt; &lt;完整性约束条件&gt;\n&lt;完整性约束条件&gt;包括NOT NULL、UNIQUE、PRIMARY KEY短语、FOREIGN KEY短语、CHECK短语等。\n\n\n使用ALTER TABLE语句修改表中的完整性限制。\n\n断言\nSQL中，可以使用CREATE ASSERTION语句，通过声明性断言来指定更具一般性的约束。\n可以定义涉及多个表的或聚集操作的比较复杂的完整性约束。\n断言创建以后，任何对断言中所涉及的关系的操作都会触发关系数据库管理系统对断言的检查，任何使断言不为真值的操作都会被拒绝执行。\n\n创建断言\nCREATE ASSERTION&lt;断言名&gt; &lt;CHECK 子句&gt;\n每个断言都被赋予一个名字，&lt;CHECK 子句&gt;中的约束条件与WHERE子句的条件表达式类似。\n\n\n删除断言\nDROP ASSERTION &lt;断言名&gt;;\n如果断言很复杂，则系统在检测和维护断言的开销较高，这是在使用断言时应该注意的\n触发器\n触发器（Trigger）是用户定义在关系表上的一类由事件驱动的特殊过程。\n触发器保存在数据库服务器中。\n任何用户对表的增、删、改操作均由服务器自动激活相应的触发器。\n触发器可以实施更为复杂的检查和操作，具有更精细和更强大的数据控制能力。\n定义触发器\n触发器又叫做事件-条件-动作规则。\n当特定的系统事件发生时，对规则的条件进行检查，如果条件成立则执行规则中的动作，否则不执行该动作。\n格式：\nCREATE TRIGGER &lt;触发器名&gt;  \n       {BEFORE | AFTER} &lt;触发事件&gt; ON &lt;表名&gt;\n       REFERENCING NEW|OLD ROW AS&lt;变量&gt;\n       FOR EACH  {ROW | STATEMENT}\n       [WHEN &lt;触发条件&gt;]&lt;触发动作体&gt;\n\n\n表的拥有者才可以在表上创建触发器\n\n\n触发器名\n触发器名可以包含模式名，也可以不包含模式名。\n同一模式下，触发器名必须是唯一的，触发器名和表名必须在同一模式下。\n\n\n表名\n触发器只能定义在基本表上，不能定义在视图上。\n当基本表的数据发生变化时，将激活定义在该表上相应触发事件的触发器。\n\n\n触发事件\n触发事件可以是INSERT、DELETE或UPDATE，也可以是这几个事件的组合，还可以UPDATE OF&lt;触发列, ...&gt;，即进一步指明修改哪些列时激活触发器。\nAFTER/BEFORE是触发的时机，AFTER表示在触发事件的操作执行之后激活触发器，BEFORE表示在触发事件的操作执行之前激活触发器。\n\n\n触发器类型\n触发器按照所触发动作的时间间隔尺寸可以分为：行级触发器（FOR EACH ROW），语句级触发器（FOR EACH STATEMENT）。\n\n\n触发条件\n触发器被激活时，只有当触发条件为真时触发动作体才执行，否则触发动作体不执行。如果省略WHEN触发条件，则触发动作体在触发器激活后立即执行。\n\n\n触发动作体\n触发动作体可以是一个匿名PL/SQL过程块，也可以是对已创建存储过程的调用。\n如果是行级触发器，用户都可以在过程体中使用NEW和OLD引用事件之后的新值和事件之前的旧值；如果是语句级触发器，则不能在触发动作体中使用NEW或OLD进行引用。\n如果触发动作体执行失败，激活触发器的事件就会终止执行，触发器的目标表或触发器可能影响的其他对象不发生任何变化 。\n\n\n\n激活触发器\n触发器的执行，是由触发事件激活的，并由数据库服务器自动执行。\n一个数据表上可能定义了多个触发器，遵循如下的执行顺序：\n\n执行该表上的BEFORE触发器；\n激活触发器的SQL语句；\n执行该表上的AFTER触发器；\n\n删除触发器\n格式：\nDROP TRIGGER &lt;触发器名&gt; ON &lt;表名&gt;;\n触发器必须是一个已经创建的触发器，并且只能由具有相应权限的用户删除。"},"计算机基础/数据库系统概论/6_关系数据理论":{"title":"关系数据理论","links":[],"tags":["数据库"],"content":"好的关系模式\n关系模式由五部分组成，是一个五元组： R(U, D, DOM, F)\n\n关系名R是符号化的元组语义\nU为一组属性\nD为属性组U中的属性所来自的域\nDOM为属性到域的映射\nF为属性组U上的一组数据依赖\n\n由于D、DOM与模式设计关系不大，因此在本章中把关系模式看作一个三元组：R&lt;U, F&gt;。\n作为二维表，关系要符合一个最基本的条件：每个分量必须是不可分开的数据项。满足了这个条件的关系模式就属于第一范式（1NF）。\n\n数据依赖：\n\n是一个关系内部属性与属性之间的一种约束关系\n通过属性间值的相等与否体现出来的数据间相互联系\n是现实世界属性间相互联系的抽象\n是数据内在的性质\n是语义的体现\n\n数据依赖的主要类型：\n\n函数依赖（Functional Dependency，简记为FD）\n多值依赖（Multi-Valued Dependency，简记为MVD）\n\n函数依赖普遍存在于现实生活中。\n例如，一个学号只对应一个学生，一个学生只在一个系中学习，“学号”值确定后，学生的姓名及所在系的值就被唯一确定。Sname=f(Sno)，Sdept=f(Sno)，即Sno函数决定Sname，Sno函数决定Sdept，记作Sno→Sname，Sno→Sdept。\n\n例：\n建立一个描述学校教务的数据库。涉及的对象包括：学号（Sno），所在系（Sdept），系主任姓名（Mname），课程号（Cno），成绩（Grade）\n假设学校教务的数据库模式用一个单一的关系模式Student来表示，则该关系模式的属性集合为：U={Sno, Sdept, Mname, Cno, Grade}\n现实世界的已知事实（语义）：一个系有若干学生， 但一个学生只属于一个系；一个系只有一名（正职）负责人；一个学生可以选修多门课程，每门课程有若干学生选修；每个学生学习每一门课程有一个成绩。\n由此可得到属性组U上的一组函数依赖F：F={Sno→Sdept, Sdept→ Mname, (Sno, Cno)→ Grade}\n\n\n\n上面例子中的关系模式存在一些问题：\n\n\n数据冗余\n浪费大量的存储空间。\n每一个系主任的姓名重复出现，重复次数与该系所有学生的所有课程成绩出现次数相同。\n\n\n更新异常\n数据冗余 ，更新数据时，维护数据完整性代价大。\n某系更换系主任后，必须修改与该系学生有关的每一个元组。\n\n\n插入异常\n如果一个系刚成立，尚无学生，则无法把这个系及其系主任的信息存入数据库。\n\n\n删除异常\n如果某个系的学生全部毕业了， 则在删除该系学生信息的同时，把这个系及其系主任的信息也丢掉了。\n\n\n以上这些问题都是由模式中的某些数据依赖引起的。\n很明显上面的关系模式不是一个好的模式。一个“好”的模式应当不会发生插入异常、删除异常和更新异常而且数据冗余应尽可能少。\n改造一个不好的模式，应该用规范化理论改造关系模式来消除其中不合适的数据依赖。\n规范化\n函数依赖\n定义：设R(U)是一个属性集U上的关系模式，X和Y是U的子集。若对于R(U)的任意一个可能的关系r，r 中不可能存在两个元组在X上的属性值相等， 而在Y上的属性值不等， 则称“X函数确定Y”或“Y函数依赖于X”，记作X\\to Y。\n\n函数依赖不是指关系模式R的某个或某些关系实例满足的约束条件，而是指R的所有关系实例均要满足的约束条件。\n函数依赖是语义范畴的概念，只能根据数据的语义来确定一个函数依赖。\n\n常用术语和记号：\n\nX\\to Y，但Y \\nsubseteq X则称X\\to Y是非平凡的函数依赖。\nX\\to Y，但Y \\subseteq X则称X\\to Y是平凡的函数依赖。\n若X\\to Y，则X称为这个函数依赖的决定因素。\n若X\\to Y，Y \\to X，则记作X\\gets \\to Y。\n若Y不函数依赖于X，则记作X\\nrightarrow Y。\n\n::: tip\n对于任一关系模式，平凡函数依赖都是必然成立的，它不反映新的语义。若不特别声明， 我们总是讨论非平凡函数依赖。\n:::\n定义：在R(U)中，\n\n若X\\to Y，并且对于X的任何一个真子集X’, 都有 X&#039;\\nrightarrow Y，则称Y对X完全函数依赖，记作X \\overset{F}{\\rightarrow}  Y。\n若X\\to Y，但Y不完全函数依赖于X，则称Y对X部分函数依赖，记作X \\overset{P}{\\rightarrow}  Y。\n\n\n定义：在R(U)中，如果X\\to Y(Y \\nsubseteq X)，Y\\nrightarrow X，Y\\to Z，Z\\nsubseteq Y，则称Z对X传递函数依赖，记为：X → Z。\n注：如果Y\\to X，即X\\gets \\to Y，则Z直接依赖于X，而不是传递函数依赖。\n\n例：\n在关系Std(Sno, Sdept, Mname)中，有：Sno → Sdept，Sdept → Mname，则Mname传递函数依赖于Sno。\n\n码\n\n候选码是最小的超码，即K的任意一个真子集都不是候选码。\n若关系模式R有多个候选码，则选定其中的一个做为主码。\n包含在任何一个候选码中的属性 ，称为主属性；不包含在任何码中的属性称为非主属性或非码属性。\n整个属性组是码，则称为全码。\n关系模式R中属性或属性组X并非R的码，但X是另一个关系模式的码，则称X是R的外部码也称外码。\n主码与外部码一起提供了表示关系间联系的手段。\n范式\n范式是符合某一种级别的关系模式的集合。\n关系数据库中的关系必须满足一定的要求。满足不同程度要求的为不同范式。范式的种类：\n\n第一范式(1NF)\n第二范式(2NF)\n第三范式(3NF)\nBC范式(BCNF)\n第四范式(4NF)\n第五范式(5NF)\n\n各种范式之间存在联系：1NF\\supset 2NF \\supset 3NF \\supset BCNF \\supset 4NF \\supset 5NF\n某一关系模式R为第n范式，可简记为R\\in nNF。\n一个低一级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化。\n\n2NF\n若关系模式R\\in 1NF，并且每一个非主属性都完全函数依赖于任何一个候选码，则R\\in 2NF。\n\n\n\n以上面问题为例，一个关系模式不属于2NF，会产生以下问题：\n\n\n插入异常\n如果插入一个新学生，但该生未选课，即该生无Cno，由于插入元组时，必须给定码值，因此插入失败。\n\n\n删除异常\n如果S4只选了一门课C3，现在他不再选这门课，则删除C3后，整个元组的其他信息也被删除了。\n\n\n修改复杂\n如果一个学生选了多门课，则Sdept，Sloc被存储了多次。如果该生转系，则需要修改所有相关的Sdept和Sloc，造成修改的复杂化。\n\n\n出现这种问题的原因是例子中有两类非主属性：一类如Grade，它对码完全函数依赖；另一类如Sdept、Sloc，它们对码不是完全函数依赖。\n解决方法：用投影分解把关系模式S-L-C分解成两个关系模式，SC(Sno,Cno,Grade)和S-L(Sno,Sdept,Sloc)。此时SC的码为(Sno,Cno)，SL的码为Sno，这样使得非主属性对码都是完全函数依赖了。\n\n3NF\n设关系模式R&lt;U,F&gt;\\in 1NF，若R中不存在这样的码X、属性组Y及非主属性Z(Z \\supseteq Y)，使得X\\to Y，Y\\to Z成立，Y \\nrightarrow X不成立，则称R&lt;U,F&gt; \\in 3NF。\nBCNF\n设关系模式R&lt;U,F&gt;\\in 1NF，若X \\to Y且Y \\subseteq   X时X必含有码，则R&lt;U,F&gt;\\in BCNF。\n换言之，在关系模式R&lt;U,F&gt;中，如果每一个决定属性集都包含候选码，则R\\in BCNF。\nBCNF的关系模式所具有的性质\n\n所有非主属性都完全函数依赖于每个候选码\n所有主属性都完全函数依赖于每个不包含它的候选码\n没有任何属性完全函数依赖于非码的任何一组属性\n\n如果一个关系数据库中的所有关系模式都属于BCNF，那么在函数依赖范畴内，它已实现了模式的彻底分解，达到了最高的规范化程度，消除了插入异常和删除异常。\n\n例1：关系模式SJP(S,J,P)中，S是学生，J表示 课程，P表示名次。每一个学生选修每门课程的成绩有一定的名次，每门课程中每一名次只有一个学生（即没有并列名次）。\n由语义可得到函数依赖： (S,J)\\to P，(J,P)\\to S。所以(S,J)与(J,P)都可以作为候选码。\n关系模式中没有属性对码传递依赖或部分依赖，所以SJP\\in 3NF。除(S,J)与(J,P)以外没有其他决定因素，所以SJP\\in BCNF。\n\n例2：关系模式STJ(S,T,J)中，S表示学生，T表示教师，J表示课程。每一教师只教一门课。每门课有若干教师，某一学生选定某门课，就对应一个固定的教师。\n由语义可得到函数依赖：(S,J)\\to T，(S,T)\\to J，T\\to J\n因为没有任何非主属性对码传递依赖或部分依赖，所以STJ\\in 3NF。因为T是决定因素，而T不包含码，所以STJ \\notin BCNF关系。\n\n多值依赖\n\n设学校中某一门课程由多个教师讲授，他们使用相同的一套参考书。每个教员可以讲授多门课程，每种参考书可以供多门课程使用。\n用关系模式Teaching(C,T,B)来表示课程C、教师T和参考书B之间的关系。\n\n\nTeaching具有唯一候选码(C,T,B)， 即全码，因而Teaching\\in BCNF 。\n存在问题：\n\n数据冗余度大：有多少名任课教师，参考书就要存储多少次。\n增加操作复杂：当某一课程增加一名任课教师时，该课程有多少本参照书，就必须插入多少个元组。\n删除操作复杂：某一门课要去掉一本参考书，该课程有多少名教师，就必须删除多少个元组\n修改操作复杂：某一门课要修改一本参考书，该课程有多少名教师，就必须修改多少个元组。\n\n问题产生原因：存在多值依赖\n\n定义：设R(U)是属性集U上的一个关系模式。X,Y,Z是U的子集，并且Z=U-X-Y。关系模式R(U)中多值依赖X\\to \\to Y成立，当且仅当对R(U)的任一关系r，给定的一对(x,z)值，有一组Y的值，这组值仅仅决定于x值而与z值无关。\n若X\\to \\to Y，而Z=\\emptyset，即Z为空，则称X\\to \\to Y为平凡的多值依赖。否则称X\\to \\to Y为非平凡的多值依赖。\n多值依赖的性质：\n\n多值依赖具有对称性。\n多值依赖具有传递性。\n函数依赖是多值依赖的特殊情况。\n若X→→Y，X→→Z，则X→→YZ。\n若X→→Y，X→→Z，则X→→Y∩Z。\n若X→→Y，X→→Z，则X→→Y-Z，X→→Z -Y。\n\n4NF\n定义：关系模式R&lt;U,F&gt;\\in 1NF，如果对于R的每个非平凡多值依赖X→→Y（Y ⊈ X），X都含有码，则R&lt;U,F&gt;∈4NF。\n4NF就是限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。4NF所允许的非平凡多值依赖实际上是函数依赖。\n如果一个关系模式是4NF， 则必为BCNF。\n小结\n在关系数据库中，对关系模式的基本要求是满足第一范式。\n规范化程度过低的关系不一定能够很好地描述现实世界，可能存在插入异常、删除异常、修改复杂、数据冗余等问题。解决方法就是对其进行规范化，转换成高级范式。\n一个低一级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式集合，这种过程就叫关系模式的规范化。关系数据库的规范化理论是数据库逻辑设计的工具。\n\n不能说规范化程度越高的关系模式就越好。必须对现实世界的实际情况和用户应用需求作进一步分析，确定一个合适的、能够反映现实世界的模式。\n数据依赖的公理系统\n数据依赖的公理系统是模式分解算法的理论基础。\n对于满足一组函数依赖F的关系模式   R &lt;U,F&gt;，其任何一个关系r，若函数依赖X→Y都成立（即r中任意两元组t、s，若t[X]=s[X]，则 t[Y]=s[Y]），则称F逻辑蕴涵X →Y。\nArmstrong公理系统：一套推理规则，是模式分解算法的理论基础\n用途：\n\n求给定关系模式的码\n从一组函数依赖求得蕴涵的函数依赖\n\nArmstrong公理系统，设U为属性集总体，F是U上的一组函数依赖， 于是有关系模式R &lt;U,F &gt;。对R &lt;U,F&gt; 来说有以下的推理规则：\n\nA1 自反律（reflexivity rule）：若Y  X  U，则X →Y 为F所蕴涵。\nA2 增广律（augmentation rule）：若X→Y为F所蕴涵，且Z  U，则XZ→YZ 为F所蕴涵。\nA3 传递律（transitivity rule）：若X→Y及Y→Z为F所蕴涵，则X→Z 为F所蕴涵。\n\n::: tip\n由自反律所得到的函数依赖均是平凡的函数依赖，自反律的使用并不依赖于F。\n:::\n根据A1，A2，A3这三条推理规则可以得到下面三条推理规则：\n\n合并规则：由X→Y，X→Z，有X→YZ。\n伪传递规则：由X→Y，WY→Z，有XW→Z。\n分解规则：由X→Y及ZY，有X→Z。\n"},"计算机基础/数据库系统概论/7_数据库设计":{"title":"数据库设计","links":[],"tags":["数据库"],"content":"数据库设计概述\n数据库设计：对于一个给定的应用环境，构造（设计）优化的数据库逻辑模式和物理结构，并据此建立数据库及其应用系统，使之能够有效地存储和管理数据，满足各种用户的应用需求，包括信息管理要求和数据操作要求。\n信息管理要求：在数据库中应该存储和管理哪些数据对象。\n数据操作要求：对数据对象需要进行哪些操作，如查询、增、删、改、统计等操作。\n数据库设计的目标：为用户和各种应用系统提供一个信息基础设施和高效率的运行环境 。\n高效率的运行环境包括：\n\n数据库数据的存取效率高\n数据库存储空间的利用率高\n数据库系统运行管理的效率高\n\n数据库设计的特点\n数据库建设的基本规律：\n\n三分技术，七分管理，十二分基础数据\n管理：数据库建设项目管理，企业（即应用部门）的业务管理\n基础数据数据的收集、整理、组织和不断更新\n\n\n数据库设计方法\n大型数据库设计是涉及多学科的综合性技术，又是一项庞大的工程项目。\n它要求多方面的知识和技术。主要包括：\n\n计算机的基础知识\n软件工程的原理和方法\n程序设计的方法和技巧\n数据库的基本知识\n数据库设计技术\n应用领域的知识\n\n早期主要采用手工试凑法，缺点是：\n\n设计质量与设计人员的经验和水平有直接关系\n缺乏科学理论和工程方法的支持，工程的质量难以保证\n数据库运行一段时间后常常又不同程度地发现各种问题，增加了维护代价\n\n现在采用的是规范设计法，基本思想是过程迭代和逐步求精。典型方法：\n\n新奥尔良（New Orleans）方法\n基于E-R模型的数据库设计方法\n3NF（第三范式）的设计方法\n面向对象的数据库设计方法\n统一建模语言（UML）方法\n\n数据库设计的基本步骤\n数据库设计分6个阶段：\n\n需求分析\n概念结构设计\n逻辑结构设计\n物理结构设计\n数据库实施\n数据库运行和维护\n\n\n需求分析和概念设计独立于任何数据库管理系统 ，逻辑设计和物理设计与选用的数据库管理系统密切相关。\n参加数据库设计的人员有：\n\n\n系统分析人员和数据库设计人员\n自始至终参与数据库设计，其水平决定了数据库系统的质量。\n\n\n数据库管理员和用户代表\n主要参加需求分析与数据库的运行和维护。\n\n\n应用开发人员\n包括程序员和操作员，在实施阶段参与进来，分别负责编制程序和准备软硬件环境。\n\n\n\n数据库设计过程中的各级模式\n数据库设计不同阶段形成的数据库各级模式\n\n需求分析\n需求分析的任务\n需求分析就是分析用户的要求，是设计数据库的起点。\n分析结果是否准确地反映了用户的实际要求，将直接影响到后面各个阶段的设计，并影响到设计结果是否合理和实用。\n调查的重点是“数据”和“处理”，获得用户对数据库的要求，如：\n\n信息要求\n处理要求\n安全性与完整性要求\n\n需求分析的方法\n进行需求分析首先是调查清楚用户的实际需求并进行初步分析，与用户达成共识，分析与表达这些需求。\n调查用户需求步骤：\n\n调查组织机构情况\n调查各部门的业务活动情况\n协助用户明确对新系统的各种要求，包括信息要求、处理要求、完全性与完整性要求\n确定新系统的边界\n\n常用调查方法：\n\n跟班作业\n开调查会\n请专人介绍\n询问\n设计调查表请用户填写\n查阅记录\n\n\n数据字典\n数据字典是关于数据库中数据的描述，即元数据，不是数据本身。\n数据字典在需求分析阶段建立，在数据库设计过程中不断修改、充实、完善。\n数据字典是进行详细的数据收集和数据分析所获得的主要结果。\n数据字典的内容：\n\n\n数据项\n数据项是数据的最小组成单位，是不可再分的数据单位。若干个数据项可以组成一个数据结构。数据字典通过对数据项和数据结构的定义来描述数据流、数据存储的逻辑内容。\n数据项描述 ={数据项名,数据项含义说明,别名, 数据类型,长度,取值范围,取值含义, 与其他数据项的逻辑关系, 数据项之间的联系 }\n\n\n数据结构\n数据结构反映了数据之间的组合关系。\n一个数据结构可以由若干个数据项组成，也可以由若干个数据结构组成，或由若干个数据项和数据结构混合组成。\n数据结构描述 = {数据结构名，含义说明，组成:{数据项或数据结构}}\n\n\n数据流\n数据流是数据结构在系统内传输的路径。\n数据流描述 ={数据流名,说明,数据流来源,数据流去向,组成:{数据结构},平均流量,高峰期流量}\n\n\n数据存储\n数据存储是数据结构停留或保存的地方，也是数据流的来源和去向之一。\n数据存储描述 ={数据存储名,说明,编号,输入的数据流,输出的数据流,组成 :{数据结构},数据量,\n存取频度,存取方式}\n\n\n处理过程\n处理过程的具体处理逻辑一般用判定表或判定树来描述。数据字典中只需要描述处理过程的说明性信息。\n处理过程描述 ={处理过程名,说明,输入:{数据流},输出 :{数据流},处理:{简要说明}}\n\n\n概念结构设计\n概念模型\n将需求分析得到的用户需求抽象为信息结构（即概念模型）的过程就是概念结构设计。\n概念模型的特点：\n\n能真实、充分地反映现实世界，是现实世界的一个真实模型。\n易于理解，从而可以用它和不熟悉计算机的用户交换意见。\n易于更改，当应用环境和应用要求改变时，容易对概念模型修改和扩充。\n易于向关系、网状、层次等各种数据模型转换\n\n描述概念模型的工具：E-R模型\nE-R模型\n联系的度：参与联系的实体型的数目\n\n2个实体型之间的联系度为2，也称为二元联系；\n3个实体型之间的联系度为3，称为三元联系；\nN个实体型之间的联系度为N，也称为N元联系；\n\n实体之间的联系\n两个实体型之间的联系：\n\n\n一对一联系（1∶1）\n如果对于实体集A中的每一个实体，实体集B中至多有一个（也可以没有）实体与之联系，反之亦然，则称实体集A与实体集B具有一对一联系，记为1∶1。\n\n例如，学校里一个班级只有一个正班长，而一个班长只在一个班中任职，则班级与班长之间具有一对一联系。\n\n\n\n一对多联系（1∶n）\n如果对于实体集A中的每一个实体，实体集B中有n个实体（n≥0）与之联系，反之，对于实体集B中的每一个实体，实体集A中至多只有一个实体与之联系，则称实体集A与实体集B有一对多联系，记为1∶n。\n\n例如，一个班级中有若干名学生，而每个学生只在一个班级中学习，则班级与学生之间具有一对多联系。\n\n\n\n多对多联系（m∶n）\n如果对于实体集A中的每一个实体，实体集B中有n个实体（n≥0）与之联系，反之，对于实体集B中的每一个实体，实体集A中也有m个实体（m≥0）与之联系，则称实体集A与实体集B具有多对多联系，记为m∶n。\n\n例如，一门课程同时有若干个学生选修，而一个学生可以同时选修多门课程，则课程与学生之间具有多对多联系。\n\n\n\n\n两个以上的实体型之间的联系：一般地，两个以上的实体型之间也存在着一对一、一对多、多对多联系。\n\n例如：对于课程、教师与参考书3个实体型，如果一门课程可以有若干个教师讲授，使用若干本参考书，而每一个教师只讲授一门课程，每一本参考书只供一门课程使用，则课程与教师、参考书之间的联系是一对多的。\n\n\n单个实体型内的联系：同一个实体集内的各实体之间也可以存在一对一、一对多、多对多的联系。\n\n例如，职工实体型内部具有领导与被领导的联系，即某一职工（干部）“领导”若干名职工，而一个职工仅被另外一个职工直接领导，因此这是一对多的联系。\n\n\nE-R图\nE-R图提供了表示实体型、属性和联系的方法：\n\n实体型：用矩形表示，矩形框内写明实体名。\n属性：用椭圆形表示，并用无向边将其与相应的实体型连接起来。\n联系：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体型连接起来，同时在无向边旁标上联系的类型（1∶1，1∶n或m∶n）。联系可以具有属性。\n\n\n例如，学生实体具有学号、姓名、性别、出生年份、系、入学时间等属性，用E-R图表示如图所示。\n\n\n\n例如：用供应量来描述联系供应的属性，表示某供应商供应了多少数量的零件给某个数目。\n\n\n一个实例\n某个工厂物资管理的概念模型。物资管理涉及的实体有：\n\n仓库：属性有仓库号、面积、电话号码\n零件：属性有零件号、名称、规格、单价、描述\n供应商：属性有供应商号、姓名、地址、电话号码、账号\n项目：属性有项目号、预算、开工日期\n职工：属性有职工号、姓名、年龄、职称\n\n这些实体之间的联系如下：\n\n一个仓库可以存放多种零件，一种零件可以存放在多个仓库中，因此仓库和零件具有多对多的联系。用库存量来表示某种零件在某个仓库中的数量。\n一个仓库有多个职工当仓库保管员，一个职工只能在一个仓库工作，因此仓库和职工之间是一对多的联系。\n职工之间具有领导与被领导关系。即仓库主任领导若干保管员，因此职工实体型中具有一对多的联系。\n供应商、项目和零件三者之间具有多对多的联系。即一个供应商可以供给若干项目多种零件，每个项目可以使用不同供应商供应的零件，每种零件可由不同供应商供给。\n\n\n\n\n概念结构设计\n实体与属性的划分原则\n为了简化E-R图的处置，现实世界的事物能作为属性对待的，尽量作为属性对待。\n事物作为属性的两条准则：\n\n作为属性，不能再具有需要描述的性质。属性必须是不可分的数据项，不能包含其他属性。\n属性不能与其他实体具有联系，即E-R图中所表示的联系是实体之间的联系。\n\n\n例1：\n职工是一个实体，职工号、姓名、年龄是职工的属性。\n如果职称没有与工资、福利挂钩，根据准则1可以作为职工实体的属性。如果不同的职称有不同的工资、住房标准和不同的附加福利，则职称作为一个实体更恰当。\n\n\n例2：\n在医院中，一个病人只能住在一个病房，病房号可以作为病人实体的一个属性；如果病房还要与医生实体发生联系，即一个医生负责几个病房的病人的医疗工作，则根据准则2病房应作为一个实体。\n\n\n例3：\n如果一种货物只存放在一个仓库，那么就可以把存放货物的仓库的仓库号作为描述货物存放地点的属性。\n如果一种货物可以存放在多个仓库中，或者仓库本身又用面积作为属性，或者仓库与职工发生管理上的联系，那么就应把仓库作为一个实体。\n\n\n例4：\n销售管理子系统E-R图的设计。该子系统的主要功能是：处理顾客和销售员送来的订单；工厂是根据订货安排生产的；交出货物同时开出发票；收到顾客付款后，根据发票存根和信贷情况进行应收款处理。\n参照需求分析和数据字典中的详尽描述，遵循前面给出的两个准则，进行了如下调整：\n\n\n每张订单由订单号、若干头信息和订单细节组成。订单细节又有订货的零件号、数量等来描述。按照准则2，订单细节就不能作订单的属性处理而应该上升为实体。一张订单可以订若干产品，所以订单与订单细节两个实体之间是1∶ n的联系。\n\n\n\n原订单和产品的联系实际上是订单细节和产品的联系。每条订货细节对应一个产品描述，订单处理时从中获得当前单价、产品重量等信息。\n\n\n工厂对大宗订货给予优惠。每种产品都规定了不同订货数量的折扣，应增加一个“折扣规则”实体存放这些信息，而不应把它们放在产品实体中。\n\n\n最后得到销售管理子系统E-R图如图所示。\n\n对每个实体定义的属性如下：\n顾客：{顾客号，顾客名，地址，电话，信贷状况，账目余额}\n订单：{订单号，顾客号，订货项数，订货日期，交货日期，工种号，生产地点}\n订单细则：{订单号，细则号，零件号，订货数，金额}\n应收账款：{顾客号，订单号，发票号，应收金额，支付日期，支付金额，当前余额，货款限额}\n产品：{产品号，产品名，单价，重量}\n折扣规则：{产品号，订货量，折扣}\n\nE-R图的集成\n\n由上图可知，E-R图的集成一般需要分两步：\n合并\n解决各分E-R图之间的冲突，将分E-R图合并起来生成初步E-R图。\n各个局部应用所面向的问题不同，各个子系统的E-R图之间必定会存在许多不一致的地方，称之为冲突。\n子系统E-R图之间的冲突主要有三类：\n\n\n属性冲突\n\n\n属性域冲突，即属性值的类型、取值范围或取值集合不同。\n\n例如零件号，有的部门把它定义为整数，有的部门把它定义为字符型。年龄，某些部门以出生日期形式表示职工的年龄，而另一些部门用整数表示职工的年龄。\n\n\n\n属性取值单位冲突。\n\n例如，零件的重量有的以公斤为单位，有的以斤为单位，有的以克为单位。\n\n\n\n\n\n命名冲突\n\n\n同名异义，即不同意义的对象在不同的局部应用中具有相同的名字。\n\n\n异名同义（一义多名），即同一意义的对象在不同的局部应用中具有不同的名字。\n\n如对科研项目，财务科称为项目，科研处称为课题，生产管理处称为工程。\n\n\n\n命名冲突\n可能发生在实体、联系一级上，也可能发生在属性一级上。需要通过讨论、协商等行政手段加以解决。\n\n\n\n\n结构冲突\n\n\n同一对象在不同应用中具有不同的抽象。\n\n例如，职工在某一局部应用中被当作实体，而在另一局部应用中则被当作属性。\n\n解决方法：把属性变换为实体或把实体变换为属性，使同一对象具有相同的抽象。\n\n\n同一实体在不同子系统的E-R图中所包含的属性个数和属性排列次序不完全相同。\n解决方法：使该实体的属性取各子系统的E-R图中属性的并集，再适当调整属性的次序。\n\n\n实体间的联系在不同的E-R图中为不同的类型。\n\n例如，实体E1与E2在一个E-R图中是多对多联系，在另一个E-R图中是一对多联系\n\n解决方法是根据应用的语义对实体联系的类型进行综合或调整。\n\n\n\n\n\n修改和重构\n由于合并生成的初步E-R图可能存在冗余的数据和冗余的联系，因此需要消除不必要的冗余，生成基本E-R图。\n\n冗余的数据：可由基本数据导出的数据\n冗余的联系：可由其他联系导出的联系。\n\n消除冗余主要采用分析方法，即以数据字典和数据流图为依据，根据数据字典中关于数据项之间逻辑关系的说明来消除冗余。\n\n\n\n::: tip\n并不是所有的冗余数据与冗余联系都必须加以消除，有时为了提高效率，不得不以冗余信息作为代价。\n:::\n除了分析方法外，还可以用规范化理论来消除冗余。\n\n\n确定分E-R图实体之间的数据依赖。\n实体之间一对一、一对多、多对多的联系可以用实体码之间的函数依赖来表示。于是有函数依赖集F_L。\n\n如下图中：部门和职工之间一对多的联系可表示为职工号→部门号 职工和产品之间多对多的联系可表示为（职工号，产品号）→工作天数等。\n\n\n\n\n求F_L的最小覆盖G_L，差集为 D=F_L-G_L。\n逐一考察D中的函数依赖，确定是否是冗余的联系，若是，就把它去掉。\n由于规范化理论受到泛关系假设的限制，应注意下面两个问题：\n\n冗余的联系一定在D中，而D中的联系不一定是冗余的。\n当实体之间存在多种联系时，要将实体之间的联系在形式上加以区分。\n\n\n\n逻辑结构设计\n逻辑结构设计的任务是把概念结构设计阶段设计好的基本E-R图转换为与选用数据库管理系统产品所支持的数据模型相符合的逻辑结构。\nE-R图向关系模型的转换\nE-R图由实体型、实体的属性和实体型之间的联系三个要素组成。\n关系模型的逻辑结构是一组关系模式的集合。\n将E-R图转换为关系模型实际上就是将实体型、实体的属性和实体型之间的联系转化为关系模式。\n转换原则：\n\n一个实体型转换为一个关系模式\n\n关系的属性：实体的属性；关系的码：实体的码。\n\n实体型间的联系有以下不同情况\n\n\n\n一个1 : 1联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并。\n\n\n转换为一个独立的关系模式：\n关系的属性：与该联系相连的各实体的码以及联系本身的属性；\n关系的候选码：每个实体的码均是该关系的候选码；\n\n\n与某一端实体对应的关系模式合并\n合并后关系的属性：加入对应关系的码和联系本身的属性；\n合并后关系的码：不变；\n\n\n\n\n一个1 : n联系可以转换为一个独立的关系模式，也可以与n端对应的关系模式合并。\n\n\n转换为一个独立的关系模式\n关系的属性：与该联系相连的各实体的码以及联系本身的属性；\n关系的码：n端实体的码；\n\n\n与n端对应的关系模式合并\n合并后关系的属性：在n端关系中加入1端关系的码和联系本身的属性；\n合并后关系的码：不变；\n可以减少系统中的关系个数，一般情况下更倾向于采用这种方法；\n\n\n\n\n一个m : n联系转换为一个关系模式\n关系的属性：与该联系相连的各实体的码以及联系本身的属性；\n关系的码：各实体码的组合；\n\n\n三个或三个以上实体间的一个多元联系转换为一个关系模式。\n关系的属性：与该多元联系相连的各实体的码以及联系本身的属性；\n关系的码：各实体码的组合；\n\n\n具有相同码的关系模式可合并\n目的：减少系统中的关系个数\n合并方法：\n\n将其中一个关系模式的全部属性加入到另一个关系模式中\n然后去掉其中的同义属性（可能同名也可能不同名）\n适当调整属性的次序\n\n\n\n数据模型的优化\n一般的数据模型还需要向特定数据库管理系统规定的模型进行转换。转换的主要依据是所选用的数据库管理系统的功能及限制。没有通用规则。\n对于关系模型来说，这种转换通常都比较简单。\n数据库逻辑设计的结果不是唯一的。\n得到初步数据模型后，还应该适当地修改、调整数据模型的结构，以进一步提高数据库应用系统的性能，这就是数据模型的优化。\n关系数据模型的优化通常以规范化理论为指导。\n优化数据模型的方法:\n\n\n确定数据依赖\n\n\n对于各个关系模式之间的数据依赖进行极小化处理，消除冗余的联系。\n\n\n按照数据依赖的理论对关系模式进行分析，考察是否存在部分函数依赖、传递函数依赖、多值依赖等，确定各关系模式分别属于第几范式。\n\n\n按照需求分析阶段得到的各种应用对数据处理的要求，分析对于这样的应用环境这些模式是否合适，确定是否要对它们进行合并或分解。\n并不是规范化程度越高的关系就越优。当查询经常涉及两个或多个关系模式的属性时，系统必须经常地进行连接运算，连接运算的代价是相当高的。因此在这种情况下，第二范式甚至第一范式也许是适合的。\n非BCNF的关系模式虽然会存在不同程度的更新异常，但如果在实际应用中对此关系模式只是查询，并不执行更新操作，就不会产生实际影响。\n对于一个具体应用来说，到底规范化进行到什么程度，需要权衡响应时间和潜在问题两者的利弊才能决定\n\n\n对关系模式进行必要分解，提高数据操作效率和存储空间的利用率。\n常用分解方法：\n\n\n水平分解\n把(基本)关系的元组分为若干子集合，定义每个子集合为一个子关系，以提高系统的效率。\n\n\n垂直分解\n把关系模式R的属性分解为若干子集合，形成若干子关系模式。\n可以提高某些事务的效率，但可能使另一些事务不得不执行连接操作，降低了效率。\n\n\n\n\n设计用户子模式\n定义数据库模式主要是从系统的时间效率、空间效率、易维护等角度出发。\n定义用户外模式时应该更注重考虑用户的习惯与方便。包括三个方面：\n\n\n使用更符合用户习惯的别名\n合并各分E-R图曾做了消除命名冲突的工作，以使数据库系统中同一关系和属性具有唯一的名字。这在设计数据库整体结构时是非常必要的。\n用视图机制可以在设计用户视图时可以重新定义某些属性名，使其与用户习惯一致，以方便使用。\n\n\n针对不同级别的用户定义不同的视图，以保证系统的安全性。\n\n假设有关系模式产品（产品号，产品名，规格，单价，生产车间，生产负责人，产品成本，产品合格率，质量等级），可以在产品关系上建立两个视图：\n为一般顾客建立视图：产品1（产品号，产品名，规格，单价）\n为产品销售部门建立视图： 产品2（产品号，产品名，规格，单价，车间，生产负责人）\n\n\n\n简化用户对系统的使用\n如果某些局部应用中经常要使用某些很复杂的查询，为了方便用户，可以将这些复杂查询定义为视图。\n\n\n物理结构设计\n数据库在物理设备上的存储结构与存取方法称为数据库的物理结构，它依赖于选定的数据库管理系统。\n为一个给定的逻辑数据模型选取一个最适合应用要求的物理结构的过程，就是数据库的物理设计。\n数据库物理设计的步骤：\n\n确定数据库的物理结构，在关系数据库中主要指存取方法和存储结构。\n对物理结构进行评价，评价的重点是时间和空间效率。\n若评价结果满足原设计要求，则可进入到物理实施阶段。否则，就需要重新设计或修改物理结构，有时甚至要返回逻辑设计阶段修改数据模型。\n\n数据库物理设计的内容和方法\n设计物理数据库结构的准备工作\n\n充分了解应用环境，详细分析要运行的事务，以获得选择物理数据库设计所需参数。\n充分了解所用关系型数据库管理系统的内部特征，特别是系统提供的存取方法和存储结构。\n\n选择物理数据库设计所需参数\n\n\n数据库查询事务\n查询的关系，查询条件所涉及的属性，连接条件所涉及的属性，查询的投影属性。\n\n\n数据更新事务\n被更新的关系，每个关系上的更新操作条件所涉及的属性，修改操作要改变的属性值。\n\n\n每个事务在各关系上运行的频率和性能要求\n\n\n关系数据库物理设计的内容\n\n为关系模式选择存取方法（建立存取路径）\n设计关系、索引等数据库文件的物理存储结构\n\n关系模式存取方法选择\n数据库系统是多用户共享的系统，对同一个关系要建立多条存取路径才能满足多用户的多种应用要求。\n物理结构设计的任务之一是根据关系数据库管理系统支持的存取方法确定选择哪些存取方法。\n数据库管理系统常用存取方法：\n\n\nB+树索引存取方法\n根据应用要求确定，对哪些属性列建立索引，对哪些属性列建立组合索引，对哪些索引要设计为唯一索引。\n选择索引存取方法的一般规则：\n\n如果一个（或一组）属性经常在查询条件中出现，则考虑在这个（或这组）属性上建立索引（或组合索引）。\n如果一个属性经常作为最大值和最小值等聚集函数的参数，则考虑在这个属性上建立索引。\n如果一个（或一组）属性经常在连接操作的连接条\n件中 出现，则考虑在这个（或这组）属性上建立索\n引。\n\n关系上定义的索引数过多会带来较多的额外开销，如维护索引的开销和查找索引的开销。\n\n\nHash索引存取方法\n如果一个关系的属性主要出现在等值连接条件中或主要出现在等值比较选择条件中，而且满足下列两个条件之一，则此关系可以选择hash存取方法。\n\n关系的大小可预知，而且不变；\n该关系的大小动态改变，但所选用的数据库管理系统提供了动态Hash存取方法。\n\n\n\n聚簇存取方法\n为了提高某个属性（或属性组）的查询速度，把这个或这些属性（称为聚簇码）上具有相同值的元组集中存放在连续的物理块中称为聚簇。\n该属性（或属性组）称为聚簇码（cluster key）许多关系型数据库管理系统都提供了聚簇功能。\n建立聚簇索引后，基表中数据也需要按指定的聚簇属性值的升序或降序存放。也即聚簇索引的索引项顺序与表中元组的物理顺序一致。\n在一个基本表上最多只能建立一个聚簇索引。\n聚簇索引的适用条件：很少对基表进行增删操作，很少对其中的变长列进行修改操作。\n\n\n聚簇的用途：\n\n大大提高按聚簇属性进行查询的效率\n\n\n例：\n假设学生关系按所在系建有索引，现在要查询信息系的所有学生名单。\n计算机系的500名学生分布在500个不同的物理块上时，至少要执行500次I/O操作。\n如果将同一系的学生元组集中存放，则每读一个物理块可得到多个满足查询条件的元组，从而显著地减少了访问磁盘的次数。\n\n\n节省存储空间\n\n聚簇以后，聚簇码相同的元组集中在一起了，因而聚簇码值不必在每个元组中重复存储，只要在一组中存一次就行了。\n聚簇的局限性：\n\n\n聚簇只能提高某些特定应用的性能。\n\n\n建立与维护聚簇的开销相当大。\n对已有关系建立聚簇，将导致关系中元组的物理存储位置移动，并使此关系上原有的索引无效，必须重建。当一个元组的聚簇码改变时，该元组的存储位置也要做相应改变。\n\n\n聚簇的适用范围：\n\n既适用于单个关系独立聚簇，也适用于多个关系组合聚簇。\n当通过聚簇码进行访问或连接是该关系的主要应用，与聚簇码无关的其他访问很少或者是次要的时，可以使用聚簇。\n\n选择聚簇存取方法：\n\n设计候选聚簇\n\n常在一起进行连接操作的关系可以建立组合聚簇。\n如果一个关系的一组属性经常出现在相等比较条件中，则该单个关系可建立聚簇。\n如果一个关系的一个（或一组）属性上的值重复率很高，则此单个关系可建立聚簇。\n\n\n检查候选聚簇中的关系，取消其中不必要的关系\n\n从聚簇中删除经常进行全表扫描的关系\n从聚簇中删除更新操作远多于连接操作的关系\n从聚簇中删除重复出现的关系\n\n\n\n当一个关系同时加入多个聚簇时，必须从这多个聚簇方案（包括不建立聚簇）中选择一个较优的，即在这个聚簇上运行各种事务的总代价最小。\n确定数据库的存储结构\n确定数据库物理结构主要指确定数据的存放位置和存储结构，包括：确定关系、索引、聚簇、日志、备份等的存储安排和存储结构，确定系统配置等。\n确定数据的存放位置和存储结构要综合考虑存取时间、存储空间利用率和维护代价3个方面的因素。\n确定数据的存放位置基本原则：根据应用情况将易变部分与稳定部分分开存放，经常存取部分与存取频率较低部分分开存放。\n\n例：\n可以将比较大的表分别放在两个磁盘上，以加快存取速度，这在多用户环境下特别有效。\n可以将日志文件与数据库对象（表、索引等）放在不同的磁盘以改进系统的性能。\n\n评价物理结构\n对数据库物理设计过程中产生的多种方案进行评价，从中选择一个较优的方案作为数据库的物理结构。\n评价方法：\n\n定量估算各种方案的存储空间、存取时间。维护代价。\n对估算结果进行权衡、比较，选择出一个较优的合理的物理结构。\n\n数据库的实施和维护\n数据的载入和应用程序的调试\n数据库结构建立好后，就可以向数据库中装载数据了。组织数据入库是数据库实施阶段最主要的工作。\n数据装载方法：\n\n人工方法\n计算机辅助数据入库\n\n数据库应用程序的设计应该与数据设计并行进行。\n数据库的试运行\n应用程序调试完成，并且已有一小部分数据入库后，就可以开始对数据库系统进行联合调试，也称数据库的试运行。主要工作包括：\n\n功能测试：实际运行应用程序，执行对数据库的各种操作，测试应用程序的各种功能。\n性能测试：测量系统的性能指标，分析是否符合设计目标。\n\n数据库性能指标的测量\n\n数据库物理设计阶段在评价数据库结构估算时间、空间指标时，作了许多简化和假设，忽略了许多次要因素，因此结果必然很粗糙。\n数据库试运行则是要实际测量系统的各种性能指标（不仅是时间、空间指标），如果结果不符合设计目标，则需要返回物理设计阶段，调整物理结构，修改参数；有时甚至需要返回逻辑设计阶段，调整逻辑结构。\n\n重新设计物理结构甚至逻辑结构，会导致数据重新入库。由于数据入库工作量实在太大，所以可以采用分期输入数据的方法：先输入小批量数据供先期联合调试使用，待试运行基本合格后再输入大批量数据，逐步增加数据量，逐步完成运行评价。\n在数据库试运行阶段，必须做好数据库的转储和恢复工作，尽量减少对数据库的破坏。\n数据库的运行和维护\n在数据库运行阶段，对数据库经常性的维护工作主要是由数据库管理员完成的，包括：\n\n\n数据库的转储和恢复\n\n\n数据库的安全性、完整性控制\n\n\n数据库性能的监督、分析和改进\n\n\n数据库的重组织与重构造\n\n\n数据库的重组织\n为什么要重组织数据库：\n数据库运行一段时间后，由于记录的不断增、删、改，会使数据库的物理存储变坏，从而降低数据库存储空间的利用率和数据的存取效率，使数据库的性能下降。\n重组织的形式：全部重组织，部分重组织。\n重组织的目标：提高系统性能。\n重组织的工作：按原设计要求重新安排存储位置，回收垃圾，减少指针链。数据库的重组织不会改变原设计的数据逻辑结构和物理结构。\n数据库管理系统一般都提供了供重组织数据库使用的实用程序，帮助数据库管理员重新组织数据库。\n\n\n数据库的重构造\n为什么要进行数据库的重构造：\n数据库应用环境发生变化，会导致实体及实体间的联系也发生相应的变化，使原有的数据库设计不能很好地满足新的需求，如增加新的应用或新的实体，取消某些已有应用，改变某些已有应用。\n数据库重构造的主要工作：根据新环境调整数据库的模式和内模式，增加或删除某些数据项，改变数据项的类型，增加或删除某个表，改变数据库的容量，增加或删除某些索引。\n重构造数据库的程度是有限的，若应用变化太大，已无法通过重构数据库来满足新的需求，或重构数据库的代价太大，则表明现有数据库应用系统的生命周期已经结束，应该重新设计新的数据库应用系统了。\n\n\n\n"},"计算机基础/数据库系统概论/8_数据库编程":{"title":"数据库编程","links":[],"tags":["数据库"],"content":"嵌入式SQL\n::: tip\nSQL语言提供了两种不同的使用方式：\n\n交互式\n嵌入式\n\n由于SQL语言是非过程性语言，事务处理应用需要高级语言，因此需要引入嵌入式SQL。\n:::\n嵌入式SQL的处理过程\n嵌入式SQL是将SQL语句嵌入程序设计语言中，被嵌入的程序设计语言，如C、C++、Java，称为宿主语言，简称主语言。\n\n嵌入式SQL语句与主语言之间的通信\n将SQL嵌入到高级语言中混合编程，程序中会含有两种不同计算模型的语句\nSQL语句\n\nSQL语句：描述性的面向集合的语句，负责操纵数据库。\n高级语言语句：过程性的面向记录的语句，负责控制逻辑流程。\n\n数据库工作单元与源程序工作单元之间的通信包括：\n\n向主语言传递SQL语句的执行状态信息，使主语言能够据此控制程序流程，主要用SQL通信区实现\n主语言向SQL语句提供参数，主要用主变量实现\n将SQL语句查询数据库的结果交主语言处理，主要用主变量和游标实现\n\n嵌入式SQL语句中可以使用主语言的程序变量来输入或输出数据。\n\n在SQL语句中使用的主语言程序变量简称为主变量。\n主变量的类型有：\n\n输入主变量：由应用程序对其赋值，SQL语句引用。\n输出主变量：由SQL语句对其赋值或设置状态信息，返回给应用程序。\n\n指示变量是一个整型变量，用来“指示”所指主变量的值或条件，一个主变量可以附带一个指示变量。\n指示变量的用途：指示输入主变量是否为空值；检测输出变量是否为空值，值是否被截断。\n\n为什么要使用游标，因为SQL语言与主语言具有不同数据处理方式：\n\nSQL语言是面向集合的，一条SQL语句原则上可以产生或处理多条记录。\n主语言是面向记录的，一组主变量一次只能存放一条记录。\n\n仅使用主变量并不能完全满足SQL语句向应用程序输出数据的要求，嵌入式SQL引入了游标的概念，用来协调这两种不同的处理方式。\n游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果。每个游标区都有一个名字。用户可以用SQL语句逐一从游标中获取记录，并赋给主变量，交由主语言进一步处理。\n不用游标的SQL语句\n不用游标的SQL语句：\n\n说明性语句\n数据定义语句\n数据控制语句\n查询结果为单记录的SELECT语句\n非CURRENT形式的增删改语句\n\n查询结果为单记录的SELECT语句，非CURRENT形式的增删改语句，这两类语句不需要使用游标，只需用INTO子句指定存放查询结果的主变量。\n使用游标的SQL语句\n必须使用游标的SQL语句：\n\n查询结果为多条记录的SELECT语句\nCURRENT形式的UPDATE语句\nCURRENT形式的DELETE语句\n\n动态SQL\n静态嵌入式SQL：静态嵌入式SQL语句能够满足一般要求，但无法满足要到执行时才能够确定要提交的SQL语句、查询的条件 。\n动态嵌入式SQL：允许在程序运行过程中临时“组装”SQL语句，支持动态组装SQL语句和动态参数两种形式 。\n过程化SQL\n基本的SQL是高度非过程化的语言，嵌入式SQL借助高级语言的控制功能实现过程化。\n“过程化SQL”通常指的是使用存储过程的SQL编程。存储过程是一组预编译的SQL语句，它们被存储在数据库中并可以被重复调用。这种方法允许将一系列SQL语句封装到一个单独的可执行单元中，提供了更高的模块化和可维护性。\n过程化SQL的块结构\n过程化SQL的基本结构是块，块之间可以互相嵌套 ，每个块完成一个逻辑操作。\n基本结构：\n\n\n定义部分\nDECLARE 变量、常量、游标、异常等\n定义的变量、常量等只能在该基本块中使用，当基本块执行结束时，定义就不再存在。\n\n\n执行部分\nBEGIN\n\t\tSQL语句、过程化SQL的流程控制语句\nEXCEPTION\n\t\t异常处理部分        \t\t\nEND；\n\n\n变量和常量的定义\n\nwww.cnblogs.com/easonjim/p/7966918.html\n\n在MySQL中，变量和常量的定义和赋值语法略有不同。以下是在MySQL中定义和使用变量和常量的语法：\n\n变量定义\n\n-- 定义变量\nSET @variable_name = value; \n \n-- 或者使用 DECLARE\nDECLARE variable_name datatype [DEFAULT value];\n \n-- 赋值\nSET @variable_name = expression;\n在MySQL中，\n使用 SET 语句来定义和赋值变量，可以在一个会话的任何地方声明，作用域是整个会话，称为用户变量。\n使用 DECLARE 语句来定义局部变量，主要用在存储过程中，或者是给存储传参数中。\n::: tip 区别\n在调用存储过程时，以declare声明的变量都会被初始化为null。而会话变量（即@开头的变量）则不会被再初始化，在一个会话内，只须初始化一次，之后在会话内都是对上一次计算的结果，就相当于在是这个会话内的全局变量。\n:::\n\n常量定义\n\nMySQL没有直接支持用户定义的常量，但可以使用用户变量来模拟常量的行为。用户变量在会话结束前保持不变，因此可以看作是会话级别的常量。例如：\n-- 定义&quot;常量&quot;\nSET @constant_name = constant_value;\n \n-- 使用&quot;常量&quot;\nSELECT @constant_name;\n::: tip\n在MySQL中，没有像其他一些数据库管理系统那样明确的常量定义语法。\n:::\n\n赋值语句\n\nset @num = 1; \nset @num := 1;\nselect @num := 1; \nselect @num := 字段名 from 表名 where ...\nselect语句一般用来输出用户变量，比如select @变量名，用于输出数据源不是表格的数据。\n使用set时可以用“=”或“:=”，但是使用select时必须用“:=赋值”。\n流程控制\n在MySQL中，条件控制语句通常用于根据特定条件执行或跳过某些SQL语句。以下是MySQL中常见的条件控制语句：\n条件控制语句\n\n\nIF语句\nIF search_condition THEN statement_list\n    [ELSEIF search_condition THEN statement_list]...\n    [ELSE statement_list]\nEND IF\n\n-- 例如：\nSET @num = 10;\nIF @num &gt; 5 THEN\n SELECT &#039;Number is greater than 5&#039;;\nELSE\n SELECT &#039;Number is not greater than 5&#039;;\n   END IF;\n\n\n\nCASE语句\n-- 1.\nCASE case_value\n    WHEN when_value THEN statement_list\n    [WHEN when_value THEN statement_list]...\n    [ELSE statement_list]\nEND CASE\n-- 2.\nCASE\n    WHEN search_condition THEN statement_list\n    [WHEN search_condition THEN statement_list] ...\n    [ELSE statement_list]\nEND CASE\n\n-- 例如：\nCASE age\n    WHEN 20 THEN SET @count1=@count1+1;\n    ELSE SET @count2=@count2+1;\nEND CASE;\n \nCASE\n    WHEN age=20 THEN SET @count1=@count1+1;\n    ELSE SET @count2=@count2+1;\nEND CASE;\n\n\n\n循环控制语句\n\n\nLOOP 语句\n[begin_label:]LOOP\n    statement_list\nEND LOOP [end_label]\nLOOP 语句可以使某些特定的语句重复执行。与 IF 和 CASE 语句相比，LOOP 只实现了一个简单的循环，并不进行条件判断。\nLOOP 语句本身没有停止循环的语句，必须使用 LEAVE 语句等才能停止循环，跳出循环过程。\n\n\nWHILE 语句\n[begin_label:] WHILE search_condition DO\n    statement list\nEND WHILE [end label]\n\n-- 例如：\nWHILE @count&lt;100 DO\n    SET @count=@count+1;\nEND WHILE;\n\n\n\nITERATE 语句\nITERATE label\n用来跳出本次循环，直接进入下一次循环。\n\n-- 例如：\nadd_num:LOOP\n    SET @count=@count+1;\n    IF @count=100 THEN\n        LEAVE add_num;\n    ELSE IF MOD(@count,3)=0 THEN\n        ITERATE add_num;\n    SELECT * FROM employee;\nEND LOOP add_num;\n\n::: tip\nLEAVE 语句和 ITERATE 语句都用来跳出循环语句，但两者的功能是不一样的。\nLEAVE 语句是跳出整个循环，然后执行循环后面的程序。而 ITERATE 语句是跳出本次循环，然后进入下一次循环。\n:::\n\n\nREPEAT 语句\n[begin_label:] REPEAT\n    statement_list\n    UNTIL search_condition\nEND REPEAT [end_label]\nREPEAT 语句是有条件控制的循环语句，每次语句执行完毕后，会对条件表达式进行判断，如果表达式返回值为 TRUE，则循环结束，否则重复执行循环中的语句。\n\n-- 例如：\nREPEAT\n    SET @count=@count+1;\n    UNTIL @count=100\nEND REPEAT;\n\n\n\n错误处理\n如果过程化SQL在执行时出现异常，则应该让程序在产生异常的语句处停下来，根据异常的类型去执行异常处理语句。\n存储过程和函数\n过程化SQL块类型\n\n命名块：编译后保存在数据库中，可以被反复调用，运行速度较快，过程和函数是命名块；\n匿名块：每次执行时都要进行编译，它不能被存储到数据库中，也不能在其他过程化SQL块中调用；\n\n存储过程\n存储过程：由过程化SQL语句书写的过程，经编译和优化后存储在数据库服务器中，使用时只要调用即可。\n存储过程的优点：\n\n运行效率高\n降低了客户机和服务器之间的通信量\n方便实施企业规则\n\n存储过程的用户接口\n\n\n创建存储过程\n\n\n执行存储过程\n\n\n修改存储过程\n\n\n删除存储过程\n\n\n函数\n::: tip 函数和存储过程的区别\n\n存储过程主要用于执行一系列SQL语句，而函数主要用于计算并返回一个值。\n存储过程可以包含事务控制语句，而函数不能。\n存储过程可以通过输出参数传递多个值，而函数只能通过返回值传递一个值。\n存储过程的调用通常使用CALL语句，而函数可以在SELECT语句或其他表达式中直接调用。\n\n选择存储过程还是函数取决于需求，如果需要执行一系列的操作或者包含事务控制，通常会选择存储过程。如果只需要计算并返回一个值，则选择函数。\n:::\nODBC编程\nODBC优点：\n\n移植性好\n能同时访问不同的数据库\n共享多个数据资源\n\nODBC概述\nODBC产生的原因：由于不同的数据库管理系统的存在，在某个关系数据库管理系统下编写的应用程序就不能在另一个关系数据库管理系统下运行。许多应用程序需要共享多个部门的数据资源，访问不同的关系数据库管理系统。\nODBC是微软公司开放服务体系中有关数据库的一个组成部分，提供了一组访问数据库的应用程序编程接口。\nODBC的作用是：规范应用开发，规范关系数据库管理系统应用接口。\nODBC工作原理概述\nODBC应用系统的体系结构由四部分组成：用户应用程序，ODBC驱动程序管理器，数据库驱动程序，数据源。\n\n\n\n用户应用程序\n使用ODBC开发的应用系统程序简称为ODBC应用程序，包括的内容有：\n\n请求连接数据库\n向数据源发送SQL语句\n为SQL语句执行结果分配存储空间，定义所读取的数据格式\n获取数据库操作结果或处理错误\n进行数据处理并向用户提交处理结果\n请求事务的提交和回滚操作\n断开与数据源的连接\n\n\n\nODBC驱动程序管理器\n用来管理各种驱动程序 。\n包含在ODBC32.DLL中，管理应用程序和驱动程序之间的通信。\n建立、配置或删除数据源，并查看系统当前所安装的数据库ODBC驱动程序。\n主要功能：\n\n装载ODBC驱动程序\n选择和连接正确的驱动程序\n管理数据源\n检查ODBC调用参数的合法性\n记录ODBC函数的调用等\n\n\n\n数据库驱动程序\nODBC通过驱动程序来提供应用系统与数据库平台的独立性。\nODBC应用程序不能直接存取数据库，其各种操作请求由驱动程序管理器提交给某个关系数据库管理系统的ODBC驱动程序，通过调用驱动程序所支持的函数来存取数据库。\n数据库的操作结果也通过驱动程序返回给应用程序，如果应用程序要操纵不同的数据库，就要动态地链接到不同的驱动程序上。\n驱动程序类型：\n\n\n单束\n数据源和应用程序在同一台机器上。驱动程序相当于数据管理器  ，直接完成对数据文件的I/O操作。\n\n\n多束\n支持客户机—服务器、客户机—应用服务器/数据库服务器等网络环境下的数据访问。\n由驱动程序完成数据库访问请求的提交和结果集接收。\n应用程序使用驱动程序提供的结果集管理接口操纵执行后的结果数据。\n\n\n\n\n数据源\n最终用户需要访问的数据，包含了数据库位置和数据库类型等信息，是一种数据连接的抽象。\n数据源对最终用户是透明的。\n\n\nODBC API 基础\nODBC 应用程序编程接口的一致性包括 ：\n\nAPI一致性：包含核心级、扩展1级、扩展2级\n语法一致性：包含最低限度SQL语法级、核心SQL语法级、扩展SQL语法级\n\n函数概述\nODBC 3.0 标准提供了76个函数接口\n\n分配和释放环境句柄、连接句柄、语句句柄\n连接函数\n与信息相关的函数\n事务处理函数\n执行相关函数\n编目函数\n\n句柄及其属性\n句柄是32位整数值，代表一个指针。\nODBC 3.0中句柄分类：\n\n环境句柄\n连接句柄\n语句句柄\n描述符句柄\n\n应用程序句柄之间的关系：\n每个ODBC应用程序需要建立一个ODBC环境，分配一个环境句柄，存取数据的全局性背景，如环境状态、当前环境状态诊断、当前在环境上分配的连接句柄等。\n一个环境句柄可以建立多个连接句柄，每一个连接句柄实现与一个数据源之间的连接\n在一个连接中可以建立多个语句句柄，它不只是一个SQL语句，还包括SQL语句产生的结果集以及相关的信息等。\n描述符句柄是描述SQL语句的参数、结果集列的元数据集合。\n\n数据类型\nODBC数据类型：\n\nSQL数据类型：用于数据源\nC数据类型 ：用于应用程序的C代码\n\nODBC的工作流程\n"},"计算机基础/数据库系统概论/9_关系查询处理和查询优化":{"title":"关系查询处理和查询优化","links":[],"tags":["数据库"],"content":"关系数据库系统的查询处理\n查询处理步骤\n\n关系数据库管理系统查询处理阶段：\n\n\n查询分析\n任务：对查询语句进行扫描、词法分析和语法分析。\n\n词法分析：从查询语句中识别出正确的语言符号；\n语法分析：进行语法检查；\n\n\n\n查询检查\n任务：合法权检查，视图转换，安全性检查，完整性初步检查。\n\n\n查询优化\n选择一个高效执行的查询处理策略。\n优化分类：\n\n代数优化/逻辑优化：指关系代数表达式的优化\n物理优化：指存取路径和底层操作算法的选择\n\n查询优化的选择依据：\n\n基于规则\n基于代价\n基于语义\n\n\n\n查询执行\n依据优化器得到的执行策略生成查询执行计划。\n代码生成器生成执行查询计划的代码。\n两种执行方法：自顶向下，自底向上。\n\n\n实现查询操作的算法示例\n\n\n选择操作的实现\n\n\n全表扫描方法 (Table Scan)\n对查询的基本表顺序扫描，逐一检查每个元组是否满足选择条件，把满足条件的元组作为结果输出。\n适合小表，不适合大表。\n\n\n索引扫描方法 (Index Scan)\n适合于选择条件中的属性上有索引（例如B+树索引或Hash索引）。\n通过索引先找到满足条件的元组主码或元组指针，再通过元组指针直接在查询的基本表中找到元组。\n\n\n\n\n连接操作的实现\n连接操作是查询处理中最耗时的操作之一 ，这里只讨论等值连接(或自然连接)最常用的实现算法 。\n\n嵌套循环算法\n排序—合并算法\n索引连接算法\nHash Join算法\n\n\n\n关系数据库系统的查询优化\n查询优化在关系数据库系统中有着非常重要的地位。\n关系查询优化是影响关系数据库管理系统性能的关键因素。\n由于关系表达式的语义级别很高，使关系系统可以从关系表达式中分析查询语义，提供了执行查询优化的可能性。\n查询优化概述\n关系系统的查询优化是关系数据库管理系统实现的关键技术又是关系系统的优点所在，减轻了用户选择存取路径的负担。\n查询优化的优点：\n\n用户不必考虑如何最好地表达查询以获得较好的效率\n系统可以比用户程序的“优化”做得更好\n\n关系数据库管理系统通过某种代价模型计算出各种查询执行策略的执行代价，然后选取代价最小的执行方案。\n查询优化的总目标：\n\n选择有效的策略\n求得给定关系表达式的值\n使得查询代价最小(实际上是较小)\n\n代数优化\n关系代数表达式等价变换规则\n代数优化策略：通过对关系代数表达式的等价变换来提高查询效率。\n关系代数表达式的等价：指用相同的关系代替两个表达式中相应的关系所得到的结果是相同的。\n两个关系表达式E_1和E_2是等价的，可记为E_1\\equiv E_2。\n常用的等价变换规则：\n\n\n连接、笛卡尔积交换律\n\n\n\n连接、笛卡尔积的结合律\n\n\n\n投影的串接定律\n\n\n\n选择的串接定律\n\n\n\n选择与投影操作的交换律\n\n\n\n选择与笛卡尔积的交换律\n\n\n\n选择与并的分配律\n\n\n\n选择与差运算的分配律\n\n\n\n选择对自然连接的分配律\n\n\n\n投影与笛卡尔积的分配律\n\n\n\n投影与并的分配律\n\n\n\n查询树的启发式优化\n典型的启发式规则:\n\n\n选择运算应尽可能先做\n在优化策略中这是最重要、最基本的一条。\n\n\n把投影运算和选择运算同时进行\n如有若干投影和选择运算，并且它们都对同一个关系操作，则可以在扫描此关系的同时完成所有的这些运算以避免重复扫描关系。\n\n\n把投影同其前或其后的双目运算结合起来，没有必要为了去掉某些字段而扫描一遍关系。\n\n\n把某些选择同在它前面要执行的笛卡尔积结合起来成为一个连接运算，连接特别是等值连接运算要比同样关系上的笛卡尔积省很多时间。\n\n\n找出公共子表达式\n如果这种重复出现的子表达式的结果不是很大的关系并且从外存中读入这个关系比计算该子表达式的时间少得多，则先计算一次公共子表达式并把结果写入中间文件是合算的。\n当查询的是视图时，定义视图的表达式就是公共子表达式的情况\n\n\n物理优化\n代数优化改变查询语句中操作的次序和组合，不涉及底层的存取路径。\n对于一个查询语句有许多存取方案，它们的执行效率不同， 仅仅进行代数优化是不够的。\n物理优化就是要选择高效合理的操作算法或存取路径，求得优化的查询计划。\n物理优化方法：\n\n\n基于规则的启发式优化\n启发式规则是指那些在大多数情况下都适用，但不是在每种情况下都是适用的规则。\n\n\n基于代价估算的优化\n优化器估算不同执行策略的代价，并选出具有最小代价的执行计划。\n\n\n两者结合的优化方法\n常常先使用启发式规则，选取若干较优的候选方案，减少代价估算的工作量，然后分别计算这些候选方案的执行代价，较快地选出最终的优化方案 。\n\n\n基于启发式规则的存取路径选择优化\n\n\n选择操作的启发式规则\n对于小关系，使用全表顺序扫描，即使选择列上有索引。\n对于大关系，启发式规则有：\n\n\n对于选择条件是“主码=值”的查询\n查询结果最多是一个元组，可以选择主码索引。一般的关系数据库管理系统会自动建立主码索引。\n\n\n对于选择条件是“非主属性=值”的查询，并且选择列上有索引\n要估算查询结果的元组数目，如果比例较小(&lt;10%)可以使用索引扫描方法，否则还是使用全表顺序扫描。\n\n\n对于选择条件是属性上的非等值查询或者范围查询，并且选择列上有索引\n要估算查询结果的元组数目，如果选择率&lt;10%，可以使用索引扫描方法，否则还是使用全表顺序扫描。\n\n\n对于用AND连接的合取选择条件\n如果有涉及这些属性的组合索引，优先采用组合索引扫描方法。\n如果某些属性上有一般的索引，可以用索引扫描方法。\n其他情况：使用全表顺序扫描。\n\n\n对于用OR连接的析取选择条件，一般使用全表顺序扫描\n\n\n\n\n连接操作的启发式规则\n\n如果2个表都已经按照连接属性排序，选用排序-合并算法\n如果一个表在连接属性上有索引，选用索引连接算法\n如果上面2个规则都不适用，其中一个表较小，选用Hash join算法\n可以选用嵌套循环方法，并选择其中较小的表，确切地讲是占用的块数较少的表，作为外表(外循环的表) 。\n\n\n\n基于代价的优化\n启发式规则优化是定性的选择，适合解释执行的系统。解释执行的系统，优化开销包含在查询总开销之中 。\n编译执行的系统中查询优化和查询执行是分开的，可以采用精细复杂一些的基于代价的优化方法。\n\n\n统计信息\n基于代价的优化方法要计算查询的各种不同执行方案的执行代价，它与数据库的状态密切相关 。\n优化器需要的统计信息：\n\n对每个基本表：该表的元组总数(N)，元组长度(l)，占用的块数(B)，占用的溢出块数(BO)\n对基表的每个列：该列不同值的个数(m)，列最大值和最小值，列上是否已经建立了索引，哪种索引，可以计算选择率(f)\n对索引：索引的层数(L)，不同索引值的个数，索引的选择基数S(有S个元组具有某个索引值)，索引的叶结点数(Y)\n\n\n\n代价估算示例\n\n\n全表扫描算法的代价估算公式\n如果基本表大小为B块，全表扫描算法的代价 cost=B。如果选择条件是“码=值”，那么平均搜索代价 cost=B/2。\n\n\n索引扫描算法的代价估算公式\n如果选择条件是“码=值”，则采用该表的主索引。若为B+树，层数为L，需要存取B+树中从根结点到叶结点L块，再加上基本表中该元组所在的那一块，所以cost=L+1。\n如果选择条件涉及非码属性。若为B+树索引，选择条件是相等比较，S是索引的选择基数(有S个元组满足条件)，满足条件的元组可能会保存在不同的块上，所以(最坏的情况)cost=L+S。\n如果比较条件是&gt;，&gt;=，&lt;，⇐操作。假设有一半的元组满足条件，就要存取一半的叶结点，通过索引访问一半的表存储块，cost=L+Y/2+B/2。如果可以获得更准确的选择基数，可以进一步修正Y/2与B/2。\n\n\n嵌套循环连接算法的代价估算公式\n嵌套循环连接算法的代价cost=Br+BrBs/(K-1)。如果需要把连接结果写回磁盘，cost=Br+Br Bs/(K-1)+(FrsNrNs)/Mrs。其中Frs为连接选择性，表示连接结果元组数的比例；\nMrs是存放连接结果的块因子，表示每块中可以存放的结果元组数目；\n\n\n排序-合并连接算法的代价估算公式\n如果连接表已经按照连接属性排好序，则cost=Br+Bs+(FrsNrNs)/Mrs。如果必须对文件排序，还需要在代价函数中加上排序的代价，对于包含B个块的文件排序的代价大约是(2*B)+(2*B*\\log _2B)。\n\n\n\n"},"计算机基础/数据结构和算法/1_数据结构基本概念":{"title":"数据结构的基本概念","links":[],"tags":["数据结构和算法"],"content":"基本概念和术语\n数据\n数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。\n数据是计算机程序加工的原料。\n数据元素\n数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。\n一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。\n例如，学生记录就是一个数据元素， 它由学号、姓名、性别等数据项组成。\n数据对象\n数据对象是具有相同性质的数据元素的集合，是数据的一个子集。例如，整数数据对象是集合 N\n数据类型\n数据类型是一个值的集合和定义在此集合上的一组操作的总称。\n\n\n原子类型\n其值不可再分的数据类型。\n例如：bool类型、int类型\n\n\n结构类型\n其值可以再分解为若干成分(分量)的数据类型。\n例如：\nstruct Coordinate{\n    int x;\n    int y;\n}\n\n\n抽象数据类型（ADT）\n抽象数据组织及与之相关的操作。\n\n\n\n数据结构三要素\n逻辑结构\n\n集合结构\n线性结构：一对一\n树形结构：一对多\n图状结构：多对多\n\n\n数据的存储结构（物理结构）\n\n\n顺序存储\n把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系体现。\n\n优点：可以随机存取；每个元素占用最少的存储空间；\n缺点：只能使用一整块存储单元，可能产生较多的外部碎片；\n\n\n\n链式存储\n逻辑上相邻的元素在物理位置上也可以不相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。\n\n优点：不会出现碎片现象，能充分利用所有存储单元；\n缺点：每个元素因存储指针要占用额外空间，且只能顺序存取；\n\n\n\n索引存储\n存储元素信息的同时，建立附加的索引表。索引表中的每项称为索引项，索引项一般形式是（关键字，地址）。\n\n优点：检索速度快；\n缺点：附加的索引表占用额外空间；增加删除数据时也要修改所以表，因而会花费较多的时间；\n\n\n\n散列存储\n根据元素的关键字直接计算出该元素的存储地址，又称哈希存储。\n\n优点：检索、增加和删除结点的操作都很快；\n缺点：若是散列函数不好，可能出现元素存储单元冲突，解决冲突会增加时间和空间开销；\n\n\n\n数据的存储结构会影响存储空间分配的方便程度和对数据运算的速度。\n\n\n数据的运算\n针对于某种逻辑结构，结合实际需求，定义基本运算。\n运算的定义是针对逻辑结构的，指出运算的功能；\n运算的实现是针对存储结构的，指出运算的具体步骤。"},"计算机基础/数据结构和算法/2_算法基本概念":{"title":"算法基本概念","links":[],"tags":["数据结构和算法"],"content":"\n什么是算法\n算法(Algorithm)是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作。\n算法还具有下列 5 个重要特性：\n\n\n有穷性\n一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间（合理的，可接受的）内完成。\n\n算法必须是有穷的，程序既可以是有穷的也可以是无穷的\n\n\n\n确定性\n算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。\n\n\n可行性\n算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。\n\n\n输入\n一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。\n\n\n输出\n一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量\n\n\n“好”算法设计的要求\n\n\n正确性\n算法应能够正确地解决求解问题。\n\n如果算法不能正确解决问题，那么这个算法不是一个好算法，但也能被称为算法。\n\n\n\n可读性\n算法应具有良好的可读性，以帮助人们理解。\n\n\n健壮性\n输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的 输出结果。\n\n\n高效率与低存储量需求\n效率是指算法执行的时间，高效率即花的时间少、时间复杂度低；存储量需求是指算法执行过程中所需要的最大存储空间，低存储量需求即不费内存、空间复杂度低；这两者都与问题的规模有关。\n\n\n算法效率的度量\n算法效率的度量是通过时间复杂度和空间复杂度来描述的。\n时间复杂度\n一个语句的频度是指该语句在算法中被重复执行的次数。\n算法中所有语句的频度之和记为 T(n)，它是该算法问题规模 n 的函数，时间复杂度主要分析 T(n)的数量级。\n算法中基本运算（最深层循环内的语句）的频度与  T(n) 同数量级，因此通常采用算法中基本运算的频度 f(n) 来分析算法的时间复杂度。因此，算法的时间复杂度记为\nT(n)=O(f(n))\n\n\n式中，O 的含义是 T(n) 的数量级，其严格的数学定义是：若 T(n) 和 f(n)是定义在正整数集合上的两个函数，则存在正常数 C 和 n_0，使得当 n ≥ n_0 时，都满足 0 ≤ T(n) ≤ Cf(n)。\n\n在分析一个程序的时间复杂性时，有以下两条规则：\n\n\n加法规则\n多项相加，只保留最高阶的项，且系数变为 1\nT(n) = T_1(n)+T_2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n)))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n操作数量 T(n)时间复杂度 O(f(n))10000000O(1)3n +2O(n)2n^2+3n+2O(n^2)n^3+10000n^2O(n^3)2^n+10000n^{100000}O(2^n)\n\n\n乘法规则\n多项相乘，都保留\nT(n) = T_1(n) \\times T_2(n)=O(f(n))\\times O(g(n))=O(f(n)\\times g(n))\n\n\n\n常见的渐近时间复杂度为\n0(1) &lt; O(\\log_2{n})&lt; O(n) &lt; O(n\\log_2{n}) &lt; O(n^2) &lt; O(n^3) &lt; 0(2^n) &lt; 0(n!) &lt; O(n^n)\n\n\n常数阶 O(1)\n常数阶的操作数量与输入数据大小 n 无关，即不随着 n 的变化而变化。\n线性阶 O(n)\n线性阶的操作数量相对于输入数据大小以线性级别增长。线性阶通常出现在单层循环中。\n平方阶 O(n^2)\n平方阶的操作数量相对于输入数据大小以平方级别增长。平方阶通常出现在嵌套循环中，外层循环和内层循环都为 O(n)，因此总体为O(n^2)。\n\n指数阶 O(2^n)\n指数阶增长非常迅速，在实际应用中通常是不可接受的。若一个问题使用「暴力枚举」求解的时间复杂度为 O(2^n)，那么通常需要使用「动态规划」或「贪心算法」等方法来解决。在实际算法中，指数阶常出现于递归函数。\n\n对数阶 O(\\log(n))\n对数阶仅次于常数阶，时间增长缓慢，是理想的时间复杂度。对数阶常出现于「二分查找」和「分治算法」中，体现了“一分为多”和“化繁为简”的算法思想。\n\n线性对数阶 O(n\\log(n))\n线性对数阶常出现于嵌套循环中，两层循环的时间复杂度分别为 O(\\log(n))和 O(n)。\n\n阶乘阶 O(n!)\n阶乘通常使用递归实现。\n\n最差、最佳、平均时间复杂度\n算法的时间复杂度不仅依赖于问题的规模 n，也取决于待输入数据的性质。\n\n最坏时间复杂度：在最坏情况下，算法的时间复杂度。\n平均时间复杂度：所有可能输入实例在等概率出现的情况下，算法的期望运行时间。\n最好时间复杂度：在最好情况下，算法的时间复杂度。\n\n一般总是考虑在最坏情况下的时间复杂度，以保证算法的运行时间不会比它更长。\n空间复杂度\n算法的空间复杂度 S(n) 定义为该算法所耗费的存储空间，它是问题规模 n 的函数。记为\nS(n) = O(g(n))\n\n一个程序在执行时除需要存储空间来存放本身所用的指令、常数、变量和输入数据外，还需 要一些对数据进行操作的工作单元和存储一些为实现计算所需信息的辅助空间。\n算法原地工作是指算法所需的辅助空间为常量，即 O(1)。\n常数阶O(1)\n常数阶常见于数量与输入数据大小 n 无关的常量、变量、对象。\n需要注意的是，在循环中初始化变量或调用函数而占用的内存，在进入下一循环后就会被释放，即不会累积占用空间，空间复杂度仍为O(1)。\n线性阶O(n)\n线性阶常见于元素数量与 n 成正比的数组、链表、栈、队列等。\n\n平方阶O(n^2)\n平方阶常见于矩阵和图，元素数量与 n 成平方关系。\n\n指数阶O(2^n)\n指数阶常见于二叉树。高度为 n 的「满二叉树」的节点数量为 2^n-1 ，占用 O(2^n)空间。\n\n对数阶 O(\\log(n))\n对数阶常见于分治算法和数据类型转换等。"},"计算机基础/数据结构和算法/3_线性表":{"title":"线性表","links":[],"tags":["数据结构和算法"],"content":"线性表\n线性表（linear list）是具有相同数据类型的n(n&gt;=0)个数据元素的有限序列，其中n为表长，当n=0时线性表是一个空表。若用L命名线性表，则其一般表示为\nL=(a_1,a_2,...,a_i,a_{i+1},...,a_n)\n\na_1是唯一的“第一个”数据元素，又称表头元素；a_n是唯一的“最后一个”数据元素，又称表尾元素。除第一个元素外，每个元素有且仅有一个直接前驱。除最后一个元素外，每个元素有且仅有一个直接后继（“直接前驱”和“前驱”、“直接后继”和”后继”通常被视为同义词）。 以上就是线性表的逻辑特性，这种线性有序的逻辑结构正是线性表名字的由来。\n由此，我们得出线性表的特点如下：\n\n表中元素的个数有限。\n表中元素具有逻辑上的顺序性，表中元素有其先后次序。\n表中元素都是数据元素，每个元素都是单个元素。\n表中元素的数据类型都相同，这意味着每个元素占有相同大小的存储空间。\n表中元素具有抽象性，即仅讨论元素间的逻辑关系，而不考虑元素究竟表示什么内容。\n\n\n线性表是一种逻辑结构，表示元素之间一对一的相邻关系。顺序表和链表是指存储结构，两者属于不同层面的概念。\n\n\n在稍复杂的线性表中，一个数据元素可以由若干个数据项组成。在这种情况下，常把数据元素称为记录，含有大量记录的线性表又称为文件。\n\n顺序表\n线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素。\n定义\n线性表的顺序存储又称顺序表。它是用一组地址连续的存储单元依次存储线性表中的数据元 素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。\n第 1 个元素存储在线性表的起始位置, 第i个元素的存储位置后面紧接着存储的是第i+1个元素，称i为元素a_i在线性表中的位序。因此，顺序表的特点是表中元素的逻辑顺序与其物理顺序相同。\n\n位序 = 下标+1\n\n\n顺序表：用顺序存储的方式实现线性表。\n顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系体现。\n\n优点：\n\n随机访问，即可以在O(1)时间内找到第i个元素\n存储密度高，每个节点只存储数据元素\n\n缺点：\n\n拓展容量不方便\n插入，删除操作不方便，需要移动大量元素\n\n实现\n\n\n插入操作：\n\n\n最好情况\n在表尾插入，元素后移语句将不执行，最好时间复杂度为O(1)。\n\n\n最坏情况\n在表头插入，元素后移语句将执行n次，最坏时间复杂度为O(n)。\n\n\n平均情况\n假设p_i=\\frac{1} {n+1}是在第i个位置上插入一个结点的概率，则在长度为n的线性表中插入一个结点时，所需移动结点的平均次数为\n\\sum_{i=1}^{n+1}{p_i(n-i+1)}=\\sum_{i=1}^{n+1}{\\frac{1} {n+1}(n-i+1)}=\\frac{1} {n+1}\\sum_{i=1}^{n+1}{(n-i+1)}=\\frac{1} {n+1}\\frac{n(n+1)} {2}=\\frac{n}{2}\n\n平均时间复杂度为O(n)。\n\n\n\n\n\n删除操作：\n\n\n最好情况\n删除表尾元素，不用移动元素，最好时间复杂度为O(1)。\n\n\n最坏情况\n删除表头元素，需移动除表头元素外的所有元素，最坏时间复杂度为O(n)。\n\n\n平均情况\n假设p_i=\\frac{1} {n}是在第i个位置上插入一个结点的概率，则在长度为n的线性表中插入一个结点时，所需移动结点的平均次数为\n\\sum_{i=1}^{n}{p_i(n-i)}=\\sum_{i=1}^{n}{\\frac{1} {n}(n-i)}=\\frac{1} {n}\\sum_{i=1}^{n}{(n-i)}=\\frac{1} {n}\\frac{n(n-1)} {2}=\\frac{n-1}{2}\n\n平均时间复杂度为O(n)。\n\n\n\n\n\n按值查找：\n\n\n最好情况\n查找的元素就在表头，仅需比较一次，时间复杂度为O(1)。\n\n\n最坏情况\n查找的元素在表尾(或不存在)时，需要比较n次，时间复杂度为O(n)。\n\n\n平均情况\n假设p_i=\\frac{1} {n}是查找的元素在第i(1&lt;=i&lt;=L. length)个位置上的概率，则在长度为n的线性表中查找值为e的元素所需比较的平均次数为\n\\sum_{i=1}^{n}{p_i\\times i)}=\\sum_{i=1}^{n}{\\frac{1} {n}\\times i }=\\frac{1} {n}\\frac{n(n+1)} {2}=\\frac{n+1}{2}\n\n平均时间复杂度为O(n)。\n\n\n\n\n链表\n\n单链表\n线性表的链式存储又称单链表。它是指通过一组任意的存储单元来存储线性表中的数据元素（这组存储单元可以是连续的，也可以是不连续的）。\n每个数据元素a_i除存放元素自身的信息外，还需要存放一个指向其后继的指针。这两部分信息组成的数据元素a_i的存储映像称为结点。n个结点(a_i(1⇐ i ⇐ n)的存储映像)链结成一个链表，即线性表的链式存储结构。\n由于链表的每个结点中只包含一个指针域，故又称线性链表或单链表。\n\n指针域中存储的信息称做指针或链。\n\n单链表节点结构：\n\n\n\n\n\n\n\ndata（数据域，存放数据元素）next（指针域，存放其后继结点的地址）\ntypedef struct LNode {\n\tint data;\n\tstruct LNode *next;\n   } LNode, *LinkList;\n优点：不需要大量连续空间、改变容量方便。\n缺点：不能随机存取、要耗费一定空间存放指针。\n\n初始化链表\n\n\n不带头节点\n// 初始化数组\nvoid InitList(LinkList &amp;L) {\n\tL = nullptr;// C++ 11标准是 nullptr，以前是 NULL\n}\n\n使用起来更加麻烦。\n\n对第一个数据结点和后续数据结点的处理需要不同的代码逻辑；\n对空表和非空表的处理需要不同的代码逻辑；\n\n\n\n\n带头结点\n// 初始化数组\nvoid InitList(LinkList &amp;L) {\n\tL = new LNode;\n\tL-&gt;next = nullptr;\n}\n\n使用起来与不带头结点相比更加方便\n\n\n\n\n指定节点插入元素\n// 后插操作：在p结点之后插入元素e\nbool InsertNextNode(LNode *p, int e) {\n  if (p != nullptr) {\n     LNode *q;\n     q = new LNode;\n     q-&gt;data = e;\n     q-&gt;next = p-&gt;next;\n     p-&gt;next = q;\n     return true;\n  } else {\n   \treturn false;\n  }\n}\n// 前插操作：在p结点之前插入元素e\nbool InsertPriorNode(LNode *p, int e) {\n  if (p != nullptr) {\n     LNode *q;\n     q = new LNode;\n     q-&gt;next = p-&gt;next;\n     p-&gt;next = q;\n     q-&gt;data = p-&gt;data;\n     p-&gt;data = e;\n     return true;\n  } else {\n   \treturn false;\n  }\n}\n\n按位序插入\n\n// 按位序插入（带头结点）\nbool ListInsert(LinkList &amp;l, int i, int e) {\n  if (i &gt;= 1) {\n    LNode *p = l;\n    for (int j = 0; j &lt; i - 1 &amp;&amp; p != nullptr; j++) {\n      p = p-&gt;next;\n    }\n    if (p == nullptr)return false;\n    // 要插入的新结点 q\n    LNode *q;\n    q = new LNode;\n    q-&gt;data = e;\n    q-&gt;next = p-&gt;next;\n    p-&gt;next = q;\n    return true;\n  } else {\n    return false;\n  }\n}\n// 按位序插入（不带头结点）\nbool ListInsert(LinkList &amp;l, int i, int e) {\n  if (i &gt;= 1) {\n    if (i == 1){\n      LNode *t;\n      t = new LNode;\n      t-&gt;data = e;\n    \tt-&gt;next = l;\n      l = t;\n      return true;\n    }\n    LNode *p = l;\n    for (int j = 1; j &lt; i - 1 &amp;&amp; p != nullptr; j++) {\n      p = p-&gt;next;\n    }\n    if (p == nullptr)return false;\n    // 要插入的新结点 q\n    LNode *q;\n    q = new LNode;\n    q-&gt;data = e;\n    q-&gt;next = p-&gt;next;\n    p-&gt;next = q;\n    return true;\n  } else {\n    return false;\n  }\n}\n\n指定结点删除元素\n\n\n\n\n\n\n\n\n\n未知区域LNode（要删除的结点）LNode可知区域\n// 删除指定结点p\nbool DeleteNode(LNode *p) {\n  if (p != nullptr) {\n    LNode *q = p-&gt;next;\n    p-&gt;data = p-&gt;next-&gt;data;\n    p-&gt;next = q-&gt;next;\n    delete q;\n    return true;\n  } else {\n    return false;\n  }\n}\n\n如果不知道要删除的结点的前面一个结点，就只能从头开始遍历链表找到前一个结点。\n\n\n按位序删除\n\n// 按位序删除（带头结点）\nbool ListDelete(LinkList &amp;l, int i, int &amp;e) {\n  if (i &gt;= 1) {\n    LNode *p = l;\n    for (int j = 0; j &lt; i - 1 &amp;&amp; p != nullptr; j++) {\n      p = p-&gt;next;\n    }\n    if (p == nullptr || p-&gt;next == nullptr)return false;\n    LNode *q = p-&gt;next;\n    e = q-&gt;data;\n    p-&gt;next = q-&gt;next;\n    delete q;\n    return true;\n  } else {\n    return false;\n  }\n}\n\n按位查找\n// 按位查找（带头结点）\nLNode *GetElem(LinkList l, int i) {\n  if (i &gt; 0) {\n    LNode *res = l;\n    for (int j = 0; j &lt; i &amp;&amp; res != nullptr; j++) {\n      res = res-&gt;next;\n    }\n    return res;\n  } else {\n    return nullptr;\n  }\n}\n\n按值查找\n// 按值查找（带头结点）\nLNode *LocateElem(LinkList l, int e) {\n  LNode *res = l-&gt;next;\n  while (res != nullptr &amp;&amp; res-&gt;data != e) {\n    res = res-&gt;next;\n  }\n  return res;\n}\n\n单链表的建立\n给定多个数据元素，存储到一个单链表中\n\n\n尾插法\n// 正向建立单链表（带头结点）\nLinkList List_TailInsert(LinkList &amp;l) {\n  l = new LNode;\n  LNode *end = l;\n  LNode *s;\n  int input;\n  cin &gt;&gt; input;\n  while (input != 0) {\n    s = new LNode;\n    s-&gt;data = input;\n    end-&gt;next = s;\n    end = s;\n    cin &gt;&gt; input;\n  }\n  end-&gt;next = nullptr;\n  return l;\n}\n\n\n前插法\n// 逆向建立单链表（带头结点）\nLinkList List_HeadInsert(LinkList &amp;l) {\n  l = new LNode;\n  l-&gt;next = nullptr;\n  LNode *s;\n  int input;\n  cin &gt;&gt; input;\n  while (input != 0) {\n    s = new LNode;\n    s-&gt;data = input;\n    s-&gt;next = l-&gt;next;\n    l-&gt;next = s;\n    cin &gt;&gt; input;\n  }\n  return l;\n}\n\n\n双链表\n单链表结点中只有一个指向其后继的指针，使得单链表只能从头结点依次顺序地向后遍历。要访问某个结点的前驱结点(插入、删除操作时)，只能从头开始遍历，访问后继结点的时间复杂度为O(1),访问前驱结点的时间复杂度为O(n)。\n为了克服单链表的上述缺点，引入了双链表，双链表结点中有两个指针 prior 和 next，分别指向其前驱结点和后继结点\ntypedef struct DNode { //定义双链表结点类型\n    int data; //数据域\n    struct DNode *prior, *next; //前驱和后继指针\n} DNode, *DLinklist;\n\n以下实现均是带头结点\n\n初始化\n// 初始化双链表\nvoid InitDLinkList(DLinklist &amp;l) {\n  l = new DNode;\n  l-&gt;next = nullptr;\n  l-&gt;prior = nullptr;\n}\n插入\n// 在p结点之后插入s结点\nbool InsertNextDNode(DNode *p, DNode *s) {\n  if (p != nullptr &amp;&amp; s != nullptr) {\n    s-&gt;next = p-&gt;next;\n    s-&gt;prior = p;\n    if (p-&gt;next != nullptr) {\n      p-&gt;next-&gt;prior = s;\n    }\n    p-&gt;next = s;\n    return true;\n  } else {\n    return false;\n  };\n}\n删除\n// 删除p结点的后继结点\nbool DeleteNextDNode(DNode *p) {\n  if (p != nullptr) {\n    DNode *q = p-&gt;next;\n    if (q != nullptr) {\n      p-&gt;next = q-&gt;next;\n      q-&gt;next-&gt;prior = p;\n      delete q;\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    return false;\n  }\n}\n循环链表\n循环单链表\n循环单链表和单链表的区别在于，表中最后一个结点的指针不是 NULL，而改为指向头结点，从而整个链表形成一个环。\n\ntypedef struct LNode {\n\tint data;\n\tstruct LNode *next;\n} LNode, *LinkList;\n循环单链表的插入、删除算法与单链表的几乎一样，所不同的是若操作是在表尾进行，则执行的操作不同，以让单链表继续保持循环的性质。\n因为循环单链表是一个“环”，因此在任何一个位置上的插入和删除操作都是等价的，无须判断是否是表尾。\n// 初始化一个循环单链表\nvoid InitList(LinkList &amp;l) {\n  l = new LNode;\n  l-&gt;next = l;\n}\n循环双链表\n循环双链表与循环单链表类似，不同的是在循环双链表中，头结点的 prior 指针要指向表尾结点。\n\n静态链表\n静态链表借助数组来描述线性表的链式存储结构，结点也有数据域 data 和指针域 next, 与前面所讲的链表中的指针不同的是，这里的指针是结点的相对地址(数组下标)，又称游标。\n和顺序表一样，静态链表也要预先分配一块连续的内存空间。\n#define MaxSize 50\ntypedef struct {\n    int data;\n    int next;\n} SLinkList[MaxSize];\n// 等价于\n#define MaxSize 50\nstruct Node {\n    int data;\n    int next;\n};\ntypedef struct Node SLinkList[MaxSize];\n\n优点：\n\n插入删除不需要大量移动元素\n\n缺点：\n\n不能随机存取，只能从头结点开始依次往后查找\n容量固定不可变\n\n使用场景：\n\n不支持指针的低级语言\n数据元素数量固定不变的场景（如操作系统的文件分配表 FAT）\n\n顺序表和链表的比较\n\n存取(读写)方式\n\n顺序表可以顺序存取，也可以随机存取\n链表只能从表头顺序存取元素\n\n\n逻辑结构与物理结构\n\n采用顺序存储时，逻辑上相邻的元素，对应的物理存储位置也相邻。\n采用链式存储时，逻 辑上相邻的元素，物理存储位置不一定相邻，对应的逻辑关系是通过指针链接来表示的\n\n\n查找、插入和删除操作\n\n对于按值查找\n\n顺序表无序时，两者的时间复杂度均为O(n)；\n顺序表有序时，可采用折半查 找，此时的时间复杂度为O(\\log _2n)\n\n\n对于按序号查找\n\n顺序表支持随机访问，时间复杂度为O(1)\n链表的平均时间复杂度为O(n)。\n\n\n顺序表的插入、删除操作，平均需要移动半个表长的元素。\n链表的插入、删除操作，只需修改相关结点的指针域即可。由于链表的每个结点都带有指针域，故而存储密度不够大。\n\n\n空间分配\n\n顺序存储\n\n在静态存储分配情形下，一旦存储空间装满就不能扩充，若再加入新元素，则会出现内存溢出，因此需要预先分配足够大的存储空间。预先分配过大，可能会导致顺序表后部大量闲置；预先分配过小，又会造成溢出。\n动态存储分配虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低，而且若内存中没有更大块的连续存储空间，则会导致分配失败。\n\n\n链式存储的结点空间只在需要时申请分配，只要内存有空间就可以分配，操作灵活、高效。\n\n\n"},"计算机基础/数据结构和算法/4_栈和队列":{"title":"栈和队列","links":[],"tags":["数据结构和算法"],"content":"栈\n概念\n栈(Stack)是只允许在一端进行插入或删除操作的线性表。\n首先栈是一种线性表，但限定这种线性表只能在某一端进行插入和删除操作。\n\n栈顶：线性表允许进行插入删除的那一端。\n栈底：固定的，不允许进行插入和删除的另一端。\n空栈：不含任何元素的空表。\n\n\n栈的操作特性可以概括为后进先出。\n性质\nn个不同元素进栈，出栈元素不同排列的个数为\\frac{1}{n+1}C_{2n}^{n}。上述公式称为卡特兰，可采用数学归纳法证明。\n存储结构\n顺序存储结构\n顺序栈\n采用顺序存储的栈称为顺序栈，它利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针(top)指示当前栈顶元素的位置。\n在这样的设计下，入栈与出栈操作就分别对应在数组尾部添加元素与删除元素，时间复杂度都为 O(1) 。\nusing namespace std;\n \n#define MaxSize 50 //定义栈中元素的最大个数\ntypedef struct {\n    //存放栈中元素\n    int data[MaxSize];\n    //栈顶指针\n    int top;\n} SqStack;\n \n// 初始化栈\nvoid InitStack(SqStack &amp;S) {\n  S.top = -1;\n}\n \n// 判断栈空\nbool StackEmpty(SqStack S) {\n  return S.top &lt; 0;\n}\n \n// 入栈\nbool Push(SqStack &amp;S, int x) {\n  if (S.top == MaxSize - 1) {\n    return false;\n  }\n  S.data[++S.top] = x;\n  return true;\n}\n \n// 出栈\nbool Pop(SqStack &amp;S, int &amp;x) {\n  if (S.top &lt; 0) {\n    return false;\n  }\n  x = S.data[S.top--];\n  return true;\n}\n\n栈和队列的判空、判满条件，会因实际给的条件不同而变化，上面的代码实现只是在栈顶指针设定的条件下的相应方法，而其他情况则需具体问题具体分析。\n\n\n这里top指向的是栈顶元素，所以进栈操作为S .data [++S . top] =x，出栈操作为 x=S.data[S.top--]。\n若栈顶指针初始化为S.top=0，即top指向的是栈顶元素的下一位置，则入栈操作变为S. data [S. top++] =x；出栈操作变为x=S. data [--S . top]。相应的栈空、栈满条件也会发生变化。\n\n共享栈\n利用栈底位置相对不变的特性，可让两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸。\n\n两个栈的栈顶指针都指向栈顶元素，top0 =- 1时0号栈为空，top1 = MaxSize时1号栈为空；仅当两个栈顶指针相邻top1 - top0 = 1时，判断为栈满。当0号栈进栈时top0先加1再赋值，1号栈进栈时top1先减1再赋值；出栈时则刚好相反。\n共享栈是为了更有效地利用存储空间，两个栈的空间相互调节，只有在整个存储空间被占满时才发生上溢。\n其存取数据的时间复杂度均为0(1)，对存取效率没有什么影响。\nusing namespace std;\n \n#define MaxSize 50 //定义栈中元素的最大个数\ntypedef struct {\n    //存放栈中元素\n    int data[MaxSize];\n    //0号栈栈顶指针\n    int top0;\n    //号栈栈顶指针\n    int top1;\n} SqStack;\n \n// 初始化栈\nvoid InitStack(SqStack &amp;S) {\n  S.top0 = -1;\n  S.top1 = MaxSize;\n}\n \n// 判断栈空\nbool Stack0Empty(SqStack S) {\n  return S.top0 &lt; 0;\n}\n \nbool Stack1Empty(SqStack S) {\n  return S.top1 == MaxSize;\n}\n \n// 入栈\nbool Push0(SqStack &amp;S, int x) {\n  if (S.top0 + 1 == S.top1) {\n    return false;\n  }\n  S.data[++S.top0] = x;\n  return true;\n}\n \nbool Push1(SqStack &amp;S, int x) {\n  if (S.top0 + 1 == S.top1) {\n    return false;\n  }\n  S.data[--S.top1] = x;\n  return true;\n}\n \n// 出栈\nbool Pop0(SqStack &amp;S, int &amp;x) {\n  if (S.top0 &lt; 0) {\n    return false;\n  }\n  x = S.data[S.top0--];\n  return true;\n}\n \nbool Pop1(SqStack &amp;S, int &amp;x) {\n  if (S.top1 == MaxSize) {\n    return false;\n  }\n  x = S.data[S.top1++];\n  return true;\n}\n链式存储结构\n采用链式存储的栈称为链栈，链栈的优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况。\n通常采用单链表实现，并规定所有操作都是在单链表的表头进行的。\n采用链式存储，便于结点的插入与删除。链栈的操作与链表类似，入栈和出栈的操作都在链表的表头进行。\n\n将链表头部作为栈顶的一端，可以避免在实现数据 “入栈” 和 “出栈” 操作时做大量遍历链表的耗时操作。\n\n\n对于带头结点和不带头结点的链栈，具体的实现会有所不同。\n\n// 不带头结点实现\n \nusing namespace std;\n \n#define MaxSize 50 //定义栈中元素的最大个数\ntypedef struct LinkNode {\n    int data;\n    struct LinkNode *next;\n} *LiStack;\n \n// 初始化栈\nvoid InitStack(LiStack &amp;S) {\n  S = nullptr;\n}\n \n// 判断栈空\nbool StackEmpty(LiStack S) {\n  return S == nullptr;\n}\n \n// 入栈\nvoid Push(LiStack &amp;S, int x) {\n  LinkNode *node;\n  node = new LinkNode();\n  node-&gt;data = x;\n  node-&gt;next = S;\n  S = node;\n}\n \n// 出栈\nbool Pop(LiStack &amp;S, int &amp;x) {\n  if (StackEmpty(S)) {\n    return false;\n  } else {\n    LinkNode *p = S;\n    x = p-&gt;data;\n    S = p-&gt;next;\n    delete p;\n    return true;\n  }\n}\n// 带头结点实现\nusing namespace std;\n \n#define MaxSize 50 //定义栈中元素的最大个数\ntypedef struct LinkNode {\n    int data;\n    struct LinkNode *next;\n} *LiStack;\n \n// 初始化栈\nvoid InitStack(LiStack &amp;S) {\n  S-&gt;next = nullptr;\n}\n \n// 判断栈空\nbool StackEmpty(LiStack S) {\n  return S-&gt;next == nullptr;\n}\n \n// 入栈\nvoid Push(LiStack &amp;S, int x) {\n  LinkNode *node;\n  node = new LinkNode();\n  node-&gt;data = x;\n  node-&gt;next = S-&gt;next;\n  S-&gt;next = node;\n}\n \n// 出栈\nbool Pop(LiStack &amp;S, int &amp;x) {\n  if (StackEmpty(S)) {\n    return false;\n  } else {\n    LinkNode *p = S-&gt;next;\n    x = p-&gt;data;\n    S-&gt;next = p-&gt;next;\n    delete p;\n    return true;\n  }\n}\n队列\n概念\n队列(Queue)简称队，也是一种操作受限的线性表，只允许在表的一端进行插入，而在表的另一端进行删除。\n\n\n向队列中插入元素称为入队或进队；\n\n\n删除元素称为出队或离队。\n\n\n这和我们日常生活中的排队是一致的，最早排队的也是最早离队的，其操作的特性是先进先出。\n\n\nInitQueue (&amp;Q)：初始化队列，构造一个空队列Q。\nQueueEmpty (Q)：判队列空，若队列Q为空返回true,否则返回false。\nEnQueue (&amp;Q, x)：入队，若队列Q未满，将x加入，使之成为新的队尾。\nDeQueue (&amp;Q, &amp;x)：出队，若队列Q非空，删除队头元素，并用x返回。\nGetHead(Q,&amp;x)：读队头元素，若队列Q非空，则将队头元素赋值给X。\n\n存储结构\n顺序存储结构\n顺序存储\n队列的顺序实现是指分配一块连续的存储单元存放队列中的元素，并附设两个指针：\n\n队头指针front指向队头元素\n队尾指针rear指向队尾元素的下一个位置\n\n队列的顺序存储类型可描述为\n#define MaxSize 10\ntypedef struct {\n    int data[MaxSize];// 用静态数组存队列\n    int front, rear;// 队头指针和队尾指针\n} SqQueue;\n\n初始化：Q.front=Q.rear=0\n进队：队不满时，先送值到队尾元素，再将队尾指针加1\n出队：队不空时，先取队头元素值，再将队头指针加1\n\n\nQ. rear==MaxSize不能作为队列满的条件。下图(d)中，队列中仅有一个元素，但仍满足该条件。这时入队出现“上溢出”，但这种溢出并不是真正的溢出，在 data数组中依然存在可以存放元素的空位置，所以是一种“假溢出”。为了解决这个缺点可以使用循环队列。\n\n\n循环队列\n将顺序队列臆造为一个环状的空间, 即把存储队列元素的表从逻辑上视为一个环，称为循环队列。\n当队首指针Q.front=MaxSize-1 后，再前进一个位置就自动到0，这可以利用除法取余运算来实现。\n\n\n初始时：Q.front = Q.rear = 0 \n\n\n队首指针进 1： Q.front = (Q.front + 1) % MaxSize\n\n\n队尾指针进 1： Q.rear = (Q.rear + 1) % MaxSize\n\n\n队列长度：(Q.rear + MaxSize-Q.front) % MaxSize\n\n\n判断队满：\n\n\n牺牲一个单元来区分队空和队满，此时\n队满条件：(Q.rear+1) %MaxSize == Q.front\n队空条件：Q.front == Q.rear\n\n\n类型中增设一个数据成员，用来表示元素个数，此时\n队空条件：Q.size == 0\n队满条件： Q.size == MaxSize\n\n\n类型中增设tag数据成员，用来表示最近进行的操作。删除操作成功时，tag = 0；插入操作成功时，tag = 1。此时，\n队空条件：Q.front == Q.rear &amp;&amp; tag = 0\n队满条件：Q.front == Q.rear &amp;&amp; tag = 1\n\n\n\n\n以下代码是以牺牲一个单元来区分队空和队满\n#define MaxSize 10\n \ntypedef struct {\n    // 用静态数组存队列\n    int data[MaxSize];\n    // 队头指针和队尾指针\n    int front, rear;\n} SqQueue;\n \n// 初始化队列\nvoid InitQueue(SqQueue &amp;Q) {\n  Q.front = Q.rear = 0;\n}\n \n// 判断队列是否为空\nbool QueueEmpty(SqQueue Q) {\n  return Q.front == Q.rear;\n}\n \n// 入队\nbool EnQueue(SqQueue &amp;Q, int x) {\n  if ((Q.rear + 1) % MaxSize == Q.front) {\n    return false;\n  } else {\n    Q.data[Q.rear] = x;\n    Q.rear = (Q.rear + 1) % MaxSize;\n    return true;\n  }\n}\n \n// 出队\nbool DeQueue(SqQueue &amp;Q, int &amp;x) {\n  if (Q.front == Q.rear) {\n    return false;\n  } else {\n    x = Q.data[Q.front];\n    Q.front = (Q.front + 1) % MaxSize;\n    return true;\n  }\n}\n \n// 获取队头元素\nbool GetHead(SqQueue Q, int &amp;x) {\n  if (Q.rear == Q.front) {\n    return false;\n  } else {\n    x = Q.data[Q.front];\n    return true;\n  }\n}\n队列的链式存储结构\n队列的链式表示称为链队列，它实际上是一个同时带有队头指针和队尾指针的单链表。\n头指针指向队头结点，尾指针指向队尾结点，即单链表的最后一个结点。\ntypedef struct LinkNode {\n    int data;\n    struct LinkNode *next;\n} LinkNode;\n \ntypedef struct {\n    LinkNode *front, *rear;\n} LinkQueue;\n// 带头结点\n \n// 判断队列是否为空\nbool IsEmpty(LinkQueue Q) {\n  return Q.front == Q.rear;\n}\n \n// 初始化队列\nvoid InitQueue(LinkQueue &amp;Q) {\n  // 初始化时 front 和 rear 都指向头结点\n  LinkNode *node;\n  node = new LinkNode();\n  Q.front = Q.rear = node;\n  Q.front-&gt;next = nullptr;\n}\n \n// 入队\nvoid EnQueue(LinkQueue &amp;Q, int x) {\n  LinkNode *s;\n  s = new LinkNode();\n  s-&gt;data = x;\n  s-&gt;next = nullptr;\n  Q.rear-&gt;next = s;\n  Q.rear = s;\n}\n \n// 出队\nbool DeQueue(LinkQueue &amp;Q, int &amp;x) {\n  if (Q.front == Q.rear) {\n    return false;\n  } else {\n    LinkNode *p = Q.front-&gt;next;\n    x = p-&gt;data;\n    Q.front-&gt;next = p-&gt;next;\n    if (Q.rear == p) {\n      Q.rear = Q.front;\n    }\n    delete p;\n    return true;\n  }\n}\n// 不带头结点\n \n// 判断队列是否为空\nbool IsEmpty(LinkQueue Q) {\n  return Q.front == nullptr;\n}\n \n// 初始化队列\nvoid InitQueue(LinkQueue &amp;Q) {\n  // 初始化时 front 和 rear 都指向NUll\n  Q.front = Q.rear = nullptr;\n}\n \n// 入队\nvoid EnQueue(LinkQueue &amp;Q, int x) {\n  LinkNode *s;\n  s = new LinkNode();\n  s-&gt;data = x;\n  s-&gt;next = nullptr;\n  if (Q.front == nullptr) {\n    Q.front = s;\n    Q.rear = s;\n  } else {\n    Q.rear-&gt;next = s;\n    Q.rear = s;\n  }\n}\n \n// 出队\nbool DeQueue(LinkQueue &amp;Q, int &amp;x) {\n  if (Q.front == Q.rear) {\n    return false;\n  } else {\n    LinkNode *p = Q.front-&gt;next;\n    x = p-&gt;data;\n    Q.front-&gt;next = p-&gt;next;\n    if (Q.rear == p) {\n      Q.rear = Q.front = nullptr;\n    }\n    delete p;\n    return true;\n  }\n}\n双端队列\n双端队列是指允许两端都可以进行入队和出队操作的队列。其元素的逻辑结构仍是线性结构。\n由此定义还可以衍生出：\n\n输出受限的双端队列：允许在一端进行插入和删除，但在另一端只允许插入的双端队列\n输入受限的双端队列：允许在一端进行插入和删除，但在另一端只允许删除的双端队列\n\n栈和队列的应用\n栈在括号匹配中的应用\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n \nusing namespace std;\n \n#define MaxSize 50\ntypedef struct {\n    char data[MaxSize];\n    int top;\n} Stack;\n \nvoid InitStack(Stack &amp;S) {\n  S.top = -1;\n}\n \nbool isEmpty(Stack S) {\n  return S.top &lt; 0;\n}\n \nbool push(Stack &amp;S, char c) {\n  if (S.top &gt; MaxSize - 1)return false;\n  S.data[++S.top] = c;\n  return true;\n}\n \nbool Pop(Stack &amp;S, char &amp;c) {\n  if (isEmpty(S))return false;\n  c = S.data[S.top--];\n  return true;\n}\n \nbool bracketCheck(string &amp;str) {\n  Stack S;\n  // 初始化一个栈\n  InitStack(S);\n  for (char i: str) {\n    // 扫描到左括号就入栈\n    if (i == &#039;(&#039; || i == &#039;[&#039; || i == &#039;{&#039;) {\n      push(S, i);\n    } else {\n       // 判断当前右与栈顶元素是否匹配\n      char topChar;\n      // 判断当前右与栈顶元素是否匹配\n      if (Pop(S, topChar)) {\n        if ((i == &#039;)&#039; &amp;&amp; topChar != &#039;(&#039;) || (i == &#039;]&#039; &amp;&amp; topChar != &#039;[&#039;) || (i == &#039;}&#039; &amp;&amp; topChar != &#039;{&#039;))\n          return false;\n      }\n    }\n  }\n  return isEmpty(S);\n}\n \nint main() {\n  string str = &quot;({[]})&quot;;\n  cout &lt;&lt; bracketCheck(str) &lt;&lt; endl;\n  return 0;\n}\n栈在表达式求值中的应用\n\nwww.bilibili.com/video/BV1b7411N798\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n中缀表达式前缀表达式（波兰表达式）后缀表达式（逆波兰表达式）a+bab++aba+b-cab+c--+abca+b-c*dab+cd*--+ab*cd\n\n\n后缀表达式的求值\n\n从左往右扫描元素，直到处理完所有元素\n扫描到操作数则压入栈，并回到1；否则执行3\n若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到1\n\n\n\n中缀表达式转后缀表达式\n初始化一个栈，用于保存暂时还不能确定运算顺序的运算符。从左到右处理各个元素，直到末尾。可能遇到三种情况：\n\n遇到操作数。直接加入后缀表达式。\n遇到界限符。遇到(直接入栈；遇到)则依次弹出栈内运算符并加入后缀表达式，直到弹出(为止。注意：)不加入后缀表达式。\n遇到运算符。依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到(或栈空则停止。之后再把当前运算符入栈。\n\n按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。\n\n\n中缀表达式的计算\n中缀转后缀，后缀表达式求值两个算法的结合\n初始化两个栈，操作数栈和运算符栈\n\n\n若扫描到操作数，压入操作数栈\n\n\n若扫描到运算符或界限符，则按照“中缀转后缀”相同的逻辑压入运算符栈（期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈）\n\n\n\n\n栈在递归中的应用\n递归是一种重要的程序设计方法。简单地说，若在一个函数、过程或数据结构的定义中又应用了它自身，则这个函数、过程或数据结构称为是递归定义的，简称递归。\n递归模型不能是循环定义的，其必须满足下面的两个条件： 递归表达式(递归体)、边界条件(递归出口)。\n队列的应用\n\nwww.bilibili.com/video/BV1b7411N798/\n\n树的层次遍历和图的广度优先遍历。\n\n队列在计算机系统中的作用：\n\n\n解决主机与外部设备之间速度不匹配的问题\n以主机和打印机之间速度不匹配的问题为例。有一个打印数据缓冲区，主机把要打印输出的数据依次写入这个缓冲区，写满后就暂停输出，转去做其他的事情。打印机就从缓冲区中按照 先进先出的原则依次取出数据并打印，打印完后再向主机发出请求。主机接到请求后再向缓冲区 写入打印数据。\n\n\n解决由多用户引起的资源竞争问题\nCPU资源的竞争就是一个典型的例子。\n\n\n特殊矩阵的压缩存储\n\nwww.bilibili.com/video/BV1b7411N798/\n\n\n压缩存储：指为多个值相同的元素只分配一个存储空间，对零元素不分配存储空间。其目的是节省存储空间。\n特殊矩阵：指具有许多相同矩阵元素或零元素，并且这些相同矩阵元素或零元素的分布有一定规律性的矩阵。常见的特殊矩阵有对称矩阵、上(下)三角矩阵、对角矩阵等。\n特殊矩阵的压缩存储方法：找出特殊矩阵中值相同的矩阵元素的分布规律，把那些呈现规律性分布的、值相同的多个矩阵元素压缩存储到一个存储空间中。\n\n对称矩阵\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n二维数组 A[n][n] 和 A[0...n-1] [O...n-1] 的写法是等价的。\n如果数组写为 A[1...n] [1...n]，则说明指定了从下标1开始存储元素。\n二维数组元素写为a[i][j]，注意数组 元素下标 i 和 j 通常是从0开始的。\n矩阵元素通常写为 a_{i,j} 或 a_{(i)(j)}，注意行号 i 和列号 j $是 从1开始的。\n\n\n三角矩阵\n\n\n三对角矩阵\n\n稀疏矩阵\n若采用常规的方法存储稀疏矩阵，则相当浪费存储空间，因此仅存储非零元素。但通常非零元素的分布没有规律，所以仅存储非零元素的值是不够的，还要存储它所在的行和列。因此，将非零元素及其相应的行和列构成一个三元组。然后按照某种规律存储这些三元组线性表。\n稀疏矩阵压缩存储后便失去了随机存取特性。\n\n\n\n                  \n                  Tip\n                  \n                \n\n三元组仅存储行，列，值是不够的，因为无法通过这些判断稀疏矩阵的大小。因此还需要保存稀疏矩阵的行数和列数。\n\n\n稀疏矩阵的三元组表既可以采用数组存储，又可以采用十字链表存储。当存储稀疏矩阵时，不仅要保存三元组表，而且要保存稀疏矩阵的行数、列数和非零元素的个数。\n"},"计算机基础/数据结构和算法/5_串":{"title":"串","links":[],"tags":["数据结构和算法"],"content":"定义\n字符串简称串，串（string）是由零个或多个字符组成的有限序列。一般记为\nS=a_1,a_2,a_3,\\cdots a_n(n&gt;=0)\n\n其中，S 是串名，单引号括起来的字符序列是串的值；a_i可以是字母、数字或其他字符；串中字符的个数 n 称为串的长度。n=0 时的串称为空串（用\\emptyset表示）。\n当两个串的长度相等且每个对应位置的字符都相等时，称这两个串是相等的。\n\n子串：串中任意多个连续的字符组成的子序列称为该串的子串\n主串：包含子串的串。\n字符在串中的位置：字符在串中的序号（下标从 1 开始）\n子串在主串中的位置：子串的第一个字符在主串中的位置\n空格串：由一个或多个空格组成的串，空格串不是空串，其长度为串中空格字符的个数。\n\n串是一种特殊的线性表，数据元素之间呈线性关系。\n在基本操作上， 串和线性表有很大差别。\n\n线性表的基本操作主要以单个元素作为操作对象，如查找、插入或删除 某个元素等；\n串的基本操作通常以子串作为操作对象，如查找、插入或删除一个子串等。\n\n存储结构\n定长顺序存储\n类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列。在串的定长顺序存储结构中，为每个串变量分配一个固定长度的存储区，即定长数组。\n#define MAXLEN 255\ntypedef struct {\n    char ch[MAXLEN];\n    int length;\n} SString;\n堆分配存储\n堆分配存储表示仍然以一组地址连续的存储单元存放串值的字符序列，但它们的存储空间是在程序执行过程中动态分配得到的。\n#define MAXLEN 255\ntypedef struct {\n    char *ch;\n    int length;\n} HString;\n \nint main() {\n  HString S;\n  S.ch = new char[MAXLEN];\n}\n块链存储表示\n类似于线性表的链式存储结构，也可采用链表方式存储串值。由于串的特殊性（每个元素只有一个字符），在具体实现时，每个结点既可以存放一个字符，也可以存放多个字符。\n每个结点称为块，整个链表称为块链结构。\n#define MAXLEN 255\ntypedef struct StringNode {\n    char ch[4];// 为了提高存储密度\n    struct StringNode *next;\n} StringNode, *String;\n模式匹配\n字符串模式匹配：在主串中找到与模式串相同的子串，并返回其所在位置。\n朴素模式匹配算法\n这是一种暴力匹配算法\n主串长度为 n，模式串长度为 m\n朴素模式匹配算法：将主串中所有长为 m 的子串依次与模式串对比，直到找到一个完全匹配的子串，或所有子串都不匹配为止。\n最坏情况下，每个子串都要对比 m 个字符，共 n-m+1 个子串，最坏时间复杂度为O(nm)\n#define MAXLEN 255\ntypedef struct {\n    char ch[MAXLEN];\n    int length;\n} SString;\n \nint Index(SString S, SString T) {\n  int i = 1, j = 1;\n  while (i &lt;= S.length &amp;&amp; j &lt;= T.length) {\n    if (S.ch[i] == T.ch[j]) {\n      // 继续比较后续字符串\n      i++;\n      j++;\n    } else {\n      // 指针后退重新匹配下一个子串\n      i = i - j + 2;\n      j = 1;\n    }\n  }\n  if (j &gt; T.length) {\n    return i - T.length;\n  } else {\n    return 0;\n  }\n}\nKMP 算法\n在暴力匹配中，每趟匹配失败都是模式后移一位再从头开始比较。而某趟己匹配相等的字符序列是模式的某个前缀，这种频繁的重复比较相当于模式串在不断地进行自我比较，这就是其低效率的根源。\nKMP 算法：根据模式串 T，求出 next 数组，利用 next 数组进行匹配（主串指针不回溯）\nnext 数组的作用：当模式串的第 j 个字符失配时，从模式串的第 netx[j]的继续往后匹配\n该算法最坏时间复杂度为O(m+n)，其中求 next 数组时间复杂度O(m)，模式匹配过程最坏时间复杂度O(n)\n\nint Index_KMP(SString S, SString T, int next[]) {\n  int i = 1, j = 1;\n  while (i &lt;= S.length &amp;&amp; j &lt;= T.length) {\n    if (S.ch[i] == T.ch[j] || j == 0) {\n      // 继续比较后续字符串\n      i++;\n      j++;\n    } else {\n      // 匹配失败时，主串i不用回溯\n      // 模式串向右移动\n      j = next[j];\n    }\n  }\n  if (j &gt; T.length) {\n    return i - T.length;\n  } else {\n    return 0;\n  }\n}\n\n求 next 数组\nnext[0]不用处理\nnext[1] = 0和next[2] = 1是固定的。\n其它 next：在不匹配的位置前，划一根分界线，模式串一步一步往后退，直到分界线之前“能对上”，或模式串完全跨过分界线。此时 j 指向哪，next 数组值就是多少。\nKMP 进一步优化\n本质上只是优化 next 数组。\n将 next 数组优化成 nextval 数组\nint Index_KMP(SString S, SString T, int nextval[]) {\n  // 逻辑不变，只是用nextval数组替代next数组\n}\n求 nextval 数组\nnextval[1] = 0;\nfor (int j = 2; j &lt;= T.length; j++){\n  if(T.ch[next[j]] == T.ch[j]){\n    nextval[j] = nextval[next[j]];\n  }else{\n    nextval[j] = next[j];\n  }\n}\n\n"},"计算机基础/数据结构和算法/6_树":{"title":"树","links":[],"tags":["数据结构和算法"],"content":"树\n概念\n树：由 n(n&gt;=0) 个结点的有限集。当n = 0时，称为空树。\n在任意一棵非空树中应满足：\n\n有且仅有一个特定的称为根的结点。\n当 n&gt;1 时，其余结点可分为 m(m&gt;0) 个互不相交的有限集合 T_1,T_2,\\cdots,T_m 其中每个集合本身又是一棵树，并且称为根的子树。\n\n\n非空树的特性：\n\n有且仅有一个根节点。\n树的根结点没有前驱，除根结点外的所有结点有且只有一个前驱。\n树中所有结点都可以有零个或多个后继。\n没有后继的结点称为叶子结点（或终端结点）。\n有后继的结点称为分支结点（或非终端结点）。\n\n树的定义是递归的，即在树的定义中又用到了其自身，树是一种递归的数据结构。树作为一种逻辑结构，同时也是一种分层结构，因此树适合于表示具有层次结构的数据。\n树中的某个结点（除根结点外）最多只和上一层的一个结点有直接关系，根结点没有直接上层结点，因此在n个结点的树中有n-1条边。 而树中每个结点与其下一层的零个或多个结点都有直接关系。\n\n\n祖先结点：根结点 A 到结点 K 的唯一路径上的任意结点，称为结点 K 的祖先。如：K 结点的祖先结点是 H、D、A。\n子孙结点：一个结点下面所有的结点都为子孙结点。如：B 结点的子孙结点是 E、F、J。\n双亲结点（父节点）：一个结点的直接前驱结点。如：B 结点的双亲结点是 A。\n孩子节点：一个结点的直接后继结点。如：B 结点的孩子结点是 E、F。\n兄弟节点：一个结点的前驱的其他后继结点。如：E 结点的兄弟结点是 F。\n堂兄弟节点：除兄弟节点外的同一层结点。如：E 结点的兄弟结点是 G、H、I。\n路径：树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的，由于树中的分支是有向的，即从双亲指向孩子，所以树中的路径是从上向下的， 同一双亲的两个孩子之间不存在路径。\n路径长度：路径长度是路径上所经过的边的个数。\n结点的层次（深度）：从树根开始定义，从上往下数，默认根结点为第 1 层，它的子结点为第 2 层，以此类推。\n结点的高度：从叶结点开始自底向上逐层累加的。\n树的高度（深度）：总共多少层。\n结点的度：树中一个结点的孩子个数。\n树的度：各结点的度的最大值。\nm 叉树：每个结点最多只能有 m 个孩子。\n有序树：从逻辑上看，树中结点的各子树从左到右是有次序的，不能互换。\n无序树：从逻辑上看，树中结点的各子树从左到右是无次序的，可以互换。、\n森林：森林是m(m&gt;=0)棵互不相交的树的集合。森林的概念与树的概念十分相近，因为只要把树的根结点删去就成了森林。反之，只要给m棵独立的树加上一个结点，并把这m棵树作为该结点的子树，则森林就变成了树。\n\n\n性质\n\n\n结点数 = 总度数 + 1\n\n\n度为 m 的树、m 叉树的区别\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n度为 m 的树m 叉树任意结点的度小于等于 m（最多 m 个孩子）任意结点的度小于等于 m（最多 m 个孩子）至少有一个结点的度等于 m（有 m 个孩子）允许所有结点的度都小于 m一定是非空树，至少有 m+1 个结点可以是空树\n\n\n度为 m 的树中第 i 层至多有 m^{i-1} 个结点。（i&gt;=1）\nm 叉树第 i 层至多有 m^{i-1} 个结点。（i&gt;=1）\n\n\n\n高度为 h 的 m 叉树至多有 \\frac{(m^h-1)}{(m-1)} 个结点。\n如上图，由等比数列求和公式 \\frac{a_1\\times(1-q^n)}{1-q} 可得\n\n\n高度为 h 的 m 叉树至少有 h 个结点；\n高度为 h 、度为 m 的树至少有 h+m-1 个结点。\n\n\n\n具有 n 个结点的 m 叉树的最小高度为 \\lceil \\log_m(n(m-1)+1) \\rceil（向上取整）。\n高度最小的情况即所有结点都有 m 个孩子\n\\frac{(m^{h-1}-1)}{(m-1)}&lt;n&lt;=\\frac{(m^h-1)}{(m-1)}\nm^{h-1}&lt;n(m-1)+1&lt;=m^h\nh -1&lt; \\log_m(n(m-1)+1)&lt;=h\n\n\n\n已知一棵有 2011 个结点的树，其叶结点个数为 116，该树对应的二叉树中无右孩子的结点个数是 1896。\n树转换为二叉树时，树的每个分支结点的所有子结点中的最 右子结点无右孩子，根结点转换后也没有右孩子，因此，对应二叉树中无右孩子的结点个数 = 分支结点数 + 1 = 2011 - 116 + 1 = 1896。\n设树是如下图所示的结构，则对应的二叉树中仅有前 115 个叶结点有右孩子，故无右孩子的结点个数 = 2011-115 = 1896。\n\n\n存储结构\n树的存储方式有多种，既可采用顺序存储结构，又可采用链式存储结构，但无论采用何种存 储方式，都要求能唯一地反映树中各结点之间的逻辑关系。\n双亲表示法\n这种存储结构采用一组连续空间来存储每个结点，同时在每个结点中增设一个伪指针，指示其双亲结点在数组中的位置。\n根结点下标为 0，其伪指针域为-1。\n\n#define MAX_TREE_SIZE 100\ntypedef struct{\n  int data; // 数据\n  int parent; // 双亲位置域\n}PTNode;\ntypedef struct{\n  PTNode nodes[MAX_TREE_SIZE];\n  int n; // 结点数\n}PTree;\n相关操作：\n\n\n插入结点\n直接在数组后面新增数据元素，无需按逻辑上的次序存储。\n\n\n删除结点\n\n\n将需要删除的节点的指针域设为 -1，表示没有双亲。\n缺点：数组之间的空数据导致遍历数组的速度变慢。\n\n\n把后面的结点都前进一位，保证前面的存储单元都是有效的。\n\n\n\n\n该存储结构利用了每个结点（根结点除外）只有唯一双亲的性质，可以很快地得到每个结点的双亲结点，但求结点的孩子时则需要遍历整个结构。\n\n\n                  \n                  Tip\n                  \n                \n\n区别树的顺序存储结构与二叉树的顺序存储结构。\n\n在树的顺序存储结构中，数组下标代表结点的编号，下标中所存的内容指示了结点之间的关系。\n在二叉树的顺序存储结构中，数组下标既代表了结点的编号，又指示了二叉树中各结点之间的关系。\n\n二叉树属于树，因此二叉树都可以用树的存储结构来存储，但树却不都能用二叉树的存储结构来存储。\n\n\n孩子表示法\n孩子表示法是将每个结点的孩子结点都用单链表链接起来形成一个线性结构。\n\nstruct CTNode{\n  int child; // 孩子节点在数组中的位置\n  struct CTNode *next; // 下一个孩子\n}\ntypedef struct{\n  int data;\n  struct CTNode *firstChild;// 第一个孩子\n}CTBox;\ntypedef struct{\n  CTBox nodes[MAX_TREE_SIZE];\n  int n ,r;// 结点数和根的位置\n}CTree;\n这种存储结构寻找子女的操作非常直接，而寻找双亲的操作需要遍历 n 个结点中孩子链表指 针域所指向的 n 个孩子链表。\n孩子兄弟表示法\n孩子兄弟表示法又称二叉树表示法，即以二叉链表作为树的存储结构。\n孩子兄弟表示法使每个结点包括三部分内容：结点值、指向结点第一个孩子结点的指针，以及指向结点下一个兄弟结点的指针（沿此域可以找到结点的所有兄弟结点）。\n\n这种存储表示法比较灵活，其最大的优点是可以方便地实现树转换为二叉树的操作，易于查 找结点的孩子等，但缺点是从当前结点查找其双亲结点比较麻烦。\n二叉树\n概念\n与树相似，二叉树也以递归的形式定义。\n二叉树是一种特殊的树形结构，其特点是每个结点至多只有两棵子树（即二叉树中不存在度大于 2 的结点），并且二叉树的子树有左右之分，其次序不能任意颠倒。\n二叉树是 n(n&gt;=0) 个结点的有限集合：\n\n或者为空二叉树，即 n=0。\n或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树 又分别是一棵二叉树。\n\n\n二叉树是有序树，左右子树不能颠倒，若将其左、右子树颠倒，则成为另一棵不同的二叉树。即使树中结点只有一棵子树，也要区分它是左子树还是右子树。\n二叉树与度为 2 的有序树的区别：\n\n度为 2 的树至少有 3 个结点，而二叉树可以为空。\n度为 2 的有序树的孩子的左右次序是相对于另一孩子而言的，若某个结点只有一个孩子, 则这个孩子就无须区分其左右次序，而二叉树无论其孩子数是否为 2，均需确定其左右次序，即二叉树的结点次序不是相对于另一结点而言的，而是确定的。\n\n二叉树的 5 种基本形态：\n\n性质\n\n\n非空二叉树上中度为 0、1、2 的结点个数分别为n_0,n_1,n_2，则 n_0=n_2+1。（叶子结点比二分支结点多一个）\n\n\n\n二叉树第 i 层最多由 2^{i-1} 个结点（i\\ge1）；m 叉树第 i 层最多由 m^{i-1} 个结点（i\\ge1）\n\n\n高度为 h 的 2 叉树至多有 2^h-1 个结点。（刚好是满二叉树）；高度为 h 的 m 叉树至多有 \\frac{(m^h-1)}{(m-1)} 个结点。\n\n\n具有 n(n&gt;0) 个结点的完全二叉树的高度 h 为 \\lceil \\log_2(n+1) \\rceil或 \\lceil \\log_2(n) \\rceil +1。\n\n\n当该完全二叉树是满二叉树时：\n\n\n\n当该完全二叉树不是满二叉树时：\n\n\n\n\n\n对于完全二叉树，可以由结点数 n 推出度为 0、1、2 的结点的个数为n_0,n_1,n_2。\n\nn_0+n_2=2n_2+1是奇数，2k=n_0+n_1+n_2=n_1+2n_2+1，因此 n_1 只能是奇数 1。\n\n\n存储结构\n顺序存储结构\n二叉树的顺序存储是指用一组地址连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素。\n完全二叉树和满二叉树采用顺序存储比较合适，树中结点的序号可以唯一地反映结点之间的逻辑关系，这样既能最大可能地节省存储空间，又能利用数组元素的下标值确定结点在二叉树中的位置，以及结点之间的关系。\n但对于一般二叉树树而言，采用顺序存储会浪费极大空间。\n\n#define MaxSize 100\nstruct TreeNode {\n    int val;// 结点中的数据元素\n    bool isEmpty;// 结点是否为空\n};\n链式存储结构\n由于顺序存储的空间利用率较低，因此二叉树一般都采用链式存储结构，用链表结点来存储二叉树中的每个结点。\n二叉链表至少包含 3 个域：数据域 data、左指针域 lchild、右指针域 rchild。实际上在不同的应用中，还可以增加某些指针域，如增加指向父结点的指针后，变为三叉链表的存储结构。\n\ntypedef struct BiTNode {\n    int val;\n    struct BiTNode *lChild, *rChild;\n} BiTNode, *BiTree;\n遍历\n先中后序遍历\n二叉树的遍历是指按某条搜索路径访问树中每个结点，使得每个结点均被访问一次，而且仅被访问一次。\n按照先遍历左子树再遍历右子树的原则，常见的遍历次序有先序（NLR）、中序（LNR）和后序（LRN）三种遍历算法，其中“序”指的是根结点 在何时被访问。\n\n\n// 先序遍历\nvoid PreOrder(BiTree T) {\n  if (T != nullptr) {\n    visit(T);// 访问根节点\n    PreOrder(T-&gt;lChild);// 递归遍历左子树\n    PreOrder(T-&gt;rChild);// 递归遍历右子树\n  }\n}\n// 中序遍历\nvoid PreOrder(BiTree T) {\n  if (T != nullptr) {\n    PreOrder(T-&gt;lChild);// 递归遍历左子树\n    visit(T);// 访问根节点\n    PreOrder(T-&gt;rChild);// 递归遍历右子树\n  }\n}\n// 后序遍历\nvoid PreOrder(BiTree T) {\n  if (T != nullptr) {\n    PreOrder(T-&gt;lChild);// 递归遍历左子树\n    PreOrder(T-&gt;rChild);// 递归遍历右子树\n    visit(T);// 访问根节点\n  }\n}\n\n层序遍历\n\ntypedef struct BiTNode {\n    int val;\n    struct BiTNode *lChild, *rChild;\n} BiTNode, *BiTree;\n \ntypedef struct LinkNode {\n    BiTNode data;\n    struct LinkNode *next;\n} LinkNode;\n \ntypedef struct {\n    LinkNode *front, *rear;\n} LinkQueue;\n \nvoid LevelOrder(BiTree T) {\n  LinkQueue Q;\n  InitQueue(Q);// 初始化队列\n  BiTree p;\n  EnQueue(Q, T);// 根节点入队\n  while (!isEmpty(Q)){\n    DeQueue(Q,p);// 对头结点出队\n    if (p-&gt;lChild != nullptr){\n      EnQueue(Q, p-&gt;lChild);// 左孩子入队\n    }\n    if (p-&gt;rChild != nullptr){\n      EnQueue(Q, p-&gt;rChild);// 有孩子入队\n    }\n  }\n}\n由遍历序列构造二叉树\n若只给出一颗二叉树的 前/中/后/层 序遍历序列中的一种，不能唯一确定一颗二叉树。\n\n\n\n唯一地确定一棵二叉树：\n\n先序序列+中序序列\n后序序列+中序序列\n层序序列+中序序列\n\n\n\n                  \n                  Tip\n                  \n                \n\n\n由遍历序列构造二叉树的核心就是：找到根节点，根据根节点在中序序列划分左右子树，找到左右子树的根节点，继续划分左右子树。\n必须要有中序遍历序列。\n\n\n\nQ&amp;A\n\n\n                  \n                  Tip\n                  \n                \n\n先序序列为 a,b,c,d,…… 的不同二叉树的个数是多少？\n前序序列中序序列和相当于以前序序列为入栈次序，以中序序列为出栈次序。又因为前序序列+中序序列唯一地确定一棵二叉树，所以该问题等价于以 a,b,c,d,…… 为入栈次序，出栈序列的个数是多少？\nn个不同元素进栈，出栈元素不同排列的个数为\\frac{1}{n+1}C_{2n}^{n}。\n\n\n特殊二叉树\n满二叉树\n一棵高度为 h，且含有 2^h-1 个结点的二叉树称为满二叉树，即树中的每层都含有最多的结点。\n对满二叉树按层序编号：约定编号从根结点（根结点编号为 1）起，自上而下，自左向右。\n\n\n特点：\n\n只有最后一层有叶子结点\n不存在度为 1 的结点\n对于编号为 i 的结点，若有双亲，则其双亲为质 \\lfloor i/2 \\rfloor , 若有左孩子，则左孩子为 2i ，若有右孩子，则右孩子为 2i+1 。\n\n完全二叉树\n高度为 h、有 n 个结点的二叉树，当且仅当其每个结点都与高度为 h 的满二叉树中编号为 1 \\sim  n 的结点一一对应时，称为完全二叉树。\n满二叉树是是一种特殊的完全二叉树，但完全二叉树不一定是满二叉树\n\n\n特点：\n\n只有最后两层可能有叶子结点\n最多只有一个度为 1 的结点，且该结点只有左孩子而无右孩子\ni\\le \\lfloor n/2 \\rfloor 为分支结点，i &gt;  \\lfloor n/2 \\rfloor为叶子结点\n若 n 为奇数，则每个分支结点都有左孩子和右孩子；若 n 为偶数，则编号最大的分支结点（编号为 n/2）只有左孩子，没有右孩子，其余分支结点左、右孩子都有。\n\n二叉排序树\n左子树上所有结点的关键字均小于根结点的关键字；右子树上的所有结点的关键字均大于根结点的关键字；左子树和右子树又各是一棵二叉排序树。\n\n平衡二叉树\n树上任意一个结点的左子树和右子树的深度之差不超过 1。\n\n线索二叉树\n传统的二叉链表存储仅能体现一种父子关系，不能直接得到结点在遍历中的前驱或后继\n\n从根结点出发，进行中序遍历，定义指针 q 记录当前访问的结点，指针 pre 记录上一个访问的结点。\nvoid vistit(BiTNode T){\n  pre = q;\n  q = T;\n  if(q == p){\n    // 此时 pre 指向的结点就是 p 的前驱\n  }\n  if(pre == p){\n    // 此时 pre 指向的结点就是 p 的后继\n  }\n}\n缺点：找前驱、后继很不方便；必须从根开始进行一次遍历。\n概念\n为了加快查找结点前驱和后继的速度，因此引入线索二叉树这个概念。\n在含 n 个结点的二叉树中，有 n+1 个空指针，线索二叉树就是利用这些空指针来存放指向其前驱或后继的指针。这样就可以像遍历单链表那样方便地遍历二叉树。\n二叉树是一种逻辑结构，但线索二叉树是加上线索后的链表结构，即它是二叉树在计算机内部的一种存储结构，所以是一种物理结构。\n\n\n                  \n                  Tip\n                  \n                \n\n含 n 个结点的二叉树中，有 n+1 个空指针。\n每个叶结点都有 2 个空指针，每个度为 1 的结点都有 1 个空指针，空指针总数为 2n_0+n_1，又 n_0=n_2+1，所以空指针总数为 n_0+n_1+n_2+1=n+1。\n\n\n\n存储结构\n\n三种线索二叉树的对比\n\n\n\n                  \n                  Note\n                  \n                \n\n后序线索树的遍历仍需要栈的支持。\n后序线索树遍历时，最后访问根结点，若从右孩子 x 返回访问父结点，则由于结点 x 的右孩子不一定为空（右指针无法指向其后继），因此通过指针可能无法遍历整棵树。\n如下图所示，结点中的数字表示遍历的顺序，图(C)中结点 6 的右指针指向其右孩子 5，而不指向其后序后继结点 7，因此后序遍历还需要栈的支持，而图(A)和图(B)均可遍历。\n\n\n\n二叉树的线索化实现\n中序线索化\ntypedef struct ThreadNode {\n    int val;\n    struct ThreadNode *lChild, *rChild;\n    int lTag, rTag;\n} ThreadNode, *ThreadTree;\n \n// 当前访问结点的前驱\nThreadNode *pre = nullptr;\n \nvoid visit(ThreadNode *q) {\n  // 左子树为空，建立当前结点前驱线索\n  if (q-&gt;lChild == nullptr) {\n    q-&gt;lChild = pre;\n    q-&gt;lTag = 1;\n  }\n  // 建立前驱结点的后继结点\n  if (pre != nullptr &amp;&amp; pre-&gt;rChild == nullptr) {\n    pre-&gt;rChild = q;\n    pre-&gt;rTag = 1;\n  }\n  pre = q;\n}\n \n// 中序遍历\nvoid InThread(ThreadTree T) {\n  if (T != nullptr) {\n    InThread(T-&gt;lChild);\n    visit(T);\n    InThread(T-&gt;rChild);\n  }\n}\n \n// 中序线索化二叉树\nvoid CreateThread(ThreadTree T) {\n  pre = nullptr;\n  if (T != nullptr) {\n    InThread(T);\n    // 处理遍历后的最后一个结点\n    if (pre-&gt;rChild == nullptr) {\n      pre-&gt;rTag = 1;\n    }\n  }\n}\n先序线索化\n// 其他代码一样\n \n// 先序遍历\nvoid PreThread(ThreadTree T) {\n  if (T != nullptr) {\n    visit(T);\n    if (T -&gt; lTag == 0){\n    \tInThread(T-&gt;lChild);// lTag不是前驱线索\n    }\n    InThread(T-&gt;rChild);\n  }\n}\n \n// 先序线索化二叉树\nvoid CreateThread(ThreadTree T) {\n  pre = nullptr;\n  if (T != nullptr) {\n    PreThread(T);\n    // 处理遍历后的最后一个结点\n    if (pre-&gt;rChild == nullptr) {\n      pre-&gt;rTag = 1;\n    }\n  }\n}\n在线索二叉树中找前驱和后继\n\n\n中序线索二叉树找中序后继\n\n\n\n中序线索二叉树找中序前驱\n\n\n\n先序线索二叉树找先序后继\n\n\n\n先序线索二叉树找先序前驱\n由于每个结点只有指向左右孩子的指针，因此无法找到前驱。\n\n要找到前驱可以使用三叉链表，即在结点中添加一个指向父节点的指针\n\n\n\n后序线索二叉树找后序前驱\n\n\n\n后序线索二叉树找后序后继\n\n仍然是使用三叉链表\n\n\n\n\n树、森林与二叉树的转换\n树 → 二叉树\n\n\n规则：\n每个结点左指针指向它的第一个孩子，右指针指向它在树中的相邻右兄弟，这个规则又称“左孩子右兄弟”。由于根结点没有兄弟，所以对应的二叉树没有右子树。\n\n\n画法：\n\n在兄弟结点之间加一连线；\n对每个结点，只保留它与第一个孩子的连线，而与其他孩子的连线全部抹掉；\n以树根为轴心，顺时针旋转 45。\n\n\n\n\n若 T_1 是由有序树 T 转换而来的二叉树，则 T 中结点的后根序列就是 T_1 中结点的中序序列。\n\n森林 → 二叉树\n\n\n规则：\n先将森林中的每棵树转换为二叉树，由于任意一棵和树对应的二叉树的右子树必空，若把森林中第二棵树根视为第一棵树根的右兄弟，即将第二棵树 对应的二叉树当作第-棵二叉树根的右子树，将第三棵树对应的二叉树当作第二棵二叉树根的右 子树……以此类推，就可以将森林转换为二叉树。\n\n\n画法：\n\n将森林中的每棵树转换成相应的二叉树；\n每棵树的根也可视为兄弟关系，在每棵树的根之间加一根连线；\n以第一棵树的根为轴心顺时针旋转 45。\n\n\n\n\n二叉树 → 森林\n\n\n规则：\n若二叉树非空，则二叉树的根及其左子树为第一棵树的二叉树形式，故将根的右链断开。二叉树根的右子树又可视为一个由除第一棵树外的森林转换后的二叉树，应用同样的方法，直到最后只剩一棵没有右子树的二叉树为止，最后再将每棵二叉树依次转换成 树，就得到了森林。二叉树转换为树或森林是唯一的。\n\n\n\n树和森林的遍历\n树的遍历\n\n\n先根遍历\n若树非空，先访问根结点，再依次遍历根结点的每棵子树，遍历子树时仍遵循先根后子树的规则。其遍历序列与这棵树相应二叉树的先序序列相同。\n\n\n\n后根遍历\n若树非空，先依次遍历根结点的每棵子树，再访问根结点，遍历子树时仍遵循先子树后根的规则。其遍历序列与这棵树相应二叉树的中序序列相同。\n\n\n\n层次遍历\n与二叉树的层次遍历思想基本相同，即按层序依次访问各结点。\n\n\n\n森林的遍历\n\n\n先序遍历森林\n若森林为非空，则按如下规则进行遍历：\n\n访问森林中第一棵树的根结点。\n先序遍历第一棵树中根结点的子树森林。\n先序遍历除去第一棵树之后剩余的树构成的森林。\n\n\n\n\n\n中序遍历森林\n森林为非空时，按如下规则进行遍历：\n\n中序遍历森林中第一棵树的根结点的子树森林。\n访问第一棵树的根结点。\n中序遍历除去第一棵树之后剩余的树构成的森林。\n\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n部分教材也将森林的中序遍历称为后序遍历，称中序遍历是相对其二叉树而言的，称后序遍历是因为根确实是最后才访问的，如遇到这两种称谓，那么都可以理解为同一种遍历方法。\n\n\n\n\n哈夫曼树\n\n\n                  \n                  Note\n                  \n                \n\n\n\n结点的权：有某种现实含义的数值。\n\n\n结点的带权路径长度：从树的根到任意结点的路径长度（经过的边数）与该结点上权值的乘积。\n\n\n树的带权路径长：树中所有叶结点的带权路径长度之和，记为\n WPL=\\sum_{i=1}^{n} w_il_i\n\n\n\n\n\n\n定义\n在含有 n 个带权叶结点的二叉树中，其中带权路径长度(WPL)最小的二叉树称为哈夫曼树，也称最优二叉树。\n\n构造\n给定 n 个权值分别为W_1,W_2,\\cdots,W_n的结点，构造哈夫曼树的算法描述如下：\n\n将这 n 个结点分别作为 n 棵仅含一个结点的二叉树，构成森林 F。\n构造一个新结点，从 F 中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根结点的权值之和。\n从 F 中删除刚才选出的两棵树，同时将新得到的树加入 F 中。\n重复步骤 2. 和 3. ，直至 F 中只剩下一棵树为止。\n\n\n除上图的构造的哈夫曼树外，还可以如下图构造哈夫曼树\n\n\n给定整数集合 {3,5,6,9,12}，与之对应的哈夫曼树是(C)。\n\n\n特点\n\n每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大。\n构造过程中共新建了 n-1 个结点（双分支结点），因此哈夫曼树的结点总数为 2n-1。\n每次构造都选择 2 棵树作为新结点的孩子，因此哈夫曼树中不存在度为 1 的结点。\n哈夫曼树并不唯一，但 WPL 必然相同且为最优。\n\n\n一棵哈夫曼树共有 215 个结点，对其进行哈夫曼编码，共能得到 108 个不同的码字。\n\n在哈夫曼树中，叶节点数 - 叶节点数 = 1，因此叶结点数为(215 + 1)/2=108，所以共有 108 个不同的码字。\n在哈夫曼树中只有度为 0 和 2 的结点，结点总数n = n_0 + n_2，且n_0=n_2+1，由题知 n=215, n_0= 108。\n\n\n哈夫曼编码\n\n5.51哈夫曼树\n\n\n\n                  \n                  Note\n                  \n                \n\n\n固定长度编码：在数据通信中，若对每个字符用相等长度的二进制位表示。\n可变长度编码：在数据通信中，允许对不同字符用不等长的二进制位表示。\n\n可变长度编码比固定长度编码要好得多，其特点是对频率高的字符赋以短编码，而对频率较低的字符则赋以较长一些的编码，从而可以使字符的平均编码长度减短，起到压缩数据的效果。\n\n\n\n\n                  \n                  Note\n                  \n                \n\n前缀编码：没有一个编码是另一个编码的前缀。\n\n\n哈夫曼编码是一种被广泛应用而且非常有效的数据压缩编码。\n由哈夫曼树得到哈夫曼编码：\n\n\n将字符集中出现的每一个字符当作一个叶子结点，其权值为它出现的频度（或次数），构造出对应的哈夫曼树。\n\n\n将字符的编码解释为从根至该字符的路径上边标记的序列。\n\n\n\n\n\n\n\n\n                  \n                  Note\n                  \n                \n\n左分支和右分支究竞是表示 0 还是表示 1 没有明确规定，因此构造出的哈夫曼树并不唯一，但各哈夫曼树的带权路径长度 WPL 相同且为最优。此外，如有若干权值相同的结点，则构造出的哈夫曼树更可能不同，但 WPL 必然相同且为最优。\n\n\n\n\n                  \n                  Important\n                  \n                \n\n哈夫曼编码的加权平均长度 = WPL / 叶子结点权值之和\n\n\n并查集\n\n5.52并查集\n\n\n\n                  \n                  Note\n                  \n                \n\n\n\n\n定义\n并查集是一种简单的集合表示。\n\n\n通常用树（森林）的双亲表示作为并查集的存储结构，每个子集合以一棵树表示。\n所有表示子集合的树，构成表示全集合的森林，存放在双亲表示数组内。通常用数组元素的下标代表元素名，用根结点的下标代表子集合名，根结点的双亲结点为负数。\n实现\n\n\nInitial(S)\n将集合 S 中的每个元素都初始化为只有一个单元素的子集合。\n\n\nUnion(S, Rootl, Root2)（并）\n把集合 S 中的子集合 Root2 并入子集合 Root1。要求 Root1 和 Root2 互不相交，否则不执行合并。\n\n\nFind(S, x)（查）\n查找集合 S 中单元素 x 所在的子集合，并返回该子集合的根结点。\n\n\n#define SIZE 13\n \nint UFSets[SIZE];// 集合元素数组\n \n// 初始化并查集\nvoid Initial(int S[]) {\n  for (int i = 0; i &lt; SIZE; i++) {\n    S[i] = -1;\n  }\n}\n \nint Find(int S[], int x) {\n  while (S[x] &gt;= 0) {\n    x = S[x];\n  }\n  return x;\n}\n \nvoid Union(int S[], int Root1, int Root2) {\n  if (Root1 == Root2)return;\n  S[Root2] = Root1;\n}\n时间复杂度\n\n\nFind() 查操作的最坏时间复杂度为 O(n)。\n\n\n\nUnion() 并操作的时间复杂度为 O(1)。\n\n\n优化\n核心：降低树的高度\n\n\nUnion 操作优化\n目的：降低 Find() 的时间复杂度。\n\n用根节点的绝对值表示树的结点总数\nUnion 操作，让小树合并到大树\n\n\n\n使用该方法构造的树高不超过 \\left \\lfloor \\log_2n \\right \\rfloor +1\n优化后，Find 操作最坏时间复杂度度为 O(\\log_2n)，Union 最坏时间复杂度为 O(n\\log_2n)\n\n\nFind 操作优化（压缩路径）\n先找到根节点，再将查找路径上的所有结点都挂到根结点下。\n\n每次 Find 操作，先找根，在压缩路径，可使树的高度不超过 O(\\alpha (n)) 。\\alpha (n) 是一个增长很缓慢的函数，对于常见的 n 值，通常 \\alpha(n) \\le  4，因此优化后的并查集的 Find、Union 操作时间开销都很低。\nFind  最坏时间复杂度为 O(\\alpha (n))，Union 最坏时间复杂度为 O(n\\alpha (n))\n\n\n\n"},"计算机基础/数据结构和算法/7_图":{"title":"图","links":[],"tags":["数据结构和算法"],"content":"图的基本概念\n图的定义\n图G 由 顶点集V 和 边集E 组成，记为G=(V,E)，其中 V(G) 表示图G中顶点的有限非空集；E(G) 表示图G中顶点之间的关系（边）集合。\n\nV=\\{v_1,v_2,\\cdots,v_n\\} ，用 \\left | V \\right | 示图 G 中顶点的个数，也称图G的阶\nE=\\{ (u,v)| u\\in V,v\\in V \\} ，用 \\left | E \\right | 表示图 G 中边的条数。\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n经性表可以是空表，树可以是空树，但图不可以是空图。\n即图中不能一个顶点也没有，图的顶点集V一定非空，但边集E可以为空，此时图中只有顶点而没有边。\n\n\n无向图、有向图\n\n\n无向图\n若 E 是无向边（简称边）的有限集合时，则图 G 为无向图。\n边是顶点的无序对，记为 (v, w) 或 (w,v)，因为 (v, w)=(w,v)，其中v,w是顶点。\n可以说顶点w和顶点v互为邻接点。边(v, w)依附于顶点w和v，或称边(v, w)和顶点v, w相关联。\n\nG_1 = (V_1,E_1)\nV_1=\\{ A,B,C,D,E \\}\nE_1=\\{ (A,B),(B,D),(B,E),(C,D),(C,E),(D,E) \\}\n\n\n有向图\n若 E 是有向边（也称弧）的有限集合时，则图 G 为有向图。\n弧是顶点的有序对，记为 &lt;v,w&gt;，其中v,w是顶点，v称为弧尾，w称为弧头，&lt;v,w&gt;称为从顶点v到顶点w的弧，也称v邻接到w，或w邻接自v。\n&lt;v,w&gt;\\ne &lt;w,v&gt;\n\nG_2 = (V_2,E_2)\nV_2=\\{ A,B,C,D,E \\}\nE_2=\\{ &lt;A,B&gt;,&lt;A,C&gt;,&lt;A,D&gt;,&lt;A,E&gt;,&lt;B,A&gt;,&lt;B,C&gt;,&lt;B,E&gt;,&lt;C,D&gt;\\}\n\n\n简单图、多重图\n\n\n简单图\n\n不存在重复边；\n不存在顶点到自身的边；\n\n\n\n\n多重图\n图 G 中某两个顶点之间的边数大于 1 条，又允许顶点通过一条边和自身关联。\n\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n数据结构中仅讨论简单图。\n\n\n路径、路径长度、回路、距离\n\n\n路径\n顶点v_p到顶点v_q之间的一条路径，是指顶点序列，v_p,v_{i_1},v_{i_2},\\cdots,v_q。\n\n\n路径长度\n路径上边的数目。\n\n\n回路\n第一个顶点和最后一个顶点相同的路径称为回路或环。若一个图有 n 个顶点，并且有大于 n-1 条边，则此图一定有环。\n\n图是一个环： 当说一个图是一个环时，意味着整个图的结构是一个环。换句话说，图中的所有顶点都可以按照一定的方式连接成一个闭合的环，每个顶点都与它相邻的两个顶点相连。这种情况下，整个图可以被看作一个环的扩展，每个顶点都是环中的一个节点，每条边都是环中的一条边。\n图存在一个环： 当说一个图存在一个环时，意味着在这个图中存在一个封闭的路径，这个路径可以回到起始顶点，形成一个环。这个环可能是图中的一个子集，而不一定涵盖所有的顶点。换句话说，图中的某些顶点和边组成了一个闭合路径，形成了一个环，但是这个环不一定包括图中的所有顶点。\n\n\n\n\n\n简单路径\n在路径序列中，顶点不重复出现的路径称为简单路径。\n\n回路不是简单路径\n\n\n\n简单回路\n除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路。\n\n\n点到点的距离\n从顶点u出发到顶点v的最短路径若存在，则此路径的长度称为从u到v的距离。若从u到v根本不存在路径，则记该距离为无穷（\\infty）。\n\n\n子图\n设有两个图G = (V,E)和G&#039;= (V&#039;,E&#039;)\n\n\n若V&#039;是V的子集，且E&#039;是E的子集，则称G&#039;是G的子图。\n\n\n若有满足V(G&#039;)=V(G) 的子图G&#039;，则称其为G的生成子图。\n\n\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n并非V和E的任何子集都能构成G的子图，因为这样的子集可能不是图，即E的子集中的某些边关联的顶点可能不在这个V的子集中。\n\n\n\n连通 、连通图 、连通分量\n\n\n                  \n                  Tip\n                  \n                \n\n在无向图中讨论连通性，在有向图中讨论强连通性。\n\n\n\n\n连通\n在无向图中，若从顶点V到顶点W有路径存在，则称V和W是连通的。\n\n\n强连通\n在有向图中，如果有一对顶点V和W，从V到W和从W到V之间都有路径，则称这两个顶点是强连通的。\n\n\n连通图\n若图G中任意两个顶点都是连通的，则称图G为连通图，否则称为非连通图。\n\n\n\n                  \n                  常见考点 \n                  \n                \n\n对于 n 个顶点的无向图G\n\n若G是连通图，则最少有 n-1 条边；\n\n\n\n\n若G是非连通图，则最多可能有C_{n-1}^2条边；\n除去一个顶点，剩下顶点两两相连\n\n\n\n\n\n\n\n强连通图\n若图中任何一对顶点都是强连通的，则称此图为强连通图。\n\n\n                  \n                  常见考点 \n                  \n                \n\n对于 n 个顶点的有向图G，若 G 是强连通图，则最少有 n 条边（形成回路）\n\n\n\n\n\n连通分量\n无向图中的极大连通子图称为连通分量。\n\n\n                  \n                  极大连通子图 \n                  \n                \n\n子图必须连通，且包含尽可能多的顶点和边。\n\n\n\n\n\n\n强连通分量\n有向图中的极大强连通子图称为有向图的强连通分量。\n\n\n                  \n                  极大强连通子图 \n                  \n                \n\n子图必须强连通，同时保留尽可能多的边。\n\n\n\n\n\n生成树、生成森林\n\n\n生成树\n连通图的生成树是包含图中全部顶点的一个极小连通子图。\n若图中顶点数为 n，则它的生成树含有 n-1 条边。包含图中全部顶点的极小连通子图，只有生成树满足这个极小条件，对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。\n\n极小连通子图：边尽可能少，但要保持连通。\n\n\n\n\n生成森林\n在非连通图中， 连通分量的生成树构成了非连通图的生成森林。\n\n\n\n顶点的度、入度和出度\n\n\n在无向图中\n顶点v的度是指依附于顶点 v 的边的条数，记为 TD(v)。\n\n\n                  \n                  Note\n                  \n                \n\n对于具有 n 个顶点、e 条边的无向图，\n\\sum_{i=1}^{n}TD(v_i) =2\\mid E\\mid =2e\n\n即无向图的全部顶点的度的和等于边数的 2 倍，因为每条边和两个顶点相关联。\n\n\n\n\n在有向图中\n入度是以顶点v为终点的有向边的数目，记为 ID(v)；\n出度是以顶点v为起点的有向边的数目，记为 OD(v)；\n顶点v的度等于其入度与出度之和，即 TD(v) = ID(v) + OD(v)。\n\n\n                  \n                  性质 \n                  \n                \n\n对于具有 n 个顶点、e 条边的有向图，\n\\sum_{i=1}^{n}ID(v_i)=\\sum_{i=1}^{n}OD(v_i)=e\n\n即有向图的全部顶点的入度之和与出度之和相等，并且等于边数，这是因为每条有向边都有一个起点和终点。\n\n\n\n\n边的权、带权图/网\n\n\n边的权\n在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值。\n\n\n带权图/ 网\n边上带有权值的图称为带权图，也称网。\n\n\n带权路径长度\n当图是带权图时，一条路径上所有边权值之和，称为路径的带权路径长度。\n\n\n\n几种特殊形态的图\n完全图\n也称简单完全图\n\n\n对于无向图\n|E| 的取值范围为 0 到C_n^2=n(n-1)/2，有n(n-1)/2条边的无向图称为完全图，在完全图中任意两个顶点之间都存在边。\n\n\n对于有向图\n|E| 的取值范围为 0 到n(n-1)，有而n(n-1)条弧的有向图称为有向完全图，在有向完全图中任意两个顶点之间都存在方向相反的两条弧。\n\n\n稠密图、稀疏图\n\n树\n不存在回路，且连通的无向图\nn 个顶点的树，必有 n-1 条边。\n\n有向树\n一个顶点的入度为 0，其余顶点的入度均为 1 的有向图，称为有向树。\n\n图的存储\n\n邻接矩阵法\n所谓邻接矩阵存储，是指用一个一维数组存储图中顶点的信息，用一个二维数组存储图中边的信息（即各顶点之间的接关系），存储顶点之间邻接关系的二维数组称为邻接矩阵。\n结点数为n的图G=(V,E)的邻接矩阵A是n\\times n的。将G的顶点编号为约v_1,v_2,\\cdots,v_n。若(v_i,v_j)\\in E，则A[i][j]=1，否则A[i][j]=0。\n\n#define MaxVertexNum 100 // 顶点数目的最大值\n \ntypedef struct {\n    char Vex[MaxVertexNum]; // 顶点表\n    int Edge[MaxVertexNum][MaxVertexNum]; // 邻接矩阵，边表\n    int vexnum, arcnum; // 图的当前顶点数和边数/弧数\n} MGraph;\n对于带权图而言，若顶点V_i和V_j之间有边相连，则邻接矩阵中对应项存放着该边对应的权值，若顶点V_i和V_j不相连，则通常用\\infty来代表这两个顶点之间不存在边。\n\n#include &lt;climits&gt;\n \n#define MaxVertexNum 100 // 顶点数目最大值\n#define INFINITY INT_MAX // 无穷\n \ntypedef struct {\n    char Vex[MaxVertexNum]; // 顶点表\n    int Edge[MaxVertexNum][MaxVertexNum]; // 边的权\n    int vexnum, arcnum; // 图的当前顶点数和边数/弧数\n} MGraph;\n\n\n                  \n                  Tip\n                  \n                \n\n\n在简单应用中，可直接用二维数组作为图的邻接矩阵（顶点信息等均可省略）。\n当邻接矩阵的元素仅表示相应边是否存在时，EdgeType 可采用 bool 类型。\n\n\n\n特点：\n\n\n无向图的邻接矩阵一定是一个对称矩阵(并且唯一)。因此，在实际存储邻接矩阵时只需存储上(或下)三角矩阵的元素。\n\n\n稠密图适合使用邻接矩阵的存储表示。\n\n\n邻接矩阵表示法的空间复杂度为O(n^2)，其中 n 为图的顶点数|V|，只和顶点数相关，和实际边数无关。\n\n\n邻接矩阵求顶点的度/出度/入度的时间复杂度为O(|V|)\n\n\n对于无向图，\n第 i 个结点的度 = 第 i 行(或第 i 列)的非零元素的个数。\n\n\n对于有向图，\n\n第 i 个结点的出度 = 第 i 行的非零元素的个数。\n第 i 个结点的入度 = 第 i 列的非零元素的个数。\n第 i 个结点的度 = 第 i 行、第 i 列的非零元素的个数。\n\n\n\n用邻接矩阵存储图，很容易确定图中任意两个顶点之间是否有边相连。但是，要确定图中有多少条边，则必须按行、按列对每个元素进行检测，所花费的时间代价很大。\n\n\n设图G的邻接矩阵为A，A^n的元素A^n[i][j]等于由顶点 i 到顶点 j 的长度为 n 的路径的数目。\n\n\n\n\n                  \n                  Note\n                  \n                \n\n若用邻接矩阵存储有向图，矩阵中主对角线以下的元素均为零，则该图拓扑序列存在，但可能不唯一。\n对角线以下的元素均为零，表明只有从顶点i到顶点j(i&lt;j)可能有边，而从顶点j到顶点i一定无边，即有向图是一个无环图，因此一定存在拓扑序列。\n对于拓扑序列是否唯一，举例：设有向图的邻接矩阵为\n\\begin{bmatrix}\n0 &amp; 1 &amp; 1\\\\\n0 &amp;  0&amp; 0\\\\\n0 &amp; 0 &amp;0\n\\end{bmatrix}\n\n则存在两个拓扑序列，因此该图存在可能不唯一的拓扑序列。\n\n\n邻接表法\n邻接表，是指对图G中的每个顶点 v 建立一个单链表，第i个单链表中的结点表示依附于顶点 v 的边（对于有向图则是以顶点 v_i 为尾的弧），这个单链表就称为顶点 v_i 的边表（对于有向图则称为出边表）。\n边表的头指针和顶点的数据信息采用顺序存储（称为顶点表），所以在邻接表中存在两种结点：顶点表结点和边表结点。\n\n#define MaxVertexNum 100\n \n// 边/弧\ntypedef struct ArcNode {\n    int adjvex;// 边/弧指向哪个结点\n    struct ArcNode *next;// 指向下一条弧的指针\n    // int info;// 可以储存边的权值\n} ArcNode;\n \n// 顶点\ntypedef struct VNode {\n    int data;/ / 顶点信息\n    ArcNode *first;// 第一条边/弧\n} VNode, AdjList[MaxVertexNum];\n \n// 用邻接表存储的图\ntypedef struct {\n    char Vex[MaxVertexNum]; // 顶点表\n    int Edge[MaxVertexNum][MaxVertexNum]; // 边的权\n    int vexnum, arcnum; // 图的当前顶点数和边数/弧数\n} ALGraph;\n\n邻接表的特点：\n\n\n\n若 G 为无向图，则所需的存储空间为O(|V|+2|E|)；\n若 G 为有向图，则所需的存储空间为O(|V|+|E|)；\n\n前者的倍数 2 是由于无向图中，每条边在邻接表中出现了两次。\n\n\n对于稀疏图，采用邻接表表示将极大地节省存储空间。\n\n\n在邻接表中，给定一顶点，能很容易地找出它的所有邻边，因为只需要读取它的邻接表。 在邻接矩阵中，相同的操作则需要扫描一行，花费的时间为O(n)。\n\n\n要确定给定的两个顶点间是否存在边，在邻接矩阵中可以立刻查到，而在邻接表中则需要在相应结点对应的边表中查找另一结点，效率较低。\n\n\n在有向图的邻接表表示中， 求一个给定顶点的出度只需计算其邻接表中的结点个数；但求其顶点的入度则需要遍历全部的邻接表。\n\n\n图的邻接表表示并不唯一，因为在每个顶点对应的单链表中，各边结点的链接次序可以是任意的，它取决于建立邻接表的算法及边的输入次序。\n\n\n\n\n十字链表\n\n\n                  \n                  Tip\n                  \n                \n\n只适用于存储有向图\n\n\n十字链表是有向图的一种链式存储结构。在十字链表中，对应于有向图中的每条弧有一个结点，对应于每个顶点也有一个结点。\n\n空间复杂度：O(|V|+|E|)\n\n找到指定顶点的所有出边：顺着绿色线路找\n找到指定顶点的所有入边：顺着橙色线路找\n\n邻接多重表\n\n\n                  \n                  Tip\n                  \n                \n\n只适用于存储无向图。\n\n\n在邻接表中，容易求得顶点和边的各种信息，但在邻接表中求两个顶点之间是否存在边而对边执行删除等操作时，需要分别在两个顶点的边表中遍历，效率较低。\n邻接多重表是无向图的另一种链式存储结构。\n\n空间复杂度：O(|V|+|E|)\n和十字链表相比较，\n\n四种存储方式的区别\n\n图的遍历\n图的遍历是指从图中的某一顶点出发，按照某种搜索方法沿着图中的边对图中的所有顶点访问一次且仅访问一次。\n树是一种特殊的图，所以树的遍历实际上也可视为一种特殊的图的遍历。\n图的遍历算法是求解图的连通性问题、拓扑排序和求关键路径等算法的基础。\n广度优先遍历(BFS)\n\n6.31图的广度优先遍历\n\n\nBreadth-First-Search，BFS\n\n\n定义\n类似于二叉树的层序遍历算法。\n基本思想是：首先访问起始顶点 v，接着由 v 出发，依次访问 v 的各个未访问过的邻接顶点w_1,w_2,\\cdots,w_i，然后依次访问w_1,w_2,\\cdots,w_i的所有未被访问过的邻接顶点；再从这些访问过的顶点出发，访问它们所有未被访问过的邻接顶点，直至图中所有顶点都被访问过为止。若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作为始点，重复上述过程，直至图中所有顶点都被访问到为止。\n同一个图的邻接矩阵存储表示是唯一的，因此广度优先遍历序列唯一。\n\n同一个图的邻接表存储表示不唯一，因此广度优先遍历序列不唯一。\n\n\n实现\n要点：\n\n找到与一个顶点相邻的所有顶点\n标记哪些顶点被访问过\n需要一个辅助队列\n\n#define MaxVertexNum 100\n \nbool visited[MaxVertexNum];// 访问标记数组，初始值为false\n \nvoid BFS(Graph G, int v) {// 从顶点v出发，广度优先遍历图G\n  visit(v); //访问初始顶点v\n  visited[v] = true; // 标记为已访问\n  Enqueue(Q, v); // 顶点v入队列Q\n  while (!isEmpty(Q)) {\n    DeQueue(Q, v);// 顶点v出列\n    for (int w = FirstNeighbor(G, v); w &gt;= 0; w = NextNeighbor(G, v, w)) {\n      // 检测v所有邻接点\n      if (!visited[w]) {// w为v尚未访问的邻接顶点\n        visit(w);// 访问顶点w\n        visited[w] = true;\n        EnQueue(Q, w);// 顶点w入队列\n      }\n    }\n  }\n}\n如果是非连通图，只执行一次遍历是无法遍历完所有结点的\n\n如需解决这个问题，只需遍历一遍访问标记数组，找到仍为 false 的顶点，继续执行 BFS 就行\n#define MaxVertexNum 100\n \nbool visited[MaxVertexNum];// 访问标记数组，初始值为false\n \nvoid BFS(Graph G, int v) {// 从顶点v出发，广度优先遍历图G\n  visit(v); //访问初始顶点v\n  visited[v] = true; // 标记为已访问\n  Enqueue(Q, v); // 顶点v入队列Q\n  while (!isEmpty(Q)) {\n    DeQueue(Q, v);// 顶点v出列\n    for (int w = FirstNeighbor(G, v); w &gt;= 0; w = NextNeighbor(G, v, w)) {\n      // 检测v所有邻接点\n      if (!visited[w]) {// w为v尚未访问的邻接顶点\n        visit(w);// 访问顶点w\n        visited[w] = true;\n        EnQueue(Q, w);// 顶点w入队列\n      }\n    }\n  }\n}\n \nvoid BFSTraverse(Graph G) {// 对图G进行广度优先遍历\n  for (int i = 0; i &lt; G.vexnum; i++) {\n    visited[i] = false;// 访问标记数组初始化\n  }\n  InitQueue(Q);// 初始化辅助队列Q\n  for (int i = 1; i &lt; G.vexnum; i++) {// 遍历\n    if (!visited[i]) {\n      BFS(G, i);// i结点未访问过，从i开始执行BFS\n    }\n  }\n}\n复杂度\n\n\n空间复杂度\n无论是邻接表还是邻接矩阵的存储方式，BFS 算法都需要借助一个辅助队列 Q。最坏的情况是n个顶点均需入队一次，空间复杂度为O(n) 。\n\n\n\n时间复杂度\n\n\n邻接矩阵：\n访问|V|个顶点需要O(|V|)的时间；查找每个顶点的邻接点都需要O(|V|)的时间，总共有|V|个顶点；\n时间复杂度 = O(|V|^2)\n\n\n邻接表：\n访问|V|个顶点需要O(|V|)的时间；查找每个顶点的邻接点都需要O(|E|)的时间；\n时间复杂度 = O(|V|+ |E|)\n\n\n\n\n\n广度优先生成树和生成森林\n广度优先生成树由广度遍历的过程确定的。\n同一个图的邻接矩阵存储表示是唯一的，故其广度优先生成树也是唯一的，但由于邻接表存储表示不唯一，故其广度优先生成树也是不唯一的。\n\n\n对非连通图或者只执行一次 BFS 无法遍历全部结点的图进行广度优先遍历，可得到广度优先生成森林。\n\n深度优先遍历(DFS)\n\n6.32图的深度优先遍历\n\n\nDepth-First-Search，DFS\n\n\n定义\n类似于树的先序遍历。\n基本思想如下：首先访问图中某一起始顶点v，然后由v出发，访问与v邻接且未被访问的任意一个顶点w_1，再访问与w_1邻接且未被访问的任意一个顶点w_2，重复上述过程。当不能再继续向下访问时，依次退回到最近被访问的顶点，若它还有邻接顶点未被访问过，则从该点开始继续上述搜索过程，直至图中所有顶点均被访问过为止。\n\n图的邻接矩阵表示是唯一的，但对于邻接表来说，若边的输入次序不同，生成的邻接表也不同。因此，对于同样一个图，基于邻接矩阵的遍历所得到的 DFS 序列和 BFS 序列是唯一的，基于邻接表的遍历所得到的 DFS 序列和 BFS 序列是不唯一的。\n实现\n#define MaxVertexNum 100\n \nbool visited[MaxVertexNum];// 访问标记数组，初始值为false\n \nvoid DFS(Graph G, int v) {// 从顶点v出发，深度优先遍历图G\n  visit(v); //访问初始顶点v\n  visited[v] = true; // 标记为已访问\n  for (int w = FirstNeighbor(G, v); w &gt;= 0; w = NextNeighbor(G, v, w)) {\n    if (!visited[w]) {// w为v尚未访问的邻接顶点\n      DFS(G, w);\n    }\n  }\n}\n与广度优先遍历一样，如果是非连通图，只执行一次遍历是无法遍历完所有结点的\n#define MaxVertexNum 100\n \nbool visited[MaxVertexNum];// 访问标记数组，初始值为false\n \nvoid DFS(Graph G, int v) {// 从顶点v出发，深度优先遍历图G\n  visit(v); //访问初始顶点v\n  visited[v] = true; // 标记为已访问\n  for (int w = FirstNeighbor(G, v); w &gt;= 0; w = NextNeighbor(G, v, w)) {\n    if (!visited[w]) {// w为v尚未访问的邻接顶点\n      DFS(G, w);\n    }\n  }\n}\n \nvoid DFSTraverse(Graph G) {// 对图G进行深度优先遍历\n  for (int i = 0; i &lt; G.vexnum; i++) {\n    visited[i] = false;// 访问标记数组初始化\n  }\n  for (int i = 0; i &lt; G.vexnum; i++) {\n    if (!visited[i]) {\n      DFS(G, i);\n    }\n  }\n}\n复杂度\n\n\n空间复杂度\n\n\n\n时间复杂度\n时间复杂度 = 访问各结点所需的时间 + 探索各边所需的时间\n\n\n邻接矩阵：\n访问|V|个顶点需要O(|V|)的时间；查找每个顶点的邻接点都需要O(|V|)的时间，总共有|V|个顶点；\n时间复杂度 = O(|V|^2)\n\n\n邻接表：\n访问|V|个顶点需要O(|V|)的时间；查找每个顶点的邻接点都需要O(|E|)的时间；\n时间复杂度 = O(|V|+ |E|)\n\n\n\n时间复杂度与广度优先遍历序列的时间复杂度一样\n\n\n\n深度优先的生成树和生成森林\n与广度优先搜索一样，深度优先搜索也会产生一棵深度优先生成树。\n与广度优先遍历类似，对只执行一次 DFS 无法遍历全部结点的图进行深度优先搜索，那生成的就是深度优先生成森林。相关内容可查看图的连通性。\n\n\n                  \n                  Tip\n                  \n                \n\n\n同一个图的邻接矩阵表示方式唯一，因此深度优先遍历序列唯一，深度优先生成树也唯一\n同一个图的邻接表表示方式不唯一，因此深度优先遍历序列不唯一，深度优先生成树也不唯一\n\n\n\n遍历可视化\n\n图的连通性\n\n\n对于无向图进行 BFS/DFS 遍历，调用 BFS/DFS 函数的次数 = 连通分量数。\n\n若该无向图是连通图，只需调用 1 次BFS/DFS。\n\n\n\n对于有向图进行 BFS/DFS 遍历，调用 BFS/DFS 函数的次数需要具体分析\n\n\n若起始顶点到其它各顶点都有路径，则只需调用 1 次 BFS/DFS；\n\n\n如图，若从 7 顶点开始遍历，遍历一次就可以遍历完全部结点；若从 2 结点开始遍历就需要遍历多次。\n\n\n\n若该有向图是强连通图，从任一节点出发只需调用 1 次 BFS/DFS；\n\n\n\n\n\n最小生成树（最小代价树）\n\n6.41最小生成树\n\n定义\n对于一个带权连通无向图 G = (V, E)，生成树不同，每棵树的权（即树中所有边上的权值之和）也可能不同。设 R 为 G 的所有生成树的集合，若 T 为 R 中边的权值之和最小的那棵生成树，则 T 称为 G 的最小生成树(Minimum-Spanning-Tree, MST)。\n性质\n\n当图 G 中的各边权值互不相等时，G 的最小生成树是唯一的。\n若无向连通图 G 的边数比顶点数少 1，即 G 本身是一棵树时，则 G 的最小生成树就是它本身。\n最小生成树可能有多个，但边的权值之和总是唯一且最小的；\n最小生成树的边数 = 顶点数 - 1。\n\n\n\n                  \n                  Tip\n                  \n                \n\n在带权图 G 的最小生成树 G_1 中，某条边的权值可能会超过未选边的权值。\n最小生成树中的 n-1 条边并不能保证是图中权值最小的 1 条边，因为权值最小的 n-1 条边并不一定能使图连通。在下图中，左图的最小生成树如下图所示，权值为 3 的边并不在其最小生成树中。\n\n\n\n构造最小生成树\n构造最小生成树有多种算法，但大多数算法都利用了最小生成树的下列性质：假设 G = (V, E) 是一个带权连通无向图，U 是顶点集 V 的一个非空子集。若 (u,v) 是一条具有最小权值的边，其中 u\\in U,v\\in V-U，则必存在一棵包含边 (u,v) 的最小生成树。\n基于该性质的最小生成树算法主要有 Prim 算法和 Kruskal 算法，它们都基于贪心算法的策略。\nPrim 算法\n从某一顶点开始构建生成树；每次将代价最小的新顶点纳入生成树，知道所有顶点都纳入为止。\nPrim算法的时间复杂度为 O(|V|^2)，不依赖于|E|，因此，适合边稠密图。\n\nKruskal 算法\n每次选择一条权值最小的边，使这条边的两头连通（如果原本已经连通就跳过）；直到所有结点都连通。\n时间复杂度：O(|E|\\log_2|E|)，适合边稀疏图。\n在Kruskal 算法中，最坏情况需要对IE条边各扫描一次。通常采用堆来存放边的集合，每次选择最小权值的边需要O(\\log_2|E|) 的时间；每次使用并查集来快速判断两个顶点是否属于一个集合所需的时间为 O(\\alpha(|V|))，\\alpha(|V|)的增长极其缓慢，可视为常数。算法的总时间复杂度为 O(|E|\\log_2|E|)，不依赖于|V|，因此 Kruskal 算法适合于边稀疏而顶点较多的图。\n\n算法可视化\n\n最短路径\n\n\nBFS 算法求解单源最短路径问题\n\n\n                  \n                  Tip\n                  \n                \n\nBFS 算法求解单源最短路径只适用于无权图，或所有边权值都相同的图。\n\n\n若图G=(V,E)为非带权图，定义从顶点u到顶点v的最短路径d(u, v)为从u到v的任何路径中最少的边数；若从u到v没有通路，则d(u,v)=\\infty。\n使用 BFS 求解一个满足上述定义的非带权图的单源最短路径问题，这是由广度优先搜索总是按照距离由近到远来遍历图中每个顶点的性质决定的。\nvoid BFS_MIN_Distance(Graph G, int u) {\n  int d[G.vexnum]; //d[i]表呆从u到i结点的最短路径\n  int path[G.vexnum]; // 最短路径从哪个顶点过来\n  for (int i = 0; i &lt; G.vexnum; ++i) {\n    d[i] = INT_MAX; // 初始化路径长度\n    path[G.vexnum] = -1;\n  }\n  visited[u] = true;\n  d[u] = 0;\n  Enqueue(Q, u); // 顶点v入队列Q\n  while (!isEmpty(Q)) {\n    DeQueue(Q, u);\n    for (int w = FirstNeighbor(G, u); w &gt;= 0; w = NextNeighbor(G, u, w)) {\n      if (!visited[w]) {// w为v尚未访问的邻接顶点\n        visited[w] = true;\n        d[w] = d[u] + 1;// 路径长度加1\n        path[w] = u; // 最短路径应从u到w\n        EnQueue(Q, w);// 顶点w入队列\n      }\n    }\n  }\n}\n\nDijkstra 算法求单源最短路径问题\n\n6.43最短路径问题_Dijkstra 算法\n【算法】最短路径查找—Dijkstra 算法\n\n\n\n                  \n                  Tip\n                  \n                \n\nDijkstra 算法不适用于带有负权值的带权图。\n\n\n\nDijkstra 算法设置一个集合 S 记录己求得的最短路径的顶点，初始时把源点 v_0 放入 S，集合 S 每并入一个新顶点 v_i，都要修改源点 V_0 到集合 V-S 中顶点当前的最短路径长度。Dijkstra 算法也是基于贪心策略。\n\n\ndist[]：记录从源点 v_0 到其他各顶点当前的最短路径长度，它的初态为：若从 v_0 到 v_i 有弧，则dist[i]为弧上的权值；否则置为 \\infty。\n\n\npath[]：path[i]表示从源点到顶点 i 之间的最短路径的前驱结点。在算法结束时，可根据其值追溯得到源点 v_0 到顶点 v_i 的最短路径。\n\n\n时间复杂度：使用邻接矩阵表示时，时间复杂度为 O(|V|^2)。使用带权的邻接表表示时，虽然修改dist[]的时间可以减少，但由于在dist[]中选择最小分量的时间不变，时间复杂度仍为 O(|V|^2)。\n\n\n\n\n\n\n\n#include &lt;climits&gt;\n \n// 从顶点v出发的最短路径\nvoid Dijkstra(Graph G, int v) {\n  // 标记各顶点是否为已找到的最短路径\n  bool final[G.vexnum];\n  // 最短路径长度\n  int dist[G.vexnum];\n  // 路径上的前驱\n  int path[G.vexnum];\n  // 辅助数组初始化\n  for (int i = 0; i &lt; G.vexnum; i++) {\n    final[i] = false;\n    dist[i] = INT_MAX;\n    path[i] = -1;\n  }\n  // 初始化顶点v，将该出发点加入到最短路径，出发点到出发点的最短距离为0\n  final[v] = true;\n  dist[v] = 0;\n  // 更新顶点v的邻接顶点的dist和path信息\n  for (int w = FirstNeighbor(G, v); w &gt;= 0; w = NextNeighbor(G, v, w)) {\n    int edgeVal = Get_edge_value(G, v, w);\n    dist[w] = edgeVal;\n    path[w] = v;\n  }\n  // 主循环，由于出发结点v的final已经修改为true，因此执行G.vexnum - 1次即可\n  for (int i = 0; i &lt; G.vexnum - 1; i++) {\n    // 寻找距离出发点最小的结点，即dist值最小的结点\n    int minNodeDist = INT_MAX, minNodeIndex = -1;\n    for (int j = 0; j &lt; G.vexnum; j++) {\n      if (!final[j] &amp;&amp; dist[j] &lt; minNodeDist) {\n        minNodeIndex = j;\n        minNodeDist = dist[j];\n      }\n    }\n    // 将该结点标记为最短路径\n    final[minNodeIndex] = true;\n    // 遍历该结点的邻接结点，更新邻接结点的dist和path值\n    for (int w = FirstNeighbor(G, minNodeIndex); w &gt;= 0; w = NextNeighbor(G, minNodeIndex, w)) {\n      // 计算从出发点到w的dist值\n      int newDist = Get_edge_value(G, minNodeIndex, w) + dist[minNodeIndex];\n      // 如果该新dist值小于w原来的dist值，则证明新的路径更加短\n      if (newDist &lt; dist[w]) {\n        dist[w] = newDist;\n        path[w] = minNodeIndex;\n      }\n    }\n  }\n}\nFloyd 算法求各顶点之间最短路径问题\n\n6.44最短路径问题_Floyd 算法\n\n如果要求出每一对顶点之间的最短路径，我们可以每次以一个顶点为源点，重复执行 Dijkstra 算法 n 次。时间复杂度为O(n^3)。但相比于 Floyd 算法会更麻烦。\n\nFloyd 算法的基本思想是：递推产生一个 n 阶方阵序列 A^{(-1)},A^{(0)},\\cdots,A^{(k)},A^{(n-1)}，其中 A^{(k)}[i][j] 表示从顶点v_i到顶点v_j的路径长度，k 表示绕行第 k 个顶点的运算步骤。初始时，对于任意两个 顶点v_i和v_j，若它们之间存在边，则以此边上的权值作为它们之间的最短路径长度；若它们之间不存在有向边，则以 \\infty 作为它们之间的最短路径长度。以后逐步尝试在原路径中加入顶点 k(k=0,1,\\cdots,n-1) 作为中间顶点。若增加中间顶点后，得到的路径比原来的路径长度减少了，则以此新路径代替原路径。\nFloyd 算法的时间复杂度为O(|V|^3)。不过由于其代码很紧凑，且并不包含其他复杂的数据结构，因此隐含的常数系数是很小的，即使对于中等规模的输入来说，它仍然是相当有效的。\nFloyd 算法的空间复杂度为O(|V|^2)。\nFloyd 算法允许图中有带负权值的边，但不允许有包含带负权值的边组成的回路。\n\n定义一个n阶方阵序列A^{(-1)},A^{(0)},\\cdots,A^{(k)},A^{(n-1)}，其中\nA^{(-1)}[i][j] = arcs[i][j]\\\\\n\nA^{(k)}[i][j]=Min\\{ A^{(k-1)}[i][j],A^{(k-1)}[i][k]+A^{(k-1)}[k][j] \\} ,k(k=0,1,\\cdots,n-1)\n\n\nA^{(1)}[i][j]是从顶点v_i到v_j的中间顶点的序号不大于 1 的最短路径的长度；\nA^{(k)}[i][j]是从顶点v_i到v_j的中间顶点的序号不大于 k 的最短路径的长度；\nA^{(n-1)}[i][j]是从顶点v_i到v_j的最短路径的长度；\n\n\nA^{(-1)}的矩阵就是图的邻接矩阵表示。\n此时加入顶点v_0，将顶点v_i到v_j的距离与v_i到v_0+v_0到v_j的距离和相比较，修改A矩阵。此时A矩阵的A[i][j]的值就是v_i到v_j的最短路径。\n此时加入顶点v_1。注意现在的A[i][j]的值不管是否经过v_0都是最短路径，但这只是包含v_0情况下的最短路径，现在新加入了v_1则需要重新计算。将顶点v_i到v_j的距离与v_i到v_1+v_1到v_j的距离和相比较，修改A矩阵。此时A矩阵的A[i][j]的值就是v_i到v_j的最短路径。\n加入顶点v_2，……\n重复加入顶点。\n\n\n\n\n\n\n若图的顶点不止 3 个，求路径如下：\n\n// 以 Vk 做为中转点\n  for (int k = 0; k &lt; n; k++) {\n    // 遍历整个矩阵，i为行号，j为列号\n    for (int i = 0; i &lt; n; i++) {\n      for (int j = 0; j &lt; n; j++) {\n        // 以Vk为中转点的路径更短\n        if (A[i][j] &gt; A[i][k] + A[k][j]) {\n          // 更新最短路径长度\n          A[i][j] = A[i][k] + A[k][j];\n          // 更新中转点\n          path[i][j] = k;\n        }\n      }\n    }\n  }\n有向无环图\n有向无环图：若一个有向图中不存在环，则称为有向无环图，简称 DAG 图。\n\n有向无环图是描述含有公共子式的表达式的有效工具。\n例如表达式：((a+b)*(b*(c+d))+(c+d)*e)*((c+d)*e)\n删除重复出现的子树，只保留一颗。这样可以节省存储空间。\n\n\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n有向无环图的拓扑序列唯一并不能唯一确定该图。\n在下图所示的两个有向无环图中，拓扑序列都为 V_1,V_2,V_3,V_4。\n\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n\n6.45有向无环图描述表达式\n\n\n\n\n\n\n用有向无环图描述表达式(x + y)((x + y)/x)，需要的顶点个数至少是 5。\n\n\n拓扑排序\n\nA0V 网（Activity On Vertex Network，用顶点表示的网）：若用 DAG 图表示一个工程，其顶点表示活动，用有向边&lt;v_i,v_j&gt;表示活动v_i必须优先于活动v_j进行的这样一种关系，则将这种有向图称为顶点表示活动的网络，记为 A0V 网。\n\n拓扑排序：在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序：\n\n每个顶点出现且只出现一次。\n若顶点 A 在序列中排在顶点 B 的前面，则在图中不存在从顶点 B 到顶点 A 的路径。\n\n每个 AOV 网都有一个或多个拓扑排序序列。\n\n拓扑排序的实现：\n\n从 AOV 网中选择一个没有前驱的顶点并输出。\n从网中删除该顶点和所有以它为起点的有向边。\n重复 ① 和 ② 直到当前的 AOV 网为空或当前网中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环。\n\n时间复杂度：\n\n采用邻接表存储：O(|V|+|E|)\n采用邻接矩阵存储：O(|V|^2)\n\n\n对一个 AOV 网，如果采用下列步骤进行排序，则称之为逆拓扑排序:\n\n从 AOV 网中选择一个没有后继（出度为 0）的顶点并输出；\n从网中删除该顶点和所有以它为终点的有向边；\n重复 ① 和 ② 直到当前的 AOV 网为空；\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n若有向图的拓扑有序序列唯一，则图中每个顶点的入度和出度最多为 1。（❌）\n下图的拓扑序列也是唯一的，但度却不满足条件。\n\n\n\n关键路径\n\n在带权有向图中，以顶点表示事件，以有向边表示活动，以边上的权值表示完成该活动的开销（如完成活动所需的时间），称之为用边表示活动的网络，简称 AOE 网(Activity On Edge NetWork)。\n在 AOE 网中，有些活动是可以并行进行的。从源点到汇点的有向路径可能有多条，并且这些路径长度可能不同。完成不同路径上的活动所需的时间虽然不同，但是只有所有路径上的活动都己完成，整个工程才能算结束。\n\n\n\n                  \n                  Tip\n                  \n                \n\nAOE 网和 AOV 网都是有向无环图，不同之处在于它们的边和顶点所代表的含义是不同的，AOE 网中的边有权值；而 AOV 网中的边无权值，仅表示顶点之间的前后关系。\n\n\nAOE 网具有以下两个性质：\n\n只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始；\n只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生。\n\n\n在 AOE 网中\n\n仅有一个入度为 0 的顶点，称为开始顶点（源点），它表示整个工程的开始；\n仅有一个出度为 0 的顶点，称为结束顶点（汇点），它表示整个工程的结束；\n\n从源点到汇点的所有路径中\n\n关键路径：具有最大路径长度的路径\n关键活动：关键路径上的活动\n\n完成整个工程的最短时间就是关键路径的长度，即关键路径上各活动花费开销的总和。因为关键活动影响了整个工程的时间。若关键活动不能按时完成，则整个工程的完成时间就会延长。若关键活动的时间减少，则整个工程的完成时间就会缩短。当缩短到一定程度时，关键活动可能会变成非关键活动。\n\n\n事件v_k的最早发生时间ve(k)：指从源点v_1到顶点处的最长路径长度。\n\n\n\n活动a_i的最早开始时间e(i)：指该活动弧的起点所表示的事件的最早发生时间。\n\n\n\n事件v_k的最迟发生时间vl(k)：指在不推迟整个工程完成的前提下，即保证它的后继事件v_j在其最迟发生时间vl(k)能够发生时，该事件最迟必须发生的时间。\n\n\n\n活动a_i的最迟开始时间l(i)：指该活动弧的终点所表示事件的最迟发生时间与该活动所需时间之差。\n\n\n\n活动的时间余量d(i)：指该活动在不增加完成整个工程所需总时间的情况下，活动a_i可以拖延的时间。活动a_i的最迟开始时间l(i)和其最早开始时间e(i)的差额d(i)=l(i)-e(i)\n\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n求关键路径可以判断出一个有向图是否有环。\n关键路径本身虽然不允许有环，但求关键路径的算法本身无法判断是否有环, 判断是否有环是求关键路径的第一步一一拓扑排序。\n\n\n\n下图是一个有 10 个活动的 AOE 网，时间余量最大的活动是\n\n活动的时间余量=结束顶点的最迟开始时间-开始顶点的最早开始时间-该活动的持续时间。\n\n\nc 的时间余量=vl(3)-ve(2)-l =5-2-1 =2\ng 的时间余量=vl(6)-ve(3)-1 = 12-5-1 =6\nh 的时间余量=vl(5)-ve(4)-l = 11-8-1 =2\nj 的时间余量=vl(6)-ve(5)- 1 = 12-9-1 =2\n\n时间余量最大的活动是 g。\n"},"计算机基础/数据结构和算法/8_查找":{"title":"查找","links":[],"tags":["数据结构和算法"],"content":"查找的基本概念\n\n\n查找\n在数据集合中寻找满足某种条件的数据元素的过程称为查找。查找的结果一般分为两种：查找成功、查找失败。\n\n\n查找表(查找结构)\n用于查找的数据集合称为查找表，它由同一类型的数据元素（或记录）组成，可以是一个数组或链表等数据类型。\n对查找表经常进行的操作一般有 4 种：\n\n查询某个特定的数据元素是否在查找表中：\n检索满足条件的某个特定的数据元素的各种属性；\n在查找表中插入一个数据元素；\n从查找表中删除某个数据元素；\n\n\n\n静态查找表\n若一个查找表无须动态地修改元素， 则此类查找表称为静态查找表。适合静态查找表的查找方法有顺序查找、折半查找、散列查找等；\n\n\n动态查找表\n若一个查找表需要动态地插入或删除元素，则此类查找表称为动态查找表。适合动态查找表 的查找方法有二叉排序树的查找、散列查找等。\n\n\n关键字\n数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。\n\n\n平均查找长度\n在查找过程中，一次查找的长度是指需要比较的关键字的次数称为查找长度，而平均查找长度则是所有查找过程中进行关键字的比较次数的平均值，其数学定义为\nASL =\\sum^{n}_{i=1}P_iC_i\n\n式中，n 是查找表的长度；P_i是查找第 i 个数据元素的概率，一般认为每个数据元素的查找概率相等，即P_i=1/n；C_i是找到第 i 个数据元素所需进行的比较次数。平均查找长度是衡量查找算法效率的最主要的指标。\n\n\n顺序查找\n\n顺序查找\n\n\n顺序查找又称线性查找，通常用于线性表，它对顺序表和链表都是适用的。\n\n对于顺序表，可通过数组下标递增来顺序扫描每个元素；\n对于链表，可通过指针 next 来依次扫描每个元素；\n\n顺序查找通常分为对一般的无序线性表的顺序查找和对按关键字有序的线性表的顺序查找。\n\n\n一般线性表的顺序查找\ntypedef struct {// 查找表的数据结构，顺序表\n    int *elem;// 动态数组基址\n    int TableLen;// 表的长度\n} SSTable;\n// 第一种\nint Search_Seq1(SSTable ST, int key) {\n  int i；\n  for (i = 0; i &lt; ST.TableLen &amp;&amp; ST.elem[i] != key; i++);\n  return i == ST.TableLen ? -1 : i;\n}\n// 第二种\nint Search_Seq2(SSTable ST, int key) {\n  ST.elem[0] = key; // 哨兵\n  int i；\n  for (i = ST.TableLen; ST.elem[i] != key; i--);\n  return i;// 若表中不存在关键字为key的元素，将查找到i为0时退出for循环\n}\n查找成功的平均查找长度ASL=\\frac{n+1}{2}；\n查找失败的平均查找长度ASL=n+1；\n\n\n有序表的顺序查找\n若在查找之前就已经知道表是关键字有序的，则查找失败时可以不用再比较到表的另一端就能返回查找失败的信息，从而降低顺序查找失败的平均查找长度。\n查找成功的平均查找长度ASL=\\frac{n+1}{2}；\n查找失败的平均查找长度ASL=\\frac{n}{2}+\\frac{n}{n+1}；\n\n\n\n折半查找\n\n折半查找又称二分查找，它仅适用于有序的顺序表。\n基本思想：首先将给定值 key 与表中中间位置的元素比较，若相等，则查找成功，返回该元素的存储位置；若不等，则所需查找的元素只能在中间元素以外的前半部分或后半部分。 然后在缩小的范围内继续进行同样的查找，如此重复，直到找到为止，或确定表中没有所需要查找的元素，则查找不成功，返回查找失败的信息。\ntypedef struct {// 查找表的数据结构，顺序表\n    int *elem;// 动态数组基址\n    int TableLen;// 表的长度\n} SSTable;\n \nint Binary_Search(SSTable L, int key) {\n  int low = 0, high = L.TableLen - 1, mid;\n  while (low &lt;= high) {\n    mid = (low + high) / 2; //取中间位置\n    if (L.elem[mid] == key) {\n      return mid; //查找成功则返回所在位置\n    } else if (L.elem[mid] &gt; key) {\n      high = mid - 1;//从前半部分继续查找\n    } else {\n      low = mid + 1; //从后半部分继续查找\n    }\n  }\n  return -1; //查找失败，返回T\n}\n判定树：树中每个圆形结点表示一个记录，结点中的值为该记录的关键字值；树中最下面的叶结点都是方形的，它表示查找不成功的情况。\n\n折半查找判定树是一棵二叉排序树，其中序序列是一个有序序列。\n\n若有序序列有 n 个元素，则对应的判定树有 n 个圆形的非叶结点和 n+1 个方形的叶结点。\n\n折半查找的判定树一定是一棵平衡二叉树。\n折半查找的判定树中，只有最下面一层是不满的，因此元素个数为 n 时，树高 h=\\left \\lceil \\log_2{(n+1)} \\right \\rceil。\n折半查找在查找不成功时和给定值进行关键字比较次数最多就是树的高度即 \\left \\lceil \\log_2{(n+1)} \\right \\rceil。\n折半查找的的时间复杂度为O(\\log_2n)\n\n\n                  \n                  Tip\n                  \n                \n\n\n\n若是求查找成功或查找失败的平均查找长度，则需要画出判定树进行求解。\n\n\n对长度为 n 的有序表，采用折半查找时，查找成功和查找失败的最多比较次数相同，均为\\left \\lceil \\log_2{(n+1)} \\right \\rceil\n\n\n\n\n分块查找\n\n分块查找又称索引顺序查找，它吸取了顺序查找和折半查找各自的优点，既有动态结构，又适于快速查找。\n分块查找的基本思想：将查找表分为若干子块。块内的元素可以无序，但块间的元素是有序的，即第一个块中的最大关键字小于第二个块中的所有记录的关键字，第二个块中的最大关键字小于第三个块中的所有记录的关键字，以此类推。再建立一个索引表，索引表中的每个元素含有各块的最大关键字和各块中的第一个元素的地址，索引表按关键字有序排列。\n\n分块查找的过程分为两步：\n\n在索引表中确定待查记录所在的块，可以顺序查找或折半查找索引表；\n在块内顺序查找。\n\n设索引查找和块内查找的平均查找长度分别为L_I，L_S，则分块查找的平均查找长度为ASL=L_I+L_S\n\n\n\n用顺序查找查索引表\n则L_I=(1+2+ \\cdots +b)/b=\\frac{b+1}{2}，L_S=(1+2+ \\cdots +s)/s=\\frac{s+1}{2}，则ASL=\\frac{b+1}{2}+\\frac{s+1}{2}=\\frac{s^2+2s+n}{2s}。当s=\\sqrt{ n}时，ASL 最小，为\\sqrt{n}+1。\n\n\n用折半查找查索引表\n则L_I=\\left \\lceil  {\\log_2{(b+1)}} \\right \\rceil，L_S=(1+2+ \\cdots +s)/s=\\frac{s+1}{2}，则ASL=\\left \\lceil  {\\log_2{(b+1)}} \\right \\rceil+\\frac{s+1}{2}\n\n\n二叉排序树(BST)\n\n\n\n                  \n                  Tip\n                  \n                \n\n构造一棵二叉排序树的目的并不是为了排序，而是为了提高查找、插入和删除关键字的速度，二叉排序树这种非线性结构也有利于插入和删除的实现。\n\n\n定义\n二叉排序树（也称二叉查找树）(BST，Binary Search Tree)是一棵空树，或者是具有下列特性的二叉树：\n\n左子树结点值&lt;根结点值&lt;右子树结点值\n左、右子树分别是一棵二叉排序树。\n\n对二叉排序树进行中序遍历，可以得到一个递增的有序序列。\ntypedef struct BSTNode {\n    int key;\n    struct BSTNode *lChild, *rChild;\n} BSTNode, *BSTree;\n查找\n若二叉排序树非空，先将给定值与根结点的关键字比较，若相如果小于根结点的关键字，则在根结点的左子树上查找，否则在根结点的右子树上查找。\n\n\n非递归实现\n最坏空间复杂度：O(1)\nBSTNode *BST_Search(BSTree T, int key) {\n  while (T != nullptr &amp;&amp; key != T-&gt;key) {\n    T = key &lt; T-&gt;key ? T-&gt;lChild : T-&gt;rChild;\n  }\n  return T;\n}\n\n\n递归实现\n最坏空间复杂度：O(h)，h 为递归树的深度\nBSTNode *BST_Search(BSTree T, int key) {\n  if (T == nullptr)return nullptr;\n  if (key == T-&gt;key) {\n    return T;\n  } else if (key &lt; T-&gt;key) {\n    return BST_Search(T-&gt;lChild, key);\n  } else {\n    return BST_Search(T-&gt;rChild, key);\n  }\n}\n\n\n插入\n若原二叉排序树为空，则直接插入；否则，若关键字 k 小于根结点值，则插入到左子树，若关键字 k 大于根结点值，则插入到右子树。\n\n\n递归实现\n最坏空间复杂度：O(h)，h 为递归树的深度\nint BST_Insert(BSTree &amp;T, int key) {\n  if (T == nullptr) {\n    T = new BSTNode();\n    T-&gt;key = key;\n    T-&gt;lChild = T-&gt;rChild = nullptr;\n    return 1;\n  } else if (key == T-&gt;key) {\n    return 0;\n  } else if (key &lt; T-&gt;key) {\n    return BST_Insert(T-&gt;lChild, key);\n  } else {\n    return BST_Insert(T-&gt;rChild, key);\n  }\n}\n\n\n插入的结点一定是一个新添加的叶结点，且是查找失败时的查找路径上访问的最后一个结点的左孩子或右孩子。\n构造\n不同的关键字序列可能得到同样的二叉排序树，也可能得到不同样的二叉排序树。\nvoid Creat_BST(BSTree &amp;T, int str[], int n) {\n  T = nullptr;\n  for (int i = 0; i &lt; n; i++) {\n    BST_Insert(T, str[i]);\n  }\n}\n删除\n在二叉排序树中删除一个结点时，不能把以该结点为根的子树上的结点都删除，必须先把被删除结点从存储二叉排序树的链表上摘下，将因删除结点而断开的二叉链表重新链接起来，同时确保二叉排序树的性质不会丢失。\n\n若被删除结点 z 是叶结点，则直接删除，不会破坏二叉排序树的性质。\n若结点 z 只有一棵左子树或右子树，则让 z 的子树成为 z 父结点的子树，替代 z 的位置。\n若结点 z 有左、右两棵子树，则令 z 的直接后继（或直接前驱）替代 z，然后从二叉排序树中删去这个直接后继（或直接前驱），这样就转换成了第一或第二种情况。\n\n\n\n\n查我效率分析\n二叉排序树的查找效率，主要取决于树的高度。\n\n\n平衡二叉树(AVL)\n\n定义\n为了避免树的高度增长过快，降低二叉排序树的性能，规定在插入和删除结点时，要保证任意结点的左、右子树高度差的绝对值不超过 1，将这样的二叉树称为平衡二叉树(Balanced Binary Tree)，或称 AVL 树。\n结点左子树减去右子树的高度的值为该结点的平衡因子，则平衡二叉树结点的平衡因子的值只可能是-1、0 或 1。\n插入\n每当在二叉排序树中插入（或删除）一个结点时，首先检查其插入路径上的结点是否因为此次操作而导致了不平衡。若导致了不平衡，则先找到插入路径上离插入结点最近的平衡因子的绝对值大于 1 的结点 A 再对以 A 为根的子树，在保持二叉排序树特性的前提下，调整各结点的位置关系，使之重新达到平衡。\n\n插入位置可查看二叉排序树的插入\n\n每次调整的对象都是最小不平衡子树，即以插入路径上离插入结点最近的平衡因子的绝对值大于 1 的结点作为根的子树。\n\n\n                  \n                  Tip\n                  \n                \n\n在插入操作中，只需将最小不平衡二叉树调整平衡，则其它祖先节点都会恢复平衡。因为插入操作会导致“最小不平衡子树”高度+1，经过调整后高度恢复。\n\n\n\n\n\nLL 平衡旋转(右单旋转)\n由于在结点 A 的左孩子(L)的左子树(L)上插入了新结点，A 的平衡因子由 1 增至 2，导致以 A 为根的子树失去平衡，需要一次向右的旋转操作。\n将 A 的左孩子B 向右上旋转代替 A 成为根结点，将 A 结点向右下旋转成为 B 的右子树的根结点，而 B 的原右子树则作为 A 结点的左子树。\n\n\n\n\n\n\nRR 平衡旋转（左单旋转）\n由于在结点 A 的右孩子(R)的右子树(R)上插入了新结点，S 的平衡因子由-1 减至-2，导致以 A 为根的子树失去平衡，需要一次向左的旋转操作。\n将 A 的右孩子B 向左上旋转代替 A 成为根结点，将 A 结点向左下旋转成为 B 的左子树的根结点，而 B 的原左子树则作为 A 结点的右子树。\n\n\n\n\n\n\nLR 平衡旋转（先左后右双旋转）\n由于在 A 的左孩子(L)的右子树(R)上插入新结点， A 的平衡因子由 1 增至 2，导致以 A 为根的子树失去平衡，需要进行两次旋转操作，先左旋转后右旋转。\n先将 A 结点的左孩子 B 的右子树的根结点 C 向左上旋转提升到 B 结点的位置，然后把该 C 结点向右上旋转提升到 A 结点的位置。\n\n\n\n若插入结点在 C 的右子树上\n\n\n\n\n若插入结点在 C 的左子树上，处理方式与右子树一样\n\n\n\n\n\n\nRL 平衡旋转（先右后左双旋转）\n由于在 A 的右孩子(R)的左子树(L)上插入新结点， A 的平衡因子由-1 减至-2，导致以 A 为根的子树失去平衡，需要进行两次旋转操作，先右旋转后左旋转。\n先将 A 结点的右孩子 B 的左子树的根结点 C 向右上旋转提升到 B 结点的位置，然后把该 C 结点向左上旋转提升到 A 结点的位置\n\n\n\n\n查找\n在平衡二叉树上进行查找的过程与二叉排序树的相同。因此，在查找过程中，与给定值进行比较的关键字个数不超过树的深度。\n平衡二叉树的平均查找长度为O(\\log_2n)\n删除\n与平衡二叉树的插入操作类似，以删除结点 w 为例来说明平衡二叉树删除操作的步骤：\n\n\n用二叉排序树的方法对结点 W 执行删除操作。\n\n\n若导致了不平衡，则从结点 w 开始向上回溯，找到第一个不平衡的结点 z （即最小不平 衡子树）；y 为结点 z 的高度最高的孩子结点；x 是结点 y 的高度最高的孩子结点。\n\n\n然后对以 z 为根的子树进行平衡调整，其中 x、y 和 z 可能的位置有 4 种情况：\n\ny 是 z 的左孩子，x 是 y 的左孩子（LL，右单旋转）\ny 是 z 的左孩子，x 是 y 的右孩子（LR，先左后右双旋转）\ny 是 z 的右孩子，x 是 y 的右孩子（RR，左单旋转）\ny 是 z 的右孩子，x 是 y 的左孩子（RL，先右后左双旋转）\n\n这四种情况与插入操作的调整方式一样。不同之处在于，插入操作仅需要对以 z 为根的子树进行平衡调整；而删除操作就不一样，先对以 z 为根的子树进行平衡调整，如果调整后子树的高度减 1，则可能需要对 z 的祖先结点进行平衡调整，甚至回溯到根结点（导致树高减 1）。\n\n\n红黑树(RBT)\n\n平衡二叉树 AVL，插入和删除操作很容易破坏平衡特性，需要频繁地调整树的形态。为此在 AVL 树的平衡标准 上进一步放宽条件，引入了红黑树的结构。\n红黑树 RBT，插入和删除操作很多时候不会破坏红黑树的特性，无需频繁地调整树的形态、即使需要调整，一般可以在常数级时间内完成。\n\n\n                  \n                  总结 \n                  \n                \n\n平衡二叉树：适用于以查为主，很少插入和删除的场景；\n红黑树：适用于频繁插入和删除的场景，实用性更强；\n\n\n定义和性质\n\n红黑树是二叉排序树。\n红黑树满足如下红黑性质：\n\n每个结点或是红色，或是黑色的。\n根结点是黑色的。\n叶结点（虚构的外部结点、NULL 结点）都是黑色的。\n不存在两个相邻的红结点（即红结点的父结点和孩子结点均是黑色的）。\n对每个结点，从该结点到任意一个叶结点的简单路径上，所含黑结点的数量相同。\n\n\nstruct RBNode {\n    int key;\n    RBNode *parent;\n    RBNode *lChild;\n    RBNode *rChild;\n    int color; // 结点颜色，可用0/1 表示黑红\n};\n结点的黑高bh：从某结点出发（不含该结点）到达一个叶结点的任意一个简单路径上的黑结点总数。\n黑高的概念是由性质 5 确定的。根结点的黑高称为红黑树的黑高。\n\n\n\n                  \n                  Tip\n                  \n                \n\n\n\n结论 1：从根到叶结点的最长路径不大于最短路径的 2 倍。\n当从根到任意一个叶结点的简单路径最短时，这条路径必然全由黑结点构成。当某条路径最长时，这条路径必然是由黑结点和红结点相间构成的，此时红结点和黑结点的数量相同。\n\n\n结论 2 ：若根节点黑高为 h，内部结点数（关键字）最少有2^h-1个。\n\n\n\n\n\n查找\n查找的过程与二叉排序树和平衡二叉树相同。\n\n\n                  \n                  Tip\n                  \n                \n\n结论 3 ：有 n 个内部结点的红黑树的高度h\\le 2 \\log_2{(n+1)}。\n从根到叶结点（不含叶结点）的任何一条简单路径上都至少有一半是黑结点，因此，根的黑高至少为h/2，于是有n\\geqslant 2^{h/2}-1。\n可得红黑树查找操作的时间复杂度=O(\\log_2n)\n\n\n插入\n红黑树的插入过程和二叉查找树的插入过程基本类似，不同之处在于，在红黑树中插入新结 点后需要进行调整（主要通过重新着色或旋转操作进行），以满足红黑树的性质。\n\n\n                  \n                  Tip\n                  \n                \n\n结论：新插入红黑树中的结点初始着为红色\n假设新插入的结点初始着为黑色，那么这个结点所在的路径比其他路径多出一个黑结点，调整起来也比较麻烦。如果插入的结点是红色的，此时所有路径上的黑结点数量不变，仅在出现连续两个红结点时才需要调整，而且这种调整也比较简单。\n\n\n\n案列：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n删除\n红黑树的插入操作容易导致连续的两个红结点，破坏性质 4。而删除操作容易造成子树黑高 的变化（删除黑结点会导致根结点到叶结点间的黑结点数量减少），破坏性质 5。\n\n红黑树删除操作的时间复杂度为O(\\log_2n)。\n红黑树中删除结点的处理方式与二叉排序树的删除一样。但红黑树中删除结点后可能破坏“红黑树特性”，此时需要调整结点颜色、位置。\n\nB 树\n\n7.4_1_B 树\n\n\n定义\nB 树，又称多路平衡查找树，B 树中所有结点的孩子个数的最大值称为 B 树的阶，通常用 m 表示。所谓 m 阶 B 树是所有结点的平衡因子均等于 0 的 m 路平衡查找树。\n\n一棵 m 阶 B 树可能是空树，也可能是满足如下特性的 m 叉树：\n\n\n树中每个结点至多有 m 棵子树，即至多含有 m-1 个关键字。\n\n\n若根结点不是终端结点，则至少有两棵子树。\n\n\n除根结点外的所有非叶结点至少有\\left \\lceil m/2 \\right \\rceil棵子树，即至少含有\\left \\lceil m/2 \\right \\rceil -1个关键字。\n\n\n所有的叶结点都出现在同一层次上，并且不带信息（可以视为外部结点或类似于折半查找判定树的查找失败结点，实际上这些结点不存在，指向这些结点的指针为空）。\n\n\n所有非叶结点的结构如下：\n\n\nK_i(i=1,2,\\cdots,n)为结点的关键字，且满足 K_1&lt;K_2&lt;\\cdots&lt;K_n；\nP_i(i=0,1,\\cdots,n)为指向子树根节点的指针，且指针**P_i-1所指子树中所有结点的关键字均小于K_i，P_i所指子树中所有结点的关键字均大于K_i**；\nn （\\left \\lceil m/2 \\right \\rceil \\leqslant n \\leqslant m-1）为结点中关键字的个数；\n\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n当整棵树只有 1 个元素时，根节点只有两个分叉，所以根结点不用保证至少有\\left \\lceil m/2 \\right \\rceil棵子树。\n\n\n\n高度\n一般情况下，B 树的高度不包括最后的叶结点（失败节点）。\n若n\\geqslant1，则对任意一棵包含n个关键字、高度为h、阶数为m的 B 树：\n\n\n最小高度：h\\geqslant \\log_m(n+1)\n让每个结点尽可能的满，则n \\leqslant (m-1)(1+m+m^2+m^3+\\cdots+m^{h-1})=m^h-1，因此h\\geqslant \\log_m(n+1)。\n\n\n最大高度：h \\leqslant (\\log_{\\left \\lceil m/2 \\right \\rceil}{\\frac{n+1}{2}})+1\n让各层的分叉尽可能少，即根节点只有 2 个分叉，其它结点只有\\left \\lceil m/2 \\right \\rceil个分叉。因此第一层 1 个结点；第二层至少有 2 个结点；第三层至少有2\\left \\lceil m/2 \\right \\rceil个结点；第h层至少有2(\\left \\lceil m/2 \\right \\rceil)^{h-2}个结点。第h+1层至少有2(\\left \\lceil m/2 \\right \\rceil)^{h-1}个叶子结点（失败结点）。\n因为n 个关键字的 B 树必有 n+1 个叶子结点，则 n+1\\geqslant2(\\left \\lceil m/2 \\right \\rceil)^{h-1}，得h \\leqslant (\\log_{\\left \\lceil m/2 \\right \\rceil}{\\frac{n+1}{2}})+1。\n\n\n\n\n                  \n                  n 个关键字的 B 树必有 n+1 个叶子结点 \n                  \n                \n\n原理跟前面折半查找的“n 个圆形的非叶结点有 n+1 个方形的叶结点”一样，都是用关键字切割(-\\infty,+\\infty)然后得到各个区间，这个区间就是失败结点。\n\n\n\n插入\n将关键字 key 插入 B 树的过程如下：\n\n\n定位：找出插入该关键字的最底层中的某个非叶结点（在 B 树中查找 key 时，会找到表示查找失败的叶结点，这样就确定了最底层非叶结点的插入位置）。\n\n\n插入：在 B 树中，每个非失败结点的关键字个数都在区间内。插入后的结点关键字个数小于 m，可以直接插入；插入后检查被插入结点内关键字的个数，当插入后的结点关键字个数大于 m-1 时，必须对结点进行分裂。\n\n\n分裂：取一个新结点，在插入 key 后的原结点，从中间位置（\\left \\lceil m/2 \\right \\rceil）将其中的关键字分为两部分，左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中，中间位置（\\left \\lceil m/2 \\right \\rceil）的结点插入原结点的父结点。若此时导致其父结点的关键字个数也超过了上限，则继续进行这种分裂操作，直至这个过程传到根结点为止，进而导致 B 树高度增 1。\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n插入位置一定是“终端结点”\n\n\n以 5 阶 B 树为例，该树的结点关键字个数2 \\leqslant n\\leqslant 4。\n\n\n插入 80\n\n\n\n插入 90\n\n\n\n插入 99\n\n\n\n插入 88\n\n\n\n插入 83，87\n\n\n\n插入 70\n\n\n\n插入 92，93，94\n\n\n\n插入 73，74，75\n\n\n\n删除\n删除操作一定会导致叶节点的变化。\n\n\n若被删关键字不在终端结点中时，可以用直接前驱或直接后继来替代被删除的关键字。\n\n直接前驱：当前关键字左侧指针所指子树中“最右下”的关键字。\n例如下图中 80 的直接前驱就是 77，因此删除 80 只需用 77 顶替 80 即可，顶替后要记得删去终端结点的 77。\n\n\n\n直接后继：当前关键字右侧指针所指子树中“最左下”的关键字。\n例如下图中 77 的直接后继就是 82。\n\n\n对非终端结点关键字的删除，必然可以转化成对终端结点的删除操作。\n\n\n若被删除关键字在终端结点：\n\n\n直接删除该关键字\n若被删关键字所在结点的关键字个数\\geqslant \\left \\lceil m/2 \\right \\rceil，则可以直接删去该关键字。\n\n\n\n兄弟够借\n若被删关键字所在结点删除前的关键字个数=\\left \\lceil m/2 \\right \\rceil-1，且与该结点相邻的右兄弟结点或左兄弟结点的关键字个数\\geqslant \\left \\lceil m/2 \\right \\rceil，则需要调整该结点的兄弟结点或左兄弟结点及其双亲结点（父子换位法），以达到新的平衡。\n换句话说，当右兄弟很宽裕时，用当前结点的后继、后继的后继来填补空缺；当左兄弟很宽裕时，用当前结点的前驱、前驱的前驱来填补空缺；\n\n\n\n\n兄弟不够借\n若被删关键字所在结点删除前的关键字个数=\\left \\lceil m/2 \\right \\rceil-1，且此时与该结点相邻的左、右兄弟结点的关键字个数均=\\left \\lceil m/2 \\right \\rceil-1，则将关键字删除后与左（或右）兄弟结点及双亲结点中的关键字进行合并。\n在合并过程中，双亲结点中的关键字个数会减 1。若其双亲结点是根结点且关键字个数减少至 0，则直接将根结点删除，合并后的新结点成为根；若双亲结点不是根结点，且关键字个数减少到\\left \\lceil m/2 \\right \\rceil-2，则又要与它自己的兄弟结点进行调整或合并操作。\n\n假设要删除 49\n\n\n\n右兄弟不够借，只能合并。\n\n\n\n由于 73 所处的结点不满足 B 树的性质，继续合并。\n\n\n\n根节点变空了，直接删除根节点。\n\n\n\n\n\n\nB+树\nB+ 树是应文件系统所需而产生的 B 树的变形，B+ 树更加适用于实际应用中操作系统的文件索引和数据库索引，因为 B+ 树的磁盘读写代价更低，查询效率更稳定。\n一棵 m 阶的 B+树需满足下列条件：\n\n\n每个分支结点最多有 m 棵子树（孩子结点）；\n\n\n非叶根结点至少有两棵子树，其他每个分支结点至少有\\left \\lceil m/2 \\right \\rceil棵子树；\n\n\n\n结点的子树个数与关键字个数相等；\n\n\n所有叶结点包含全部关键字及指向相应记录的指针，叶结点中将关键字按大小顺序排列， 并且相邻叶结点按大小顺序相互链接起来（因此支持顺序查找）；\n\n\n所有分支结点中仅包含它的各个子结点中关键字的最大值及指向其子结点的指针；\n\n\n\n\nm 阶的 B+树与 m 阶的 B 树的区别：\n\n\n\n在 B+树中，具有 n 个关键字的结点只含有 n 棵子树；\n在 B 树中，具有 n 个关键字的结点含有 n+1 棵子树；\n\n\n\n\n在 B+树中，根结点关键字个数1\\leqslant n \\leqslant m，其它结点的关键字个数\\left \\lceil m/2 \\right \\rceil \\leqslant n \\leqslant m；\n在 B 树中，根结点关键字个数1\\leqslant n \\leqslant m-1，其它结点的关键字个数\\left \\lceil m/2 \\right \\rceil-1\\leqslant n \\leqslant m-1；\n\n\n\n\n在 B+树中，叶结点包含全部关键字，非叶结点中出现的关键字也会出现在叶结点中；\n在 B 树中，各结点包含的关键字是不重复的；\n\n\n\n\n在 B+树中，叶结点包含信息，所有非叶结点仅起索引作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。\n在 B 树中，结点都包含了关键字对应记录地址的存储地址；\n\n\n\n\n\n\n                  \n                  Tip\n                  \n                \n\nB+树是应数据库所需而出现的一种 B 树的变形树。\n在 B+树中，非叶结点不含有该关键字对应记录的存储地址，可以使一个磁盘块能够包含更多个关键字，使 B+树的阶更大，树更矮，读磁盘次数更少，查找更快。\n\n\n\n散列查找（哈希查找）\n\n散列表的基本概念\n\n\n散列表（Hash Table）：又称哈希表，是一种数据结构。特点是关键字与其存储地址直接相关。\n\n\n散列函数：把查找表中的关键字映射成该关键字对应的地址的函数，记为 Hash(key)=Addr。\n散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为冲突，这些发生碰撞的不同关键字称为同义词。如下图所示，\n\n\n冲突总是不可避免的。\n\n\n\n理想情况下，对散列表进行查找的时间复杂度为O(1)，即与表中元素的个数无关。\n散列函数的构造方法\n\n散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围。\n散列函数计算出来的地址应该能等概率、均匀地分布在整个地址空间中，从而减少冲突的发生。\n散列函数应尽量简单，能够在较短的时间内计算出任意一个关键字对应的散列地址。\n\n\n散列函数设计目标：尽量降低不同关键字产生冲突的可能性。\n\n\n\n直接定址法\n直接取关键字的某个线性函数值为散列地址，散列函数为H(key)= key或H(key)= a\\times key + b。式中，a 和 b 是常数。\n这种方法不会产生冲突，它适合关键字的分布基本连续的情况。若关键字分布不连续，空位较多，则会造成存储空间的浪费。\n\n\n\n除留余数法\n假定散列表表长为 m，取一个不大于 m 但最接近或等于 m 的质数 p，利用以下公式把关键字转换成散列地址。散列函数为H(key)= key\\%p\n除留余数法的关键是选好 p，使得每个关键字通过该函数转换后等概率地映射到散列空间上的任意一个地址，从而尽可能减少冲突的可能性。\n\n\n\n                  \n                  质数 \n                  \n                \n\n质数又称素数，一个大于 1 的自然数，除了 1 和它自身外，不能被其他自然数整除的数；\n\n\n\n\n数字分析法\n设关键字是 r 进制数（如十进制数），r 个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀一些，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常出现，此时应选取数码分布较为均匀的若干位作为散列地址。\n这种方法适合于已知的关键字集合，若更换了关键字，则需要重新构造新的散列函数。\n\n\n\n平方取中法\n取关键字的平方值的中间几位作为散列地址。\n具体取多少位要视实际情况而定。这种方法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布比较均匀， 适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数。\n\n\n\n查找\n散列表的查找过程与构造散列表的过程基本一致。\n对于一个给定的关键字 key，根据散列函数计算出其散列地址。检测查找表中相应地址位置上是否有记录，若无记录，返回查找失败；若有记录，与 key 值进行比较，相等则返回查找成功标志，不相等则返回查找失败。\n对同一组关键字，即使使用相同的散列函数，则不同的处理冲突的方法得到的散列表不同，它们的平均查找长度也不同。\n散列表的查找效率的度量仍以平均查找长度作为衡量。因为散列表在关键字与记录的存储位置之间建立了直接映像，但由于”冲突”的产生，使得散列表的查找过程仍然是一个给定值和关键字进行比较的过程。\n散列表的查找效率取决于三个因素：散列函数、处理冲突的方法、装填因子。\n\n\n                  \n                  装填因子 \n                  \n                \n\n散列表的装填因子一般记为\\alpha，定义为一个表的装满程度，\\alpha =  表中记录数n / 散列表长度m\n散列表的平均查找长度依赖于散列表的装填因子\\alpha，而不直接依赖于n或m。\n\\alpha越大，表示装填的记录越“满”，发生冲突的可能性越大，反之发生冲突的可能性越小。\n\n\n处理冲突的方法\n开放定址法\n开放定址法，是指可存放新表项的空闲地址既向它的同义词表项开放，又向它的非同义词表项开放。其数学递推公式为\nH_i=(H(key)+d_i)\\%m\n\ni为第i次发生冲突，i=0,1,2,\\cdots,k(k\\leqslant m-1)；m表示散列表表长；d_i为增量序列；\n\n\n                  \n                  Tip\n                  \n                \n\n如果遇到空位置还没有查找到元素，就可以确定查找失败了。\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n删除结点不能简单地将被删结点的空间置为空，否则将截断在它之后填入散列表的同义词结点的查找路径。我们可以将被删结点添加一个标记，在逻辑上进行删除。\n计算查找失败的平均查找长度时，遇到删除节点应该继续往后查找。\n\n\n如何确定增量序列：\n\n\n线性探测法\nd_i=0,1,2,3,\\cdots,m-1。冲突发生时，顺序查看表中下一个单元，直到找出一个空闲单元（当表未填满时一定能找到一个空闲单元）或查遍全表。\n\n\n\n由于 H(key) 的取值为 0~13，所有查找失败时可能 对应的地址有 13 个。\n\n对于地址为 0 的关键字，需要比较 1 次即可确定该关键字不在哈希表中，因为该地址没有元素（若该地址有元素则需要比较到地址 13，即比较 14 次才能确定）。\n对于地址为 1 的关键字，需要从地址 1 比较到地址 13，即需要比较 13 次才能确定该关键字不在哈希表中（若地址 13，14 有元素，则需要比较到地址 15 才能确定不在哈希表中，即比较 15 次）。\n其他元素同理。\n\n\n线性探测法容易造成大量元素在相邻的散列地址上“聚集”（或堆积）起来，大大降低了查找效率。\n\n\n平方探测法\nd_i=0^2,1^2,-1^2,2^2,-2^2,\\cdots,k^2,-k^2时，称为平方探测法，又称二次探测法，其中k\\leqslant m/2，散列表长度 m 必须是一个可以表示成4k+3的素数。\n平方探测法比线性探测法更不易出现”堆积”问题，但它的缺点是不能探测到散列表上的所有单元，但至少能探测到一半单元。\n\n\n\n伪随机序列法\n当d_i伪随机数序列时，称为伪随机序列法。\n\n\n再散列法\n\n又称再哈希法\n\n当第一个散列函数H(key)得到的地址发生冲突时，则利用下一个散列函数计算该关键字的新地址，直到不冲突为止。此时，\nH_i=RH_i(key)\n\n这种方法不易产生“聚集”，但增加了计算的时间。\n拉链法\n\n又称链接法、链地址法。\n\n对于不同的关键字可能会通过散列函数映射到同一地址，为了避免非同义词发生冲突，可以把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识。\n\n\n由上图可知，冲突越多，查找效率越低。\n"},"计算机基础/数据结构和算法/9_排序":{"title":"排序","links":[],"tags":["数据结构和算法"],"content":"排序动画\n\n排序的基本概念\n\n排序，就是重新排列表中的元素，使表中的元素满足按关键字有序的过程。\n排序的确切定义如下：\n输入：n个记录R_1,R_2,\\cdots,R_n，对应的关键字为k_1,k_2,\\cdots,k_n。\n输出：输入序列的一个重排R_1^{&#039;},R_2^{&#039;},\\cdots,R_n^{&#039;}，使得k_1^{&#039;}\\leqslant k_2^{&#039;}\\leqslant \\cdots,k_n^{&#039;}（其中\\leqslant可以换成其他的比较大小的符号）。\n\n算法的稳定性：若待排序表中有两个元素R_i和R_j，其对应的关键字相同即key_i= key_j，且在排序前R_i在R_j的前面，若使用某一排序算法排序后，R_i仍然在R_j的前面，则称这个排序算法是稳定的，否则称排序算法是不稳定的。\n\n\n\n                  \n                  Tip\n                  \n                \n\n算法的稳定性与算法优劣无关。稳定的排序算法不一定比不稳定的好，取决于实际需求。\n\n\n根据数据元素是否完全在内存中，可将排序算法分为两类：\n\n内部排序：在排序期间元素全部存放在内存中的排序；\n外部排序：在排序期间元素无法全部同时存放在内存中，必须在排序的过程中根据要求不断地在内、外存之间移动的排序。\n\n\n\n                  \n                  Tip\n                  \n                \n\n大多数的内部排序算法只适用于顺序存储的线性表。\n\n\n插入排序\n\n直接插入排序\n空间复杂度：O(1)\n平均时间复杂度：O(n^2)\n直接插入排序算法是稳定的。\n// 直接插入排序\nvoid InsertSort(int A[], int n) {\n  for (int i = 1; i &lt; n; i++) {\n    if (A[i] &lt; A[i - 1]) {\n      int temp = A[i];\n      int j;\n      for (j = i - 1; j &gt;= 0 &amp;&amp; A[j] &gt; temp; j--) {\n        A[j + 1] = A[j];\n      }\n      A[j + 1] = temp;\n    }\n  }\n}\n// 直接插入排序（带哨兵）\nvoid InsertSort(int A[], int n) {\n  for (int i = 2; i &lt; n; i++) {\n    if (A[i] &lt; A[i - 1]) {\n      A[0] = A[i];\n      int j;\n      for (j = i - 1; A[0] &lt; A[j]; j--) {\n        A[j + 1] = A[j];\n      }\n      A[j + 1] = A[0];\n    }\n  }\n}\n折半插入排序\n先用折半查找找到插入的位置，再移动元素。\n因为改进的只是比较的次数，而移动次数未发生变化，所以折半插入排序的时间复杂度仍为O(n^2)。\nvoid InsertSort(int A[], int n) {\n  int low, high, mid;\n  for (int i = 2; i &lt;= n; i++) {\n    A[0] = A[i];\n    low = 1;\n    high = i - 1;\n    while (low &lt;= high) {\n      mid = (low + high) / 2;\n      if (A[mid] &gt; A[0]) {\n        high = mid - 1;\n      } else {\n        low = mid + 1;\n      }\n    }\n    for (int j = i - 1; j &gt;= high + 1; j--) {\n      A[j + 1] = A[j];\n    }\n    A[high + 1] = A[0];\n  }\n}\n希尔排序\n\n\n又称缩小增量排序\n\n思想：先将待排序表分割成若干形如L[i, i + d,i + 2d,\\cdots,i + kd]的“特殊” 子表，对各个子表分别进行直接插入排序，当整个表中的元素已呈“基本有序”时，再对全体记录进行一次直接插入排序。\n\n空间复杂度：0(1)。\n时间复杂度：和增量序列d有关，无法用数学手段证明确切的时间复杂度，最坏时间复杂度O(n^2)，当 n 在某个范围内时，可达O(n^{1.3})\n\n希尔排序算法仅适用顺序表，不适用于链表。\n\n\n\n\n\nvoid a(int A[], int n) {\n  int d, i, j;\n  // A[0]只是暂存单元，不是哨兵，当就&lt;=0时，插入位置已到\n  for (d = n / 2; d &gt;= 1; d = d / 2) {\n    for (i = d + 1; i &lt; n; i++) {\n      // 需要将A[i]插入有序增量子表\n      if (A[i] &lt; A[i - d]) {\n        // 暂存在A[0]\n        A[0] = A[i];\n        for (j = i - d; j &gt; 0 &amp;&amp; A[0] &lt; A[j]; j -= d) {\n          A[j + d] = A[j];\n        }\n        A[j + d] = A[0]\n      }\n    }\n  }\n}\nvoid ShellSort(int num[], int length) {\n  // 设置增量gap\n  for (int gap = length / 2; gap &gt; 0; gap /= 2) {\n    // 根据增量划分子序列\n    for (int i = gap; i &lt; length; i++) {\n      // 对子序列进行插入排序\n      int insertVal = num[i];\n      int insertIndex = i - gap;\n      while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; num[insertIndex]) {\n        num[insertIndex + gap] = num[insertIndex];\n        insertIndex -= gap;\n      }\n      num[insertIndex + gap] = insertVal;\n    }\n  }\n}\n\n\n\n\n对有 n 个元素的顺序表采用直接插入排序算法进行排序，在最坏情况下所需的比较次数 是(D)；在最好情况下所需的比较次数是(A)。\nA. n - 1 B. n + 1 C. n/2 D. n(n-1)/2\n\n\n待排序表为反序时，直接插入排序需要进行 n(n-1)/2 次比较\n待排序表为正序时，只需进行 n-1 次比较\n\n\n\n\n对 5 个不同的数据元素进行直接插入排序，最多需要进行的比较次数是(B)。\nA. 8 B. 10 C. 15 D. 25\n\n直接插入排序在最坏的情况下要做 n(n-1)/2 次关键字的比较\n\n\n\n在待排序的元素序列基本有序的前提下，效率最高的排序方法是(A)。\nA. 直接插入排序 B. 简单选择排序 C. 快速排序 D. 归并排序\n\n由于这里的序列基本有序，使用直接插入排序算法的时间复杂度接近O(n)，而使用其他算法 的时间复杂度均大于O(n)\n\n\n\n数据序列｛ 8, 10 , 13 , 4 , 6 , 7 , 22 , 2 , 3 ｝只能是(C)两趟排序后的结果。\nA. 简单选择排序 B. 起泡排序 C. 直接插入排序 D. 堆排序\n\n冒泡排序和选择排序经过两趟排序后，应该有两个最大（或最小）元素放在其最终位置；插入排序经过两趟排序后，前 3 个元素应该是局部有序的。只有可能是插入排序。\n\n\n\n                  \n                  Tip\n                  \n                \n\n在排序过程中，每趟都能确定一个元素在其最终位置的有冒泡排序、简单选择排序、堆排序、快速排序，其中前三者能形成全局有序的子序列，后者能确定枢轴元素的最终位置。\n\n\n\n\n若数据元素序列｛ 11 , 12 , 13 , 7 , 8 , 9 , 23 , 4 , 5 ｝是采用下列排序方法之一得到的第二趟排序后的结果，则该排序算法只能是(B)。\nA. 冒泡排序 B. 插入排序 C. 选择排序 D. 2 路归并排序\n\n\n每趟冒泡和选择排序后，总会有一个元素被放置在最终位置上。显然，这里｛11 , 12｝和｛4 , 5｝所处的位置并不是最终位置，因此不可能是冒泡和选择排序。\n2 路归并算法经过第二趟后应该是 每 4 个元素有序的，但｛11,12,13,7｝并非有序，因此也不可能是 2 路归并排序。\n\n\n\n\n有些排序算法在每趟排序过程中，都会有一个元素被放置到其最终位置上，(A)算法不会出现此种情况。\nA. 希尔排序 B. 堆排序 C. 冒泡排序 D. 快速排序\n\n由于希尔排序是基于插入排序算法而提出的，它不一定在每趟排序过程后将某一元素放置到最终位置上。\n\n\n\n在下列算法中，(C)算法可能出现下列情况：在最后一趟开始之前，所有元素都不在最终位置上。\nA. 堆排序 B. 冒泡排序 C. 直接插入排序 D. 快速排序\n\n在直接插入排序中，若待排序列中的最后一个元素应插入表中的第一个位置，则前面的有序子序列中的所有元素都不在最终位置上。\n\n\n\n折半插入排序算法的时间复杂度为(C)。\nA. O(n) B. O(n\\log _2n) C. O(n^2) D. O(n^3)\n\n虽然折半插入排序是对直接插入排序的改进，但它改进的只是比较的次数，而移动次数未发生变化，时间复杂度仍为O(n^2)。\n\n\n\n以下排序算法中， 稳定的是(C)。\nA. 快速排序 B. 堆排序 C. 直接插入排序 D. 简单选择排序\n\n基于插入、交换、选择的三类排序方法中，通常简单方法是稳定的(直接插入、折半插入、 冒泡)，但有一个例外就是简单选择，复杂方法都是不稳定的(希尔、快排、堆排)。\n\n\n\n\n交换排序\n\n交换：根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置。\n冒泡排序\n\n空间复杂度：O(1)\n最好时间复杂度：O(n)\n最坏时间复杂度：O(n^2)\n快速排序\n\n在待排序表L[1...n]中任取一个元素 pivot 作为枢轴（或称基准，通常取首元素），通过一趟排序将待排序表划分为独立的两部分L[1...k-1]和L[k+1...n]，使得L [1...k-1]中的所有元素小于 pivot，L[k+1...n]中的所有元素大于或等于 pivot，则 pivot 放在了其最终位置L (k)，这个过程称为一次划分。然后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或空为止，即所有元素放在了其最终位置上。\nint Partition(int A[], int low, int high) {\n  int pivot = A[low];// 第一个元素做为枢轴\n  while (low &lt; high) {// 用low，high搜索枢轴的最终位置\n    while (low &lt; high &amp;&amp; A[high] &gt;= pivot)high--;\n    A[low] = A[high];// 比枢轴小的元素移动到左端\n    while (low &lt; high &amp;&amp; A[low] &lt;= pivot)low++;\n    A[high] = A[low];// 比枢轴大的元素移动到右端\n  }\n  A[low] = pivot;// 枢轴元素存放到最终位置\n  return low;// 返回存放枢轴的最终位置\n}\n \nvoid QuickSort(int A[], int low, int high) {\n  if (low &lt; high) {// 递归跳出条件\n    int pivot = Partition(A, low, high);// 划分\n    QuickSort(A, low, pivot - 1);// 划分左子表\n    QuickSort(A, pivot + 1, high);// 划分右子表\n  }\n}\n\n就平均性能而言，目前最好的内部排序方法是快速排序。\n\n\n快速排序算法在要排序的数据已基本有序情况下最不利于发挥其长处。\n\n当待排序数据为基本有序时，每次选取第 n 个元素为基准，会导致划分区间分配不均匀，不利于发挥快速排序算法的优势。\n当待排序数据分布较为随机时，基准元素能将序列划分为两个长度大致相等的序列，这时才能发挥快速排序的优势。\n\n\n性能分析：\n\n\n递归层数\n快速排序的时间空间效率都与递归层数有关。\n\n\n\n时间\n快速排序的运行时间与划分是否对称有关。\n快速排序的最坏情况发生在两个区域分别包含个元素和 0 个元素时（例如第一次选取的枢轴是这个数组中的最大值或最小值），这种最大限度的不对称性若发生在每层递归上，即对应于初始排序表基本有序或基本逆序时，就得到最坏时间复杂度O(n^2)。\n在最理想的状态下，即Partition()可能做到最平衡的划分，得到的两个子问题的大小都 不可能大 n/2，可以得到最好时间复杂度O(n\\log_2n)。平均时间复杂度O(n\\log_2n)\n\n\n\n                  \n                  优化思路 \n                  \n                \n\n尽量选取一个可以将数据中分的枢轴元素\n\n选取头中尾三个位置的元素，取中间值作为枢轴元素；\n随机选取一个元素做为枢轴元素\n\n\n\n\n\n空间\n由于快速排序是递归的，需要借助一个递归工作栈来保存每层递归调用的必要信息，其容量与递归调用的最大深度一致。\n最好空间复杂度为O(\\log_2n)；最坏情况下，因为要进行 n-1 次递归调用，所以栈的最坏空间复杂度为O(n)；平均情况下，栈的深度为O(\\log_2n)。\n\n\n递归次数与各元素的初始排列有关。若每次划分后分区比较平衡，则递归次数少；若分区不平衡，递归次数多。\n递归次数与处理顺序没有关系==。\n\n\n\n选择排序\n选择排序：每一趟在待排序元素中选取关键字最小（最大）的元素加入有序子序列\n简单选择排序\n\n思想：假设排序表为L[1\\cdots n]，第i趟排序即从L[i\\cdots n]中选择关键字最小的元素与L(i)交换，每一趟排序可以确定一个元素的最终位置，这样经过趟排序就可使得整个排序表有序。\nvoid swap(int &amp;a, int &amp;b) {\n  int t = a;\n  a = b;\n  b = t;\n}\n \nvoid SelectSort(int A[], int n) {\n  for (int i = 0; i &lt; n - 1; i++) {\n    int min = i;\n    for (int j = i + 1; j &lt; n; j++) {\n      if (A[j] &lt; A[min]) {\n        min = j;\n      }\n    }\n    if (min != i) {\n      swap(A[min], A[i]);\n    }\n  }\n}\n\n\n空间复杂度：O(1)：仅使用常数个辅助单元，故空间效率为O(1)。\n\n\n时间复杂度：O(n^2)：无论有序、逆序、乱序，都需要 n-1 趟处理。\n\n\n稳定性：不稳定。\n\n\n适用于顺序表和链表。\n\n\n                  \n                  Note\n                  \n                \n\n简单选择排序算法的比较次数和移动次数分别为 O(n^2)，O(n)。\n\n\n堆排序\n堆\n\nn 个关键字序列L[1\\cdots n]满足下面某一条性质，称为堆（Heap）。\n\n大根堆（大顶堆）：L(i)\\geqslant L(2i) 且 L(i)\\geqslant L(2i + 1) (1\\leqslant i\\leqslant n/2)\n小根堆（小顶堆）：L(i)\\leqslant L(2i) 且 L(i)\\leqslant L(2i+ 1) (1\\leqslant i\\leqslant n/2)\n\n\n可以将堆视为一棵完全二叉树。\n\n\n基本操作\n\n\n插入元素\n进行插入操作时，先将新结点放在堆的末端，再对这个新结点向上执行调整操作。\n\n插入一个新元素的时间复杂度为O(\\log _2n)。因为在向有 n 个元素的堆中插入一个新元素时，需要调用一个向上调整的算法，比较次数最多等于树的高度减 1，由于树的高度为\\left \\lfloor \\log _2n \\right \\rfloor+1，所以堆的向上调整算法的比较次数最多等于\\left \\lfloor \\log _2n \\right \\rfloor。\n\n例如将关键字 [6, 9, 1, 5, 8, 4, 7] 依次插入到初始为空的大根堆 H 中。\n\n\n\n例如已知序列 [25, 13, 10, 12, 9] 是大根堆，在序列尾部插入新元素 18，将其再调整为大根堆，调整过程中元素之间进行的比较次数是多少。\n\n\n\n\n删除元素\n被删除元素用堆底元素替代，然后让该元素不断下坠，直到无法下坠为止。\n\n\n建立堆\n首先将存放在L[1\\cdots n]中的 n 个元素建成大根堆，从后往前把所有非终端结点都检查一遍，查看是否满足大根堆的要求，如果不满足，则将当前结点与更大的结点进行互换。小根堆同理。\n\n例如有一组数据 [15, 9, 7, 8,20,-1,7, 4]，用堆排序的筛选方法建立的初始小根堆。\n\n\n\n\n堆排序\n\n堆排序思路：\n\n\n调整为大根堆\n\n\n输出堆顶元素：由于堆顶元素就是最大值，将堆顶元素加入有序子序列，通常是与待排序序列的最后一个元素交换。然后将待排序元素序列再次调整为大根堆。\n\n\n\n在顺序存储的 n 个结点的完全二叉树中，非终端结点的编号是i\\leqslant \\left \\lfloor n/2 \\right \\rfloor。\n\n时间复杂度为O(n\\log_2n)=O(n)+O(n\\log_2n)。其中建立初始堆的时间复杂度为O(n)；排序的时间复杂度为O(n\\log_2n)\n空间复杂度为O(1)\n堆排序是不稳定的。\n\n\n                  \n                  Tip\n                  \n                \n\n通常，取一大堆数据中的 n 个最大（最小）的元素时，都优先采用堆排序。\n例如只想得到 1000 个元素组成的序列中第 10 个最小元素之前的部分排序的序列，用堆排序)方法最快。\n\n\n归并排序\n\n归并：将两个或两个以上的有序表合并成一个新的有序表。\n\n// A[low...mid],A[mid...high]各自有序\nvoid Merge(int A[], int low, int mid, int high) {\n  int i, j, k;\n  int B[low + high + 1];// 辅助数组\n  for (k = low; k &lt;= high; k++) {\n    B[k] = A[k];// 将A中的元素复制到B中\n  }\n  for (i = low, j = mid + 1, k = i; i &lt; mid &amp;&amp; j &lt;= high; k++) {\n    // 将较小值复制到A中\n    A[k] = B[i] &lt;= B[j] ? B[i++] : B[j++];\n  }\n  while (i &lt;= mid)A[k++] = B[i++];\n  while (j &lt;= high)A[k++] = B[j++];\n}\n \nvoid MergeSort(int A[], int low, int high) {\n  if (low &lt; high) {\n    int mid = (low + high) / 2;\n    MergeSort(A, low, mid);\n    MergeSort(A, mid + 1, high);\n    Merge(A, low, mid, high);\n  }\n}\n// 归并排序\nvoid Merge(int num[], int l, int mid, int r) {\n  // 储存排序结果的辅助数组（也可以不使用辅助数组，直接在原数组进行排序，但更麻烦）\n  int res[l + r + 1], resIndex = 0;\n  // 排序\n  int lIndex = l, rIndex = mid + 1;\n  while (lIndex &lt;= mid &amp;&amp; rIndex &lt;= r) {\n    res[resIndex++] = num[lIndex] &lt; num[rIndex] ? num[lIndex++] : num[rIndex++];\n  }\n  while (lIndex &lt;= mid) {\n    res[resIndex++] = num[lIndex++];\n  }\n  while (rIndex &lt;= r) {\n    res[resIndex++] = num[rIndex++];\n  }\n  // 修改原数组\n  for (int i = l, j = 0; i &lt;= r &amp;&amp; j &lt; resIndex; i++, j++) {\n    num[i] = res[j];\n  }\n}\n \nvoid MergeSort(int num[], int l, int r) {\n  if (l &gt;= r) {\n    return;\n  } else {\n    int mid = (l + r) / 2;\n    MergeSort(num, l, mid);\n    MergeSort(num, mid + 1, r);\n    Merge(num, l, mid, r);\n  }\n}\n时间复杂度：O(n\\log_2n)\n空间复杂度：O(n)\n归并排序是稳定的。\n基数排序\n\n基数排序不基于比较和移动进行排序，而基于关键字各位的大小进行排序。\n假设长度为n的线性表中每个结点a_j的关键字由d元组（k^{d-1}_j,k^{d-2}_j,k^{d-3}_j,\\cdots ,k^{1}_j,k^{0}_j）组成。k^{d-1}_j称为最高位关键字（最主位关键字）；k^{0}_j称为最低位关键字（最次位关键字）；其中，0\\leqslant k_j^i\\leqslant r-1，（0\\leqslant j&lt;n,0\\leqslant i \\leqslant d - 1），r称为基数。\n为实现多关键字排序，通常有两种方法：\n\n最高位优先(MSD)法：按关键字位权重递减依次逐层划分成若干更小的子序列，最后将所有子序列依次连接成一个有序序列。\n最低位优先(LSD)法：按关键字位权重递增依次进行排序，最后形成一个有序序列。\n\n基数排序得到递减序列过程：\n\n初始化，设置r个空队列，Q_{r-1}，Q_{r-2},\\cdots,Q_0\n按照各个关键字位的权重的递增的次序（个、十、百…），对 d 个关键字分别进行“分配”和“收集”。\n\n分配：顺序扫描各个元素，若当前出来的关键字位=x，则将元素插入Q_x队尾；\n收集：把Q_{r-1}，Q_{r-2},\\cdots,Q_0各个队列的结点依次出队\n\n\n\n\n如果想要得到递增序列，只需在收集时按照Q_0,Q_{1}\\cdots,Q_{r-1}的顺序进行出队即可。\n\n\n\n\n\n\n空间复杂度\n需要r个辅助队列，所以空间复杂度为O(r)\n\n\n时间复杂度\n基数排序需要进行d趟分配和收集，一趟分配需要O(n)，一趟收集需要O(r)，所以基数排序的时间复杂度为O(d(n + r))，它与序列的初始状态无关。\n\n\n稳定性\n基数排序是稳定的\n\n\n基数排序擅长解决的问题：\n\n数据元素的关键字元素可以方便的拆分为 d 组，且 d 较小；（反例：给 5 个人的身份证号排序）\n每组关键字的取值范围不大，即 r 较小；（反例：给人名排序）\n数据元素个数 n 较大；（擅长：给十亿人的身份证号排序）\n\n应用示例\n\n\n\n\n在下列排序算法中，平均情况下空间复杂度为O(n)的是(D)；最坏情况下空间复杂度为O(n)的是(C)。\nI.希尔排序 II. 堆排序 III.冒泡排序 IV.归并排序 V. 快速排序 VI.基数排序\nA. I、IV、VI B. II、V C. IV、V D. IV\n\n归并排序算法在平均情况下和最坏情况下的空间复杂度都会达到O(n)，快速排序只在最坏情况下才会达到O(n)，平均情况下为O(\\log _2n)。\n\n\n\n2 路归并排序中，归并趟数的数量级是(B)。\nA. O(n) B. O(\\log _2n) C. O(n\\log _2n) D. O(n^2)\n\n对于 N 个元素进行 k 路归并排序时，排序的趟数 m 满足m=\\left \\lceil \\log _kN \\right \\rceil，所以，本题中即为\\left \\lceil \\log _2n \\right \\rceil。\n\n\n\n将两个各有 N 个元素的有序表合并成一个有序表，最少的比较次数是(A)，最多的比较次数是(B)。\nA. N B. 2N-1 C. 2N D. N-1\n\n注意到当一个表中的最小元素比另一个表中的最大元素还大时，比较的次数是最少的，仅比较 N 次；而当两个表中的元素依次间隔地比较时，即a_1&lt;b_1&lt;a_2&lt;b_2&lt;\\cdots时，比较的次数是最多的，为 2N-1 次。\n\n\n\n对给定的关键字序列 110, 119, 007, 911, 114, 120, 122 进行基数排序, 第 2 趟分配收集后得到的关键字序列是(C)。\nA. 007, 110, 119, 114, 911, 120, 122\nB. 007, 110, 119, 114, 911, 122, 120\nC. 007, 110, 911, 114, 119, 120, 122\nD. 110, 120, 911, 122, 114, 007, 119\n\n基数排序的第 1 趟排序是按照个位数字的大小来进行的，第 2 趟排序是按照十位数字的大小来进行的。\n\n\n\n\n\n内部排序算法的比较及应用\n\nx 为没有或者不需要关心\n\n\n外部排序\n\n前面介绍过的排序方法都是在内存中进行的（称为内部排序）。\n\n外部排序：将待排序的记录存储在外存上，排序时再把数据一部分一部分地调入内存进行排序，在排序过程中需要多次进行内存和外存之间的交换。\n\n\n\n\n\n\n\n\n\n\n\n败者树\n\n败者树是树形选择排序的一种变体，可视为一棵完全二叉树。k 个叶结点分别是当前参加比较的元素，非叶子结点用来记忆左右子树中的”失败者”，而让胜者往上继续进行比较，一直到根结点。\n\n败者树\n\n\n\n置换-选择排序\n\n8.73置换-选择排序\n\n\n最佳归并树\n\n\n\n\n\n\n\n"},"计算机基础/编译原理/1_开始":{"title":"开始","links":[],"tags":["编译原理"],"content":"视频：www.bilibili.com/video/BV11t411V74n\n\n龙书：Compilers：Principles, Techniques, and Tools\n虎书：Modern Compiler Implementation in Java，Modern Compiler Implementation in C\n鲸书：Advanced Compiler Design and Implementation\n"},"计算机基础/编译原理/2_引论":{"title":"引论","links":[],"tags":["编译原理"],"content":"什么是编译程序\n翻译程序\n把某一种语言程序 ( 称为源语言程序 ) 等价地转换成另一种语言程序 ( 称为目标语言程序 ) 的程序。\n比如说C语言写的程序交给翻译程序后，可以翻译成目标程序，例如某台机器的目标指令。\n\n编译程序\n编译程序一种特殊的，较为复杂的翻译程序。\n编译程序把某一种高级语言程序等价地转换成另一种低级语言程序 ( 如汇编语言或机器语言程序 ) 的程序。\n::: tip\n翻译程序是任何两个语言之间都可以翻译，而编译程序特指高级语言程序翻译到低级语言程序。\n:::\n\n\n传统的编译程序源语言通常为高级语言（如C、C++、Java、Python…），目标语言通常为机器级语言或较低级的虚拟机语言（如汇编语言、机器语言、Bytecode…）。\n::: info\n高级语言的执行通常分为两个阶段：\n\n编译阶段：将源程序变换成目标程序；\n运行阶段：由所生成的目标程序连同运行系统接收程序的初始数据做为输入，运行后输出结果；\n\n\n\n如果目程序是汇编语言形式的，则在编译阶段和运行阶段之间还有一个汇编阶段\n\n汇编阶段：将编译生成的汇编语言目标程序经过汇编程序变换成机器语言目标程序；\n\n\n:::\n解释程序\n解释程序也是一种翻译程序，它把源程序作为输入，一条一条读入并解释执行。\n\n不产生目标程序\n不区别翻译阶段和执行阶段\n翻译源程序的每条语句后直接执行\n程序执行期间一直有解释程序守候\n常用于实现虚拟机\n\n\n\n编译过程\n编译程序的工作过程是指从输入源程序开始到输出目标程序为止的整个过程。\n整个编译过程可以划分五个阶段：词法分析、语法分析、语义分析和中间代码生成、优化、目标代码生成。\n词法分析\n\n\n\n任务：输入源程序，对构成源程序的字符串进行扫描和分解，识别出一个个单词符号。\n\n\n依循的原则：构词规则（语言的词法规则）\n\n\n描述方法：正规式和有限自动机\n\n\n\n\n语法分析\n\n\n\n任务：在词法分析的基础上，根据语言的语法规则把单词符号串分解成各类语法单位（语法范畴）。\n\n\n依循的原则：语法规则\n\n\n描述方法：上下文无关文法\n\n\n\n\n语义分析和中间代码生成\n\n任务：对各类不同语法范畴按语言的语义进行初步翻译；\n\n对每种语法范畴进行静态语义检查，如变量是否定义、类型是否正确等。\n在语义检查正确的情况下进行中间代码的翻译。\n\n\n依循的原则：语义规则\n描述方法：属性文法\n中间代码：三元式、四元式、树， …\n\n::: info\n中间代码是介于高级语言的语句和低级语言的指令之间的一种独立于具体硬件的记号系统，它的表达性和复杂性介于高级语言和低级语言之间。\n:::\n\n\n\n\n优化\n\n\n任务：对于前阶段产生的中间代码进行等价变换或改造（另一种优化是针对目标机即对目标代码进行优化），以期在获得更高效（节省时间和空间）的目标代码\n\n\n依循的原则：程序的等价变换规则\n\n\n\n目标代码生成\n\n\n任务 : 把中间代码变换成特定机器上的机器语言程序或汇编语言程序。\n\n\n依赖于硬件系统结构和机器指令的含义\n\n\n目标代码三种形式\n\n绝对指令代码 : 可直接运行；（机器语言）\n可重新定位指令代码 : 需要连接装配；（机器语言）\n汇编指令代码 : 需要进行汇编；（汇编语言）\n\n\n\n\n编译程序的结构\n\n\n表格\n编译过程中源程序的各种信息被保留在不同的表格里，编译过程的绝大部分时间都用在造表、查表和更新表格上。\n符号表：收集每个名字的各种属性用于语义分析及后续各阶段\n\n出错处理\n出错处理与编译的各个阶段都有联系，与前三个阶段的联系尤为密切。\n主要功能：\n\n检查错误：报错错误信息\n排错：恢复编译工作\n\n遍\n” 遍 ” 是对源程序或源程序的中间表示从头到尾扫描一次。\n阶段与遍是不同的概念：\n\n一遍可以由若干段组成；\n一个阶段也可以分若干遍来完成；\n\n编译前端与后端\n\n\n\n编译前端\n与源语言有关，如词法分析，语法分析，语义分析与中间代码产生，与机器无关的优化；\n\n\n编译后端\n与目标机有关，与目标机有关的优化，目标代码产生；\n\n\n好处：\n\n程序逻辑结构清晰\n优化更充分，有利于移植\n\n编译程序的开发\n编译程序的开发通常采用\n\n\n自编译\n用某种高级语言编写自己的编译程序称为自编译。\n\n\n交叉编译\n用A机器上的编译程序来产生在B机器上运行的代码。\n\n\n自展\n\n\n\n移植\nA机器上的某种高级语言的编译程序稍加修改就能在B机器上运行。\n一个程序若能较容易的从A机器搬到B机器运行，则称该程序是可移植的。\n移植具有一定的局限性。\n\n"},"计算机基础/编译原理/3_词法分析":{"title":"词法分析","links":[],"tags":["编译原理"],"content":"词法分析\n词法分析是编译的第一个阶段，任务是从左至右逐个字符地对源程序进行扫描，产生 一个个单词符号，把字符串形式的源程序改造成为单词符号串形式的中间程序。\n词法分析器\n执行词法分析的程序称为词法分析程序，也称词法分析器 (Lexical Analyzer) 又称扫描器 (Scanner)。\n最基本的要求是能够实现输入源程序、输出单词符号。\n单词符号\n单词符号是程序语言最基本的语法单位，具有确定的语法意义。\n单词符号的种类：\n\n基本字（保留字）：如for、while\n标识符：如变量名、数组名\n常数：各种类型的常数\n运算符：如 + ， - ， * ， /\n界符：如,、;、[、{\n\n::: tip\n一个程序语言的基本字、运算符、界符的个数是确定的，常数、标识符的个数是不确定的。\n:::\n输出的单词符号的表示形式：( 单词种别，单词自身的值 )\n\n\n单词种别\n通常用整数编码表示，表示单词的种类，它是语法分析所需要的信息。\n\n若一个种别只有一个单词符号，则种别编码就代表该单词符号。\n若一个种别有多个单词符号，则对于每个单词符号，给出种别编码和自身的值。\n\n\n\n\n单词自身的值\n是编译中其它阶段所需要的信息。\n对于单词符号来说，\n\n如果一个种别只含有一个单词符号，其种别编码就完全代表了它自身的值。\n如果一个种别含有多个单词符号，那么对于它的每个单词符号，除了给出种别编码之外还应给出单词符号自身的值。\n\n\n\n\n\n词法分析程序与语法分析程序的接口方式\n词法分析可以采用两种处理结构：\n\n\n把词法分析程序做为主程序\n把词法分析工作可以是独立的一遍，即把源程序变为单词符号串形式的中间程序，把这个中间程序作为语法分析程序的输入。在这种结构中，词法分析和语法分析是分别实现的。\n\n\n\n把词法分析程序做为子程序\n每当语法分析程序需要一个单词时，则调用该子程序。词法分析程序每得到一次调用，便从源程序文件中读入一些字符，直到识别出一个单词，或说直到下一单词的第一个字符为止。\n\n\n\n::: tip\n通常采用第二种处理结构。\n:::\n词法分析器的结构\n\n\n状态转换图\n在词法分析中，可以用状态转换图来识别单词。\n什么是状态转换图\n状态转换图是有限的有向图。结点代表状态，用圆圈表示；结点之间用有向边连接，有向边上可以标记字符。\n一张转换图只包含有限个状态， 其中有一个为初态，至少要有一个终态（终止状态）。终态的结点使用双圆圈表示以区别于其它状态。\n\n状态转换图可用于识别 ( 或接受 ) 一定的字符串。若存在一条从初态到某一终态的道路，且这条路上所有边上的标记符连接成的字等于\\alpha，则称\\alpha为该状态转换图所识别 ( 接受 )。\n::: tip\n终态右上角的” * “表示要退掉最后一个读入的字符。\n:::\n\n状态转换图的实现\n每个状态结点对应一小段程序。\n方法：\n\n对不含回路的分叉结点 ，可用一个switch语句或if else语句实现；\n对含回路的状态结点，可对应一段由while语句；\n终态结点表示识别出某种单词符号，对应语句为return(单词种类,单词自身的值)\n\n状态转换矩阵\n状态转换矩阵行表示状态，列表示输入字符。\n状态转换矩阵与状态转换图表示的内容一样，只是表示的方式不一样。\n\n将上述状态转换图转换成状态转换矩阵，如下图表示\n\n正规表达式\n正规式和正规集的定义\n正规表达式是一种形式化的表示法，它可以表示单词符号的结构，从而精确地定义单词符号集。\n正规表达式简称正规式，它表示的集合即为正规集。\n::: info 例如\n假设某个语言的标识符是以字母开头的字母数字字符串，字母使用 letter 表示，数字使用 digit 表示，则标识符可表示为：letter(letter|digit)^*\n\nletter和(letter|digit)^* 的并置表示两者连接；\n“ | ”读为“或”，表示 letter 或 digit 二选一；\n“ * ”读为“闭包”，表示零次或多次引用；\n(letter|digit)^* 表示 letter|digit 的零次或多次并置；\nletter(letter|digit)^* 表示以字母开头的字母数字字符串，即标识符集\n\n在以上例子中，letter(letter|digit)^* 就是正规式；标识符集就是正规集。\n:::\n对于给定的字母表为\\Sigma，正规式和正规集的递归定义：\n\n\\varepsilon 和 \\Phi 都是\\Sigma上的正规式，它们所表示的正规集分别为 \\{\\varepsilon\\} 和 \\Phi；\n对于任何一个 a\\in \\Sigma，a 是\\Sigma上的一个正规式，它所表示的正规集为 \\{a\\}；\n如果 R 和 S 是\\Sigma​上的正规式，他们所表示的正规集分别为L(R)和L(S)，则：\n\nR|S 是\\Sigma上的正规式，它所表示的正规集为L(R)\\cup L(S)；\nR\\bullet S 是\\Sigma上的正规式，它所表示的正规集为L(R)L(S)；\n(R)^* 是\\Sigma上的正规式，它所表示的正规集为(L(R))^*；\nR 是\\Sigma上的正规式，它所表示的正规集为L(R)；\n\n\n\n仅由有限次使用上述三个规则得到表达式才是\\Sigma上的正规式，仅由这些正规式表示的字集才是\\Sigma上的正规集。\n::: info 相关概念\n\n\\Sigma 上的字（字符串）：指由\\Sigma中的字符所构成的一个有穷序列；\n“ \\Sigma^* ”：表示\\Sigma上的所有字的全体，若\\Sigma =\\{a,b\\}，则\\Sigma^* = \\{\\varepsilon,a,b,aa,ab,ba,bb,\\cdots  \\}；\n“ \\varepsilon ”：表示空字，即不包含任何字符的序列；\n“ \\Phi ”：表示不包含任何序列的空集\\{\\}；\n“ | ”：读为“或”，也可以使用“ + ”代替；\n“ \\bullet ”：读为“连接”，通常可以省略；\n“ * ”：读为“闭包”；\n\n:::\n::: tip\n\\{ \\} 表示的不包含任何字的集合；\\{\\varepsilon \\} 是由空字组成的集合；\n:::\n\\Sigma^* 的正规式 R 和 S 的连接定义为 RS=\\{ \\alpha \\beta | \\alpha \\in R \\&amp; \\beta \\in    \\beta \\}；R 自身的 n 次连接记为 R^n=R_1R_2\\cdots R_n；\n规定 R^0=\\{\\varepsilon \\}，令 R^*=R^0\\cup R^1\\cup \\cdots ，称 R^* 是 R 的闭包；令 R^+=RR^*，称 R^+ 是 R 的正则闭包。\n对于 \\Sigma 上的正规式 R 和 S ，如果它所表示的正规集L(R)=L(S)，则称 R 和 S 是等价的，并记为 R=S。\n\n正规式的性质\n\n交换律：R|S=S|R\n结合律：R|(S|T)=(R|S)|T、R(ST)=(RS)T\n分配律：R(S|T)=RS|RT\n同一律：\\varepsilon R= R\\varepsilon =R\n\n有限自动机\n有限自动机FA是更一般化的状态转换图，它分为确定有限自动机DFA和非有限自动机NFA。\n确定的有限自动机（DFA）\n一个确定的有限自动机M_d（记为DFA M_d）是一个五元组M_d=(S,\\Sigma ,f,s_0,Z)，其中：\n\nS：有限状态集，它的每一个元素称为一个状态；\n\\Sigma：有穷输入字母表，它的每一个元素称为一个输入字符；\nf：状态转换函数，为 S\\times \\Sigma 到 S 的单值映射，即 f(S_i,a)=S_j（ S_i,S_j \\in S ，a\\in \\Sigma），表示当前状态为 S_i ，输入字符a时，状态转换为 S_j；\ns_0：唯一的一个初态；\nZ： 一个可空的终态集 ；\n\nDFA可以表示为状态转换图。假定 DFA M 含有 m 个状态和 n 个输入字符，则这个图含有 m 个状态结点，每个结点顶多含有 n 条弧射出，且每条弧用\\Sigma上的不同的输入字符来作标记。\n\n对于\\Sigma ^*中的任何字 \\alpha，若存在一条从初态到某一终态的道路，且这条路上所有弧上的标记符连接成的字等于 \\alpha，则称 \\alpha为 DFA M 所识别 ( 接收 )。\nDFA M 所识别的字的全体记为L(M)。\n\n::: danger\n上图状态4是终态，理应用双层圆圈表示，但不知是什么原因导致课件显示的不是双层圆圈。\n:::\n非确定的有限自动机（NFA）\n一个确定的有限自动机M_n（记为NFA M_n）是一个五元组M_n=(S,\\Sigma ,f,Q,Z)，其中：\n\nS,\\Sigma ,Z 的意义与DFA一样；\nf ：状态转换函数，为 S\\times \\Sigma ^*\\rightarrow 2^S 的部分映射；即 f(S_i,a)=\\{S_j,\\cdots \\}，表示不能由当前状态和当前输入字符确定下一个要转换的状态；\nQ：一个非空初态集，Q \\subset S；\n\n::: info NFA 和 DFA 的区别：\n\nNFA 可以多个初态，DFA 仅有一个初态；\n弧上的标记可以是\\Sigma ^*中的一个字 ( 甚至可以是一个正规式 ) ，而不一定是单个字符；\nNFA 状态转换图中，同一个字可能出现在同状态射出的多条弧上；\n\n:::\n::: tip\nDFA 是 NFA 的特例。\n:::\n\n\n对于 \\Sigma ^* 中的任何字 \\Sigma ^*，若存在一条从初态到某一终态的道路，且这条路上所有弧上的标记字连接成的字等于 \\Sigma ^*( 忽略那些标记为 \\varepsilon 的弧 ) ，则称 \\alpha 为 NFA M 所识别 ( 接收 )。\nNFA M 所识别的字的全体记为L(M)。\nDFA与NFA等价\n对于任何两个有限自动机 M 和 M’，如果 L(M)=L(M’)，则称 M 与 M’ 等价。\n对于每个 NFA M 存在一个 DFA M’，使得 L(M)=L(M’)。因此，DFA是NFA的特例，NFA可以有DFA与之等价，即两者描述能力相同。\n::: info\n自动机理论中一个重要的结论：判定两个自动机等价性的算法是存在的。\nDFA便于识别，易于计算机实现，而NFA便于定理的证明。\n:::\nNFA转变为DFA\n假定 NFA M=&lt;S,\\Sigma ,\\delta ,S_0,F&gt;，我们对 M 的状态转换图进行以下改造：\n\n引入初态和终态\n引进新的初态结点 X 和终态结点 Y， X,Y\\notin S ， 从 X 到 S_0 中任意状态结点连一条 \\varepsilon 弧，从 F 中任意状态结点连一条 \\varepsilon 弧到 Y 。\n\n\n\n对NFA弧上的标记进行等价替换\n对 M 的状态转换图进一步施行替换，其中 k 是新引入的状态。\n按下面的三条规则对弧进行分裂 :\n\n\n\n\n\n\n\nNFA的确定化\nNFA的确定化：使用子集法将给定的NFA转换成等价的DFA。\n首先介绍一下 I , I_a , \\varepsilon -closure(I) 的相关概念：\n\n\n设 I 是的状态集的一个子集，定义 I 的 \\varepsilon-闭包，即 \\varepsilon -closure(I) 。其中，\n\n状态集 I 中的任何状态 S 经任意条 \\varepsilon 弧而能到达的状态的集合都属于 \\varepsilon -closure(I)；\n状态集 I 中的任何状态 S 都属于 \\varepsilon -closure(I)；\n\n\n\n设 a 是 \\Sigma 中的一个字符，定义 I_a=\\varepsilon -closure(J)。其中， J 为 I 中的某个状态出发经过一条 a 弧而到达的状态集合。\n\n\n\n例如：\n\n\n\n如何对NFA确定化：\n\n构造转换表，第一列为 I ，对不同的 a(a\\in \\Sigma) 在表单中单设一列 I_a （即从第二列开始是 I_a,I_b,I_c,\\cdots，且a,b,c,\\cdots \\in \\Sigma）；\n表的第一行第一列为 \\varepsilon -closure(初始状态)；\n根据表中第一列的 I ，求出对应的 I_a,I_b,I_c,\\cdots ，然后检查它们是否已经出现在第一列，把未出现按顺序填入空行中的第一列；\n重复上述过程，直到所有第2,3,4…列的子集全部出现在第一列为止。至此，我们就得到了对应NFA的转换表；\n把转换表变成相应的状态转换矩阵，把其中的每个子集看成一个状态并对每个子集重命名，初态是\\varepsilon -closure(初始状态)，终态是含有原终态 Y 的子集。\n\n例如：正规表达式 (a|b)^*(aa|bb)(a|b)^* 的NFA M如下图所示，将其转化成DFA M’。\n\n构造的转换表如下图所示\n\n下图中划红线的是初态，蓝线的是终态\n\n把转换表变成相应的状态转换矩阵和DFA M’\n\n::: tip\n上图所示的DFA M’是未化简的。\n:::\nDFA的化简\n\n对 NFA 确定化后所得到的DFA可能含有多余状态。\n\n对 DFA M 的化简就是寻找一个状态数比 M 少的 DFA M’ ，使得 L(M)=L(M’) 。化简后的 M’ 应该满足：\n\n没有多余状态；\n在其状态集中，没有两个相互等价的状态存在；\n\n::: info 等价和可区分的状态\n假设 s 和 t 为 M 的两个状态：\n\n两个状态相互等价：如果从状态 s 出发能读出某个字\\alpha而停止于终态，从 t 出发也能读出\\alpha而停止于终态，则称 s 和 t 是等价的；\n两个状态可区分：存在一个\\alpha，要么 s 读出\\alpha停止于终态而 t 读出\\alpha停止于非终态，要么相反；\n\n:::\n::: info DFA M 最少化的基本思想\n将 M 的状态集划分为一些不相交的子集， 使得任何两个不同子集的状态是可区别的 ，而同一子集的任何两个状态是等价的。 最后，每个子集选出一个状态，同时消去其他等价状态。\n:::\n化简步骤：\n\n\n把 DFA M 的状态集 S 中的终态与非终态分开，形成两个子集。\n\n\n对当前划分出的I^{(1)},I^{(2)},\\cdots,I^{(m)}子集进行划分。划分依据：对某个 I^{(i)}=\\{s_1 ,s_2 ,\\cdots ,s_k \\}，若存在一个输入字符 a 使得 I_a^{(i)} 不全包含在当前划分的某个子集 I^{(i)} 中，则至少应把 I^{(i)} 分为两个部分。\n\n\n划分依据：\n假定状态 s_1 和 s_2 经 a 弧分别到达 t_1 和 t_2，且 t_1 和 t_2 属于当前划分的两个不同子集。\n\n由于属于不同子集的状态是可区分的，因此 t_1 和 t_2 也是可区分的，说明有一个字 \\alpha， t_1 读出 \\alpha 后到达终态，而 t_2 读出 \\alpha 后不能到达终态，或者反之。\n那么对于字 a\\alpha ， s_1 读出 a\\alpha 后到达终态 ，而 s_2 读出 a\\alpha 不能到达终态，或者反之。所以 s_1 和 s_2 不等价。\n\n\n\n划分方法：\n将 I^{(i)} 分成两半，使得一半含有 s_1 ，另一半含有 s_2 。\n一般地，对某个 a 和 I^{(i)} ，若 I_a^{(i)} 落入当前划分的子集中的 N 个不同子集，则应把 I^{(i)} 划分成 N 个不相交的组，使得每个组 I 的 I_a 都落入的当前划分的同一子集中。\n\n\n\n\n\n重复步骤2，直到子集个数不再增加。这时选取每个子集 I 中的一个状态代表其他状态，则可得到化简后的 DFA M’。\n若 I 含有原来的初态，则其代表为新的初态 ，若 I 含有原来的终态，则其代表为新的终态。\n\n\n::: info\nI_a ： I 状态集合中的某一状态读入 a 之后能停在 I_a 的某一个状态。\n:::\n以上面 NFA 的确定化得到的DFA为例进行化简，\n\n\n\n\n正规式与有限自动机的等价性\n定理：\n\n对任何 FA M ，都存在一个正规式 r ， 使得 L(r)=L(M) 。\n对任何正规式 r ，都存在一个 FA M ， 使得 L(M)=L(r) 。\n\n\n证明：对 \\Sigma 上任一 NFA M ，构造一个 \\Sigma 上的正规式 r ，使得 L(r)=L(M) 。\n\n\n首先，在 M 的转换图上加进两个状态 X 和 Y ，从 X 用 \\varepsilon 弧连接到 M 的所有初态结点，从 M 的所有终态结点用 \\varepsilon 弧连接到 Y ，从而形成一个新的 NFA ，记为 M’ ，它只有一个初态 X 和一个终态 Y ，显然 L(M)=L(M’) 。\n\n\n然后，反复使用下面的规则，逐步消去的所有结点，直到只剩下 X 和 Y 为止；\n\n例如：\n\n\n\n最后， X 到 Y 的弧上标记的正规式即为所构造的正规式 r。显然 L(r)=L(M)=L(M’)\n\n\n\n证明：对于 \\Sigma 上的正规式 r ，构造一个 NFA M ，使 L(M)=L(r) ，并且 M 只有一个终态，而且没有从该终态出发的弧。\n\n\n若 r 具有零个运算符，则 r= \\varepsilon 或 r=\\Phi 或 r=a，其中 a\\in \\Sigma。\n\n\n\n若 r 中含有 k(k\\geqslant 1) 个运算符时， r 有三种情形 ：\n对 r_i 存在 M_i=(S_i,\\Sigma _i ,\\delta _i,q_i,\\{f_i\\}) ，使得 L(M_i )=L(r_i ) ， 并且 M_i 没有从终态出发的弧。\n\n\n情形1：r=r_1 |r_2， r_1 和 r_2 中运算符个数少于 k 。\n设 S_1 \\cap  S_2 =\\Phi ，在 S1 \\cup  S2 中加入两个新状态 q_0 ，f_0 。\n\n\n\n\n情形2：r=r_1 r_2。\n\n\n\n\n情形3： r=r_1 ^* 。\n\n\n\n\n\n\n\n上述证明过程实质上是一个将正规表达式转换为有限自动机的算法。\n\n\n构造 \\Sigma 上的 NFA M’ 使得 L(V)=L(M’)\n\n\n\n按下面的三条规则对 V 进行分裂\n\n\n\n逐步把这个图转变为每条弧只标记为 \\Sigma 上的 一个字符或 \\varepsilon，最后得到一个 NFA M’ ， 显然 L(M’)=L(V)\n\n\n以下是将正规式转换成有限自动机的示例：\n\n根据正规式得到NFA后，只需将NFA转变为DFA即可。\n词法分析器的自动产生\nLex/Flex是一个词法分析器生成工具，通常和Yacc一起使用，生成编译器的前端。\n\nLEX 的工作过程：\n\n首先，对每条识别规则 P_i 构造一个相应的非确定有限自动机 M_i ；\n然后，引进一个新初态 X ，通过 \\varepsilon 弧，将这些自动机连接成一个新的 NFA ；\n最后，把 M 确定化、最小化，生成该 DFA 的状态转换表和控制执行程序；\n\n"},"计算机基础/编译原理/4_语法分析":{"title":"语法分析","links":[],"tags":["编译原理"],"content":"在描述程序语言的语法结构时，需借助于上下文无关文法，而文法是描述程序语言的依据。\n程序语言的定义\n程序本质上是一定字符集上的字符串。\n语法\n语法：一组规则，用它可以形成和产生一个合适的程序。\n词法规则：单词符号的形成规则\n\n单词符号是语言中具有独立意义的最基本结构\n一般包括：常数、标识符、基本字、算符、界符等\n描述工具：有限自动机\n\n语法规则：语法单位的形成规则\n\n语法单位通常包括：表达式、语句、分程序、过程、函 数、程序等 ;\n描述工具：上下文无关文法\n\n语法规则和词法规则定义了程序的形式结构。\n语义\n语义：一组规则，用它可以定义一个程序的意义\n语义分类：\n\n静态语义：是一系列限定规则，并确定哪些合乎语法的程序是合适的。\n动态语义(运行语义、执行语义)：表明程序要做什么，要计算什么。\n\n描述方法：\n\n自然语言描述：隐藏错误、二义性和不完整性\n形式描述：操作语义 (PL/1)、指称语义 (ADA)、代数语义 (PASCAL)\n\n程序语言的基本功能和层次结构\n程序语言的基本功能：描述数据和对数据的运算\n所谓程序，本质上是描述一定数据的处理过程\n程序的层次结构\n\n标识符与名字\n标识符：以字母开头的，由字母数字组成的字符串。\n名字：由值（单元中的内容）和属性（类型和作用域）组成。\n名字的性质的说明方式：\n\n\n由说明语句来明确规定\n\n\n隐含说明\nFORTRAN 以 I、J、K、…N 为首的名字代表整型，否则为实型\n\n\n动态确定\n走到哪里，是什么，算什么\n\n\n::: tip 标识符与名字的区别\n标识符是语法概念，名字是语义概念\n:::\n\n若一个标识符 ABC，\n\n绑定了一个人，那么 ABC 就是人名\n绑定了一个国家，那么 ABC 就是国名\n\n程序语言的语法描述\n考虑一个有穷字母表 \\Sigma 字符集，\n\n\n其中每一个元素称为一个字符(符号)；\n\n\n由 \\Sigma 中的字符所构成的一个有穷序列称为 \\Sigma 上的字(也叫字符串，符号串)；\n\n\n不包含任何字符的序列称为空字，记为 \\varepsilon ；\n\n\n用 \\Sigma ^* 表示 \\Sigma 上的所有字的全体，包含空字 \\varepsilon ；\n\n例如：\n设 \\Sigma =\\{a,b \\} ，则 \\Sigma ^*=\\{\\varepsilon ,a,b,aa,ab,ba,\\cdots \\}\n\n\n\n对于字母表 \\Sigma 来说， \\Sigma ^* 上的任意一个子集都称为 \\Sigma 上的一个语言，记为 L(L\\subset  \\Sigma ^*)；\n\n\n语言的每一个字符串称为语言 L 的一个语句或句子；\n\n\n::: info 重要约定\n\n小写字母 a, b, c,\\cdots , r 表示字符\n小写字母 s, t, u,\\cdots , z 表示字符串\n大写字母 A, B, C,\\cdots , Z 表示字符串集合\n\n:::\n字符串的运算：\n\n\n字符串相等\n设 x、y 是 \\Sigma 上的两个字符串，若 x 与 y 的诸符号依次相等，则该两符号串相等，记为 x = y。\n\n\n字符串长度\n设 x 是 \\Sigma 上的字符串，字符串中包含符号的个数称为字符串 x 的长度，用 \\left | x \\right | 表示。\n\n\\left | \\varepsilon \\right |=0\n\\left | ax \\right |=\\left | xa \\right   | = \\left | x \\right |+1 (a\\in \\Sigma)\n\n\n\n字符串的连结\n设 x 与 y 是 \\Sigma 上的两个字符串，把 y 的所有符号相继写在 x 的符号之后所得到的字符串称为 x 与 y 的连结，用 xy 表示。\n\n\\left | xy \\right |=\\left | x \\right |+\\left | y \\right |\n\\varepsilon x=x \\varepsilon = x\n\n\n\n字符串的逆\n设 x 是 \\Sigma 上的符号串，其逆为符号串 x 的倒置，记为 \\widetilde{x}。\n\n若 x=abcd，则 \\widetilde{x}=dcba\n\\widetilde{\\varepsilon} =\\varepsilon\n\n\n\n字符串的前缀、后缀和子串\n设 x、y、z 是 \\Sigma 上的符号串，则称 x 为符号串 xy 的前缀，y 是符号串 xy 的后缀。x、y、z、xy、yz 是符号串 xyz 的子串。\n\n\n字符串集合的乘积\n\\Sigma ^* 的子集 U 和 V 的**连接（积）**定义为 UV=\\{\\alpha  \\beta | \\alpha \\in U \\&amp; \\beta \\in V \\}\n\n例如：\n设 U = \\{a,aa\\} 和 V = \\{b,bb\\} ，那么 UV = \\{ab, abb, aab, aabb\\}\n\n\n\n空集\n不含任何元素的集合，记为 \\phi\n\n\\phi U=U\\phi = \\phi\n\\varepsilon \\notin \\phi\n\n\n\n字符串的幂\n设 x 是 \\Sigma 上的符号串，则 x 的幂运算为 x^0=\\varepsilon，x^n=xx\\cdots x(n&gt;0)。\n\n例如：\n若 x=ab，则 x^0=\\varepsilon，x^1=ab，x^2=abab\n\n\n\n字符串集合的幂\nV 自身的 n 次积记为 V^n=VV\\cdots V （n 个V相乘），规定 V^0=\\{\\varepsilon \\}\n\n例如：\n若 V=\\{ab,cd\\}，则 V^0=\\{\\varepsilon \\}，V^1=\\{ ab,cd \\}，V^2=\\{abab,abcd,cdab,cdcd \\}\n\n\n\n集合 A的闭包与正规闭包\n记 V^* =V^1\\cup V^2 \\cup V^3\\cup \\cdots ，称 V^* 是 V 的闭包。\n记 V^+=VV^* ，称 V^+ 是 V 的正规闭包。\n大多数情况下，闭包和正规闭包没有太大区别。\n\n例如：\n若 U= \\{a, aa  \\}，则 U^* = \\{\\varepsilon ,a, aa, aaa, aaaa,\\cdots \\}，U^+=\\{a, aa, aaa, aaaa,\\cdots \\}\n\n\n\n::: tip\n\n\\phi：一个集合，这个集合里面没有字\n\\varepsilon：一个长度为 0 的字\n\\{\\varepsilon \\}：一个集合，这个集合里面有一个字，但这个字的长度为 0\n\n:::\n上下文无关文法\n文法的定义\n::: info 规则（重写规则、产生式、生成式）\n一个规则是一个二元组，通常写作 \\alpha ::= \\beta 或 \\alpha \\to \\beta 。\n\\alpha 称为规则的左部，\\beta 称为规则的右部，\\to 和 ::= 读作“ 定义为 ”，这是一条关于 \\alpha 的规则（产生式）。\n:::\n::: info 巴科斯范式 (BNF)\n“ \\to ” 也可以用“ ::= ” 表示， 这种表示称为巴科斯范式 (BNF)。\n:::\n文法： 描述语言的语法结构的形式规则。\n一个上下文无关文法 G 是一个四元式 G=(V_T ,V_N , S, P) ，其中\n\nV_T ：终结符集合 ( 非空，有限 )\nV_N ：非终结符集合 ( 非空，有限 ) ，且 V_T \\cap  V_N =\\phi\nS ：文法的开始符号，它是一个非终结符，至少要在一条规则中作为左部出现， S\\in V_N\nP ：产生式集合 ( 非空，有限 ) ，每个产生式形式为 P \\to \\alpha , P\\in V_N , \\alpha \\in (V_T \\cup V_N)^*\n\nV=V_N\\cup V_T，称为文法 G 的字母表。\n::: info 终结符\n终结符是指语言不可再分的基本符号，通常是一个语言的字母表；\n终结符代表了语法的最小元素，是一个个体记号。\n:::\n::: info 非终结符\n非终结符也称语法变量，代表语法实体或语法范畴；\n:::\n如果P\\to \\alpha _1，P\\to \\alpha _2，P\\to \\alpha _3，… ，为了书写方便，可以缩写为\nP\\to \\alpha _1|\\alpha _2|\\alpha _3|\\cdots\n\n其中，“|” 读成 “或”，每个 \\alpha _i 称为P的一个候选式。\n表示一个文法时，不用将文法 G 的四元组显式地表示出来，通常只给出开始符号和产生式。\n::: info 一般约定\n\n第一条产生式的左部是识别符\n用尖括号括起来的是非终结符（或者用大写字母表示）\n不用尖括号括起来的是终结符（或者用小写字母表示）\n将 G 也写成 G[S]，其中 S 是识别符\n\n:::\n文法产生的语言\n::: warning 推导\n\n在下面的内容中， ” + ”，“ * ” 应该放在\\Rightarrow的上面，但由于 Markdown 文档没有相关的公式，因此只能写成\\Rightarrow ^+这样的形式。\n:::\n设文法G[S]=(V_T ,V_N , S, P)，且\\alpha , \\beta \\in (V_T\\cup V_N)^* ，\n如果存在产生式A\\to \\delta , (\\delta  \\in (V_T\\cup V_N)^*)，则称\\alpha A \\beta 可直接推导到 \\alpha \\delta \\beta，\\alpha A \\beta \\Rightarrow \\alpha \\delta \\beta，或 \\alpha \\delta \\beta 直接规约到 \\alpha A \\beta。\n\n例：\nG：S\\to 0S1，S\\to 01\nS\\Rightarrow 0S1 \\Rightarrow 00S11 \\Rightarrow 000S111\\Rightarrow 00001111\n\n通常，\n\n\\alpha _1\\Rightarrow ^+\\alpha _n表示从\\alpha _1出发，经过一步或若干步，可以推出\\alpha _n。\n\\alpha _1\\Rightarrow ^*\\alpha _n表示从\\alpha _1出发，经过0 步或若干步，可以推出\\alpha _n。\n\n\n句型：由文法的开始符S出发，经过 0 步或有限步推导出来的符号串\\alpha（S\\Rightarrow ^* \\alpha，\\alpha \\in (V_T\\cup V_N)^*）\n句子：由文法的开始符S出发，经过 1 步或有限步推导出来的符号串\\alpha，且该字符串全部由终结符组成（S\\Rightarrow ^+ \\alpha，\\alpha \\in V_T^*）\n语言：由对应的文法G所产生的句子的全体，记为L[G]，L[G]=\\{\\alpha |S\\Rightarrow ^+ \\alpha ,\\alpha \\in V_T^* \\}\n\n例：\n\n\n证明(i*i+i)是文法G(E) ： E \\to i | E+E | E*E | (E) 的一个句子。\n\n\n\n文法 G_1 (A) ： A \\to c|Ab ，G_1(A)的语言是什么 ?\nL(G_1)=\\{c ， cb ， cbb ，\\cdots \\}\n\n\n\n文法 G_2 (S)： S \\to AB，A \\to aA|a，B \\to bB|b，G_2 (S)的语言是什么 ?\nL(G_2 )=\\{a^mb^n|m , n&gt;0\\}\n\n\n\n\n递归规则：是指在规则的左部和右部具有相同的非终结符的规则。\n\n右递归：A\\to \\cdots A\n左递归：A\\to  A\\cdots\n规则递归：A\\to \\cdots A\\cdots\n\n文法的递归性：是指文法中任一非终结符，若能建立一个推导过程，在推导所得的符号串中又出现了该非终结符本身。\n\n文法右递归：A\\Rightarrow ^+ \\cdots A\n文法左递归：A\\Rightarrow ^+  A\\cdots\n文法递归：A\\Rightarrow ^+ \\cdots A\\cdots\n\n当一个语言是无穷集合时，则定义该语言的文法一定是递归的；程序设计语言都是无穷集合，描述它的文法必定是递归的。\n\n例：\n\n给出产生语言为 \\{a^nb^n |n\\geqslant 1\\} 的文法\n\n\n\n给出产生语言为 \\{a^mb^n |1\\leqslant n\\leqslant  m\\leqslant 2n\\} 的文法\n\n\n\n::: info 计算思维的典型方法——递归\n问题的解决又依赖于类似问题的解决，只不过后者的复杂程度或规模较原来的问题更小，一旦将问题的复杂程度和规模化简到足够小时，问题的解法其实非常简单。\n:::\n若L(G_1)=L(G_2)，则称文法G_1和G_2是等价的。\n\n例：\n文法G[A]：A\\to 0R，A\\to 01，R\\to A1和文法G[S]：S\\to 0S1，S\\to 01等价于L(G)=\\{n^n1^n|n\\geqslant 1\\}\n\n形式语言\n一种不考虑含义的符号语言。\n定义\n序列的集合称为形式语言。\n具体讲：每个形式语言都是某个字母表上按某种规则构成的所有符号的集合。即：任何一个字母表上符号串的集合均可定义为一个形式语言。\n对形式语言的描述有两种方法：\n\n当语言为有穷集合时，用枚举的方法。\n当语言为无穷集合时，常用文法描述的方法。\n\n分类\n乔姆斯基于 1956 年建立形式语言体系，他把文法分成四种类型：0 ，1 ，2 ，3 型。\n\n\n0 型文法 ( 短语文法，图灵机 )\n产生式形如：\\alpha \\to \\beta\n其中：\\alpha \\in (V_T \\cup V_N)^*V_N(V_T \\cup V_N)^*，即至少含有一个非终结符；\\beta \\in (V_T \\cup V_N)^*\n\n\n1 型文法 ( 上下文有关文法，线性界限自动机 )\n产生式形如：\\alpha \\to \\beta\n其中： |\\alpha| \\leqslant |\\beta|，仅 S\\to \\varepsilon 例外\n\n\n2 型文法 ( 上下文无关文法，非确定下推自动机 )\n产生式形如：A \\to \\beta\n其中：A\\in V_N；\\beta \\in (V_T \\cup V_N)^*\n\n\n3 型文法 ( 正规文法，有限自动机 )\n\n\n左线性文法\n产生式形如： A \\to B\\alpha 或 A \\to \\alpha\n其中：\\alpha \\in V_T^*； A ,B\\in V_N\n\n\n右线性文法\n产生式形如： A \\to \\alpha B 或 A \\to \\alpha\n其中：\\alpha \\in V_T^*； A ,B\\in V_N\n\n\n\n\n联系和区别\n由四类文法的定义可知，4 个文法类的定义是逐渐增加限制的。\n\n1~3 型文法都属于 0 型文法；\n2、3 型文法如果存在形如A\\to \\varepsilon的产生式，则不属于 1 型文法，如不存在则属于 1 型文法；\n3 型文法属于 2 型文法；\n\n区别：\n\n1 型文法中不允许有形如A\\to \\varepsilon的产生式存在，而 2、3 型文法允许；\n0、1 型文法的产生式左部存在含有终结符号的符号串或两个以上的非终结符，而2、3 型文法的产生式左部只允许是单个的非终结符号；\n\n推导\n从一个句型到另一个句型的推导往往不唯一，可以分为\n\n最左推导：任何一步\\alpha  \\Rightarrow  \\beta都是对\\alpha中的最左非终结符进行替换，例如 E+E \\Rightarrow i+E \\Rightarrow i+i\n最右推导：任何一步\\alpha  \\Rightarrow  \\beta都是对\\alpha中的最右非终结符进行替换，例如 E+E \\Rightarrow E+i \\Rightarrow i+i\n\n一般称最右推导为规范推导，规范推导的逆过程便是规范规约（最左规约）。\n语法树\n语法树\n给定文法 G，对于 G 的任何句型都能构造与之关联的语法树（推导树、语法分析树、分析树）。\n这棵树满足下列 4 个条件：\n\n每个结点都用 G 的一个终结符或非终结符标记；\n根的标记是开始符号；\n内部结点一点是非终结符。如果某内部结点 A 有 n 个分支，它的所有子结点从左到右标记为n_1,n_2,\\cdots ,n_n，则A\\to n_1,n_2,\\cdots ,n_n一定是文法 G 的一个产生式；\n如果某结点标记为\\varepsilon，则它必须为叶结点且其是父结点的唯一子结点；\n\n::: info 内部结点\n内部结点是指非树叶结点，内部结点也包括根结点。\n:::\n语法树可以表示一个句型的推导过程。\n\n例：\n\n\n文法G(E) ： E \\to i | E+E | E*E | (E) 的句子 (i*i+i) 的语法树\n\n\n\n下图的推导树是文法 G 的句型 aabbaa 的推导过程。\n把 aabbaa 叫做推导树的结果，把推导树叫做句型 aabbaa 的语法树。\n\n\n\n\n文法的二义性\n若一个文法存在某个句子对应两棵不同的语法树，或者说，若一个文法存在某个句子有两个不同的最左推导或最右推导，则称这个文法是二义的。\n\n例：\n\n\n\n\n二义性的消除\n对于二义性文法的句子，当编译程序对它的结构进行语法分析时，会产生多种不同的解释，由于语法结构的这种不确定性，必然导致语义处理上的不确定性。\n文法的二义性和语言的二义性是两个不同的概念。\n对于一个二义性的文法G，如果能找到一个非二义性的文法G&#039;，使得L(G&#039;)=L(G)，则称该二义性文法的二义性是可以消除的。如果找不到G&#039;，则二义性文法的描述的语言为先天二义性的。\n::: info 总结\n如果一个语言的每一个文法都是二义的，那么这个语言是先天二义性的。\n:::\n文法二义性消除的两种方法：\n\n\n不改变文法中原有的语法规则，仅加进一些语法的非形式规定。例如加进运算符的优先顺序和结合规则等。\n\n\n构造一个等价的无二义性文法。通过添加新的非终结符来消除文法中的二义性。\n\n例：将文法 G 改写为无二义性的文法G&#039;\n\n\n\n\n::: tip\n二义性问题是不可判定问题，即不存在一个算法能在有限步骤内，确切地判定一个文法是否是二义的。\n:::\n::: info 描述程序设计语言时，对于上下文无关文法的限制\n\n不含 P\\to P 形式的产生式；\n每个非终结符 P 必须能推出终结符号串；\n\n:::\n语法分析\n语法分析的任务：分析一个文法的句子结构。\n语法分析器的功能：按照文法的产生式，识别输入符号串是否为一个句子。\n\n语法分析的方法通常分为两类，即自上而下分析方法和自下而上分析方法。\n\n\n自上而下分析法：从文法的开始符号出发，根据文法的规则进行推导，最终推导出给定的句子来。\n\n\n\n自下而上分析法：从给定的输入串开始，根据文法规则逐步进行归约，直至归约到文法的开始符号为止。\n\n\n\n自上而下的语法分析\n自上而下就是从文法的开始符号出发，向下推导，推出句子。\n递归下降分析法\n递归下降分析法是一种自上而下的分析方法，文法的每个非终结符对应一个递归过程。\n多个产生式候选带来的问题\n回溯\n分析过程中，当一个非终结符用某一个候选匹配成功时，这种匹配可能是暂时的。出错时，不得不“回溯”。\n\n文法左递归问题\n一个文法是含有左递归的，如果存在非终结符 P1\n\n构造不带回溯的自上而下分析算法\n消除文法的左递归性\n假定关于非终结符 P 的规则为 P\\to P\\alpha|\\beta，我们可以把 P 的规则等价地改写为 P\\to \\beta P&#039;和P&#039;\\to \\alpha P&#039;|\\varepsilon\n\n假定 P 关于的全部产生式是 P\\to P\\alpha _1|\\cdots |P\\alpha _m |\\beta _1|\\cdots |\\beta _n，那么消除 P 的直接左递归性就是把这些规则改写成：P\\to \\beta _1P&#039;|\\cdots |\\beta _nP&#039; ， P&#039;\\to \\alpha _1P&#039;|\\cdots  |\\alpha _mP&#039;|\\varepsilon\n\n直接左递归的消除\n\n间接左递归的消除\n\n\n\n\n克服回溯\n回溯发生的原因在于候选式存在公共的左因子，如：A\\to \\alpha \\beta _1∣\\alpha \\beta _2 。此时如果输入串待分析的字符串前缀为 \\alpha，则选用哪个候选式以寻求与输入串匹配就难以确定。\n倘若候选式不含公共左因子，则推导出的首字符能与输入串匹配的那个候选式便是惟一的匹配。\n\n\nLL(1)分析法\nLL(1)分析法又称预测分析法，是一种不带回溯的非递归自上而下分析法。\nLL(1)的含义是：\n\n第一个 L 表明自上而下分析是从左至右扫描输入串的；\n第二个 L 表明分析过程中将用最左推导；\n“1”表明只需向右查看一个符号就可决定如何推导（即可知用哪个产生式进行推导）。\n\n\n类似地，也可以有 LL(k)文法，也就是向前查看 k 个符号才能确定选用哪个产生式，不过 LL(k)(k&gt;1)在实际中极少使用。\n\n表驱动的 LL(1)分析器\nLL(1)分析法的基本思想是根据输入串的当前输入符号来唯一确定选用某条产生式来进行推导；当这个输入符号与推导的第一个符号相同时，再取输入串的下一个符号，继续确定下一个推导应选的规则；如此下去，直到推导出被分析的输入串为止。\n一个 LL(1)分析器由一张LL(1)分析表（也称预测分析表）、一个先进后出分析栈和一个控制程序(表驱动程序)组成。\n\n关于 LL(1)分析器的说明：\n\n\n输入串是待分析的符号串，它以界符 ‘#’ 作为结束标志。\n\\ \\in V_T但不是文法符号，是由分析程序自动添加的。\n\n\n分析栈中存放分析过程中的文法符号。\n分析开始时栈底先放入一个‘#’ ，然后再压入文法的开始符号；当分析栈中仅剩‘#’ ，输入串指针也指向串尾的‘#’时，分析成功。\n\n\n分析表用一个矩阵（或二维数组）M 表示，它概括了相应文法的全部信息。\n矩阵的每一行与文法的一个非终结符相关联，而每一列与文法的一个终结符或界符‘#’相关联。\n分析表元素 M[A,a]中的内容为一条关于 A 的产生式，表示当 A 面临输入符号 a 时当前推导所应采用的候选式；当元素内容为空白（空白表示“出错标志”）时，则表明 A 不应该面临这个输入符号 a，即输入串含有语法错误。\n\n\n控制程序根据分析栈顶符号 x 和当前输入符号 a 来决定分析器的动作。\n\n\n若 x = a =‘#’ ，则分析成功，分析器停止工作。\n\n\n若 x = a ≠ ‘#’ ，即栈顶符号 x 与当前扫描的输入符号 a 匹配；则将 x 从栈顶弹出，输入指针指向下一个输入符号，继续对下一个字符进行分析。\n\n\n若 x 为一非终结符 A，则查 M[A,a]：\n若 M[A,a]中为一个 A 的产生式，则将 A 自栈顶弹出，并将 M[A,a]中的产生式右部符号串按逆序逐一压入栈中；如果 M[A,a]中的产生式为A\\to \\varepsilon，则只将 A 自栈顶弹出。\n若 M[A,a]中为空，则发现语法错误，调用出错处理程序进行处理。\n\n\n\n\n\n\nLL(1)分析表的构造\n\n\n\nFIRST 集构造方法：对文法中的每一个非终结符 X 构造 FIRST(X)，其方法是连续使用下述规则，直到每个集合的 FIRST 不再增大为止。\n\n\n若 X\\in V_T ，则 FIRST(X) = {X}。\n\n\n若 X\\in V_N ，且有产生式X\\to a \\cdots，则把 a 加入到 FIRST(X) 中；若X\\to \\varepsilon也是一条产生式， 则把\\varepsilon也加到 FIRST(X) 中。\n\n\n若有X\\to Y \\cdots，且Y\\in V_N，则将 FIRST(Y)中的所有非\\varepsilon元素都加入到 FIRST(X)中。\n\n\n若有X\\to Y_1Y_2\\cdots Y_k，且Y_1 \\sim Y_i都是非终结符，\n\n若Y_1\\sim Y_{i-1}的候选式都有\\varepsilon存在，则把 FIRST(Y_j)(j=1,2,\\cdots,i)的所有非\\varepsilon元素都加入到 FIRST(X)中；\n若Y_1\\sim Y_k均含有\\varepsilon产生式时，应把\\varepsilon也加到 FIRST(X)中。\n\n\n\n::: tip\n对终结符 a 而言，FIRST(‘a’)={a}，因而无需构造。\n:::\n\n\n\nFOLLOW 集构造方法：对文法的每个非终结符 A 构造 FOLLOW(A)的方法是连续使用下述规则，直到每个 FOLLOW 不再增大为止。\n\n对文法开始符号 S，置#于 FOLLOW(S)中（由语句括号“#S#”中的 S#得到）。\n若有A\\to \\alpha B\\beta（\\alpha可为空），则将FIRST(\\beta)除了\\{\\varepsilon \\}加入到 FOLLOW(B)中。\n若有A\\to \\alpha B或A\\to \\alpha B\\beta，且\\beta \\Rightarrow ^* \\varepsilon（即\\varepsilon \\in FIRST(\\beta)），则把 FOLLOW(A)加到 FOLLOW(B)中（此处的\\alpha也可为空)\n\n::: tip\nFOLLOW 集合不存在\\varepsilon\n:::\n\n\n视频：www.bilibili.com/video/BV11t411V74n\n\n\n构造分析表 M\n构造文法 G 的分析表 M[A,a] ，就是确定每个产生式 A\\to \\alpha 在表中的位置。\n\n对文法 G[S]的每个产生式 A\\to \\alpha 执行以下 2、3 步。\n对每个终结符a\\in FIRST(A)，把 A\\to \\alpha 加入到 M[A,a]中，其中\\alpha为含有首字符 a 的候选式或为惟一的候选式。\n若\\varepsilon \\in FIRST(A)，则对任何属于 FOLLOW(A)的终结符 b，将A\\to \\varepsilon加入到 M[A,b]中。\n把所有无定义的 M[A,a]标记为“出错”。\n\n\nwww.bilibili.com/video/BV11t411V74n\n根据上面 G(E)的 FIRST 集和 FOLLOW 集，构造分析表\n\n\nLL(1) 文法与二义性\n如果一个文法是左递归或二义的，那么 M 至少含有一个多重定义入口。\n如果一个文法的分析表 M 不含多重定义入口，则称它是一个 LL(1)文法，它所定义的语言恰好就是它的分析表所能识别的全部句子。\n一个上下文无关文法是LL(1)文法的充分必要条件是：对每一个非终结符 A 的任何两个不同产生式A\\to \\alpha \\mid \\beta，有下面的条件成立：\n\n\nFIRST(\\alpha )\\cap FIRST(\\beta )=\\phi；\n意味着 A 的每个候选式都不存在相同的首字符，它避免了在分析表的同一栏目内出现多个产生式的情况，即避免了多重入口。\n\n\n假若\\beta  \\Rightarrow ^* \\varepsilon，则有FIRST(\\alpha)∩FOLLOW(A)=\\phi；\n避免了在分析表的同一栏目内出现A\\to \\alpha和A\\to \\varepsilon（同样是避免多重入口）。\n\n例如文法G[S]：S\\to Aa|b A\\to a|\\varepsilon，有FIRST(A)=\\{a,\\varepsilon \\}， FOLLOW(A)=\\{a \\}；\n此时文法对应的中 M[A, a]  栏里必然有两个产生式A\\to \\alpha和A\\to \\varepsilon存在，即形成了多重入口，FIRST(&#039;a&#039;)\\cap FIRST(A)\\neq \\phi；\n\n\n\n::: tip\nLL(1)文法首先是无二义的，其次是不含左递归和消除回溯的。\n:::\n自下向上的语法分析\n自下向上的语法分析与自顶向下的语法分析相比，它无需消除左递归和回溯；\n对某些二义文法，也可以采用自下向上分析方法，因此，自下向上分析的适用范围更大。\n自下而上分析的基本问题\n自下而上分析法就是从输入串开始，逐步进行归约，直到归约到文法的开始符号。\n::: info 归约\n根据文法的产生式规则，把产生式的右部替换成左部符号。\n:::\n自下而上分析法是一种“移进—归约”法，这是因为在自下而上分析过程中采用了一个先进后出的分析栈。\n把输入符号自左至右逐个移进分析栈，并且边移入边分析，一旦栈顶的符号串形成某个句型的句柄就进行一次归约，即用相应产生式的左部非终结符替换当前句柄。\n接下来继续查看栈顶是否形成新的句柄，若为句柄则再进行归约；若栈顶不是句柄则继续向栈中移进后续输入符号。不断重复这一过程，直到将整个输入串处理完毕。\n若此时分析栈只剩有文法的开始符号则分析成功，即确认输入串是文法的一个句子；否则，即认为分析失败。\n\n短语\n\nwww.bilibili.com/video/BV11t411V74n\n\n\n\n短语\n设 \\alpha A \\delta 是文法G[s]的一个句型，如果有：S\\Rightarrow ^* \\alpha A\\delta且A\\Rightarrow ^+\\beta\n则称\\beta是句型\\alpha \\beta \\delta关于非终结符A的一个短语，或称\\beta是\\alpha \\beta \\delta的一个短语。\n特别是有A\\to \\beta产生式时，\\beta为句型\\alpha \\beta \\delta的一个直接短语或简单短语。\n\n例：文法G(E) ： E \\to i | E+E | E*E | (E)\n\n由E\\Rightarrow ^*E+E*E\\Rightarrow E+E*i，可知i是E+E*i的一个短语，并且是直接短语。\n由E\\Rightarrow ^*E+E\\Rightarrow ^+ E+E*i，可知E*i是E+E*i的一个短语，但不是直接短语。\nE+E*i是E+E*i自身的短语。\n\n\n\n\n句柄\n一个句型的最左直接短语称为该句型的句柄。\n一个句型的直接短语可能不止一个，但最左直接短语则是唯一。\n\n\n素短语\n素短语是指这样一种短语，它至少包含一个终结符，并且除自身之外，不再包含其它更小的素短语。\n最左素短语则是指处于句型最左边的那个素短语。\n\n\n语法树的某个内部结点连同它的所有后代组成了一棵子树，只含有单层分枝的子树称为简单子树。\n子树与短语的联系十分密切，在子树中\n\n\n短语\n子树的末端结点组成的符号串是相对于子树根的短语；\n由内部结点向下生长的全部树叶自左至右的排列。\n每个内部结点都有一个短语，也可能多个内部结点的短语是同一个。\n\n\n直接短语\n简单子树的末端结点组成的符号串是相对于简单子树根的直接短语；\n内部结点直接一步生长出来的结点全部由树叶组成（即以该内部结点为根的子树是简单子树），该全部树叶自左至右的排列即为直接短语。\n\n\n句柄\n最左简单子树的末端结点组成的符号串为句柄；\n\n\n素短语\n子树的末端结点组成的含终结符的符号串，且在该子树中不再含有终结符的更小子树。\n\n\n\n\n::: tip 比较\n\n直接短语是在短语的基础上增加了只能向下生长一步且向下生长一步所产生的结点都是树叶结点这一限制；\n句柄是在直接短语的基础上增加了“最左”这一限制；\n\n:::\n规范归约\n假定\\alpha是文法 G 的一个句子，有一个序列 \\alpha _n,\\alpha _n-1,\\cdots,\\alpha _0，如果此序列满足：\n\n\\alpha _n = a\n\\alpha _0 =S，S是文法的开始符号\n对任何 i， 0 \\leqslant i \\leqslant n ，\\alpha _{i-1} 是从 \\alpha _i 经把句柄替换成为相应产生式左部符号而得到的\n\n则称次序列是\\alpha的一个规范归约。\n由规范推导推出的句型称为规范句型。\n::: tip 为什么要叫规范归约\n因为规范归约得到的分析树一定是与语法树一致的。\n:::\n算符优先分析法\n考虑二义文法文法 G(E)：E \\to i| E+E|E-E|E*E|E/E|(E)，它的句子有几种不同的规范归约。\n\n\n\n归约即计算表达式的值。归约顺序不同， 则计算的顺序也不同，结果也不一样。\n如果规定算符的优先次序，并按这种规定进行归约，则归约过程是唯一的。所谓算符优先分析法就是定义算符 ( 终结符 ) 之间的某种优先关系，借助于这种关系寻找“可归约串”和进行归约。起决定作用的是相继两个算符 ( 终结符 ) 之间的优先关系。\n定义任何两个可能相继出现的终结符 a 与 b 的三种优先关系：\n\n𝑎 ⋖ 𝑏：𝑎 的优先级低于 𝑏\n𝑎 ≖ 𝑏：𝑎 的优先级等于 𝑏\n𝑎 ⋗ 𝑏：𝑎 的优先级高于 𝑏\n\n::: tip\na⋖b 并不意味着 b⋗a ，如( ⋖ + 和 + ⋖ (\n:::\n算符优先文法\n一个文法，如果它的任一产生式的右部都不含两个相继 ( 并列 ) 的非终结符，即不含 ...QR... 形式的产生式右部，则我们称该文法为算符文法。\n\n::: tip\n算符优先文法首先应是一个算符文法。\n:::\n算符优先关系表\n如果能把终结符之间的优先关系都找出来，那么我们就能得到一张二维表。\n\n构造优先关系表\n\n为了找出所有满足关系“ ⋖ ”和“ ⋗ ”的终结符对，我们需要对 G[S]的每个非终结符 P 构造两个集合 FIRSTVT(P)和 LASTVT(P)：\n\n::: tip\n与 LL(1)文法相比，\n\nFIRST(A)是推导出的第一个终结符集，而 FIRSTVT 是首先遇到的终结符集；\nFOLLOW(A)是指紧跟非终结符 A 后的终结符集，而 LASTVT 是最后遇到的终结符集。\n\n:::\nFIRSTVT 集的构造方法：\n\nLASTVT 集的构造方法：\n\n\n其它例子：www.bilibili.com/video/BV11t411V74n\n\n\n\n\n\n\n算符优先分析算法的设计\n由于算符优先分析法不是一种规范归约的分析方法，它仅在终结符之间定义了优先关系而未对非终结符定义优先关系，这样就无法使用优先关系表去识别由单个非终结符组成的可归约串。\n因此，算符优先分析法实际上不是用句柄来刻画“可归约串”，而是用最左素短语来刻画“可归约串”。\n\n查找最左素短语的方法：\n\n\n最左子串法\n\n\n\n语法树法\n\n\n\n算符优先分析法特点\n\n优点 : 简单，快速；\n缺点 : 可能错误接受非法句子，能力有限；\n\n优先函数\n用优先关系表来表示每对终结符之间的优先关系时，存在的缺点是存储量大、查找费时。\n因此使用优先函数，对终结符 a、b 之间的优先关系比较转换为两个优先函数值的比较。好处是节省空间和便于进行比较运算。\n\n::: tip\n\n\n对应一个优先关系表的优先函数不是惟一的；只要存在一对，就存在无穷多对。\n\n\n许多优先关系表不存在对应的优先函数。\n\n\n\n::\n根据优先关系表构造优先函数的两种方法：\n\n\n关系图法\n\n\n\n直接构造\n\n\n\nLR 分析法\nLR 分析法是一种自底向上进行规范归约的语法分析方法，LR 指“自左向右扫描和自底向上进行归约”。\nLR 分析法的一个主要缺点是，若用手工构造分析器则工作量相当大，因此必须求助于自动产生 LR 分析器的产生器。\nLR 分析器的工作原理\n规范归约的关键问题是寻找句柄 。\nLR 分析方法：把已移入符号栈的内容及根据产生式推测未来可能遇到的输入符号综合抽象成状态；由栈顶的状态和现行的输入符号唯一确定每一步工作。\n\nLR 分析器的核心是一张分析表\n\n\nACTION[s, a]：当状态 s 面临输入符号 a 时 ，应采取什么动作。\nGOTO[s, X]：状态 s 面对文法符号 X 时，下一状态是什么。\ns_j：移进，指把下一状态 j 和现行输入符号 a 移进栈，下一输入符号变成现行输入符号。\nr_j：归约，指按文法的第 j 个产生式进行归约；\nacc：表示分析成功；\n空白格：出错\n\n\n输入串 i+i*i 的归约过程用语法树表示，如下图所示。\n\n从分析过程可以看出，每次归约恰好是语法树中的句柄，这种归约过程实际上就是修剪语法树的过程，直到归约到树根（也即文法开始符 E）为止。\n因此，LR 分析法解决了在语法分析过程中寻找每一次归约的句柄问题。\n\n我们主要关心的问题是如何由文法构造 LR 分析表。\n对于一个文法，如果能够构造一张分析表，使得它的每个入口均是惟一确定的，则称这个文法为LR 文法。\n一个文法如果能用一个每步最多向前检查 k 个输入符号的 LR 分析器进行分析，则这个文法就称为LR(k)文法。\n对于一个文法，如果它的任何“移进—归约”分析器都存在这样的情况：尽管栈的内容和下一个输入符号都已了解，但仍无法确定是“移进”还是“归约”，或者无法从几种可能的归约中确定其一，则该文法是非 LR(1)的。\n::: tip\nLR 文法肯定是无二义的，一个二义文法决不会是 LR 文法；但是，LR 分析技术可以进行适当修改以适用于分析一定的二义文法。\n:::\n介绍四种分析表的构造方法，它们是：\n\nLR(0)表构造法：这种方法局限性很大，但它是建立一般 LR 分析表的基础。\nSLR(1)表(即简单 LR 表)构造法：这种方法较易实现又极有使用价值。\nLR(1)表(即规范 LR 表)构造法：这种表适用大多数上下文无关文法，但分析表体积庞大。\nLALR 表(即向前 LR 表)构造法：该表能力介于 SLR(1)和 LR(1)之间。\n\nLR(0)分析器\nLR(0)项目集规范族的构造\n\n字的前缀，是指该字的任意首部，例如字 abc 的前缀有 ε、a、ab 或 abc。\n活前缀，是指规范句型的一个前缀，这种前缀不含句柄之后的任何符号。\n\n在 LR 分析工作过程中的任何时候，栈里的文法符号(自栈底而上)X_1X_2...X_m应该构成活前缀，把输入串的剩余部分匹配于其后即应成为规范句型（如果整个输入串确为一个句子的话）。\n规范归约过程中，保证分析栈中总是活前缀 ，就说明分析采取的移进—归约动作是正确的。\n\n项目表示我们在分析过程中看到了产生式多大部分。\n文法 G 的每个产生式的右部添加一个圆点称为 G 的 LR(0)项目。\n\n圆点“ · ”指出了分析过程中扫描输入串的当前位置；\n圆点“ · ”前的部分为已经扫描过的符号串，构成了一个活前缀；\n圆点“ · ”后的部分为待扫描的符号串；\n\n\n\n由于产生式的项目与识别 NFA 的状态相对应，因此可以用项目来构造 NFA。\n\n因为在 NFA 中发生状态转换的非终结符 B 不可能由输入串（由终结符组成）提供，而必须由 NFA 的归约来产生，这就要启动另一路 NFA 来识别（归约出）所需要的非终结符 B。\n例如，若非终结符 B 的产生式为B\\to ef，则在含项目A\\to a·Bc的状态中就应加入项目B\\to ·ef，称为 A 的闭包项。也即，要获得非终结符 B，就必须先识别 B 的产生式，这就意味着在识别 A 的 NFA 中嵌入了识别 B 的 NFA。\n\n如果闭包项B\\to ·ef中的 e 是另一个非终结符 R，即闭包项为B\\to ·Rf的话，则B\\to ·Rf仍然是一个待约项目，也即在图中还应加入识别 R 的闭包项。\n如此下去，不断在同一个状态中加入闭包项直至没有新的“待约项”出现为止。这样，就把识别活前缀的 NFA 确定化，形成了一个识别产生式的 DFA，此时的状态也可能不再是含有一个项目，而是含有多个项目，我们称其为项目集。\n构成识别一个文法活前缀的 DFA 的项目集（状态）的全体称为这个文法的 LR(0) 项目集规范族。\n\n\n\nLR(0)分析表的构造\n::: tip 拓广文法\n\n:::\n假若一个文法 G 的拓广文法 G‘ 的活前缀识别自动机中的每个状态 ( 项目集 ) 不存在下述情况：\n\n既含移进项目又含归约项目\n含有多个归约项目\n\n则称 G 是一个 LR(0) 文法。\n对于 LR(0)文法，我们可直接从它的项目集规范族 C 和活前缀自动机的状态转换函数 GO 构造出 LR 分析表。\n\n\n由于假定 LR(0)文法规范族的每个项目集不含冲突项目，因此按上述方法构造的分析表的每个入口都是惟一的(即不含多重定义)。\n我们称如此构造的分析表是一张 LR(0)表，使用 LR(0)表的分析器叫做一个 LR(0)分析器。\n\n &gt; &gt;  &gt; &gt; \n\n项目集的构造原则是：只要紧随在“ · ”之后的符号是非终结符，则该非终结符所有以“ · ”开头的项目全都纳入到该项目集；如果这些新纳入的项目中，又在“ · ”后紧随出现新的非终结符，则这些新的非终结符所有以“· ”开始的项目也全部纳入该项目集。\n::: tip 检查所构造的 DFA 是否完整\n对一个项目集来说，除了归约项目之外，对于其余移进项目，“ · ”之后有多少个不同的首字符(包括非终结符)，就要引出多少条有向边到不同的项目集(也可能有一条有向边到此项目集自身)。\n:::\n掌握了上述构造原则和方法后，则可在写出拓广文法后就直接画出该文法的 DFA，而无需再列出 LR(0)  的所有项目和构造 LR(0)  项目集规范族。"},"计算机基础/编译原理/5_语义分析与中间代码生成器":{"title":"语义分析与中间代码生成器","links":[],"tags":["编译原理"],"content":"语义分析概述\n一个源程序经过词法分析、语法分析之后，表明该源程序在书写上是正确的，并且符合程序语言所规定的语法。\n\n但是语法分析并未对程序内部的逻辑含义加以分析，因此编译程序接下来的工作是语义分析，即审查每个语法成分的静态语义。\n如果静态语义正确，则生成与该语言成分等效的中间代码，或者直接生成目标代码。\n如同在进行词法分析、语法分析的同时也进行着词法检查、语法检查一样，在语义分析时也必然要进行语义检查。\n\n动态语义检查需要生成相应的目标代码，它是在运行时进行的；\n静态语义检查是在编译时完成的，涉及类型检查、控制流检查、一致性检查；\n\n由于语义是上下文有关的，因此语义的形式化描述是非常困难的，目前较为常见的是用属性文法作为描述程序语言语义的工具，并采用语法制导翻译的方法完成对语法成分的翻译工作。\n属性文法\n属性：与文法符号（终结符或非终结符）的类型和值等有关的一些信息，在编译中用属性描述处理对象的特征。\n文法符号的属性可分为：\n\n\n继承属性\n用于“自顶向下”传递信息。\n继承属性由相应语法树中结点的父结点属性计算得到，即沿语法树向下传递，由根结点到分枝（子）结点，它反映了对上下文依赖的特性。继承属性可以很方便地用来表示程序语言上下文的结构关系。\n\n\n综合属性\n用于“自底向上”传递信息。\n综合属性由相应语法分析树中结点的分枝结点（即子结点）属性计算得到，其传递方向与继承属性相反，即沿语法分析树向上传递，从分枝结点到根结点。\n\n\n\n属性文法也称属性翻译文法。\n属性文法它将文法符号的语义以“属性”的形式附加到各个文法的符号上，再根据产生式所包含的含义，给出每个文法符号属性的求值规则，从而形成一种带有语义属性的上下文无关文法，即属性文法。\n在上下文无关文法的基础上，为每个文法符号（终结符或非终结符）配备若干相关的“值”（称为属性）\n属性代表与文法符号相关信息，如类型、值 、代码序列、符号表内容等\n属性可以进行计算和传递\n语义规则：对于文法的每个产生式都配备了一组属性的计算规则\n语法制导翻译\n语法制导翻译的方法就是为每个产生式配上一个翻译子程序(称语义动作或语义子程序)，并在语法分析的同时执行这些子程序。\n语义动作是为产生式赋予具体意义的手段，它一方面指出了一个产生式所产生的符号串的意义，另一方面又按照这种意义规定了生成某种中间代码应做哪些基本动作。在语法分析过程中，当一个产生式获得匹配(对于自顶向下分析)或用于归约(对于自底向上分析)时，此产生式相应的语义子程序就进入工作，完成既定的翻译任务。\n语法制导翻译分为自底向上语法制导翻译和自顶向下语法制导翻译，我们重点介绍自底向上语法制导翻译。\n几种常见的中间语言\n抽象语法树\n抽象语法树也称图表示，是一种较为流行的中间语言表示形式。\n在抽象语法树表示中，每一个叶结点都表示诸如常量或变量这样的运算对象，而其它内部结点则表示运算符。抽象语法树不同于前述的语法树，它展示了一个操作过程并同时描述了源程序的层次结构。\n注意：语法规则中包含的某些符号可能起标点符号作用也可能起解释作用。如赋值语句语法规则：\n逆波兰表示法"},"计算机基础/计算机操作系统/1_操作系统概述":{"title":"操作系统概述","links":["计算机基础/计算机组成原理/7_IO系统"],"tags":["操作系统"],"content":"操作系统的概念\n操作系统（Operating System，OS）是指控制和管理整个计算机系统的硬件与软件资源，合理地组织、调度计算机的工作与资源的分配，进而为用户和其他软件提供方便接口与环境的程序集合。操作系统是计算机系统中最基本的系统软件。\n\n操作系统的特征\n\n并发\n并发：指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，微观上是交替发生的。\n操作系统的并发性：指计算机系统中同时存在多个运行的程序，这些程序宏观上看是同时发生的，微观上看是交替发生的。\n\n\n                  \n                  同一时间间隔（并发）和同一时刻（并行）的区别 \n                  \n                \n\n并行: 在同一时刻能完成两种或两种以上的工作。\n\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n单核 CPU 同一时刻只能执行一个程序，各个程序只能并发执行；\n多核 CPU 同一时刻可以执行多个程序，多个程序可以并行执行（运行程序数量要小于核的数量）；\n\n\n共享\n共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。\n\n\n\n                  \n                  共享和并发的关系 \n                  \n                \n\n\n资源共享是以程序的并发为条件的，若系统不允许程序并发执行，则不存在资源共享问题；\n若系统不能对资源共享实施有效的管理，则必将影响到程序的并发执行，甚至根本无法并发执行。\n\n\n\n\n虚拟\n虚拟：指把一个物理上的实体变为若干逻辑上的对应物。前者是实际存在的；而后者是用户感觉上的事物。\n用于实现虚拟的技术，称为虚拟技术。\n\n\n虚拟处理器\n利用多道程序设计技术把一个物理上的 CPU 虚拟为多个逻辑上的 CP。\n\n\n虚拟存储器\n采用虚拟存储器技术将一台机器的物理存储器变为虚拟存储器，从逻辑上扩充存储器的容量，此时用户感觉到的存储器（实际不存在）称为虚拟存储器。\n\n\n\n异步\n多道程序环境允许多个程序并发执行，但由于资源有限，进程的执行并不是一贯到底的，而是走走停停的，它以不可预知的速度向前推进，这就是进程的异步性。\n异步性使得操作系统运行在一种随机的环境下，可能导致进程产生与时间有关的错误（就像对全局变量的访问顺序不当会导致程序出错一样）。但只要运行环境相同，操作系统就须保证多次运行进程后都能获得相同的结果。\n\n只有系统拥有并发性，才有可能导致异步性。\n\n操作系统的目标和功能\n计算机系统资源的管理者\n\n\n\n处理机管理\n在多道程序环境下，处理机的分配和运行都以进程（或线程）为基本单位，因而对处理机的管理可归结为对进程的管理。\n\n\n存储器管理\n存储器管理是为了给多道程序的运行提供良好的环境，方便用户使用及提高内存的利用率。\n\n\n文件管理\n计算机中的信息都是以文件的形式存在的，操作系统中负责文件管理的部分称为文件系统。\n\n\n设备管理\n设备管理的主要任务是完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。\n\n\n用户与计算机硬件系统之间的接口\n\n操作系统提供的接口主要分为两类：\n\n\n命令接口\n用户利用这些操作命令来组织和控制作业的执行。\n\n\n联机命令接口（交互式命令接口）\n\n\n\n脱机命令接口（批处理命令接口）\n\n\n\n\n\n程序接口（也称系统调用）\n系统调用是操作相同的一部分，是内核为用户提供的程序接口，运行在内核空间中。\n用户通过在程序中使用这些系统调用来请求操作系统为其提供服务。\n普通用户不能直接使用程序接口，只能通过代码间接使用。\n\n\n未使用系统调用的库函数执行效率通常要比系统调用更高，因为使用系统调用时需要上下文的却换和状态的转换。\n\n\n\n对计算机资源的扩充\n\n操作系统发展历程\n\n手工操作阶段\n此阶段无操作系统。\n缺点：\n\n用户独占全机，虽然不会出现因资源已被其他用户占用而等待的现象，但资源利用率低。\nCPU 等待手工操作，CPU 的利用不充分。\n\n\n批处理阶段\n操作系统开始出现。\n为了解决人机矛盾及 CPU 和 I/O 设备之间速度不匹配的矛盾。\n单道批处理系统\n系统对作业的处理是成批进行的，但内存中始终保持一道作业。\n\n主要特征：\n\n\n自动性：在顺利的情况下，磁带上的一批作业能自动地逐个运行，而无须人工干预。\n\n\n顺序性：磁带上的各道作业顺序地进入内存，各道作业的完成顺序与它们进入内存的顺序在正常情况下应完全相同，亦即先调入内存的作业先完成。\n\n\n单道性：内存中仅有一道程序运行，即监督程序每次从磁带上只调入一道程序进入内存运行，当该程序完成或发生异常情况时，才换入其后继程序进入内存运行。\n\n\n\n多道批处理系统\n多道程序设计技术允许多个程序同时进入内存并允许它们在 CPU 中交替地运行，这些程序共享系统中的各种硬/软件资源。\n当一道程序因 I/O 请求而暂停运行时，CPU 便立即转去运行另一道程序，即多道批处理系统的 I/O 设备可与 CPU 并行工作（借助中断技术）。\n主要特征：\n\n\n多道：计算机内存中同时存放多道相互独立的程序。\n\n\n宏观上并行：同时进入系统的多道程序都处于运行过程中，即它们先后开始各自的运行, 但都未运行完毕。\n\n\n微观上串行：内存中的多道程序轮流占有 CPU，交替执行。\n\n\n\n分时操作系统\n分时技术：把处理器的运行时间分成很短的时间片，按时间片轮流把处理器分配给各联机作业使用。若某个作业在分配给它的时间片内不能完成其计算，则该作业暂时停止运行，把处理器让给其他作业使用，等待下一轮再继续运行。\n分时操作系统：多个用户通过终端同时共享一台主机，这些终端连接在主机上，用户可以同时与主机进行交互操作而互不干扰。\n主要特征：\n\n\n同时性: 同时性也称多路性，指允许多个终端用户同时使用一台计算机。\n\n\n交互性: 用户能够方便地与系统进行人机交互。\n\n\n独立性: 系统中多个用户可以彼此独立地进行操作，互不干扰。\n\n\n及时性: 用户请求能在很短时间内获得响应。\n\n\n优点：用户请求可以被即使响应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立。\n缺点：不能优先处理一些紧急任务。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业时间片，不区分任务的紧急性。\n实时操作系统\n\n为了能在某个时间限制内完成某些紧急任务而不需要时间片排队。\n\n实时操作系统可以分为：\n\n\n硬实时系统: 某个动作必须绝对地在规定的时刻（或规定的时间范围）发生，如导弹控制系统。\n\n\n软实时系统: 能够接受偶尔违反时间规定且不会引起任何永久性的损害，如订票系统。\n\n\n在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并在严格的时限内处理完接收的事件。\n实时操作系统的主要特点是及时性和可靠性。\n其他操作系统\n\n操作系统运行环境\n操作系统运行机制\n\n在计算机系统中，通常 CPU 执行两种不同性质的程序：\n\n内核程序：操作系统中的一个核心组件，它是操作系统的主要部分之一，负责管理计算机的硬件资源和提供对这些资源的访问。\n应用程序：一种计算机程序，旨在执行特定的任务、功能或目的，以满足用户的需求。应用程序通常运行在操作系统之上，利用操作系统提供的服务和资源来完成各种任务。\n\n\n\n                  \n                  内核 \n                  \n                \n\n操作系统内核（内核）是由很多内核程序组成的。内核是操作系统最重要最核心的部分，也是最接近硬件的部分。\n操作系统的功能未必都在内核中，如图形化用户界面 GUI。\n\n\n\n\n                  \n                  特权指令和非特权指令 \n                  \n                \n\n\n特权指令：不允许用户直接使用的指令，如 I/O 指令、关中断指令，存取用于内存保护的寄存器、送程序状态字到程序状态字寄存器等的指令。\n非特权指令：允许用户直接使用的指令，为了防止用户程序对系统造成破坏，它不能直接访问系统中的软硬件资源，仅限于访问用户的地址空间。\n\n\n\n\n将 CPU 的运行模式划分为用户态（目态）和核心态（又称管态、内核态）。应用程序运行在用户态，操作系统内核程序运行在核心态。\n\n处于核心态时，说明此时运行的是内核程序，此时可以执行特权指令；\n处于用户态时，说明此时运行的是应用程序，此时只能执行非特权指令；\n\n\n\n                  \n                  CPU 如何分辨出当前是应用程序还是内核程序？ \n                  \n                \n\nCPU 内部有一个程序状态字寄存器（PSW），其中有个二进制位，用 1/0 表示当前是核心态还是用户态。\n\n\n\n\n内核是计算机上配置的底层软件，它管理着系统的各种资源，可以看作是连接应用程序和硬件的一座桥梁，大多数操作系统的内核包含一下 4 方面的内容：\n\n\n时钟管理\n在计算机的各种部件中，时钟是最关键的设备。通过时钟管理，向用户提供标准的系统时间。通过时钟中断的管理，可以实现进程的切换。\n\n时钟中断的主要工作是处理和时间有关的信息及决定是否执行调度程序。和时间有关的所有信息包括系统时间、进程的时间片、延时、使用 CPU 的时间、各种定时器。\n\n\n\n中断机制\n引入中断机制的初衷是提高多道程序运行时的 CPU 利用率，使 CPU 可以在 I/O 操作期间执行其他指令。\n操作系统各项操作的基础，如进程的管理和调度、系统功能的调用、设备驱动、文件访问等都依赖于中断机制。\n\n\n原语\n按层次结构设计的操作系统，底层必然是一些可被调用的公用小程序，它们各自完成一个规定的操作。\n特点：\n\n处于操作系统的最底层，是最接近硬件的部分。\n运行具有原子性，出于系统安全性和便于管理考虑其操作只能一气呵成。\n运行时间都较短，而且调用频繁。\n\n具有这些特点的程序称为原语。\n\n\n系统技制的数据结构及处理\n系统中用来登记状态信息的数据结构很多，如消息队列、缓冲区、内存分配表等。\n为了实现有效的管理，系统需要一些基本的操作，常见的操作有以下 3 种：\n\n进程管理：进程状态管理、进程调度和分派、创建与撤销进程控制块等。\n存储器管理：存储器的空间分配和回收、内存信息保护程序、代码对换程序等。\n设备管理：缓冲区管理、设备分配和回收等。\n\n\n\n\n核心态指令实际上包括系统调用类指令和一些针对时钟、中断和原语的操作指令。\n\n中断和异常的概念\n操作系统是中断驱动的，OS 总在等待某个事件的发生，事件总是由中断或异常引起的。\n\n定义\n\n\n中断：由硬件引起。也称外中断，是指来自 CPU 执行指令外部的事件。如设备发出的 I/O 结束中断，表示设备输入/输出处理已经完成，希望处理机能够向设备发出下一个输入/输出请求，同时让完成输入/输出后的程序继续运\n行。\n\n\n异常：由软件引起。也称内中断，是指来自 CPU 执行指令内部的事件。如程序的非法操作码、地址越界、运算溢出等引起的事件。\n\n\n分类\n\n\n\n                  \n                  外中断分类 \n                  \n                \n\n\n可屏蔽中断：通过 INTR 线发出的中断请求。\n不可屏蔽中断：通过 NMI 线发出的中断请求，通常是紧急的硬件故障，如电源掉电等。\n\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n外部中断发生在用户态，在核心态完成中断处理过程。\n\n\n处理过程\n\n配合 程序中断方式 理解\n\n当 CPU 执行到第 i 条指令时检测到异常事件，或执行完该条指令后发现中断请求信号，CPU 当断当前用户程序，调用相应的中断或异常处理程序。\n\n\n若中断或异常处理程序能够解决相应的问题，则在中断或异常处理程序的最后，CPU 通过执行中断或异常返回指令，回到被打断的用户程序的第 i 条指令或第 i+1 条指令继续执行；\n\n异常指令通常并没有执行成功，异常处理后要重新执行，所以异常断点通常是当前指令的地址，中断的断点则是下一条指令的地址。\n\n\n\n若中断或异常处理程序发现是不可恢复的致命错误，则终止用户程序。\n\n\n\n当 CPU 检测到中断信号后，中断程序的断点[程序计数器(PC)和程序状态字寄存器(PSW)]是由硬件自动保存，而不是操作系统。\n\n\n\n中断向量表采用数组作为存储结构。\n\n\n\n                  \n                  Note\n                  \n                \n\n外部中断处理过程，PC 值由中断隐指令自动保存，而通用寄存器内容由操作系统保存。块表(TLB)和 Cache 中的内容则由硬件机构保存。\n\n\n\n\n                  \n                  调用中断处理程序 和 调用子程序 的区别 \n                  \n                \n\n\n\n中断处理程序与被中断的当前程序是相互独立的，它们之间没有确定的关系；子程序与主程序是同一程序的两部分，它们属于主从关系。\n\n\n通常中断的产生都是随机的；而子程序调用是通过调用指令引起的，是由程序设计者事先安排的。\n\n\n中断处理的过程还需要有专门的硬件电路才能实现；而调用子程序的过程完全属于软件处理过程。\n\n\n中断处理程序的入口地址可由硬件向量法产生向量地址，再由向量地址找到入口地址；子程序的入口地址是由 CALL 指令中的地址码给出的。\n\n\n调用中断处理程序和子程序都需要保护程序计数器(PC)的内容。\n\n\n只有中断处理程序才会保存状态字寄存器(PSW)的内容，子程序不会保存。\n\n子程序调用不改变程序的状态，因为子程序调用是编译器可控流程，而中断不是。以程序if(a==b)为例，它通常包含一条测试指令，以及一条根据标志位决定是否需要跳转来调用子程序的指令。执行if(a==b)时，会进行 a-b 操作，并生成相应的标志位，进而根据标志位来判断是否发生跳转。\n假设刚好在生成相应的标志位后发生了中断，若不保存 PSW 的内容，则后续根据标志位来进行跳转的流程就可能发生错误。\n但是，若进行了子程序调用，则说明已经根据 a-b 的标志位进行了跳转，此时 PSW 的内容已无意义而无须保存。\n综上所述，中断处理和子程序调用都有可能使 PSW 的内容发生变化，但中断处理程序执行完返回后，可能需要用到 PSW 原来的内容，子程序执行完返回后，一定不需要用到 PSW 原来的内容。\n\n\n\n响应中断时，需对同时检测到的多个中断请求进行裁决，而调用子程序时没有这种操作。\n\n\n\n\n系统调用\n\n定义\n系统调用是指用户在程序中调用操作系统所提供的一些子功能，可视为特殊的公共子程序。换句话说，系统调用是由用户进程发起的，请求操作系统的服务。\n\n\n                  \n                  注意操作系统完成与系统调用完成的区别 \n                  \n                \n\n\n页置换，内存中的空闲页框不够时，操作系统会将某些页面调出，并将要访问的页面调入，这个过程完全由操作系统完成，不涉及系统调用。\n进程调度完全由操作系统完成，无法通过系统调用完成。\n\n以上两者都是操作系统自动完成的，因为用户进程不会涉及页置换和进程调度。\n\n\n在用户程序中，凡是与资源有关的操作（如存储分配、进行 I/O 传输及管理文件等），都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。\n系统调用按功能大致可分为如下几类：\n\n设备管理：完成设备的请求或释放，以及设备启动等功能；\n文件管理：完成文件的读、写、创建及删除等功能；\n进程控制：完成进程的创建、撤销、阻塞及唤醒等功能；\n进程通信：完成进程之间的消息传递或信号传递等功能；\n内存管理：完成内存的分配、回收以及获取作业占用内存区大小及始址等功能；\n\n\n\n                  \n                  系统调用和库函数的区别 \n                  \n                \n\n\n\n\n执行过程\n\n\n                  \n                  Note\n                  \n                \n\n发生系统调用时，CPU 通过执行软中断指令将 CPU 的运行状态从用户态切换到内核态，这个过程与中断和异常的响应过程相同，由硬件负责保存断点和程序状态字，并将 CPU 模式从用户态改为内核态（都由硬件完成）。\n然后，执行操作系统内核的系统调用入口程序，该内核程序负责保存通用寄存器的内容，再调用执行特定的系统调用服务例程（都由操作系统完成）。\n\n\n\n传递系统调用参数：用户程序首先将系统调用号和所需的参数压入堆栈；\n执行陷入(trap)指令：调用实际的调用指令，然后执行一个陷入指令，将 CPU 状态从用户态转为核心态，再后由硬件和操作系统内核程序保护被中断进程的现场，将程序计数器(PC)、程序状态字(PSW)及通用寄存器内容等压入堆栈。\n执行相应的服务程序：分析系统调用类型，转入相应的系统调用处理子程序。在系统中配置了一张系统调用入口表，表中的每个表项都对应一个系统调用，根据系统调用号可以找到该系统调用处理子程序的入口地址。\n返回用户态：在系统调用处理子程序执行结束后，恢复被中断的或设置新进程的 CPU 现场，然后返回被中断进程或新进程，继续往下执行。\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内中断，使CPU进入核心态。\n系统调用发生在用户态，被调用程序在核心态下执行。\n\n\n\n\n                  \n                  Note\n                  \n                \n\n用户程序可以执行陷入指令来发起系统调用，请求操作系统提供服务。\n用户程序执行“陷入指令”，相当于把 CPU 的使用权主动交给操作系统内核程序（CPU 状态会从用户态进入核心态），之后操作系统内核程序再对系统调用请求做出相应处理。处理完成后，操作系统内核程序又会把 CPU 的使用权还给用户程序（即 CPU 状态会从核心态回到用户态）。\n这样设计的目的是保证系统的稳定性和安全性，防止用户程序随意更改或访问重要的系统资源，影响其他进程的运行。\n\n\n这样，操作系统的运行环境就可以理解为：用户通过操作系统运行上层程序，而这个上层程序的运行依赖于操作系统的底层管理程序提供服务支持\n\n当需要管理程序服务时，系统则通过硬件中断机制进入核心态，运行管理程序。\n当程序运行出现异常情况，被动地需要管理程序的服务，这时就通过异常处理来进入核心态。\n\n管理程序运行结束时，用户程序需要继续运行，此时通过相应的保存的程序现场退出中断处理程序或异常处理程序，返回断点处继续执行。\n\n一些用户态转向核心态的例子\n\n用户程序要求操作系统的服务，即系统调用，例如 read 系统调用；\n发生一次中断，例如进行了整数除以 0 的操作（需要中断进行处理）；\n用户程序中产生了一个错误状态；\n用户程序中企图执行一条特权指令；\n从核心态转向用户态由一条指令实现，这条指令也是特权命令，一般是中断返回指令；\n\n\n\n                  \n                  Tip\n                  \n                \n\n由用户态进入核心态，不仅状态需要切换，而且所用的堆栈也可能需要由用户堆栈切换为系统堆栈、但这个系统堆栈也是属于该进程的。\n\n\n操作系统结构\n\n分层法\n分层法是将操作系统分为若干层，在低层上构建高层。最底层（层 0）为硬件，最高层（层 N）为用户接口。高层仅依赖于紧邻它的底层。\n\n优点：\n\n易保证系统的准确性。\n易扩充和易维护。\n\n缺点：\n\n合理定义各层比较困难。\n效率较差。\n\n模块化\n模块化是将操作系统按功能划分为若干具有一定独立性的模块。每个模块具有某方面的管理功能，并规定好各模块间的接口，使各模块之间能够通过接口进行通信。还可以进一步将各模块细分为若干具有一定功能的子模块，同样也规定好各子模块之间的接口。\n\n划分模块时，\n\n\n模块不能划分得太小，也不能划分得过大。\n\n\n要充分考虑模块的独立性问题。\n衡量模块的独立性主要有两个标准：\n\n内聚性：模块内部各部分间联系的紧密程度。内聚性越高，模块独立性越好；\n耦合度：模块间相互联系和相互影响的程度。耦合度越低，模块独立性越好；\n\n\n\n优点：\n\n提高了操作系统设计的正确性、可理解性和可维护性；\n增强了操作系统的可适应性；\n加速了操作系统的开发过程；\n\n缺点：\n\n模块间的接口规定很难满足对接口的实际需求；\n各模块设计者齐头并进, 每个决定无法建立在上一个己验证的正确决定的基础上，因此无法找到一个可靠的决定顺序。\n\n内核\n内核是操作系统最基本、最核心的部分。实现操作系统内核功能的程序就是内核程序。\n\n\n由上图可以引出内核的两种设计方法\n\n把所有功能都包含在操作系统内核中的就叫宏内核；\n只保留与硬件关系最紧密的部分就叫微内核；\n\n换句话说，从操作系统的内核架构来划分，可分为宏内核和微内核。\n宏内核\n宏内核，也称单内核或大内核，是指将系统的主要功能模块都作为一个紧密联系的整体运行在核心态，从而为用户程序提供高性能的系统服务。\n微内核\n微内核构架，是指将内核中最基本的功能保留在内核，而将那些不需要在核心态执行的功能移到用户态执行，从而降低内核的设计复杂性。\n在进行操作系统结构设计时，大多采用基于客户/服务器模式的微内核结构，将操作系统划分为两大部分：微内核和多个服务器。\n微内核基本概念：\n\n\n足够小的内核\n内核是指精心设计的、能实现操作系统最基本核心功能的小型内核。\n微内核不是一个完整的 OS，而只是将操作系统中最基本的部分放入微内核，通常包含：与硬件处理紧密相关的部分、一些较基本的功能、客户和服务器之间的通信。\n\n\n基于客户/服务器模式\n客户与服务器之间是借助微内核提供的消息传递机制来实现信息交互的。\n\n\n\n应用“机制与策略分离”原理\n机制：实现某一功能的具体执行结构；\n策略：在进制的基础上借助于某些参数和算法来实现功能的优化，或达到不同的功能目标；\n\n\n采用面向对象技术\n\n\n\n在微内核结构中，为了实现高可靠性，只有微内核运行在内核态，其余模块都运行在用户态， 一个模块中的错误只会使这个模块崩溃，而不会使整个系统崩溃。\n\n例如，文件服务代码运行时出了问题，\n\n宏内核的文件服务是运行在内核态的，系统会直接崩溃。\n微内核的文件服务是运行在用户态的，只要把文件服务功能强行停止，然后重启，就可以继续使用，系统不会崩溃。\n\n\n\n微内核的基本功能：\n\n进程（线程）管理；\n低级存储器管理；\n中断和陷入处理；\n\n微内核系统优点：\n\n较强的可扩展性\n较高的可靠性\n较高的安全性\n可移植性强\n\n微内核结构的主要问题是性能问题，因为要频繁地在核心态和用户态之间进行切换。\n宏内核和微内核比较\n\n\n外核\n在底层中，一种称为外核（exokemel）的程序在内核态中运行。它的任务是为虚拟机分配资源，并检查使用这些资源的企图，以确保没有机器会使用他人的资源。每个用户层的虚拟机可以运行自己的操作系统，但限制只能使用已经申请并且获得分配的那部分资源。\n\n优点：\n\n减少了映射层。在其他的设计中，每个虚拟机都认为它有自己的磁盘，虚拟机监控程序就必须维护一张表格以重映像磁盘地址，有了外核，这个重映射处理就不需要了。\n将多道程序（在外核内）与用户操作系统代码（在用户空间内）加以分离，而且相应的负载并不重。\n\n操作系统引导\n操作系统引导是指计算机利用 CPU 运行特定程序，通过程序识别硬盘，识别硬盘分区，识别硬盘分区上的操作系统，最后通过程序启动操作系统。\n\n常见操作系统的引导过程如下：\n\n\n激活 CPU\n激活的 CPU 读取 ROM 中的 boot 程序，将指令寄存器置为 BIOS 的第一条指令，即开始执行 BIOS 的指令。\n\n\n硬件自检\nBIOS 程序在内存最开始的空间构建中断向量表，接下来的 POST 过程要用到中断功能。\n然后进行通电自检，检查硬件是否出现故障。如有故障，主板会发出不同含义的蜂鸣，启动中止；如无故障，屏幕会显示 CPU、内存、硬盘等信息。\n\n\n加载带有操作系统的硬盘\n通电自检后，BIOS 开始读取 BootSequence（通过 CMOS 里保存的启动顺序，或者通过与用户交互的方式)，将控制权交给启动顺序排在第一位的存储设备，然后 CPU 将该存储设备引导扇区的内容加载到内存中。\n\n\n加载主引导记录(MBR)\n主引导记录 MBR 的作用是告诉 CPU 去硬盘的哪个主分区去找操作系统。\n硬盘以特定的标识符区分引导硬盘和非引导硬盘。如果发现一个存储设备不是可引导盘，就检查下一个存储设备。如无其他启动设备，就会死机。\n\n\n扫描硬盘分区表，并加载硬盘活动分区\nMBR 包含硬盘分区表，硬盘分区表以特定的标识符区分活动分区和非活动分区。\n主引导记录扫描硬盘分区表，进而识别含有操作系统的硬盘分区（活动分区）。找到硬盘活动分区后，开始加载硬盘活动分区，将控制权交给活动分区。\n\n\n加载分区引导记录(PBR)\n取活动分区的第一个扇区，这个扇区称为分区引导记录，其作用是寻找并激活分区根目录下用于引导操作系统的程序（启动管理器）。\n\n\n加载启动管理器\n分区引导记录搜索活动分区中的启动管理器，加载启动管理器。\n\n\n加载操作系统\n将操作系统的初始化程序加载到内存中执行。\n\n\n虚拟机\n\n\n                  \n                  传统计算机 \n                  \n                \n\n\n\n\n虚拟机：使用虚拟化技术，将一台物理机虚拟化为多台虚拟机器（Virtual Machine，VM），每个虚拟机器都可以独立运行一个操作系统。\n第一类虚拟机管理程序\n\n从技术上讲，第一类虚拟机管理程序就像一个操作系统，因为它是唯一一个运行在最高特权级的程序。\n虚拟机作为用户态的一个进程运行，不允许执行特权指令。\n虚拟机上的操作系统认为自己运行在内核态（实际上不是），称为虚拟内核态。\n当虚拟机操作系统执行了一条特权指令时，\n\n\n在支持虚拟化的 CPU 上\n虚拟机管理程序会检查这条指令是由虚拟机中的操作系统执行的还是由用户程序执行的。如果是前者，虚拟机管理程序将安排这条指令功能的正确执行。否则，虚拟机管理程序将模拟真实硬件面对用户态执行特权指令时的行为。\n\n\n在不支持虚拟化的 CPU 上\n真实硬件不会直接执行虚拟机中的敏感指令，这些敏感指令被转为对虚拟机管理程序的调用，由虚拟机管理程序模拟这些指令的功能。\n\n\n第二类虚拟机管理程序\n\n它是一个依赖于操作系统分配和调度资源的程序，很像一个普通的进程。\n两类虚拟机管理程序的对比\n"},"计算机基础/计算机操作系统/2_进程与线程":{"title":"进程与线程","links":[],"tags":["操作系统"],"content":"前驱图\n前驱图是一个有向无循环图，可记为 DAG，用于描述进程之间执行的先后顺序。\n\n结点表示进程或程序段\n有向边表示两个结点直接存在偏序或前趋关系\n\n程序执行\n程序顺序执行\n一个较大的程序通常都由若干个程序段组成，程序在执行时必须按照某种先后次序逐个执行，仅当前一操作执行完后，才能执行后继操作。\n\n程序并发执行\n采用多道程序技术，将多个程序同时装入内存，使之并发运行。\n\n特征：\n\n\n间断性\n并发程序之间相互制约，执行——暂停执行——执行。\n\n\n失去封闭性\n多个程序共享全机资源，执行状态受外界因素影响。\n\n\n不可再现性\n程序经过多次执行后，虽然其执行时的环境和初始条件都相同，但得到的结果却各不相同。\n\n\n进程\n进程的概念和组成\n在多道程序环境下，允许多个程序并发执行，此时它们将失去封闭性，并具有间断性及不可再现性的特征。\n为此引入了进程(Process)的概念，以便更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性（最基本的两个特性）。\n进程控制块(PCB)\n系统利用进程控制块(Process Control Block，PCB)来描述进程的基本情况和运行状态，进而控制和管理进程。\n\n\nPCB 是进程存在的唯一标志。\n\nPCB 是进程实体的一部分，是进程存在的唯一标志。在进程的整个生命期中，系统总是通过 PCB 对进程进行控制的，即系统唯有通过进程的 PCB 才能感知到该进程的存在。\nPCB 主要包括进程描述信息、进程控制和管理信息、资源分配清单和处理机相关信息等。\n\n在一个系统中，通常存在着许多进程的 PCB，常用链接方式和索引方式将各进程的 PCB 组织起来。\n\n\n链接方式\n\n\n\n索引方式\n\n\n\n程序段、数据段\n由程序段、数据段和 PCB 三部分构成了进程实体（又称进程映像），进程实体反应了进程在某一时刻的状态。\n\n进程映像是静态的，进程则是动态的。\n\n\n程序段就是能被进程调度程序调度到 CPU 执行的程序代码段。程序可被多个进程共享，即多个进程可以运行同一个程序。\n一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果。\n\n\n\n创建进程，实质上是创建进程实体中的 PCB；\n撤销进程，实质上是撤销进程的 PCB；\n\n进程\n典型的定义有：\n\n进程是程序的一次执行过程。\n进程是一个程序及其数据在处理机上顺序执行时所发生的活动。\n进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调 度的一个独立单位。\n\n了解了进程实体的概念后，我们可以把传统操作系统中的进程定义为：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。\n进程的特征\n进程是由多道程序的并发执行而引出的，它和程序是两个截然不同的概念。\n进程的基本特征是对比单个程序的顺序执行提出的，也是对进程管理提出的基本要求。\n\n进程的状态与转换\n\n状态\n进程通常有以下 5 种状态，前 3 种是进程的基本状态，\n\n\n运行态\n进程正在 CPU 上运行。\n\n在单 CPU 中，每个时刻只有一个进程处于运行态。\n\n\n\n\n就绪态\n进程获得了除处理机外的一切所需资源，一旦得到处理机，便可立即运行。\n\n系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。\n\n\n\n阻塞态（等待态）\n进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括 CPU）或等待 I/O 完成。即使 CPU 空闲，该进程也不能运行。\n\n系统通常将处于阻塞态的进程也排成一个队列，甚至根据阻塞原因的不同，设置多个阻塞队列。\n\n\n\n\n创建态\n进程正在被创建，尚未转到就绪态。\n\n创建进程需要多个步骤：\n\n首先申请一个空白 PCB，并向 PCB 中填写用于控制和管理进程的信息；\n然后为该进程分配运行时所必须的资源；\n最后把该进程转入就绪态并插入就绪队列。\n\n如果进程所需的资源尚不能得到满足，如内存不足，则创建工作尚未完成，进程此时所处的状态称为创建态。\n\n\n\n\n终止态\n进程从系统中消失，可能是进程正常结束或其他原因退出运行。\n\n进程需要结束运行时，系统首先将该进程置为终止态，然后进一步处理资源释放和回收等工作。\n\n\n\n\n\n\n                  \n                  就绪态和阻塞态的区别 \n                  \n                \n\n就绪态和等待态是进程生命周期中两个完全不同的状态。\n\n就绪态是指进程仅缺少 CPU，只要获得 CPU 资源就立即运行；\n阻塞态是指进程需要其他资源（除了 CPU）或等待某一事件；\n在分时系统的时间片轮转机制中，每个进程得到 CPU 的时间很短且非常频紧，进程在运行过程中实际上是频繁地转换到就绪态；而其他资源的使用和分配或某一事件的发生（如 I/O 完成）对应的时间相对来说很长，进程转换到阻塞态的次数也相对较少。\n这样来看，就绪态和阻塞态是进程生命周期中两个完全不同的状态。\n\n\n\n状态之间的转换\n\n\n就绪态\\to运行态\n处于就绪态的进程被调度后，获得 CPU 资源（分派 CPU 的时间片）。\n\n\n运行态\\to就绪态\n\n处于运行态的进程在时间片用完后，不得不让出 CPU，从而进程由运行态转换为就绪态。\n当有更高优先级的进程就绪时，调度程序将正在执行的进程转换为就绪态，让更高优先级的进程执行。\n\n\n\n运行态\\to阻塞态\n进程请求某一资源的使用和分配或等待某一事件的发生（如 I/O 操作的完成）时，它就从运行态转换为阻塞态。\n\n\n阻塞态\\to就绪态\n进程等待的事件到来时，如 I/O 操作结束或中断结束时，中断处理程序必须把相应进程的状态由阻塞态转换为就绪态。\n\n\n\n进程控制\n\n进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。\n在操作系统中，一般把进程控制用的程序段称为原语。原语的特点是执行期间不允许中断，它是一个不可分割的基本单位。\n\n\n                  \n                  如何实现原语的“原子性” \n                  \n                \n\n原语的执行具有原子性，即执行期间不允许中断。\n可以使用“关中断指令”和“开中断指令”实现。\n\n\n\n\n进程的创建\n\n在操作系统中，用户登录、作业调度、系统提供服务、用户程序的应用请求等都会引起进程的创建。\n\n设备分配不会引起进程创建。\n\n操作系统创建新进程的过程如下（创建原语）：\n\n\n为新进程分配一个唯一的进程标识号，并申请一个空白 PCB （PCB 是有限的）。\n\n若申请失败，则创建失败。\n\n\n\n为进程分配其运行所需的资源（如内存、文件、I/O 设备和 CPU 时间等），这些资源或从操作系统获得，或仅从其父进程获得。\n\n如果资源不足，则并不是创建失败，而是处于创建态，等待内存资源。\n\n\n\n初始化 PCB，主要包括初始化标志信息、初始化 CPU 状态信息和初始化处理机控制信息，以及设置进程的优先级等。\n\n\n若进程就绪队列能够接纳新进程，则将新进程插入就绪队列，等待被调度运行。\n\n\n\n\n                  \n                  父进程与子进程 \n                  \n                \n\n允许一个进程创建另一个进程，此时创建者称为父进程，被创建的进程称为子进程。\n\n子进程可以继承父进程所拥有的资源。\n父进程可与子进程共享一部分资源，但不能共享虚拟地址空间。在创建子进程时，会为子进程分配资源，如虚拟地址空间等。\n子进程也有自己的 PCB。\n父进程与子进程可以并发执行。\n当子进程被撤销时，应将其从父进程那里获得的资源还给父进程。此外，在撤销父进程时，通常也会同时撤销其所有的子进程。\n\n\n\n进程的终止\n\n引起进程终止的事件主要有：\n\n正常结束：进程的任务己完成并准备退出运行。\n异常结束：进程在运行时，发生了某种异常事件，使程序无法继续运行，如存储区越界、保护错、 非法指令、特权指令错、运行超时、算术运算错、I/O 故障等。\n外界干预：指进程应外界的请求而终止运行，如操作员或操作系统干预、父进程请求和父进程终止。\n\n统终止进程的过程如下（终止原语）：\n\n根据被终止进程的标识符，检索出该进程的 PCB，从中读出该进程的状态。\n若被终止进程处于运行状态，立即终止该进程的执行，将 CPU 资源分配给其他进程。若该进程还有子孙进程，则应将其所有子孙进程终止。\n归还该进程所拥有的全部资源给其父进程，或操作系统。\n将该 PCB 从所在队列中删除。\n\n进程的阻塞和唤醒\n\n正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新任务可做等，进程便通过调用阻塞原语，使自已由运行态变为阻塞态。\n可见，阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得 CPU），才可能将其转为阻塞态。\n阻塞原语的执行过程如下：\n\n找到将要被阻塞进程的标识号对应的 PCB。\n若该进程为运行态，则保护其现场，将其状态转为阻塞态，停止运行。\n把该 PCB 插入相应事件的等待队列，将处理机资源调度给其他就绪进程。\n\n当被阻塞进程所期待的事件出现时，如它所期待的 I/O 操作已完成或其所期待的数据已到达，由有关进程调用唤醒原语，将等待该事件的进程唤醒。\n唤醒原语的执行过程如下：\n\n在该事件的等待队列中找到相应进程的 PCB。\n将其从等待队列中移出，并置其状态为就绪态。\n把该 PCB 插入就绪队列，等待调度程序调度。\n\n\n\n                  \n                  Tip\n                  \n                \n\n阻塞原语和唤醒原语是一对作用相反的原语，必须成对使用。\n如果在某进程中调用了阻塞原语，则必须在与之合作的或其他相关的进程中安排一条相应的唤醒原语，以便唤醒阻塞进程；否则，阻塞进程将会因不能被唤醒而永久地处于阻塞状态。\n\n\n进程的切换\n\n进程切换是在内核的支持下实现的。可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。\n上下文：某一时刻 CPU 寄存器和程序计数器的内容。\n上下文切换：切换 CPU 到另一个进程需要保存当前进程状态并恢复另一个进程的状态的过程。\n\n上下文切换只能发生在内核态，它是多任务操作系统中的一个必需的特性。\n\n实质：处理机从一个进程的运行转到另一个进程上运行，在这个过程中，进程的运行环境产生了实质性的变化。\n上下文切换的流程：\n\n挂起一个进程，保存 CPU 上下文，包括程序计数器和其他寄存器。\n更新 PCB 信息。\n把进程的 PCB 移入相应的队列，如就绪、在某事件阻塞等队列。\n选择另一个进程执行，并更新其 PCB。\n跳转到新进程 PCB 中的程序计数器所指向的位置执行。\n恢复处理机上下文。\n\n上下支切换的消耗：上下文切换通常是计算密集型的，即需要消耗大量的 CPU 时间。但当处理器提供多个寄存器组的时候，上下文切换就只需要简单改变当前寄存器组的指针。\n\n\n                  \n                  模式切换 \n                  \n                \n\n用户态和内核态之间的切换称为模式切换，因为没有改变当前的进程。\n模式切换与上下文切换是不同的，模式切换时，CPU 逻辑上可能还在执行同一进程。\n\n\n\n\n                  \n                  调度和切换的区别 \n                  \n                \n\n\n调度是指决定资源分配给哪个进程的行为，是一种决策行为；\n切换是指实际分配的行为，是执行行为。\n\n一般来说，先有资源的调度，然后才有进程的切换。\n\n\n进程的通信\n\n进程通信：进程之间的信息交换。\n\n\n                  \n                  为什么进程通信需要操作系统支持 \n                  \n                \n\n进程空间一般都是独立的，进程运行期间一般不能访问其他进程的空间，想让两个进程共享空间，必须通过特殊的系统调用实现。\n\n\n\n\nPV 操作是低级通信方式，高级通信方式是指以较高的效率传输大量数据的通信方式。\n\n高级通信方法主要有以下三类。\n共享存储\n在通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行写/读操作实现进程之间的信息交换。\n\n在对共享空间进行写/读操作时，需要使用同步互斥工具（如 PV 操作）对共享空间的写/读进行控制。\n共享存储又分为两种：\n\n低级方式的共享是基于数据结构的共享；\n高级方式的共享是基于存储区的共享；\n\n操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具，而数据交换则由用户自己安排读/写指令完成。\n消息传递\n若通信的进程之间不存在可直接访问的共享空间，则必须利用操作系统提供的消息传递方法实现进程通信。\n在消息传递系统中，进程间的数据交换以格式化的消息为单位。进程通过系统提供的发送消息和接收消息两个原语进行数据交换。\n\n\n\n直接通信方式\n发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息。\n\n\n\n间接通信方式\n发送进程把消息发送到某个中间实体（一般称为信箱），接收进程从中间实体取得消息。\n\n\n\n管道通信\n管道是一种存储在内存中的、固定大小的缓冲区，管道的大小通常为内存的一页，其大小不受磁盘容量大小的限制。\n管道通信允许两个进程按生产者-消费者方式进行通信，生产者向管道的一端写，消费者从管道的另一端读。\n\n数据在管道中是先进先出的。\n\n\n只要管道非空，读进程就能从管道中读出数据。若管道读空，则读进程阻塞，直到写进程往管道中写入新的数据，再将读进程唤醒。\n\n\n只要管道不满，写进程就能往管道中写入数据。若管道写满，则写进程阻塞，直到读进程读出数据，再将写进程唤醒。\n\n\n进程对管道进行读操作和写操作都有可能被阻塞。因为管道的读/写操作都可能遇到缓冲区满或空的情况，当管道满时，写操作会被阻塞，直到有数据读出；而当管道空时，读操作会被阻塞，直到有数据写入。\n\n\n普通管道只允许单向通信，若要实现父子进程双向通信，则需要定义两个管道。\n\n\n\n从管道读数据是一次性操作，数据一旦被读取，就会彻底消失。因此当多个进程读同一个管道时，可能会错乱，通常采用一个管道允许多个写进程，一个读进程的方案解决。\n\n\n为了协调双方的通信，管道机制必须提供三方面的协调能力：互斥、同步和确定对方的存在。\n线程\n线程的概念\n\n\n引入进程的目的是更好地使多道程序并发执行，提高资源利用率和系统吞吐量。\n引入线程的目的是减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。\n\n\n线程最直接的理解就是“轻量级进程”，它是一个基本的 CPU 执行单元，也是程序执行流的最小单元，由线程 ID、程序计数器、寄存器集合和堆栈组成。\n\n线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。\n一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。\n线程与进程的比较\n\n\n                  \n                  引入线程机制后的变化 \n                  \n                \n\n\n不管系统是否支持线程，进程都是资源分配的基本单位。\n\n\n\n\n调度\n在传统的操作系统中，拥有资源和独立调度的基本单位都是进程，每次调度都要进行上下文切换，开销较大。\n在引入线程的操作系统中，线程是独立调度的基本单位，而线程切换的代价远低于进程。\n在同一进程中，线程的切换不会引起进程切换。但从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。\n\n\n并发性\n在引入线程的操作系统中，\n\n进程之间可以并发执行，\n一个进程中的多个线程之间可以并发执行\n不同进程中的线程也可以并发执行\n\n\n\n拥有资源\n进程是系统中拥有资源的基本单位，而线程不拥有系统资源，但线程可以访问其隶属进程的系统资源，这主要表现在属于同一进程的所有线程都具有相同的地址空间。\n\n若线程也是拥有资源的单位, 则切换线程就需要较大的时空开销，线程这个概念的提出就没有意义。\n\n\n\n独立性\n每个进程都拥有独立的地址空间和资源，除了共享全局变量，不允许其他进程访问。某进程中的线程对其他进程不可见。\n同一进程中的不同线程是为了提高并发性及进行相互之间的合作而创建的，它们共享进程的地址空间和资源。\n\n\n系统开销\n在创建或撤销进程时，系统都要为之分配或回收进程控制块 PCB 及其他资源。操作系统为此所付出的开销大于创建或撤销线程时的开销。\n在进程切换时涉及进程上下文的切换，而线程切换时只需保存和设置少量寄存器内容，开销很小。\n由于同一进程内的多个线程共享进程的地址空间，因此这些线程之间的同步与通信非常容易实现，甚至无须操作系统的干预。\n\n\n支持多处理机系统\n对于传统单线程进程，进程只能运行在一个处理机上。对于多线程进程，可以将进程中的多个线程分配到多个处理机上执行。\n\n\n线程的属性\n\n多线程操作系统中的进程已不再是一个基本的执行实体，但它仍具有与执行相关的状态。进程处于“执行”状态，实际上是指该进程中的某线程正在执行。\n\n线程是一个轻型实体，它不拥有系统资源，但每个线程都应有一个唯一的标识符和一个线程控制块，线程控制块记录线程执行的寄存器和栈等现场状态。\n不同的线程可以执行相同的程序，即同一个服务程序被不同的用户调用时，操作系统将它们创建成不同的线程。\n同一进程中的各个线程共享该进程所拥有的资源。\n线程是 CPU 的独立调度单位，多个线程是可以并发执行的。在单 CPU 的计算机系统中，各线程可交替地占用 CPU；在多 CPU 的计算机系统中，各线程可同时占用不同的 CPU，若各个 CPU 同时为一个进程内的各线程服务，则可缩短进程的处理时间。\n一个线程被创建后，便开始了它的生命周期，直至终止。线程在生命周期内会经历阻塞态、就绪态和运行态等各种状态变化。\n\n线程的状态与转换\n由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有就绪、阻塞和运行三种基本状态。\n\n执行态：线程己获得处理机而正在运行。\n就绪态：线程已具备各种执行条件，只需再获得 CPU 便可立即执行。\n阻塞态：线程在执行中因某事件受阻而处于暂停状态。\n\n线程这三种基本状态之间的转换和进程基本状态之间的转换一样。\n\n线程的组织与控制\n线程控制块\n与进程类似，系统也为每个线程配置一个线程控制块(TCB)，用于记录控制和管理线程的信息。\n\n同一进程中的所有线程都完全共享进程的地址空间和全局变量。\n各个线程都可以访问进程地址空间的每个单元，所以一个线程可以读、写或甚至清除另一个线程的堆栈。\n线程的创建\n线程也是具有生命期的，它由创建而产生，由调度而执行，由终止而消亡。\n用户程序启动时，通常仅有一个称为“初始化线程”的线程正在执行，其主要功能是用于创建新线程。\n线程的终止\n当一个线程完成自己的任务后，或线程在运行中出现异常而要被强制终止时，由终止线程调用相应的函数执行终止操作。但是有些线程（主要是系统线程）一旦被建立，便一直运行而不会被终止。\n通常，线程被终止后并不立即释放它所占有的资源，只有当进程中的其他线程执行了分离函数后，被终止线程才与资源分离，此时的资源才能被其他线程利用。\n被终止但尚未释放资源的线程仍可被其他线程调用，以使被终止线程重新恢复运行。\n线程的实现方式\n线程的实现可以分为两类：用户级线程(User-Level Thread, ULT)和内核级线程(Kermel-Level Thread, KLT)。\n\n内核级线程又称内核支持的线程，也可以叫系统级线程。\n\n用户级线程(ULT)\n在用户级线程中，有关线程管理（创建、撤销和切换等）的所有工作都由应用程序在用户空间内（用户态）完成，无\n须内核的干预，内核意识不到线程的存在，因此用户级线程可以在不支持内核级线程的操作系统上实现。\n\n\n                  \n                  Tip\n                  \n                \n\n用户级线程的控制块是由用户空间的库函数维护的，操作系统并不知道用户级线程的存在，用户级线程的控制块一般存放在用户空间的数据结构中，如链表或数组，由用户空间的线程库来管理。\n操作系统只负责为每个进程建立一个进程控制块，操作系统只能看到进程，而看不到用户级线程，所以不会为每个用户级线程建立一个线程控制块。\n但是，内核级线程的线程控制块是由操作系统创建的，当一个进程创建一个内核级线程时，操作系统会为该线程分配一个线程控制块，并将其加入内核的线程管理数据结构。\n\n\n应用程序可以通过使用线程库设计成多线程程序。\n\n对于设置了用户级线程的系统，其调度仍然以进程为单位进行，各个进程轮流执行一个时间片。\n优点：\n\n由于不需要转换到内核空间，线程切换节省了模式切换的开销。\n不同的进程可根据自身的需要对自己的线程选择不同的调度算法。\n用户级线程的实现与操作系统平台无关，对线程管理的代码是属于用户程序的一部分。\n\n缺点：\n\n系统调用的阻塞问题：当进程内的一个线程被阻塞时，进程内的所有线程都被阻塞。\n不能发挥多处理机的优势：内核每次分配给一个进程的仅有一个 CPU，因此进程中仅有一个线程能执行。\n\n内核级线程(KLT)\n内核级线程是在内核的支持下运行的，线程管理的所有工作也是在内核空间内实现的。\n操作系统为每个内核级线程设置一个线程控制块 TCB，内核根据该控制块感知某线程的存在，并对其加以控制。\n\n优点：\n\n能发挥多 CPU 的优势，内核能同时调度同一进程中的多个线程并行执行。\n当一个线程被阻塞时，内核可以运行该进程中的其他线程，也可运行其他进程中的线程。\n内核支持线程具有很小的数据结构和堆栈，线程切换比较快、开销小。\n内核本身也可采用多线程技术，可以提高系统的执行速度和效率。\n\n缺点：\n同一进程中的线程切换，需要从用户态转到核心态进行，系统开销较大。因为用户进程的线程在用户态运行，而线程调度和管理是在内核实现的。\n组合方式\n在组合实现方式中，内核支持多个内核级线程的建立、调度和管理，同时允许用户程序建立、调度和管理用户级线程。\n组合方式能结合 KLT 和 ULT 的优点，并且克服各自的不足。\n多线程模型\n有些系统同时支持用户线程和内核线程，由于用户级线程和内核级线程连接方式的不同，从而形成了三种不同的多线程模型。\n一对一模型\n将每个用户级线程映射到一个内核级线程。\n优点：当一个线程被阻塞后，允许调度另一个线程运行，所以并发能力较强。\n缺点：每创建一个用户线程，相应地就需要创建一个内核线程，开销较大。\n\n多对一模型\n将多个用户级线程映射到一个内核级线程。\n优点：线程管理是在用户空间进行的，效率比较高。\n缺点：如果一个线程在访问内核时发生阻塞，则整个进程都会被阻塞；在任何时刻，只有一个线程能够访问内核，多个线程不能同时在多个处理机上运行。\n\n多对多模型\n将 n 个用户线程映射到 m 个内核级线程上，要求n\\geqslant m。\n既克服了多对一模型并发度不高的缺点，又克服了一对一模型开销太大的缺点。此外，还拥有上述两种模型各自的优点。\n\nCPU 调度\n调度的基本概念\n在多道程序系统中，进程的数量往往多于 CPU 的个数，因此进程争用 CPU 的情况在所难免。\nCPU 调度是对 CPU 进行分配，即从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程并发地执行。\n\n处理机调度是多道程序操作系统的基础，是操作系统设计的核心问题。\n\n调度的层次\n\n三级调度\n\n一个作业从提交开始直到完成，往往要经历三级调度：\n\n\n高级调度（作业调度）\n按照一定的原则从外存上处于后备队列的作业中挑选一个或多个，给它们分配资源，并建立相应的进程，以使它们获得竞争 CPU 的权利。\n每个作业只调入一次、调出一次，调入时会建立 PCB，调出时才撤销 PCB。\n多道批处理系统中大多配有作业调度，而其他系统中通常不需要配置作业调度。\n\n作业调度就是内存与辅存之间的调度。\n\n\n\n中级调度（内存调度）\n目的是提高内存利用率和系统吞吐量。将暂时不能运行的进程调至外存等待，此时进程的状态称为挂起态。当它们己具备运行条件且内存空闲时，由中级调度把外存上的那些进程重新调入内存，并修改其状态为就绪态，挂在就绪队列上等待。\n中级调度发生的频率比高级调度高。\n\n中级调度实际上是存储器管理中的对换功能。\n\n\n\n低级调度（进程调度）\n按照某种算法从就绪队列中选取一个进程，将 CPU 分配给它。进程调度是最基本的一种调度，在各种操作系统中都必须配置这级调度。进程调度的频率很高。\n\n\n\n\n                  \n                  进程的挂起态与七状态模型 \n                  \n                \n\n\n\n\n三级调度的联系\n\n调度的实现\n调度程序（调度器）\n\n用于调度和分派 CPU 的组件称为调度程序，它通常由三部分组成：\n\n\n排队器\n将系统中的所有就绪进程按照一定的策略排成一个或多个队列，以便于调度程序选择。每当有一个进程转变为就绪态时，排队器便将它插入到相应的就绪队列中。\n\n\n分派器\n依据调度程序所选的进程，将其从就绪队列中取出，将 CPU 分配给新进程。\n\n\n上下文切换器\n在对处理机进行切换时，会发生两对上下文的切换操作：\n\n第一对，将当前进程的上下文保存到其 PCB 中，再装入分派程序的上下文，以便分派程序运行；\n第二对，移出分派程序的上下文，将新选进程的 CPU 现场信息装入处理机的各个相应寄存器；\n\n\n\n\n\n上图所说的是进程的调度，如果一个系统支持线程，那么调度的对象就是线程了。\n\n调度的时机、切换与过程\n调度程序是操作系统内核程序。\n请求调度的事件发生后，才可能运行调度程序，调度了新的就绪进程后，才会进行进程切换。\n理论上这三件事情应该顺序执行，但在实际的操作系统内核程序运行中，若某时刻发生了引起进程调度的因素，则不一定能马上进行调度与切换。\n现代操作系统中，应该进行进程调度与切换的情况如下：\n\n创建新进程后，由于父进程和子进程都处于就绪态，因此需要决定是运行父进程还是运行子进程，调度程序可以合法地决定其中一个进程先运行。\n进程正常结束后或者异常终止后，必须从就绪队列中选择某个进程运行。若没有就绪进程，则通常运行一个系统提供的闲逛进程。\n当进程因 I/O 请求、信号量操作或其他原因而被阻塞时，必须调度其他进程运行。\n当I/O 设备完成后，发出 I/O 中断，原先等待 I/O 的进程从阻塞态变为就绪态，此时需要决定是让新的就绪进程投入运行，还是让中断发生时运行的进程继续执行。\n\n\n\n\n\n                  \n                  进程切换 \n                  \n                \n\n进程切换往往在调度完成后立刻发生，它要求保存原进程当前断点的现场信息，恢复被调度进程的现场信息。\n对于通常的进程而言，其创建、撤销及要求由系统设备完成的 I/O 操作，都是利用系统调用而进入内核，再由内核中的相应处理程序予以完成的。进程切换同样是在内核的支持下实现的，因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。\n\n切换 CPU 到另一个进程需要保存当前进程状态并恢复另一个进程的状态，这个任务称为上下文切换。进程上下文采用进程 PCB 表示，包括 CPU 寄存器的值、进程状态和内存管理信息等。\n上下文切换只能发生在内核态，它是多任务操作系统中的一个必需的特性。\n当进行上下文切换时，内核将旧进程状态保存在其 PCB 中，然后加载经调度而要执行的新进程的上下文。在切换过程中，进程的运行环境产生实质性的变化。\n上下文切换的流程如下：\n\n挂起一个进程，将 CPU 上下文保存到 PCB，包括程序计数器和其他寄存器。\n将进程的 PCB 移入相应的队列，如就绪、在某事件阻塞等队列。\n选择另一个进程执行，并更新其 PCB。\n恢复新进程的 CPU 上下文。\n跳转到新进程 PCB 中的程序计数器所指向的位置执行。\n\n\n上下文切换的消耗：上下文切换通常是计算密集型的，上下文切换对系统来说意味着消耗大量的 CPU 时间。有些 CPU 提供多个寄存器组，这样，上下文切换就只需要简单改变当前寄存器组的指针。\n\n用户态和内核态之间的切换称为模式切换，而不是上下文切换，因为没有改变当前的进程。模式切换与上下文切换是不同的，模式切换时，CPU 逻辑上可能还在执行同一进程。用户进程最开始都运行在用户态，若进程因中断或异常进入核心态运行，执行完后又回到用户态刚被中断的进程运行。\n\n调度和切换的区别：调度是指决定资源分配给哪个进程的行为，是一种决策行为；切换是指实际分配的行为，是执行行为。一般来说，先有资源的调度，然后才有进程的切换。\n\n\n\n\n进程调度方式\n进程调度方式，是指当某个进程正  在 CPU 上执行时，若有某个更为重要或紧迫的进程需要处理，即有优先权更高的进程进入就绪队列，此时应如何分配 CPU。\n\n\n非抢占调度方式（非剥夺方式）\n当有更重要或紧迫的进程进入就绪队列时，仍然让当前进程继续执行，直到该进程运行完成或发生某种事件而进入阻塞态时，才把 CPU 分配给其他进程。\n非抢占调度方式的优点是实现简单、系统开销小，适用于大多数的批处理系统，但它不能用于分时系统和大多数的实时系统。\n\n\n抢占调度方式（剥夺方式）\n当一个进程正在 CPU 上执行时，若有一个更重要或紧迫的进程需要使用 CPU，则暂停正在执行的进程，将 CPU 分配给更重要或紧迫的进程。\n抢占调度方式对提高系统吞吐率和响应效率都有明显的好处。适用于分时操作系统、实时操作系统。\n\n\n闲逛进程\n在进程切换时，如果系统中没有就绪进程，就会调度闲逛进程运行，如果没有其他进程就绪，该进程就一直运行，并在执行过程中测试中断。\n特点：\n\n优先级最低\n不需要 CPU 之外的资源，它不会被阻塞\n\n调度算法\n评价指标\n\n\n\nCPU 利用率\n\n\n\n系统吞吐量\n\n\n\n周转时间\n\n\n\n\n等待时间\n\n\n\n响应时间\n\n\n\n先来先服务调度算法(FCFS)\n\nFCFS, First Come First Serve\n\n\nFCFS 调度算法是一种最简单的调度算法，它既可用于作业调度，又可用于进程调度。\n\n在作业调度中，算法每次从后备作业队列中选择最先进入该队列的作业。\n在进程调度中，算法每次从就绪队列中选择最先进入该队列的进程。\n\nFCFS 调度算法属于不可剥夺算法。\nFCFS 调度算法对所有作业都是公平的，但若一个长作业先到达系统，就会使后面的许多短作业等待很长时间，因此不能作为分时系统和实时系统的主要调度策略，但它常被结合在其他调度策略中使用。\nFCFS 调度算法的特点是算法简单，但效率低；对长作业比较有利，但对短作业不利（相对 SJF 和高响应比）；有利于 CPU 繁忙型作业，而不利于 I/O 繁忙型作业。\n\n短作业优先调度算法(SJF)\n\nSJF, Shortest Job First\n\n\n短作业（进程）优先调度算法是指对短作业（进程）优先调度的算法。\n\n短作业优先（SJF）调度算法从后备队列中选择运行时间最短的作业；\n短进程优先（SPF）调度算法从就绪队列中选择运行时间最短的进程；\n\n\n\n                  \n                  死锁和饥饿的区别 \n                  \n                \n\n\n死锁是系统环形等待\n饥饿是调度策略问题\n\n\n\n缺点：\n\n\n该算法对长作业不利，SJF 调度算法中长作业的周转时间会增加。甚至有可能导致长作业长期不被调度而产生“饥饿”现象\n\n\n该算法完全未考虑作业的紧迫程度，因而不能保证紧迫性作业会被及时处理。\n\n\n由于作业的长短是根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意地缩短其作业的估计运行时间，致使该算法不一定能真正做到短作业优先调度。\n\n\n\n\n\n\n\n                  \n                  Tip\n                  \n                \n\nSJF 调度算法的平均等待时间、平均周转时间最少。\n\n\n\n优先级调度算法(PR)\n\n优先级调度算法既可用于作业调度，又可用于进程调度。\n优先级用于描述作业的紧迫程度，\n\n在作业调度中，优先级调度算法每次从后备作业队列中选择优先级最高的作业。\n在进程调度中，优先级调 度算法每次从就绪队列中选择优先级最高的进程。\n\n根据新的更高优先级进程能否抢占正在执行的进程，可将该调度算法分为如下两种：\n\n\n非抢占式优先级调度算法\n当一个进程正在处理机上运行时，即使有某个优先级更高的进程进入就绪队列，仍让正在运行的进程继续运行，直到由于其自身的原因而让出处理机时，才把处理机分配给就绪队列中优先级最高的进程。\n\n\n\n抢占式优先级调度算法\n当一个进程正在处理机上运行时，若有某个优先级更高的进程进入就绪队列，则立即暂停正在运行的进程，将处理机分配给优先级更高的进程。\n\n\n\n根据进程创建后其优先级是否可以改变，可以将进程优先级分为以下两种：\n\n\n静态优先级\n优先级是在创建进程时确定的，且在进程的整个运行期间保持不变。\n优点是简单易行，系统开销小；缺点是不够精确，可能出现优先级低的进程长期得不到调度的情况。\n\n\n动态优先级\n创建进程时先赋予进程一个优先级，但优先级会随进程的推进或等待时间的增加而改变，以便获得更好的调度性能。\n\n\n\n\n                  \n                  进程优先级的设置参照原则 \n                  \n                \n\n\n\n系统进程&gt;用户进程\n系统进程作为系统的管理者，理应拥有更高的优先级。\n\n\n交互型进程&gt;非交互型进程（前台进程&gt;后台进程）\n在前台运行的正在和用户交互的进程应该更快速地响应，因此自然需要被优先处理。\n\n\nI/O 型进程&gt;计算型进程\nI/O 型进程是指会频繁使用 I/O 设备的进程，计算型进程是指会频繁使用 CPU 的进程（很少使用 I/O 设备）。\n将 I/O 型进程的优先级设置得更高，就更有可能让 I/O 设备尽早开始工作，进而提升系统的整体效率。\n\n\n\n\n高响应比优先调度算法(HRRN)\n\nHRRN, Highest Response Ratio Next\n\n\n高响应比优先调度算法主要用于作业调度，是对 FCFS 调度算法和 SJF 调度算法的一种综合平衡，同时考虑了每个作业的等待时间和估计的运行时间。\n每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行。\n\n\n作业的等待时间相同时，要求服务时间越短，响应比越高，有利于短作业，类似于 SJF。\n要求服务时间相同时，作业的响应比由其等待时间决定，等待时间越长，其响应比越高，类似于 FCFS。\n对于长作业，作业的响应比可以随等待时间的增加而提高， 当其等待时间足够长时，也可获得处理机，克服了“饥饿“现象。\n\n\n时间片轮转调度算法(RR)\n\nRR, Round-Robin\n\n\n时间片轮转调度算法主要适用于分时系统。\n系统将所有就绪进程按 FCFS 策略排成一个就绪队列，调度程序总是选择就绪队列中的第一个进程执行，但仅能运行一个时间片， 如 50ms。在使用完一个时间片后，即使进程并未运行完成，它也必须被剥夺处理机给下一个就绪进程，而被剥夺的进程返回到就绪队列的末尾重新排队，等候再次运行。\n在时间片轮转调度算法中，时间片的大小对系统性能的影响很大。\n\n若时间片很大，则所有进程都能在一个时间片内执行完毕，则时间片轮转调度算法就退化为先来先服务调度算法。\n若时间片很小，则处理机将在进程间过于频繁地切换，使处理机的开销增大，而真正用于运行用户进程的时间将减少。\n\n因此，时间片的大小应选择适当，时间片的长短通常由系统的响应时间、就绪队列中的进程数目和系统的处理能力确定。\n\n\n\n多级反馈队列调度算法\n\n多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合与发展。\n通过动态调整进程优先级和时间片大小，多级反馈队列调度算法可以兼顾多方面的系统目标。\n\n实现思想：\n\n\n设置多个就绪队列，并为每个队列赋予不同的优先级。\n第 1 级队列的优先级最高，第 2 级队列的优先级次之，其余队列的优先级逐个降低。\n\n\n赋予各个队列的进程运行时间片的大小各不相同。\n优先级越高的队列，每个进程的时间片就越小。\n\n\n每个队列都采用 FCFS 算法。\n当新进程进入内存后，首先将它放入第 1 级队列的末尾，按 FCFS 原则等待调度。\n当轮到该进程执行时，如它能在该时间片内完成，便可撤离系统。 若在一个时间片结束时尚未完成，调度程序将其转入第 2 级队列的末尾等待调度；若在第 2 级队列中运行一个时间片后仍未完成，再将它放入第 3 级队列，以此类推。\n当进程最后被降到第 n 级队列后，在第 n 级队列中便采用时间片轮转方式运行。\n\n\n按队列优先级调度。\n仅当第 1 级队列为空时，才调度第 2 级队列中的进程运行；仅当第 1〜i-1 级队列均为空时，才会调度第 i 级队列中的进程运行。\n若处理机正在执行第 i 级队列中的某进程时，又有新进程进入任何一个优先级较高的队列，此时须立即把正在运行的进程放回到第 i 级队列的末尾，而把 CPU 分配给新到的高优先级进程。\n\n\n\nwww.bilibili.com/video/BV1YE411D7nH\n\n\n\n多级队列调度算法\n该算法在系统中设置多个就绪队列，将不同类型或性质的进程固定分配到不同的就绪队列，每个队列可实施不同的调度算法。\n同一队列中的进程可以设置不同的优先级，不同的队列本身也可以设置不同的优先级。\n\n同步与互斥\n同步与互斥的基本概念\n\n临界资源\n\n一个时间段内只允许一个进程使用的资源称为临界资源。许多物理设备都属于临界资源，如打印机等。此外，还有许多变量、数据等都可以被若干进程共享，也属于临界资源。\n临界资源的访问过程分成 4 个部分：\n\n进入区：检查可否进入临界区，若能进入临界区，则应设置正在访问临界区的标志，以阻止其他进程同时进入临界区。\n临界区：进程中访问临界资源的那段代码，又称临界段。\n退出区：将正在访问临界区的标志清除。\n剩余区：代码中的其余部分。\n\n同步\n也称直接制约关系，是指为完成某种任务而建立的两个或多个进程，这些进程因为需要协调它们的运行次序而等待、传递信息所产生的制约关系。\n同步关系源于进程之间的相互合作。\n\n互斥\n互斥也称间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源。\n\n不同线程对同一个进程内部的共享变量的访问才有可能需要进行互斥。\n不同进程的线程、代码段或变量不存在互斥访问的问题，同一个线程内部的局部变量也不存在互斥访问的问题。\n\n\n多个进程可以同时以“读”或“写”的方式打开文件，操作系统并不保证写操作的互斥性，进程可通过系统调用对文件加锁，保证互斥写（例如：读者-写者问题）。\n\n为了实现对临界资源的互斥访问，应遵循以下准则：\n\n空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区（必须遵循✅）。\n忙则等待：当己有进程进入临界区时，其他试图进入临界区的进程必须等待（必须遵循✅）。\n有限等待：对请求访问的进程，应保证能在有限时间内进入临界区（必须遵循✅）。\n让权等待：当进程不能进入临界区时，应立即释放处理器，防止进程忙等待（非必须❌）。\n\n实现临界区互斥的基本方法\n软件实现\n\n单标志法\n该算法设置一个公用整型变量 turn，用于指示被允许进入临界区的进程编号，即若 turn=0，则允许P_0进程进入临界区。\n\n该算法可确保每次只允许一个进程进入临界区，但两个进程必须交替进入临界区，若某个进程不再进入临界区，则另一个进程也将无法进入临界区（违背“空闲让进”）。\n假设此时进入临界区的进程是P_0，但P_0不访问临界区，那么即使临界区空闲其它进程也无法访问。\n双标志法先检查\n该算法在每个进程访问临界区资源之前，先查看临界资源是否正被访问，若正被访问，该进程需等待；否则，进程才进入自己的临界区。\n\n优点：不用交替进入，可连续使用；\n缺点：P_i和P_j可能同时进入临界区；\n双标志法后检查\n\nPeterson 算法\n利用 flag[]解决互斥访问问题，而利用 turn **解决“饥饿”**问题。\n\n硬件实现\n\n中断屏蔽方法\n当一个进程正在执行它的临界区代码时，防止其他进程进入其临界区的最简方法是关中断。\n因为 CPU 只在发生中断时引起进程切换，因此屏蔽中断能够保证当前运行的进程让临界区代码顺利地执行完，进而保证互斥的正确实现。\n\nTestAndSet(TSL) 指令\n这条指令是原子操作，即执行该代码时不允许被中断。其功能是读出指定标志后把该标志设置为真。\n\nTSL 指令实现原子性的原理是，执行 TSL 指令的 CPU 锁住内存总线，以禁止其他 CPU 在本指令结束之前访问内存。\nTSL 指令本身就是原子操作，不需要关中断来保证其不被打断。此外，假如while(TSL(&amp;lock))在关中断状态下执行，若 TSL(&amp;lock)一直为 true，不再开中断，则系统可能因此终止。\n\n\n\n使用 TSL 指令实现进程互斥时，并没有阻塞态进程，等待进入临界区的进程一直停留在执行while(TSL(&amp;lock))的循环中，不会主动放弃 CPU，一直处于运行态，直到该进程的时间片用完放弃处理机，转为就绪态，此时切换另一个就绪态进程占用处理机。\n这不同于信号量机制实现的互斥。\n\nSwap 指令\n该指令的功能是交换两个字(字节)的内容。\n\n互斥锁\n解决临界区最简单的工具就是互斥锁(mutex lock)。\n一个进程在进入临界区时应获得锁；在退出临界区时释放锁。函数acquire()获得锁，而函数release()释放锁。\nacquire(){\t//获得锁的定义\n\twhile(!available);\t//忙等待\n  available = false;\t//获得锁\n}\n \nrelease(){\t//释放锁的定义\n\tavailable = true;\t//释放锁\n}\n互斥锁通常采用硬件机制来实现 。\n互斥锁的主要缺点是忙等待，当有一个进程在临界区中，任何其他进程在进入临界区时必须连续循环调用acquire()。\n当多个进程共享同一个 CPU 时，就浪费了 CPU 周期。因此，互斥锁通常用于多处理器系统，一个线程可以在一个处理器上等待，不影响其他线程的执行。\n\n需要连续循环忙等待的互斥锁，都可称为自旋锁，如 TSL 指令、swap 指令、单标志法。\n自旋锁的优点是，进程在等待锁期间，没有上下文切换，若上锁的时间较短，则等待代价不高。\n\n\n信号量\n\n\n信号量机制是一种功能较强的机制，可用来解决互斥与同步问题，它只能被两个标准的原语wait()和signal()访问，也可记为“P 操作”和”V 操作”。\n\n整型信号量\n整型信号量被定义为一个用于表示资源数目的整型量 S。\n该机制并未遵循“让权等待”的准则，而是使进程处于“忙等”的状态。\n\n记录型信号量\n记录型信号量机制是一种不存在“忙等”现象的进程同步机制。\n除了需要一个用于代表资源数目的整型变量 value 外，再增加一个进程链表 L，用于链接所有等待该资源的进程。\n\n\n利用信号量实现互斥\n\n\n\n对不同的临界资源需要设置不同的互斥信号量。\nP(S)和 V(S)必须成对出现。\n有多少资源就将信号量初值设为多少，申请资源时执行 P 操作，释放资源时执行 V 操作。\n\n\n利用信号量实现同步\n\n\n利用信号量实现前驱关系\n\n互斥原则总结\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n单标志法双标志法先检查双标志法后检查Peterson 算法中断屏蔽方法TSL 指令Swap 指令信号量空闲让进❌❌✅忙则等待❌✅有限等待❌✅让权等待❌❌❌❌✅\n经典同步问题\n生产者-消费者\n\n\n问题\n\n\n\n分析\n\n\n\n实现\n\n\n\n\n\n                  \n                  能否改变相邻 P、V 操作的顺序 \n                  \n                \n\n\n\n\n多生产者-多消费者\n\n\n问题\n\n\n\n分析\n\n\n\n实现\n\n\n\n\n\n                  \n                  可不可以不设置互斥信号量 \n                  \n                \n\n结论：即使不设置专门的互斥变量 mutex，也不会出现多个进程同时访问盘子的现象。\n原因：问题中的缓冲区大小为 1，在任何时候，apple、orange、plate 三个同步信号量最多只有一个是 1。因此在任何时刻，最多只有一个进程进入临界区。因此若问题中的缓冲区大小大于 1，则必须设置一个互斥信号量来保证互斥访问缓冲区。\n\n\n\n\n吸烟者\n\n\n问题\n\n\n\n分析\n\n\n\n实现\n\n\n\n\n\n                  \n                  是否需要设置一个专门的互斥信号量 \n                  \n                \n\n与多生产者-多消费者问题相似，缓冲区的大小为 1，同一时刻，四个同步信号量中只有一个的值为 1。\n\n\n读者写者\n\n\n问题\n\n\n\n分析\n\n\n\n实现\n\n若希望写进程优先，即当有读进程正在读共享文件时，有写进程请求访问，这时应禁止后续读进程的请求，等到已在共享文件的读进程执行完毕，立即让写进程执行，只有在无写进程执行的情况下才允许读进程再次运行。\n为此，增加一个信号量并在上面程序的writer()和reader()函数中各增加一对 PV 操作，就可以得到写进程优先的解决程序。\n\n\n\n\n哲学界进餐\n\n\n问题\n\n\n\n分析\n\n\n\n实现\n\n\n\n\n\n\n管程\n\n在信号量机制中，每个要访问临界资源的进程都必须自备同步的 PV 操作，大量分散的同步操作给系统管理带来了麻烦，且容易因同步操作不当而导致系统死锁。于是，便产生了一种新的进程同步工具一一管程。\n管程的特性保证了进程互斥，无须程序员自己实现互斥，从而降低了死锁发生的可能性。同时管程提供了条件变量，可以让程序员灵活地实现进程同步。\n\n系统中的各种硬件资源和软件资源，均可用数据结构抽象地描述其资源特性，即用少量信息和对资源所执行的操作来表征该资源，而忽略它们的内部结构和实现细节。\n利用共享数据结构抽象地表示系统中的共享资源，而把对该数据结构实施的操作定义为一组过程。进程对共享资源的申请、释放等操作，都通过这组过程来实现，这组过程还可以根据资源情况，或接受或阻塞进程的访问，确保每次仅有一个进程使用共享资源，这样就可以统一管理对共享资源的所有访问，实现进程互斥。\n这个代表共享资源的数据结构，以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序，称为管程(monitor)。\n管程由 4 部分组成：\n\n管程的名称；\n局部于管程内部的共享数据结构说明；\n对该数据结构进行操作的一组过程（或函数）；\n对局部于管程内部的共享数据设置初始值的语句。\n\n\n\n\n\n                  \n                  条件变量 \n                  \n                \n\n当一个进程进入管程后被阻塞，直到阻塞的原因解除时，在此期间，如果该进程不释放管程，那么其他进程无法进入管程。为此，将阻塞原因定义为条件变量(condition)。\n一个进程被阻塞的原因可以有多个，因此在管程中可以设置多个条件变量。每个条件变量保存了一个等待队列， 用于记录因该条件变量而阻塞的所有进程。\n对条件变量只能进行两种操作，即 wait 和 signal：\n\nx.wait：当 x 对应的条件不满足时，正在调用管程的进程调用x.wait将自己插入 x 条件的等待队列，并释放管程。此时其他进程可以使用该管程。\nx.signal：x 对应的条件发生了变化，则调用x.signal，唤醒一个因 x 条件而阻塞的进程。\n\n\n\n\n\n                  \n                  Java 中类似于管程的机制 \n                  \n                \n\n\n\n\n死锁\n\n定义\n死锁：多个进程因竞争资源而造成的一种僵局（互相等待对方手里的资源），使得各个进程都被阻塞，若无外力作用，这些进程都将无法向前推进。\n\n\n                  \n                  死锁、饥饿、死循环的区别 \n                  \n                \n\n\n\n\n死锁产生的原因\n\n\n系统资源的竞争\n通常系统中拥有的不可剥夺资源（如磁带机、打印机等），其数量不足以满足多个进程运行的需要，使得进程在运行过程中，会因争夺资源而陷入僵局。\n只有对不可剥夺资源的竞争才可能产生死锁，对可剥夺资源（如 CPU 和主存）的竞争是不会引起死锁的。\n\n\n进程推进顺序非法\n进程在运行过程中，请求和释放资源的顺序不当，也同样会导致死锁。\n\n例如，进程 P_1，P_2分别保持了资源 R_2，R_2，而 P_1 申请资源 R_2，P_2申请资源 R_2 时，两者都会因为所需资源被占用而阻塞，于是导致死锁。\n\n\n\n信号量使用不当\n进程间彼此相互等待对方发来的消息，也会使得这些进程间无法继续向前推进。\n例如，进程 A 等待进程 B 发的消息，进程 B 又在等待进程 A 发的消息，进程 A 和 B 不是因为竞争同一资源，而是在等待对方的资源导致死锁。\n\n\n死锁产生的必要条件\n产生死锁必须同时满足以下 4 个条件，只要其中任意一个条件不成立，死锁就不会发生。\n\n\n互斥条件\n进程要求对所分配的资源在一段时间内某资源仅为一个进程所占有。若有其他进程请求该资源，则请求进程只能等待。\n\n\n不剥夺条件\n进程所获得的资源在未使用完之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放）。\n\n\n请求并保持条件\n进程己经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。\n\n\n循环等待条件\n存在一种进程资源的循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。\n\n\n\n\n                  \n                  循环等待和死锁关系 \n                  \n                \n\n发生死锁时一定有循环等待，但是发生循环等待时未必死锁（循环等待是死锁的必要不充分条件）。因为按照死锁定义构成等待环所要求的条件更严，它要求 Pi等待的资源必须由 Pi+1来满足，而循环等待条件则无此限制。\n例如在下图中，Pn等待一台输出设备，它可从 P0或 Pk获得。因此，虽然这些进程形成了等待环，但 Pk不在圈内，若 Pk释放了输出设备，则可打破循环等待。因此循环等待只是死锁的必要条件。\n\n如果同类资源数大于 1，则即使有循环等待，也未必发生死锁。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了。\n\n\n\n\n                  \n                  区分不可剥夺条件与请求并保持条件 \n                  \n                \n\n\n若你手上拿着一个苹果（即便你不打算吃），别人不能将你手上的苹果拿走，则这就是不可剥夺条件；\n若你左手拿着一个苹果，允许你右手再去拿一个苹果，则这就是请求并保持条件。\n\n\n\n\n\n                  \n                  死锁公式 \n                  \n                \n\n当资源数量大于各个进程所需资源数-1的总和时，不发生死锁。\n例如：三个进程分别需要3,4,5台设备，即当资源数量大于(3-1)+(4-1)+(5-1)=9时，不发生死锁。而当系统中只有9台设备时，第一个进程分配2台，第二个进程分配3台，第三个进程分配4台，这种情况下，三个进程均无法继续执行下去，发生死锁。当系统再增加1台设备，最后1台设备分配给任意一个进程都可以顺利执行完成，因此保证系统不发生死锁的最小设备数为10。\n\n\n死锁的处理策略\n为使系统不发生死锁，必须设法破坏产生死锁的 4 个必要条件之一，或者允许死锁产生，但当死锁发生时能检测出死锁，并有能力实现恢复。\n\n\n死锁预防\n设置某些限制条件，破坏产生死锁的 4 个必要条件中的一个或几个。\n\n\n死锁避免\n在资源的动态分配过程中，用某种方法防止系统进入不安全状态。\n\n\n死锁的检测及解除\n无须采取任何限制性措施，允许进程在运行过程中发生死锁。通过系统的检测机构及时地检测出死锁的发生，然后采取某种措施解除死锁。\n\n\n\n\n                  \n                  死锁预防和死锁避免的比较 \n                  \n                \n\n死锁预防和死锁避免都属于事先预防策略。\n\n预防死锁的限制条件比较严格，实现起来较为简单，但往往导致系统的效率低，资源利用率低；\n避免死锁的限制条件相对宽松，资源分配后需要通过算法来判断是否进入不安全状态，实现起来较为复杂。\n\n\n\n\n死锁预防\n\n\n\n                  \n                  Tip\n                  \n                \n\n死锁预防能确保系统不发生死锁。\n\n\n防止死锁的发生只需破坏死锁产生的 4 个必要条件之一即可。\n\n\n破坏互斥条件\n若允许系统资源都能共享使用，则系统不会进入死锁状态。但有些资源根本不能同时访问，如打印机等临界资源只能互斥使用。\n所以，破坏互斥条件而预防死锁的方法不太可行，而且在有的场合应该保护这种互斥性。\n\n\n\n破坏不剥夺条件\n当一个己保持了某些不可剥夺资源的进程请求新的资源而得不到满足时，它必须释放己经保持的所有资源，待以后需要时再重新申请。\n\n\n\n破坏请求并保持条件\n\n\n\n破坏循环等待条件\n\n\n\n死锁避免\n避免死锁的方法中，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次分配的安全性。若此次分配不会导致系统进入不安全状态，则允许分配；否则让进程等待。\n系统安全状态\n安全状态，是指系统能按某种进程推进顺序(P_1,P_2,\\cdots,P_n)为每个进程P_i分配其所需的资源，直至满足每个进程对资源的最大需求，使每个进程都可顺序完成。\n此时称P_1,P_2,\\cdots,P_n为安全序列。若系统无法找到一个安全序列，则称系统处于不安全状态。\n\n死锁状态 \\subseteq  不安全状态，即当系统处于不安全状态时，系统不一定会出现死锁。但系统处于安全状态时，一定无死锁进程。\n\n\n\n\n\n银行家算法\n银行家算法是最著名的死锁避免算法。\n算法思想：避免系统进入不安全状态。在每次进行资源分配时，首先检查系统是否有足够的资源满足要求，若有则先进行试分配，并对分配后的新状态进行安全性检查。若新状态安全，则正式分配上述资源，否则拒绝分配上述资源。这样，它保证系统始终处于安全状态，从而避免了死锁现象的发生。\n进程运行之前需要先获取各种资源的最大需求量，当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请的资源数之和是否超过该进程声明的最大需求量。若超过则拒绝分配资源，若未超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，若能满足则按当前的申请量分配资源，否则也要推迟分配。\n\n\n                  \n                  Tip\n                  \n                \n\n银行家算法只是拒绝分配资源而不是限制用户申请资源的顺序。\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n银行家算法通过是否存在安全序列判断申请资源的请求是否合法，但是安全序列不是唯一的，也不是固定的，只是一种可能的分配方案，而不是一种必须遵循的规则。\n\n\n\n\n\n\n\n\n数据结构描述：\n\n\n可利用资源向量 Available\n含有 m 个元素的数组，其中每个元素代表一类可用的资源数目。 Available[j] = K 表示系统中现有R_j类资源 K 个。\n\n\n最大需求矩阵 Max\nn\\times m矩阵，定义系统中 n 个进程中的每个进程对 m 类资源的最大需求。\n一行代表一个进程，一列代表一类资源。Max[i, j]=K 表示进程 i 需要R_j类资源的最 大数目为 K。\n\n\n分配矩阵 Allocation\nn\\times m矩阵，定义系统中每类资源当前已分配给每个进程的资源数。\nAllocation[i, j]=K 表示进程 i 当前已分得R_j类资源的数目为 K。\n\n\n需求矩阵 Need\nn\\times m矩阵，表示每个进程接下来最多还需要多少资源。\nNeed[i, j]=K 表示进程 i 还需要R_j类资源的数目为 K。\n\n\n\n\n死锁检测和解除\n\n\n\n\n                  \n                  死锁避免和死锁检测对比 \n                  \n                \n\n死锁避免需要在进程的运行过程中一直保证之后不可能出现死锁，因此需要知道进程从开始到结束的所有资源请求。\n而死锁检测则是检测某个时刻是否发生死锁，不需要知道进程在整个生命周期中的资源请求，只需知道对应时刻的资源请求。因为死锁检测不关心给某个进程分配资源会不会导致死锁，即使发生了死锁也有解决死锁的方法。\n\n\n系统死锁可利用资源分配图来描述。\n\n简化资源分配图可检测系统状态 S 是否为死锁状态。简化方法如下：\n\n\n在资源分配图中，找出既不阻塞又不孤点的进程P_i（即找出一条有向边与它相连，且该有向边对应资源的申请数量小于或等于系统中已有的空闲资源数量）。消去它所有的请求边和分配边，使之成为孤立的结点。\n\n判断某种资源是否有空闲：用它的资源数量减去它在资源分配图中的出度，例如在上图中，R_1的资源数为 3，而出度也为 3，所以R_1没有空闲资源；R_2的资源数为 2，出度为 1，所以R_2有一个空闲资源。\n\n\n\n进程P_i所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。\n根据 1. 中的方法进行一系列简化后，若能消去图中所有的边，则称该图是可完全简化的。\n\n\nS 为死锁的条件是当且仅当 S 状态的资源分配图是不可完全简化的，该条件为死锁定理。\n\n一旦检测出死锁，就应立即采取相应的措施来解除死锁。死锁解除的主要方法有：\n\n\n资源剥夺法\n挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。 但应防止被挂起的进程长时间得不到资源而处于资源匮乏的状态。\n\n\n撤销进程法\n强制撤销部分甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。\n\n\n进程回退法\n让一或多个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而非被剥夺。要求系统保持进程的历史信息，设置还原点。\n\n\n"},"计算机基础/计算机操作系统/3_内存管理":{"title":"内存管理","links":[],"tags":["操作系统"],"content":"内存管理\n内存管理(Memory Management)是操作系统设计中最重要和最复杂的内容之一。\n操作系统对内存的划分和动态分配，就是内存管理的概念。\n内存管理的主要功能有：\n\n\n内存空间的分配与回收\n由操作系统完成主存储器空间的分配和管理，使程序员摆脱存储分配的麻烦，提高编程效率。\n\n\n地址转换\n在多道程序环境下，程序中的逻辑地址与内存中的物理地址不可能一致，因此存储管理必须提供地址变换功能，把逻辑地址转换成相应的物理地址。\n\n\n内存空间的扩充\n利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存。\n\n\n内存共享\n指允许多个进程访问内存的同一部分。例如，多个合作进程可能需要访问同一块数据，因此必须支持对内存共享区域进行受控访问。\n\n\n存储保护\n保证各道作业在各自的存储空间内运行，互不干扰。\n\n\n什么是内存\n\n\n\n程序的链接与装入\n创建进程首先要将程序和数据装入内存。将用户源程序变为可在内存中执行的程序，通常需要以下几个步骤：\n\n编译：由编译程序将用户源代码编译成若干目标模块。\n链接：由链接程序将编译后形成的一组目标模块及它们所需的库函数链接在一起，形成一个完整的装入模块。\n装入：由装入程序将装入模块装入内存运行。\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n预处理 -&gt; 编译 -&gt; 汇编 -&gt; 链接\n\n\n链接的三种方式：\n\n\n静态链接\n在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的装配模块，以后不再拆开。\n需要解决两个问题：\n\n修改相对地址，编译后的所有目标模块都是从 0 开始的相对地址，当链接成一个装入模块时要修改相对地址。\n变换外部调用符号，将每个模块中所用的外部调用符号也都变换为相对地址。\n\n\n\n\n装入时动态链接\n将用户源程序编译后所得到的一组目标模块，在装入内存时，采用边装入边链接的方式。\n优点：便于修改和更新，便于实现对目标模块的共享。\n\n\n\n运行时动态链接\n对某些目标模块的链接，是在程序执行中需要该目标模块时才进行的。凡在执行过程中未被用到的目标模块，都不会被调入内存和被链接到装入模块上。\n优点：加快程序的装入过程，还可节省大量的内存空间。\n\n\n\n\n模块装入内存时的三种方式：\n\n\n绝对装入\n绝对装入方式只适用于单道程序环境。\n在编译时，若知道程序将驻留在内存的某个位置，则编译程序将产生绝对地址的目标代码。绝对装入程序按照装入模块中的地址，将程序和数据装入内存。\n由于程序中的逻辑地址与实际内存地址完全相同，因此不需对程序和数据的地址进行修改。\n\n\n程序中使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。而通常情况下在程序中采用的是符号地址，编译或汇编时再转换为绝对地址。\n\n\n\n可重定位装入\n根据内存的当前情况，将装入模块装入内存的适当位置。\n在装入时对目标程序中指令和数据地址的修改过程称为重定位，又因为地址变换通常是在进程装入时一次完成的，故称为静态重定位。\n当一个作业装入内存时，必须给它分配要求的全部内存空间，若没有足够的内存，则无法装入。作业一旦进入内存，整个运行期间就不能在内存中移动，也不能再申请内存空间。\n\n\n\n动态运行时装入\n动态运行时装入也称动态重定位。\n程序在内存中若发生移动，则需要采用动态的装入方式。\n装入程序把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正要执行时才进行。因此，装入内存后的所有地址均为相对地址。\n这种方式需要一个重定位寄存器的支持，\n优点：可以将程序分配到不连续的存储区；在程序运行之前可以只装入部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享。\n\n\n\n逻辑地址与物理地址\n编译后，每个目标模块都从 0 号单元开始编址，这称为该目标模块的相对地址（或逻辑地址）。\n当链接程序将各个模块链接成一个完整的可执行目标程序时，链接程序顺序依次按各个模块的相对地址构成统一的从 0 号单元开始编址的逻辑地址空间（或虚拟地址空间），对于 32 位系统，逻辑地址空间的范围为 0 ～ 2^32^-1。\n\n虚拟地址空间的大小由底层的虚拟内存管理机制和操作系统决定，通常在不同的操作系统中有所不同，与内存和硬盘的大小没有关系，内存和硬盘的大小仅决定虚拟存储器实际可用容量的最大值。、\n\n进程在运行时，看到和使用的地址都是逻辑地址。用户程序和程序员只需知道逻辑地址，而内存管理的具体机制则是完全透明的。不同进程可以有相同的逻辑地址，因为这些相同的逻辑地址可以映射到主存的不同位置。\n物理地址空间是指内存中物理单元的集合，它是地址转换的最终地址，进程在运行时执行指令和访问数据，最后都要通过物理地址从主存中存取。当装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址转换成物理地址，这个过程称为地址重定位。\n操作系统通过内存管理部件(MMU)将进程使用的逻辑地址转换为物理地址。进程使用虚拟内存空间中的地址，操作系统在相关硬件的协助下，将它“转换”成真正的物理地址。逻辑地址通过页表映射到物理内存，页表由操作系统维护并被处理器引用。\n\n\n\n进程的内存映像\n不同于存放在硬盘上的可执行程序文件，当一个程序调入内存运行时，就构成了进程的内存映像。\n一个进程的内存映像一般有几个要素：\n\n代码段：即程序的二进制代码，代码段是只读的，可以被多个进程共享。\n数据段：即程序运行时加工处理的对象，包括全局变量和静态变量。\n进程控制块（PCB）：存放在系统区。操作系统通过 PCB 来控制和管理进程。\n堆：用来存放动态分配的变量。\n栈：用来实现函数调用。从用户空间的最大地址往低地址方向增长。\n\n代码段和数据段在程序调入内存时就指定了大小，而堆和栈不一样。当调用像 malloc 和 free 这样的 C 标准库函数时，堆可以在运行时动态地扩展和收缩。用户栈在程序运行期间也可以动态地扩展和收缩，每次调用一个函数，栈就会增长；从一个函数返回时，栈就会收缩。\n内存保护\n确保每个进程都有一个单独的内存空间。内存分配前，需要保护操作系统不受用户进程的影响，同时保护用户进程不受其他用户进程的影响。\n内存保护可采取两种方法：\n\n\n在 CPU 中设置一对上、下限寄存器，存放用户作业在主存中的下限和上限地址。每当 CPU 要访问一个地址时，分别和两个寄存器的值相比，判断有无越界。\n\n\n采用重定位寄存器（基地址寄存器）和界地址寄存器（限长寄存器）来进行越界检查。\n重定位寄存器存放进程的起始物理地址，界地址寄存器存放进程的最大逻辑地址。\n内存管理机构动态地将逻辑地址与界地址寄存器进行比较，若未发生地址越界，则加上重定位寄存器的值后映射成物理地址，再送交内存单元。\n\n\n这种方案允许操作系统内核修改这两个寄存器的值，而不允许用户程序修改。因此加载重定位寄存器和界地址寄存器时必须使用特权指令，只有操作系统内核才可以加载这两个存储器。\n\n\n\n内存共享\n并不是所有的进程内存空间都适合共享，只有那些只读的区域才可以共享。\n可重入代码又称纯代码，是一种允许多个进程同时访问但不允许被任何进程修改的代码。\n在实际执行时，可以为每个进程配以局部数据区，把在执行中可能改变的部分复制到该数据区。这样，程序在执行时只需对该私有数据区中的内存进行修改，并不去改变共享的代码。\n\n覆盖与交换技术是在多道程序环境下用来扩充内存的两种方法。\n交换技术主要在不同进程（或作业）之间进行，而覆盖则用于同一个程序或进程中。\n对于主存无法存放用户程序的矛盾，现代操作系统是通过虚拟内存技术来解决的，覆盖技术则已成为历史，而交换技术在现代操作系统中仍具有较强的生命力。\n内存分配与回收\n存储管理方式随着操作系统的发展而发展。\n在操作系统由单道向多道发展时，存储管理方式由单一连续分配发展为固定分区分配。为了能更好地适应不同大小的程序要求，又从固定分区分配发展到动态分区分配。为了更好地提高内存的利用率，进而从连续分配方式发展到离散分配方式—页式存储管理。\n连续分配管理方式\n\n连续分配方式是指为一个用户程序分配一个连续的内存空间。例如某用户需要 100MB 的内存空间，连续分配方式就在内存空间中为用户分配一块连续的 100MB 空间。\n连续分配方式主要包括单一连续分配、固定分区分配和动态分区分配。\n单一连续分配\n内存在此方式下分为系统区和用户区。\n\n系统区仅供操作系统使用，通常在低地址部分；\n在用户区内存中，仅有一道用户程序，即整个内存的用户空间由该程序独占。\n\n优点：实现简单；无外部碎片；无须进行内存保护，因为内存中永远只有一道程序。\n缺点：只能用于单用户、单任务的操作系统中；有内部碎片；存储器的利用率极低。\n\n\n                  \n                  内部碎片 \n                  \n                \n\n内部碎片是指分配给某进程的内存区域中，如果有些部分没有使用，那么这部分就是“内部碎片”。\n\n\n\n\n                  \n                  外部碎片碎片 \n                  \n                \n\n在内存中存在的多个不连续的空闲区域。这些空闲区域太小，无法满足新的内存分配请求，即使总的空闲内存量可能足够大。\n\n\n固定分区分配\n固定分区分配是最简单的一种多道程序存储管理方式，它将用户内存空间划分为若干固定大小的区域，每个分区只装入一道作业。当有空闲分区时，便可再从外存的后备作业队列中选择适当大小的作业装入该分区，如此循环。\n在划分分区时有两种不同的方法：\n\n\n分区大小相等：程序太小会造成浪费，程序太大又无法装入，缺乏灵活性，但适用于用一台计算机控制多个相同对象的场合。\n\n\n分区大小不等：划分为多个较小的分区、适量的中等分区和少量大分区。\n\n\n\n为了便于分配，建立一张分区使用表，通常按分区大小排队，各表项包括每个分区的起始地址、大小及状态(是否己分配)。\n\n分配内存时，便检索该表，以找到一个能满足要求且尚未分配的分区分配给装入程序，并将对应表项的状态置为”已分配”；若找不到这样的分区，则拒绝分配。回收内存时，只需将对应表项的状态置为“未分配”即可。\n问题：\n\n程序可能太大而放不进任何一个分区；\n当程序小于固定分区大小时，也要占用一个完整的内存分区，这样分区内部就存在空间浪费，会产生内部碎片。固定分区方式无外部碎片，但不能实现多进程共享一个主存区，所以存储空间利用率低。\n\n动态分区分配\n分配原理\n又称可变分区分配。这种分配方式不会预先划分内存分区，它是在进程装入内存时，根据进程的实际需要，动态地为之分配内存，并使分区的大小正好适合进程的需要。因此，系统中分区的大小和数目是可变的。\n动态分区分配没有内部碎片，但是有外部碎片。\n\n\n                  \n                  举例 \n                  \n                \n\n如图所示，系统有 64MB 内存空间，其中低 8MB 固定分配给操作系统，其余为用户可用内存。\n开始时装入前三个进程，它们分别分配到所需的空间后，内存仅剩 4MB，进程 4 无法装入。在某个时刻，CPU 出现空闲，操作系统就换出进程 2，换入进程 4。由于进程 4 比进程 2 小，这样在主存中就产生了一个 6MB 的内存块。之后 CPU 又出现空闲，需要换入进程 2，而主存无法容纳进程 2，操作系统就换出进程 1，换入进程 2。\n\n动态分区在开始时是很好的，但是随着时间的推移，内存中会产生越来越多的小内存块，内存的利用率也随之下降。这些小内存块被称为外部碎片，它存在于所有分区的外部，与固定分区中的内部碎片正好相对。\n\n外部碎片可通过紧凌技术来克服，即操作系统不时地对进程进行移动和整理。但是，这需要动态重定位寄存器的支持，且相对费时。紧凑过程实际上类似于 Windows 系统中的磁盘碎片整理程序，只不过后者是对外存空间的紧凑。\n\n\n\n\n\n                  \n                  相应的数据结构 \n                  \n                \n\n\n\n空闲分区表\n\n\n\n空闲分区链\n\n\n\n\n\n在动态分区分配中，与固定分区分配类似，设置一张空闲分区链（表），可以按始址排序。\n分配内存时，检索空闲分区链，找到所需的分区，若其大小大于请求大小，便从该分区中按请求大小分割一块空间分配给装入进程（若剩余部分小到不足以划分，则无须分割），余下部分仍留在空闲分区链中。\n回收内存时，系统根据回收分区的始址，从空闲分区链中找到相应的插入点，此时可能出现四种情况：\n\n\n回收区与插入点的前一空闲分区相邻，将这两个分区合并，并修改前一分区表项的大小为两者之和；\n例：回收进程 4\n\n\n\n回收区与插入点的后一空闲分区相邻，将这两个分区合并，并修改后一分区表项的始址和大小；\n例：回收进程 3\n\n\n\n回收区同时与插入点的前、后两个分区相邻，此时将这三个分区合并，修改前一分区表项的大小为三者之和，取消后二分区表项；\n例：回收进程 4\n\n\n\n回收区没有相邻的空闲分区，此时应为回收区新建一个表项，填写始址和大小，并插入空闲分区链。\n例：回收进程 2\n\n\n\n基于顺序搜索的分配算法\n把一个新作业装入内存时，必须按照一定的动态分区分配算法，从空闲分区表或空闲分区链中选出一个分区分配给该作业。\n顺序分配算法是指依次搜索空闲分区链上的空闲分区，以寻找一个大小满足要求的分区。\n顺序分配算法有以下四种：\n\n\n首次适应(First Fit, FF)算法\n空闲分区以地址递增的次序链接。分配内存时，从链首开始顺序查找，找到大小能满足要求的第一个空闲分区分配给作业。\n首次适应算法会使得内存的低地址部分出现很多小的空闲分区，而每次分配查找时都要经过这些分区，因此增加了查找开销。\n\n\n邻近适应(Next Fit, NF)算法\n又称循环首次适应算法，由首次适应算法演变而成。不同之处是，分配内存时从上次查找结束的位置开始继续查找。\n但它常常导致在内存空间的尾部（因为在一遍扫描中，内存前面部分使用后再释放时，不会参与分配）分裂成小碎片。通常比首次适应算法要差。\n\n\n最佳适应(Best Fit, BF)算法\n空闲分区按容量递增的次序排列。分配内存时，顺序查找到一个能满足空间大小需要的最小空闲分区给作业。\n虽然称为”最佳”，但是性能通常很差，因为每次最佳的分配会留下很小的难以利用的内存块，会产生最多的外部碎片。\n\n\n最坏适应(Worst Fit, WF)算法\n空闲分区以容量递减的次序链接，找到第一个能满足要求的，即最大的分区，从中分割一部分存储空间给作业。\n与最佳适应算法相反，最坏适应算法每次都选择最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用。但会很快导致没有可用的大内存块，因此性能也非常差。\n\n\n\n基于索引搜索的分配算法\n当系统很大时，空闲分区链可能很长，此时采用顺序分配算法可能很慢。因此，在大中型系统中往往采用索引分配算法。\n算法思想：根据其大小对空闲分区分类，对于每类（大小相同）空闲分区，单独设立一个空闲分区链，并设置一张索引表来管理这些空闲分区链。当为进程分配空间时，在索引表中查找所需空间大小对应的表项，并从中得到对应的空闲分区链的头指针，从而获得一个空闲分区。\n索引分配算法有以下三种。\n\n\n快速适应算法\n空闲分区的分类根据进程常用的空间大小进行划分。\n分配过程分为两步：\n\n首先根据进程的长度，在索引表中找到能容纳它的最小空闲分区链表；\n然后从链表中取出第一块进行分配。\n\n优点是查找效率高、不产生内部碎片；缺点是回收分区时，需要有效地合并分区，算法比较复杂，系统开销较大。\n\n\n伙伴系统\n规定所有分区的大小均为 2 的 k 次幂（ k 为正整数）。\n当需要为进程分配大小为 n 的分区时(2^{i-1}&lt; n\\le 2^i )，在大小为 2^i 的空闲分区链中查找。若找到，则将该空闲分区分配给进程。否则，表示大小为 2^i 的空闲分区已耗尽，需要在大小为 2^{i+1} 的空闲分区链中继续查找。\n若存在大小为 2^{i+1} 的空闲分区，则将其等分为两个分区，这两个分区称为一对伙伴，其中一个用于分配，而将另一个加入大小为 2^{i} 的空闲分区链。若不存在，则继续查找，直至找到为止。回收时，也可能需要对伙伴分区进行合并。\n\n\n哈希算法\n根据空闲分区链表的分布规律，建立哈希函数，构建一张以空闲分区大小为关键字的哈希表，每个表项记录一个对应空闲分区链的头指针。\n分配时，根据所需分区大小，通过哈希函数计算得到哈希表中的位置，从中得到相应的空闲分区链表。\n\n\n非连续分配管理方式\n在连续分配方式中，我们发现，即使内存有超过 1GB 的空闲空间，但若没有连续的 1GB 空间，则需要 1GB 空间的作业仍然是无法运行的；但若采用非连续分配方式，则作业所要求的 1GB 内存空间可以分散地分配在内存的各个区域，当然，这也需要额外的空间去存储它们（分散区域）的索引，使得非连续分配方式的存储密度低于连续分配方式。\n非连续分配方式根据分区的大小是否固定，分为分页存储管理和分段存储管理。在分页存储管理中，又根据运行作业时是否要将作业的所有页面都装入内存才能运行，分为基本分页存储管理和请求分页存储管理。\n基本分页存储管理\n固定分区会产生内部碎片，动态分区会产生外部碎片，这两种技术对内存的利用率都比较低。\n我们希望内存的使用能尽量避免碎片的产生，这就引入了分页的思想：将内存空间分为若干固定大小（如 4KB）的分区，称为页框、页帧或物理块。进程的逻辑地址空间也分为与块大小相等的若干区域，称为页或页面。操作系统以页框为单位为各个进程分配内存空间。\n\n\n                  \n                  分页和固定分区技术的不同点 \n                  \n                \n\n块的大小相对分区要小很多，而且进程也按照块进行划分，进程运行时按块申请主存可用空间并执行。\n这样，进程只会在为最后一个不完整的块申请一个主存块空间时，才产生主存碎片。尽管会产生内部碎片，但这种碎片相对于进程来说也是很小的，每个进程平均只产生半个块大小的内部碎片（也称页内碎片）。\n\n\n分页存储的基本概念\n\n页面和页面大小\n进程中的块称为页或页面，进程的逻辑地址空间中的每个页面有一个编号，称为页号，从 0 开始；\n内存中的块称为页框或页帧，内存空间中的每个页框也有一个编号，称为页框号（或物理块号），也从 0 开始。\n进程在执行时需要申请内存空间，即要为每个页面分配内存中的可用页框，这就产生了页号和页框号的一一对应。\n\n外存也以同样的单位进行划分，直接称为块或盘块。\n\n为方便地址转换，页面大小应是 2 的整数次幂。\n\n页面大小应该适中，页面太小会使进程的页面数过多，这样页表就会过长，占用大量内存，而且也会增加硬件地址转换的开销，降低页面换入/换出的效率；页面过大又会使页内碎片增多，降低内存的利用率。\n\n\n页面大小刚好是 2 的整数幂的好处：\n计算机硬件可以很快速的把一个逻辑地址拆分成对应的页号和页内偏移量，而无需进行除法运算，从而提升了运行速度。\n然后根据页号查询页表从而找到页面存放的内存块号，将二进制表示的内存块号和页内偏移量拼接起来，就可以得到最终的物理地址。\n\n\n\n\n地址结构\n分页存储管理的逻辑地址结构包含两部分：前一部分为页号，后一部分为页内偏移量，即页内地址。\n在下图所示的例子中，地址长度为 32 位， 其中\n\n0〜11 位为页内地址，即每页大小为 4KB；\n12〜31 位为页号，即最多允许2^{20}页。\n\n\n\n页表\n为了便于在内存中找到进程的每个页面所对应的物理块，系统为每个进程建立一张页表，它记录页面在内存中对应的物理块号，页表一般存放在内存中。\n进程的每个页面对应一个页表项，每个页表项由页号和块号组成，它记录了页面在内存中对应的物理块号。\n页表是由页表项组成的。每个页表项的长度是相同的，页号是“隐含”的（因为页表项连续存放，类似于数组）。\n在配置页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。可见，页表的作用是实现从页号到物理块号的地址映射。\n\n\n\n                  \n                  页表项与地址结构比较 \n                  \n                \n\n页表项与地址都由两部分构成，而且第一部分都是页号，但页表项的第二部分是物理内存中的块号，而地址的第二部分是页内偏移；\n页表项的第二部分与地址的第二部分共同组成物理地址。\n\n\n\n\n基本地址变换机构\n\n基本地址变换机构的任务是借助进程的页表将逻辑地址转换为物理地址。\n为了提高地址变换的速度，通常会在系统中设置一个页表寄存器(PTR)，存放页表在内存中的起始地址 F 和页表长度 M。进程未执行时，页表的始址和页表长度放在进程控制块(PCB)中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。\n\n设页面大小为 L，逻辑地址 A 到物理地址 E 的变换过程如下：\n\n\n计算页号 P 和页内偏移量 W\n如果用十进制数手算，则 P=A/L, W=A%L；\n\n但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量。\n\n\n\n判断页号是否越界。比较页号 P 和页表长度 M，若 P\\geqslantM，则产生越界中断，否则继续执行。\n\n页号是从 0 开始的，而页表长度至少是 1，因此 P=M 时也会越界\n\n\n\n在页表中查询页号对应的页表项，确定页面存放的物理块号（第 1 次访存）。页表中页号 P 对应的页表项地址 = 页表起始地址 F + 页号 P \\times 页表项长度，取出该页表项内容 b，即为内存块号。\n\n\n计算物理地址 E=b\\times L+W，用得到的物理地址 E 去访存（第 2 次访存）。\n如果内存块号、页面偏移量是用二进制表示的，那么把二者拼接起来就是最终的物理地址了。\n\n\n\n\n                  \n                  如何加快虚实地址转换 \n                  \n                \n\n虚实地址转换是指逻辑地址和物理地址的转换。\n\n\n增大快表容量能把更多的表项装入快表，会加快虚实地址转换的速度。\n\n\n让页表常驻内存可以省去一些不在内存中的页表从磁盘上调入的过程，也能加快虚实地址转换。\n\n\n\n增大交换区对虚实地址转换速度无影响。\n\n\n\n\n\n                  \n                  页表项长度、页表长度、页面大小的区别 \n                  \n                \n\n\n页表长度：这个页表中总共有几个页表项，即总共有几个页；\n页表项长度：每个页表项占多大的存储空间；\n页面大小：一个页面占多大的存储空间；\n\n\n\n\n在分页存储管理（页式管理）的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。\n因此，页式管理中地址是一维的。即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。\n\n\n                  \n                  分页管理方式存在的两个主要问题 \n                  \n                \n\n\n每次访存操作都需要进行逻辑地址到物理地址的转换，地址转换过程必须足够快，否则访存速度会降低。\n每个进程引入页表，用于存储映射机制，页表不能太大，否则内存利用率会降低。\n\n\n\n具有快表的地址变换机构\n由上面介绍的地址变换过程可知，若页表全部放在内存中，则存取一个数据或一条指令至少要访问两次内存：第一次是访问页表，确定所存取的数据或指令的物理地址；第二次是根据该地址存取数据或指令。\n显然，这种方法比通常执行指令的速度慢了一半。为此，在地址变换机构中增设一个具有并行查找能力的高速缓冲存储器一一快表。\n快表，又称联想寄存器(TLB, translation lookaside buffer)，是一种访问速度比内存快很多的高速缓存（不是内存），用来存放最近访问的页表项的副本，可以加速地址变换的速度。\n与此对应，内存中的页表常称为慢表。\n\n快表是专门的硬件，当进程切换的时候，快表的内容需要被清除。\n\n\n\n                  \n                  TLB 和普通 Cache 的区别 \n                  \n                \n\nTLB 中只有页表项的副本，而普通 Cache 中可能会有其他各种数据的副本。\n\n\n\n\n在具有快表的分页机制中，地址的变换过程如下：\n\n\nCPU 给出逻辑地址，由硬件进行地址转换，得到页号、页内偏移量，将页号与快表中的所有页号进行比较。\n\n\n如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。\n因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。\n\n\n如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。\n因此，若快表未命中，则访问某个逻辑地址需要两次访存。\n\n在找到页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换。\n\n\n\n\n\n有些处理机设计为快表和慢表同时查找，若在快表中查找成功则终止慢表的查找。\n\n\n\n                  \n                  局部性原理 \n                  \n                \n\n从广义上讲，快表、页高速缓存及虚拟内存技术都属于高速缓存技术，这个技术所依赖的原理就是局部性原理。\n局部性原理既适用于程序结构，又适用于数据结构。局部性原理表现在以下两个方面：\n\n\n时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。因为程序中存在大量的循环。\n\n\n空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。因为很多数据在内存中都是连续存放的。\n\n\n时间局部性通过将近来使用的指令和数据保存到高速缓存中，并使用高速缓存的层次结构实现。\n空间局部性通常使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。\n虚拟内存技术实际上建立了“内存-外存”的两级存储器结构，利用局部性原理实现高速缓存。\n\n\n在基本地址变换机构中，每次要访问一个逻辑地址，都需要查询内存中的页表。由于局部性原理，可能连续很多次查到的都是同一个页表项。这就是为什么具有快表的地址变换机构能大幅提高系统效能的原因。\n\n两级页表\n\n引入分页管理后，进程在执行时不需要将所有页调入内存页框，而只需将保存有映射关系的页表调入内存，但仍需考虑页表的大小。因为页表必须连续存放，当页表很大时，需要占用很多个连续的页框。但没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。\n以 32 位逻辑地址空间、页面大小4KB、页表项大小4B为例：页内偏移为log_2{4K}=12位，页号部分为 20 位，则每个进程页表中的页表项数可达2^{20}之多，仅页表就要占用2^{20}×4B/4KB=1K个页，而且还要求是连续的，显然这是不切实际的。\n\n解决上述问题的方法有两种：\n\n\n对于页表所需的内存空间，采用离散分配方式，用一张索引表来记录各个页表的存放位置，这就解决了页表占用连续内存空间的问题。\n\n\n只将当前需要的部分页表项调入内存，其余的页表项仍驻留磁盘，需要时再调入（虚拟内存的思想），这就解决了页表占用内存过多的问题。\n\n该方法和引进页表机制的思路一模一样，实际上就是为离散分配的页表再建立一张页表，称为外层页表（或页目录）。\n\n\n\n\n为了方便实现地址变换，需要在系统中增设一个外层页表寄存器（也称页目录基址寄存器），用于存放页目录始址。\n二级页表如何实现地址变换：\n\n按照地址结构将逻辑地址拆分成三部分；\n将逻辑地址中的页目录号（一级页号）作为页目录的索引，从中找到对应页表的始址（第 1 次访存）；\n再用二级页号作为页表分页的索引，从中找到对应的页表项（第 2 次访存）；\n结合页内偏移量得到物理地址，再用该地址访问内存单元（第 3 次访存）。\n\n\n在多级页表中，页表基址寄存器存放的是顶级页表的起始物理地址，故存放的是一级页表的起始物理地址。\n\n\n\n\n对于更大的逻辑地址空间，以 64 位为例。\n若采用两级分页，则页面大小为 4KB，页表项大小为 4B；若按物理块大小划分页表，则有 42 位用于外层页号，此时外层页表有 4096G 个页表项，需占用 16384GB 的连续内存空间，显然这是无法接受的，因此必须采用多级页表，再对外层页表分页。\n建立多级页表的目的在于建立索引，以免浪费内存空间去存储无用的页表项。若采用多级页表机制，则各级页表的大小不能超过一个页面。\n\n\n基本分段存储管理\n分页管理方式是从计算机的角度考虑设计的，目的是提高内存的利用率，提升计算机的性能。分页通过硬件机制实现，对用户完全透明。\n分段管理方式的提出则考虑了用户和程序员，以满足方便编程、信息保护和共享、动态增长及动态链接等多方面的需要。\n\n分段\n分段系统将用户进程的逻辑地址空间划分为大小不等的段。\n例如，用户进程由主程序段、两个子程序段、栈段和数据段组成，于是可以把这个用户进程划分为 5 段，每段从 0 开始编址，并分配一段连续的地址空间（段内要求连续，段间不要求连续，进程的地址空间是二维的）。\n\n分段系统的逻辑地址结构由段号（段名）和段内地址（段内偏移量）所组成。\n段号的位数决定了每个进程最多可以分几个段。段内地址位数决定了每个段的最大长度是多少。\n\n\n在页式系统中，逻辑地址的页号和页内偏移量对用户是透明的，但在分段系统中，段号和段内偏移量必须由用户显式提供，在高级程序设计语言中，这个工作由编译程序完成。\n\n段表\n每个进程都有一张逻辑空间与内存空间映射的段表，其中每个段表项对应进程的一段，段表项记录该段在内存中的始址和长度。\n配置段表后，执行中的进程可通过查找段表，找到每段所对应的内存区。段表用于实现从逻辑段到物理内存区的映射。\n\n地址变换\n\n从逻辑地址 A 中取出前几位为段号 S，后几位为段内偏移量 W。\n判断段号是否越界，若段号 S \\ge 段表长度 M，则产生越界中断，否则继续执行。\n在段表中查询段号对应的段表项（第 1 次访存），段号 S 对应的段表项地址 = 段表始址 F + 段号 S \\times 段表项长度。取出段表项中该段的段长 C，若 W \\ge C，则产生越界中断，否则继续执行。\n取出段表项中该段的始址 b，计算物理地址 E = b + W，用物理地址 E 去访存（第 2 次访存）。\n\n\n分段、分页管理的对比\n\n\n页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的。段是信息的逻辑单位。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。\n\n\n分段对用户是可见的，用户编程时需要显式地给出段名。页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。\n\n\n分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。\n\n\n\n分段比分页更容易实现信息的共享和保护。不能被修改的代码称为纯代码或可重入代码（不属于临界资源），这样的代码是可以共享的。可修改的代码是不能共享的（比如，有一个代码段中有很多变量，各进程并发地同时访问可能造成数据不一致)。\n\n\n与分页管理类似，分段管理的保护方法主要有两种：一种是存取控制保护，另一种是地址越界保。\n地址越界保护将段表寄存器中的段表长度与逻辑地址中的段号比较，若段号大于段表长度，则产生越界中断；再将段表项中的段长和逻辑地址中的段内偏移进行比较，若段内偏移大于段长，也会产生越界中断。\n分页管理只需要判断页号是否越界，页内偏移是不可能越界的。\n\n\n段页式存储管理\n\n分页存储管理能有效地提高内存利用率，而分段存储管理能反映程序的逻辑结构并有利于段的共享和保护。将这两种存储管理方法结合起来，便形成了段页式存储管理方式。\n在段页式系统中，进程的地址空间首先被分成若干逻辑段，每段都有自已的段号，然后将每段分成若干大小固定的页。对内存空间的管理仍然和分页存储管理一样，将其分成若干和页面大小相同的存储块，对内存的分配以存储块为单位。\n\n在段页式系统中，作业的逻辑地址分为三部分：段号、页号和页内偏移量\n\n段号的位数决定了每个进程最多可以分几个段；\n段页号位数决定了每个段最多有多少页；\n页页内偏移量决定了页面大小、内存块大小是多少；\n\n\n为了实现地址变换，系统为每个进程建立一张段表，每个段对应一个段表项，每个段表项至少包括段号、页表长度和页表始址；每个段有一张页表，每个页表项至少包括页号和块号。\n\n在段页式存储管理中，每个进程的段表只有一个，而页表可能有多个。\n\n此外，系统中还应有一个段表寄存器，指出进程的段表始址和段表长度（段表寄存器和页表寄存器的作用都有两个，一是在段表或页表中寻址，二是判断是否越界）。\n\n在进行地址变换时，首先通过段表查到页表始址，然后通过页表找到物理块号，最后形成物理地址。\n如图所示，进行一次访问实际需要三次访问主存，这里同样可以使用快表来加快查找速度，其关键字由段号、页号组成，值是对应的物理块号和保护码。\n\n虚拟内存\n基本概念\n\n传统存储管理方式的特征\n\n传统存储管理方式的特征、缺点：\n\n\n一次性：作业必须一次性全部装入内存后才能开始运行。\n这会造成两个问题：\n\n作业很大时，不能全部装入内存，导致大作业无法运行；\n当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降。\n\n\n\n驻留性：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。\n事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。\n\n\n虚拟存储器的定义\n基于局部性原理，在程序装入时，仅须将程序当前要运行的少数页面或段先装入内存，而将其余部分暂留在外存，就可以让程序开始执行。\n在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。\n若内存空间不够，操作系统将内存中暂时不使用的内容换出到外存上，从而腾出空间存放将要调入内存的信息，这个过程就是页面置换（或段置换）功能。\n这样，系统好像为用户提供了一个比实际内存容量大得多的存储器，称为虚拟存储器。\n\n之所以将其称为虚拟存储器，是因为这种存储器实际上并不存在，只是由于系统提供了部分装入、请求调入和置换功能后（对用户透明），给用户的感觉是好像存在一个比实际物理内存大得多的存储器。但容量大只是一种错觉，是虚的。\n\n\n虚拟存储器只能基于非连续分配。\n\n虚拟存储器的特征\n虚拟存储器有以下三个主要特征：\n\n\n多次性\n是指无须在作业运行时一次性地全部装入内存，而允许被分成多次调入内存运行，即只需将当前要运行的那部分程序和数据装入内存即可开始运行。以后每当要运行到尚未调入的那部分程序时，再将它调入。多次性是虚拟存储器最重要的特征。\n\n\n对换性\n是指无须在作业运行时一直常驻内存，在进程运行期间，允许将那些暂不使用的程序和数据从内存调至外存的对换区（换出），待以后需要时再将它们从外存调至内存（换进）。正是由于对换性，才使得虚拟存储器得以正常运行。\n\n\n虚拟性\n是指从逻辑上扩充内存的容量，使用户所看到的内存容量远大于实际的内存容量。这是虚拟存储器所表现出的最重要特征，也是实现虚拟存储器的最重要目标。\n\n\n虚拟内存技术的实现\n虚拟内存技术允许将一个作业分多次调入内存。采用连续分配方式时，会使相当一部分内存空间都处于暂时或“永久”的空闲状态，造成内存资源的严重浪费，而且也无法从逻辑上扩大内存容量。\n因此，虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。\n\n\n不管哪种方式，都需要有一定的硬件支持。例如：\n\n一定容量的内存和外存；\n页表机制（或段表机制），作为主要的数据结构；\n中断机构，当用户程序要访问的部分尚未调入内存时，则产生中断；\n地址变换机构，用于逻辑地址到物理地址的变换。\n\n\n请求分页管理方式\n\n请求分页系统建立在基本分页系统的基础之上，为支持虚拟存储器功能而增加了请求调页和页面置换功能。\n在请求分页系统中，只要求将当前需要的一部分页面装入内存，便可启动作业运行。在作业执行过程中，当所访问的页面不在内存时，再通过请求调页功能将其从外存调入内存；当内存空间不够时，通过页面置换功能将内存中暂时用不到的页面换出到外存。\n页表机制\n与基本分页管理相比，请求分页管理中，为了实现“请求调页”，操作系统需要知道每个页面是否已经调入内存；如果还没调入，那么也需要知道该页面在外存中存放的位置。\n当内存空间不够时，要实现“页面置换”，操作系统需要通过某些指标来决定到底换出哪个页面；有的页面没有被修改过，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面是否被修改的信息。\n\n缺页中断机构\n在请求分页系统中，每当所要访问的页面不在内存中时，便产生一个缺页中断，请求操作系统的缺页中断处理程序处理。此时应将缺页的进程阻塞塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。\n若内存中有空闲页框，则为进程分配一个页框，将所缺页面从外存装入该页框，并修改页表中的相应表项，若内存中没有空闲页框，则由页面置换算法选择一个页面淘汰，若该页在内存期间被修改过，则还要将其写回外存。未被修改过的页面不用写回外存。\n缺页中断作为中断，同样要经历诸如保护 CPU 环境、分析中断原因、转入缺页中断处理程序、恢复 CPU 环境等几个步骤。但与一般的中断相比，它有以下两个明显的区别：\n\n\n指令执行期间而非一条指令执行完后产生和处理中断，属于内部异常。\n\n缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断。\n\n\n\n一条指令在执行期间，可能产生多次缺页中断。\n\n如将逻辑地址 A 中的数据复制到逻辑地址 B，而 A、B 属于不同的页面并且都没有调入内存，则有可能产生两次中断。\n\n\n\n地址变换机构\n在基本分页系统地址变换机构的基础上，为实现虚拟内存，增加了产生和处理缺页中断，及从内存中换出一页的功能。\n\n请求分页系统的地址变换过程如下：\n\n先检索快表，若命中，则从相应表项中取出该页的物理块号，并修改页表项中的访问位，以供置换算法换出页面时参考。对于写指令，还需要将修改位置为 1。\n若快表未命中，则要到页表中查找，若找到，则从相应表项中取出物理块号，并将该页表项写入快表，若快表已满，则需采用某种算法替换。\n若在页表中未找到，则需要进行缺页中断处理，请求系统将该页从外存换入内存，页面被调入内存后，由操作系统负责更新页表和快表，并获得物理块号。\n利用得到的物理块号和页内地址拼接形成物理地址，用该地址去访存。\n\n\n\n\n\n修改访问位和修改位\n只有“写指令”才需要修改“修改位”。并且，一般来说只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表。这样可以减少访存次数。\n\n\n启动 I/O 硬件\n换入/换出页面都需要启动慢速的 I/O 操作，如果换入/换出太频繁，会有很大的开销。\n\n\n修改页表\n页面调入内存后，需要修改慢表，同时也需要将表项复制到快表中。\n\n\n\n页框分配\n\n驻留集\n对于分页式的虚拟内存，在进程准备执行时，不需要也不可能将一个进程的所有页都读入主存。因此，操作系统必须决定读取多少页，即决定给特定的进程分配几个页框。\n给一个进程分配的页框的集合就是这个进程的驻留集。需要考虑以下两点：\n\n驻留集越小，驻留在内存中的进程就越多，可以提高多道程序的并发度，但分配给每个进程的页框太少，会导致缺页率较高，CPU 需耗费大量时间来处理缺页。\n驻留集越大，当分配给进程的页框超过某个数目时，再为进程增加页框对缺页率的改善是不明显的，反而只能是浪费内存空间，还会导致多道程序并发度的下降，资源利用率降低。\n\n\n在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小。\n\n内存分配策略\n在请求分页系统中，可采取两种内存分配策略，即固定和可变分配策略。\n\n\n固定分配：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，驻留集大小不变。\n可变分配：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即，驻留集大小可变。\n\n\n在进行置换时，也可采取两种置换策略，即全局置换和局部置换。\n\n\n局部置换：发生缺页时只能选进程自已的物理块进行置换。\n全局置换：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。\n\n\n于是可组合出下面三种适用的策略：\n\n\n固定分配局部置换：\n系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。\n缺点：难以确定应为每个进程分配的物理块数目。太少会频繁出现缺页中断，太多又会降低 CPU 和其他资源的利用率。\n\n采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数。\n\n\n\n可变分配全局置换：\n刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程；若已无空闲物理块，则可选择一个未锁定的页面换出外存，再将该物理块分配给缺页的进程。\n\n只要缺页就给分配新物理块。\n\n采用这种策略时，只要某进程发生缺页，都将获得新的物理块，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。被选择调出的页可能是系统中任何一个进程中的页，因此这个被选中的进程拥有的物理块会减少，缺页率会增加。\n\n\n可变分配局部置换：\n刚开始会为每个进程分配一定数量的物理块。当某进程发生缺页时，只允许从该进程自已的物理块中选出一个进行换出外存。\n如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当程度；反之，如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。\n\n根据发生缺页的频率来动态地增加或减少进程的物理块。\n\n\n\n\n\n                  \n                  为什么没有固定分配全局置换 \n                  \n                \n\n全局置换意味着一个进程拥有的物理块数量必然会改变，因此不可能是固定分配，这也就是为什么没有固定分配全局置换。\n\n\n调入页面的时机\n为确定系统将进程运行时所缺的页面调入内存的时机，可采取以下两种调页策略：\n\n\n预调页策略\n根据局部性原理（主要指空间局部性），一次调入若干个相邻的页面可能比一次调入一个页面更高效。但如果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久之后可能访问到的页面，将它们预先调入内存。\n这种策略主要用于进程的首次调入，由程序员指出应该先调入哪些部分。\n\n\n请求调页策略\n进程在运行期间发现缺页时才将所缺页面调入内存。\n由这种策略调入的页面一定会被访问到，由于每次只能调入一页，而每次调页都要磁盘 I/O 操作，因此 I/O 开销较大。\n\n\n从何处调入页面\n请求分页系统中的外存分为两部分：用于存放文件的文件区和用于存放对换页面的对换区。\n对换区采用连续分配方式，而文件区采用离散分配方式，因此对换区的磁盘 I/O 速度比文件区的更快。这样，当发生缺页请求时，系统从何处将缺页调入内存就分为三种情况：\n\n\n系统拥有足够的对换区空间：可以全部从对换区调入所需页面，以提高调页速度。为此，在进程运行前，需将与该进程有关的文件从文件区复制到对换区。\n\n\n\n系统缺少足够的对换区空间：凡是不会被修改的文件都直接从文件区调入；而当换出这些页面时，由于它们未被修改而不必再将它们换出。但对于那些可能被修改的部分，在将它们换出时须调到对换区，以后需要时再从对换区调入（因为读比写的速度快）。\n\n\n\nUNIX 方式：与进程有关的文件都放在文件区，因此未运行过的页面都应从文件区调入。曾经运行过但又被换出的页面，由于是放在对换区，因此在下次调入时应从对换区调入。进程请求的共享页面若被其他进程调入内存，则无须再从对换区调入。\n\n\n\n如何调入页面\n当进程所访问的页面不在内存中时（存在位为 O)，便向 CPU 发出缺页中断，中断响应后便转入缺页中断处理程序。\n该程序通过查找页表得到该页的物理块，此时\n\n若内存未满，则启动磁盘 I/O，将所缺页调入内存，并修改页表。\n若内存已满，则先按某种置换算法从内存中选出一页准备换出；\n\n若该页未被修改（修改位为 0），则不需要将该页写回磁盘；\n若该页已被修改（修改位为 1），则必须将该页写回磁盘，然后将所缺页调入内存，并修改页表中的相应表项，置其存在位为 1。\n\n\n\n调入完成后，进程就可利用修改后的页表形成所要访问数据的内存地址。\n页面置换算法\n进程运行时，若其访问的页面不在内存而需将其调入，但内存已无空闲空间时，就需要从内存中调出一页，换出到外存。选择调出哪个页面的算法就称为页面置换算法。\n页面的换入、换出需要磁盘 I/O，会有较大的开销，因此好的页面置换算法应该追求更少的缺页率。\n\n最佳置换算法(OPT)\n\nOPTimal replacement\n\n最佳置换算法选择的被淘汰页面是以后永不使用的页面，或是在最长时间内不再被访问的页面，以便保证获得最低的缺页率。\n最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，最佳置换算法是无法实现的。\n\n\n缺页时未必发生页面置换，若还有可用的空闲内存块就不用进行页面置换。\n\n先进先出置换算法(FIFO)\n\nFirst Input First Output\n\n优先淘汰最早进入内存的页面，即淘汰在内存中驻留时间最久的页面。\n该算法实现简单，只需把已调入内存的页面根据先后次序链接成队列，设置一个指针总是指向最老的页面。但该算法与进程实际运行时的规律不适应，因为在进程中，有的页面经常被访问。\n\nFIFO 算法还会产生当为进程分配的物理块增多，缺页次数不减反增的异常现象，称为 Belady 异常。\n\n只有 FIFO 算法会产生 Belady 异常，LRU 和 OPT 算法永远不会出现 Belady 异常。。\n\n\n另外，FIFO 算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，算法性能差。\n最近最久未使用置换算法(LRU)\n\nLeast recently used\n\nLRU 算法选每次淘汰的页面是最近最久未使用的页面，它认为过去一段时间内未访问过的页面，在最近的将来可能也不会被访问。\n该算法为每个页面设置一个访问字段，用访问字段记录该页面自上次被访问以来所经历的时间 t。当需要淘汰一个页面时，选择现有页面中 t 值最大的，即最近最久未使用的页面。\n\n\nLRU 算法的性能较好，但需要寄存器和栈的硬件支持。LRU 是堆栈类的算法。理论上可以证明，堆栈类算法不可能出现 Belady 异常。FIFO 算法基于队列实现，不是堆栈类算法。\n时钟置换算法(CLOCK)\n最佳置换算法性能最好，但无法实现；先进先出置换算法实现简单，但算法性能差；最近最久未使用置换算法性能好，是最接近 OPT 算法性能的，但是实现起来需要专门的硬件支持，算法开销大。\n因此，操作系统的设计者尝试了很多算法，试图用比较小的开销接近 LRU 算法的性能，这类算法都是 CLOCK 算法的变体。\n简单的 CLOCK 置换算法\n为每个页面设置一位访问位，当某页首次被装入或被访问时，其访问位被置为 1。算法将内存中的页面链接成一个循环队列，并有一个替换指针与之相关联。当某一页被替换时，该指针被设置指向被替换页面的下一页。\n当需要淘汰一个页面时，只需检查页的访问位。如果是 0，就选择该页换出；如果是 1，则将它置为 0，暂不换出，给予该页第二次驻留内存的机会，继续检查下一个页面，若第一轮扫描中所有页面都是 1，则将这些页面的访问位依次置为 0 后，再进行第二轮扫描。\n\n第二轮扫描中一定会有访问位为 O 的页面，因此简单的 CLOCK 算法选择一个淘汰页面最多会经过两轮扫描。\n\n由于该算法是循环地检查各个页面的使用情况，所以称为 CLOCK 算法。但是，因为该算法只有一位访问位，而置换时将未使用过的页面换出，所以也称最近未用(NRU, NotRecently Used)算法。\n\n\n改进型 CLOCK 置换算法\n简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过，就不需要执行 I/O 操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。\n在改进型 CLOCK 算法中，除考虑页面使用情况外，还增加了置换代价一一修改位。在选择页面换出时，优先考虑既未使用过又未修改过的页面。\n由访问位 A 和修改位 M 可以组合成下面四种类型的页面：\n\nA=0, M=0：最近未被访问，且未被修改，是最佳的淘汰页。\nA=0, M=1：最近未被访问，但已被修改，是次佳的淘汰页。\nA=1, M=0：最近已被访问，但未被修改，可能再被访问。\nA=1, M=1：最近已被访问，且已被修改，可能再被访问。\n\n\n\n                  \n                  Warning\n                  \n                \n\n为方便讨论，用（访问位，修改位）的形式表示各页面状态。如（1，1）表示一个页面近期被访问过，且被修改过。\n\n\n内存中的每页必定都是这四类页面之一。在进行页面置换时，可采用与简单 CLOCK 算法类似的算法，差别在于该算法要同时检查访问位和修改位。\n算法执行过程如下：\n\n第一轮：从当前位置开始扫描到第一个（0，0）的帧用于替换。本轮扫描不修改访问位。\n第二轮：若第一轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换。本轮将所有扫描过的帧访问位设为 0。\n第三轮：若第二轮扫描失败，将指针返回到开始的位置重新扫描，查找第一个（0，0）的帧用于替换。本轮扫描不修改访问位。\n第四轮：若第三轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换。\n\n\n由于第二轮已将所有帧的访问位设为 0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此改进型 CLOCK 置换算法选择一个淘汰页面最多会进行四轮扫描。\n\n\n该算法淘汰页的次序为\n\n(0,0)：算法执行第一轮。\n(0,1)：算法执行第二轮。\n(1,0)：算法执行第三轮淘汰(0,0)，页的原始数据为(1,0)。因为在算法执行第二轮过程中会将访问位 1 修改为 0，即剩下的(1,0)和(1,1)的页都修改为(0,0)和(0,1)。\n(1,1)：算法执行第四轮淘汰(0,1)，页的原始数据为(1,1)。\n\n\n改进型 CLOCK 算法优于简单 CLOCK 算法的地方在于，可减少磁盘的 I/O 操作次数。但为了找到一个可置换的页，可能要经过几轮扫描，即实现算法本身的开销将有所增加。\n操作系统中的页面置换算法都有一个原则，即尽可能保留访问过的页面，而淘汰未访问过的页面。简单的 CLOCK 算法只考虑页面是否被访问过；改进型 CLOCK 算法对这两类页面做了细分，分为修改过和未修改过的页面。因此，若有未使用过的页面，则当然优先将其中未修改过的页面换出。若全部页面都使用过，还是优先将其中未修改过的页面换出。\n抖动工作集\n抖动\n刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，或颠簸。\n系统发生抖动的根本原因是，分配给每个进程的物理块太少，不能满足进程正常运行的基本要求，致使每个进程在运行时频繁地出现缺页，必须请求系统将所缺页面调入内存。\n显然，对磁盘的访问时间也随之急剧增加，造成每个进程的大部分时间都用于页面的换入/换出，而几乎不能再去做任何有效的工作，进而导致发生 CPU 利用率急剧下降并趋于零的情况。\n\n系统发生抖动时的一个解决方法是撤销部分进程。增加对换区大小和修改进程优先级都与抖动无关。\n\n工作集\n抖动是进程运行时出现的严重问题，必须采取相应的措施解决它。由于抖动的发生与系统为进程分配物理块的多少（即驻留集）有关，于是又提出了关于进程工作集的概念。\n工作集：指在某段时间间隔里，进程实际访问页面的集合。\n\n实际应用中，工作集窗口会设置得很大，即对于局部性好的程序，工作集大小一般会比工作集窗口小很多。\n工作集反映了进程在接下来的一段时间内很有可能会频繁访问的页面集合，因此驻留集大小不能小于工作集，否则进程在运行过程中会频繁缺页。\n\n驻留集大小不能小于工作集大小，否则进程运行过程中将频繁缺页。\n\n内存映射文件\n\n内存映射文件(Memory-Mapped Files)：作系统向应用程序提供的一个系统调用，它与虚拟内存有些相似，在磁盘文件与进程的虚拟地址空间之间建立映射关系。\n进程通过该系统调用，将一个文件映射到其虚拟地址空间的某个区域，之后就用访问内存的方式读写文件。\n这种功能将一个文件当作内存中的一个大字符数组来访问，而不通过文件 I/O 操作来访问，显然这更便利。磁盘文件的读出/写入由操作系统负责完成，对进程而言是透明的。当映射进程的页面时，不会实际读入文件的内容，而只在访问页面时才被每次一页地读入。当进程退出或关闭文件映射时，所有被改动的页面才被写回磁盘文件。\n\n进程可通过共享内存来通信，实际上，很多时候，共享内存是通过映射相同文件到通信进程的虚拟地址空间来实现的。\n当多个进程映射到同一个文件时，各进程的虚拟地址空间都是相互独立的，但操作系统将对应的这些虚拟地址空间映射到相同的物理内存（用页表实现）。一个进程在共享内存上完成了写操作，此刻当另一个进程在映射到这个文件的虚拟地址空间上执行读操作时，就能立刻看到上一个进程写操作的结果。\n\n由此可见，内存映射文件带来的好处主要是：\n\n使程序员的编程更简单，已建立映射的文件，只需按访问内存的方式进行读写；\n方便多个进程共享同一个磁盘文件。\n\n\n虚拟存储器性能影响因素\n缺页率是影响虚拟存储器性能的主要因素，而缺页率又受到页面大小、分配给进程的物理块数、页面置换算法以及程序的编制方法的影响。\n\n\n根据局部性原理，页面较大则缺页率较低，页面较小则缺页率较高。\n页面较小时，一方面减少了内存碎片，有利于提高内存利用率；另一方面，也会使每个进程要求较多的页面，导致页表过长，占用大量内存。\n页面较大时，虽然可以减少页表长度，但会使页内碎片增大。\n\n\n分配给进程的物理块数越多，缺页率就越低，但是当物理块超过某个数目时，再为进程增加一个物理块对缺页率的改善是不明显的。只要保证活跃页面在内存中，保持缺页率在一个很低的范围即可。\n\n\n好的页面置换算法可使进程在运行过程中具有较低的缺页率。选择 LRU、CLOCK 等置换算法，将未来有可能访问的页面尽量保留在内存中，从而提高页面的访问速度。\n\n\n写回磁盘的频率。换出已修改过的页面时，应当写回磁盘，如果每当一个页面被换出时就将它写回磁盘，那么每换出一个页面就需要启动一次磁盘，效率极低。\n为此在系统中建立一个已修改换出页面的链表，对每个要被换出的页面（已修改），可以暂不将它们写回磁盘，而将它们挂在该链表上，仅当被换出页面数达到给定值时，才将它们一起写回磁盘，这样就可显著减少磁盘 I/O 的次数，即减少巳修改页面换出的开销。\n此外，如果有进程在这批数据还未写回磁盘时需要再次访问这些页面，就不需从外存调入，而直接从已修改换出页面链表上获取，这样也可以减少页面从磁盘读入内存的频率，减少页面换进的开销。\n\n\n地址翻译\n设某系统满足以下条件：\n\n有一个 TLB 与一个 dataCache\n存储器以字节为编址单位\n虚拟地址 14 位\n物理地址 12 位\n页面大小为 64B\nTLB 为四路组相联，共有 16 个条目\ndataCache 是物理寻址、直接映射的，行大小为 4B，共有 16 组\n\n因为本系统以字节编址，页面大小为64B，则页内偏移地址为log_2{(64B/1B)}=6位，所以虚拟页号为14-6=8位，物理页号为12-6=6位。\n因为 TLB 为四路组相联，共有 16 个条目，则 TLB 共有16/4=4组，因此虚拟页号中低log_24=2位就为组索引，高 6 位就为 TLB 标记。又因为 Cache 行大小为 4B，因此物理地址中低 log24=2 位为块偏移，Cache 共有 16 组，可知接下来log_2{16}=4位为组索引，剩下高 6 位作为标记。\n\n写出访问地址为0x03d4，0x00f1和0x0229的过程。\n先将十六进制的虚拟地址0x03d4，0x00f1和0x0229转化为二进制形式。\n\n得到每个地址的组索引和 TLB 标记，接下来就要找出每个地址的页面在不在主存中，若在主存中，则还要找出物理地址。\n\n对于 0x03d4，组索引为 3，TLB 标记为 0x03，查 TLB，第 3 组中正好有标记为 03 的项，有效位为 1，可知页面在主存中，对应的物理页号为 0d (001101)，再拼接页内地址 010100，可得物理地址为 0x354 (001101010100)。\n对于 0x00fl，组索引为 3，TLB 标记为 0x00，查 TLB，第 3 组中没有标记为 00 的项，再去找页表，虚拟页号为0x03，页表第 3 行的有效位为 1，可知页面在主存中，物理页号为 02 (000010)，再拼接页内地址 110001，可得物理地址为 0x0b1 (000010110001)。\n对于 0x0229，组索引为 0，TLB 标记为 0x02，查 TLB，第 0 组中没有标记为 02 的项，再去找页表，虚拟页号为 0x08，页表第 8 行的有效位为 0，页面不在主存中，产生缺页中断。\n\n\n找出在主存中的页面的物理地址后，就要通过物理地址访问数据，接下来要找该物理地址的内容在不在 Cache 中，物理地址结构如下表所示。\n\n\n对于 0x354，Cache 索引为 5，Cache 标记为 0x0d，对照 Cache 中索引为 5 的行，标记正好为 0d，有效位为 1，可知该块在 Cache 中，偏移 0，即块 0，可得虚拟地址 0x03d4 的内容为 36H。\n对于 0x0bl，Cache 索引为 c，Cache 标记为 0x02，对照 Cache 中索引为 c 的行，有效位为 0，可知该块不在 Cache 中，要去主存中查找物理页号为 2、偏移为 0x31 的内容。\n\n\n以上例子基本覆盖了从虚拟地址到 Cache 查找内容的所有可能出现的情况，查找顺序是从 TLB 到页表（TLB 不命中），再到 Cache 和主存，最后到外存。\n\n覆盖与交换*\n覆盖\n覆盖技术，用来解决程序大小超过物理内存总和的问题。\n由于程序运行时并非任何时候都要访问程序及数据的各个部分（尤其是大程序），因此可把用户空间分成一个固定区和若干覆盖区。将经常活跃的部分放在固定区，不常用的部分按调用关系分段。\n首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统再将其调入覆盖区，替换覆盖区中原有的段。\n\n覆盖技术打破了必须将一个进程的全部信息装入主存后才能运行的限制，但当同时运行程序的代码量大于主存时仍不能运行。\n内存中能够更新的地方只有覆盖区的段，不在覆盖区中的段会常驻内存。\n缺点的是必须由程序员声明覆盖结构，操作系统完成自动覆盖。对用户不透明，增加了编程的负担。\n交换\n交换（对换）的基本思想是，把处于等待状态（或在 CPU 调度原则下被剥夺运行权利）的程序暂时从内存移到外存，把内存空间腾出来，这一过程又称换出；把准备好竞争 CPU 运行的程序从外存移到内存，这一过程又称换入。\n暂时换出外存等待的进程状态称为挂起状态。挂起状态又可以细分为就绪挂起、阻塞挂起两种状态。\n有关交换，需要注意以下几个问题：\n\n交换需要备份存储，通常是磁盘。它必须足够大，并提供对这些内存映像的直接访问。\n为了有效使用 CPU，需要使每个进程的执行时间比交换时间长。\n若换出进程，则必须确保该进程完全处于空闲状态。\n交换空间通常作为磁盘的一整块，且独立于文件系统，因此使用起来可能很快。\n交换通常在有许多进程运行且内存空间吃紧时开始启动，而在系统负荷降低时就暂停。\n普通的交换使用不多，但交换策略的某些变体在许多系统（如 UNIX）中仍发挥作用。\n\n"},"计算机基础/计算机操作系统/4_文件管理":{"title":"文件管理","links":[],"tags":["操作系统"],"content":"文件基础\n基本概念\n文件(File)是以硬盘为载体的存储在计算机上的信息集合，文件可以是文本文档、图片、程序等。\n在系统运行时，计算机以进程为基本单位进行资源的调度和分配；而在用户进行的输入、输出中，则以文件为基本单位。\n大多数应用程序的输入都是通过文件来实现的，其输出也都保存在文件中，以便信息的长期存储及将来的访问。当用户将文件用于程序的输入、输出时，还希望可以访问、修改和保存文件等，实现对文件的维护管理，这就需要系统提供一个文件管理系统，操作系统中的文件系统就是用于实现用户的这些管理要求的。\n\n数据项：文件系统中最低级的数据组织形式，可分为：\n\n基本数据项：用于描述一个对象的某种属性的一个值，是数据中的最小逻辑单位。\n组合数据项：由多个基本数据项组成。\n\n记录：一组相关的数据项的集合，用于描述一个对象在某方面的属性。\n文件：由创建者所定义的、具有文件名的一组相关元素的集合，可分为：\n\n有结构文件：文件由若干个相似的记录组成，如一个班的学生记录；\n无结构文件：被视为一个字符流，比如一个二进制文件或字符文件。\n\n\n除了文件数据，操作系统还会保存与文件相关的信息，如所有者、创建时间等，这些附加信 息称为文件属性或文件元数据。\n文件属性在不同系统中差别很大，但通常都包括如下属性：名称，类型，创建者，所有者，位置，大小，保护，创建时间、最后一次修改时间和最后一次存取时间。\n操作系统通过文件控制块来维护文件元数据。\n\n为了便于管理文件，将文件分成了若干类型。由于不同系统对文件的管理方式不同，因此它们的文件分类方法也有很大差异。\n\n按性质和用途分类，分为系统文件、用户文件、库文件。\n按文件中数据的形式分类，分为源文件、目标文件、可执行文件。\n按存取控制属性分类，分为可执行文件、只读文件、读/写文件。\n按组织形式和处理方式分类，分为普通文件、目录文件、特殊文件。\n\n文件控制块\n文件控制块(FileCont rolBlock, FCB)是用来存放控制文件需要的各种信息的数据结构，以实现按名存取。\n文件与 FCB 一一对应，FCB 的有序集合称为文件目录，一个 FCB 就是一个文件目录项。通常，一个文件目录也被视为一个文件，称为目录文件。每当创建一个新文件，系统就要为其建立一个 FCB，用来记录文件的各种属性。\nFCB 主要包含基本信息，存取控制信息，使用信息。\n\n\n索引结点\n文件目录通常存放在磁盘上，当文件很多时，文件目录会占用大量的盘块。在查找目录的过程中，要先将存放目录文件的第一个盘块中的目录调入内存，然后用给定的文件名逐一比较，若未找到指定文件，就还需要不断地将下一盘块中的目录项调入内存，逐一比较。\n在检索目录的过程中，只用到了文件名，仅当找到一个目录项（其中的文件名与要查找的文件名匹配）时，才需从该目录项中读出该文件的物理地址。也就是说，在检索目录时，文件的其他描述信息不会用到，也不需要调入内存。\n因此，有的系统便采用了文件名和文件描述信息分离的方法，使文件描述信息单独形成一个称为索引节点的数据结构，简称i 节点(inode)。在文件目录中的每个目录项仅由文件名和相应的索引节点号（或索引节点指针）构成。\n假设一个 FCB 为 64B，盘块大小是 1KB，则每个盘块中可以存放 16 个 FCB（FCB 必须连续存放），若一个文件目录共有 640 个 FCB，则查找文件平均需要启动磁盘 20 次。而在 UNIX 系统中，一个目录项仅占 16B，其中 14B 是文件名，2B 是索引节点号。在 1KB 的盘块中可存放 64 个目录项。这样，可使查找文件的平均启动磁盘次数减少到原来的 1/4，大大节省了系统开销。\n\n\n磁盘索引节点：是指存放在磁盘上的索引节点。每个文件有一个唯一的磁盘索引节点。\n内存索引节点：是指存放在内存中的索引节点。当文件被打开时，要将磁盘索引节点复制到内存的索引节点中，便于以后使用。\n\n\n文件的基本操作\n\n文件属于抽象数据类型。为了正确地定义文件，需要考虑可以对文件执行的操作。操作系统提供系统调用，它对文件进行创建、写、读、重定位、删除和截断等操作。\n\n\n创建文件\n创建文件有两个必要步骤：一是为新文件分配外存空间；二是在目录中为之创建一个目录项，目录项记录了新文件名、文件在外存中的地址等信息。\n\n\n\n删除文件\n为了删除文件，根据文件名查找目录，删除指定文件对应的目录项和文件控制块，然后回收该文件所占用的存储空间（包括磁盘空间和内存缓冲区）。\n\n\n\n读文件\n为了读文件，根据文件名查找目录，找到指定文件的目录项后，从中得到被读文件在外存中的地址；在目录项中，还有一个指针用于对文件进行读操作。\n\n\n\n写文件\n为了写文件，根据文件名查找目录，找到指定文件的目录项后，再利用目录项中的写指针对文件进行写操作。每当发生写操作时，便更新写指针。\n\n\n\n打开文件\n当用户对一个文件实施多次读/写等操作时，每次都要从检索目录开始。为了避免多次重复地检索目录，大多数操作系统要求，当用户首次对某文件发出操作请求时，须先利用系统调用 open 将该文件打开。\n\nopen 中的参数包含文件的路径名与文件名，而 read 只需使用 open 返回的文件描述符，并不使用文件名作为参数。\n\n系统维护一个包含所有打开文件信息的表，称为打开文件表。所谓“打开”，是指系统检索到指定文件的目录项后，将该目录项从外存复制到内存中的打开文件表的一个表目中（不会把文件内容读到内存中，只有进程希望获取文件内容时才会读入文件内），并将该表目的索引号（也称文件描述符）返回给用户。\n当用户再次对该文件发出操作请求时，可通过文件描述符在打开文件表中查找到文件信息，从而节省了大量的检索开销。当文件不再使用时，可利用系统调用 close 关闭它，则系统将会从打开文件表中删除这一表目。\n\n在多个进程可以同时打开文件的操作系统中，通常采用两级表：整个系统表和每个进程表。\n整个系统的打开文件表包含与进程无关的信息，如文件在磁盘上的位置、访问日期和文件大小。每个进程的打开文件表保存的是进程对文件的使用信息，如文件的当前读写指针、文件访问权限，并包含指向系统表中适当条目的指针。一旦有进程打开了一个文件，系统表就包含该文件的条目。\n当另一个进程执行调用 open 时，只不过是在其打开文件表中增加一个条目，并指向系统表的相应条目。\n通常，系统打开文件表为每个文件关联一个打开计数器(OpenCount)，以记录多少进程打开了该文件。当文件不再使用时，利用系统调用 close 关闭它，会删除单个进程的打开文件表中的相应条目，系统表中的相应打开计数器也会递减。当打开计数器为 0 时，表示该文件不再被使用，并且可从系统表中删除相应条目。\n\n文件名不必是打开文件表的一部分，因为一旦完成对 FCB 在磁盘上的定位，系统就不再使用文件名。对于访问打开文件表的索引号，UNIX 称之为文件描述符，而 Windows 称之为文件句柄。因此，只要文件未被关闭，所有文件操作都是通过文件描述符而不是文件名来进行。\n\n换句话说只要完成了文件打开 open 系统调用，后面再使用 read、write、Lseek、close 等文件操作的系统调用，就不再使用文件名，而使用文件描述符。\n\n文件描述符 = open(文件名, 文件路径);\nread(文件描述符, 缓冲区首址, 传送的字节数);// 从描述符指示的文件中读入n个字节，并送至缓冲区中。\nclose(文件描述符);\n\n\n\n关闭文件\n关闭文件时只会对内存索引节点进行相关的操作，而不会改变磁盘索引节点的数据结构。\n\n\n\n文件保护\n\n在文件系统中建立相应的文件保护机制，可以通过口令保护、加密保护和访问控制等方式实现。\n其中，口令和加密是为了防止用户文件被他人存取或窃取，并没有控制用户对文件的访问类型，而访问控制则用于控制用户对文件的访问方式。\n\n对于多级目录结构而言，不仅需要保护单个文件，而且需要保护子目录内的文件，即需要提供目录保护机制。目录操作与文件操作并不相同，因此需要不同的保护机制。\n\n\n\n口令保护\n口令指用户在建立一个文件时提供一个口令，系统为其建立 FCB 时附上相应口令，同时告诉允许共享该文件的其他用户。用户请求访问时必须提供相应的口令。\n这种方法时间和空间的开销不多，缺点是口令直接存在系统内部，不够安全。\n\n\n\n加密保护\n密码指用户对文件进行加密，文件被访问时需要使用密钥。这种方法保密性强，节省了存储空间，不过编码和译码要花费一定的时间。\n\n\n\n访问控制\n解决访问控制最常用的方法是根据用户身份进行控制。\n而实现基于身份访问的最为普通的方法是，为每个文件和目录增加一个访问控制列表(Access-ControlList，ACL)，以规定每个用户名及其所允许的访问类型。这种方法的优点是可以使用复杂的访问方法，缺点是长度无法预计并且可能导致复杂的空间管理，使用精简的访问列表可以解决这个问题。\n\n精简的访问控制列表可采用拥有者、组和其他三种用户类型。\n\n拥有者：创建文件的用户。\n组：一组需要共享文件且具有类似访问的用户。\n其他：系统内的所有其他用户。\n\n创建文件时，系统将文件拥有者的名字、所属组名记录在该文件的 FCB 中。用户访问该文件时，若用户是文件主，按照文件主所拥有的权限访问文件；若用户和文件主在同一个用户组，则按照同组权限访问，否则只能按其他用户权限访问。\n\n\n\n文件的逻辑结构\n\n文件的逻辑结构是从用户观点出发看到的文件的组织形式。文件的物理结构是从实现观点出发看到的文件在外存上的存储组织形式。\n文件的逻辑结构与存储介质特性无关，它实际上是指在文件的内部，数据逻辑上是如何组织起来的。\n按逻辑结构，文件可划分为无结构文件和有结构文件两大类。\n无结构文件\n无结构文件是最简单的文件组织形式，它是由字符流构成的文件，所以又称流式文件，其长度以字节为单位。\n对流式文件的访问，是通过读/写指针来指出下一个要访问的字节的。\n在系统中运行的大量源程序、可执行文件、库函数等，所采用的就是无结构文件。由于无结构文件没有结构，因而对记录的访问只能通过穷举搜索的方式，因此这种文件形式对很多应用不适用。\n\n有结构文件\n\n有结构文件是指由一个以上的记录构成的文件，所以又称记录式文件。各记录由相同或不同数目的数据项组成，根据各记录的长度是否相等，可分为定长记录和变长记录两种。\n\n定长记录：文件中所有记录的长度都是相同的，各数据项都在记录中的相同位置，具有相同的长度。检索记录的速度快，方便用户对文件进行处理，广泛用于数据处理中。\n变长记录：文件中各记录的长度不一定相同，原因可能是记录中所包含的数据项数目不同，也可能是数据项本身的长度不定。检索记录只能顺序查找，速度慢。\n\n有结构文件按记录的组织形式可以分为如下几种： 顺序文件，索引文件，索引顺序文件。\n顺序文件\n文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的。\n顺序文件中记录的排列有两种结构：\n\n串结构，各记录之间的顺序与关键字无关，通常是按存入的先后时间进行排列，检索时必须从头开始顺序依次查找，比较费时；\n顺序结构，所有记录按关键字顺序排列，对于定长记录的顺序文件，检索时可采用折半查找，效率较高。\n\n\n\n索引文件\n对于定长记录的顺序文件，要查找第 i 条记录，可直接根据下式计算得到第 i 条记录相对于第 1 条记录的地址：A_i=i\\times L。\n对于变长记录的顺序文件，要查找第 i 条记录，必须顺序地查找前 i-1 条记录，以获得相应记录的长度 L，进而按下式计算出第 i 条记录的地址：A_i=\\sum_{ I=0}^{I-1} L_i +1。\n变长记录的顺序文件只能顺序查找，效率较低。为此，可以建立一张索引表，为主文件的每个记录在索引表中分别设置一个索引表项，其中包含指向记录的指针和记录长度，索引表按关键字排序，因此其本身也是一个定长记录的顺序文件。\n这样就将对变长记录顺序文件的顺序检索，转变成了对定长记录索引文件的随机检索，从而加快了记录的检索速度。\n\n索引顺序文件\n索引顺序文件是顺序文件和索引文件的结合。\n最简单的索引顺序文件只使用了一级索引，先将变长记录顺序文件中的所有记录分为若干组，然后为文件建立一张索引表，并为每组中的第一个记录建立一个索引项，其中包含该记录的关键字和指向该记录的指针。\n主文件包含姓名和其他数据项，姓名为关键字，记录按姓名的首字母分组，同一个组内的关键字可以无序，但是组与组之间的关键字必须有序。将每组的第一个记录的姓名及其逻辑地址放入索引表，索引表按姓名递增排列。检索时，首先查找索引表，找该记录所在的组，然后在该组中使用顺序查找，就能很快地找到记录。\n索引文件的缺点：每个记录对应一个索引表项，因此索引表可能会很大。比如：文件的每个记录平均只占 8B，而每个索引表项占 32 个字节，那么索引表都要比文件内容本身大 4 倍，这样对存储空间的利用率就太低了。\n\n\n\n文件的物理结构\n\n文件块、磁盘块\n内存与磁盘之间的数据交换（磁盘 I/O）都是以块为单位进行的\n\n\n文件的分配方式\n文件的物理结构就是研究文件的实现，即文件数据在物理存储设备上是如何分布和组织的。\n同一个问题有两个方面的回答：一是文件的分配方式，讲的是对磁盘非空闲块的管理；二是文件存储空间管理，讲的是对磁盘空闲块的管理。\n文件分配对应于文件的物理结构，是指如何为文件分配磁盘块。常用的文件分配方法有三种：连续分配、链接分配和索引分配。\n\n连续分配\n连续分配方式要求每个文件在磁盘上占有一组连续的块。磁盘地址定义了磁盘上的一个线性排序，这种排序使进程访问磁盘时需要的寻道数和寻道时间最小。\n采用连续分配时，逻辑文件中的记录也顺序存储在相邻的物理块中。一个文件的目录项中应记录该文件的第一个磁盘块的块号和所占用的块数。若文件长 n 块并从位置 b 开始，则该文件将占有块 b,b+1,b+2,…,b+n-1，要访问文件的第 i 块，可直接访问块 b+i-1。\n\n\n优点：\n\n支持顺序访问和直接访问（即随机访问）；\n顺序访问容易且速度快。\n\n\n缺点：\n\n要为一个文件分配连续的存储空间，与内存分配类似，为文件分配连续的存储空间会产生很多外部碎片。\n必须事先知道文件的长度，也无法满足文件动态增长的要求，否则会覆盖物理上相邻的后续文件。\n为保持文件的有序性，删除和插入记录时，需要对相邻的记录做物理上的移动。\n\n\n\n\n\n\n链接分配\n链接分配是一种采用离散分配的方式。\n链式分配的优点：\n\n消除了磁盘的外部碎片，提高了磁盘的利用率。\n便于动态地为文件分配盘块，因此无须事先知道文件的大小。\n文件的插入、删除和修改也非常方便。\n\n链接分配又可分为隐式链接和显式链接两种形式。\n\n\n隐式链接\n目录项中含有文件第一块的指针（盘块号）和最后一块的指针。每个文件对应一个磁盘块的链表，磁盘块分布在磁盘的任何地方。除文件的最后一个盘块外，每个盘块都存有指向文件下一个盘块的指针，这些指针对用户是透明的。\n缺点：\n\n只支持顺序访问，若要访问文件的第 i 块，则只能从第 1 块开始，通过盘块指针顺序查找到第 1 块，随机访问效率很低。\n稳定性问题，文件盘块中的任何一个指针出问题，都会导致文件数据的丢失。\n指向下一个盘块的指针也要耗费一定的存储空间。\n\n\n\n\n为了提高查找速度和减小指针所占用的存储空间，可以将几个盘块组成一个簇，按簇而不按块来分配，可以大幅地减少查找时间，也可以改善许多算法的磁盘访问时间。比如一簇为 4 块，这样，指针所占的磁盘空间比例也要小得多。这种方法的代价是增加了内部碎片。\n若对文件存储空间的分配以簇为单位，则一个文件所占用的空间只能是簇的整数，不存在一个文件分配一个簇和一个盘块。\n\n\n\n显式链接\n显式链接是指将用于链接文件各物理块的指针，显式地存放在内存的一张链接表中，该表在整个磁盘中仅设置一张，称为文件分配表(FileAllocationTable, FAT)。\n\n开机时文件分配表放入内存，并常驻内存。\n\n每个表项中存放指向下一个盘块的指针。文件目录中只需记录该文件的起始块号，后续块号可通过查 FAT 找到。\n\n不难看出，FAT 的表项与全部磁盘块一一对应，并且可以用一个特殊的数字-1 表示文件的最后一块，可以用 -2 表示这个磁盘块是空闲的（当然也可指定为-3，-4）。因此，操作系统可以通过 FAT 对磁盘空闲空间进行管理。当某进程请求系统分配一个磁盘块时，系统只需从 FAT 中找到-2 的表项，并将对应的磁盘块分配给该进程即可。\n优点：支持顺序访问，也支持直接访问，要访问第 i 块，无须依次访问前 i-1 块；FAT 在系统启动时就被读入内存，检索记录是在内存中进行的，因而不仅显著提高了检索速度，而且明显减少了访问磁盘的次数。\n缺点：FAT 需要占用一定的内存空间。\n\n\n\n                  \n                  Note\n                  \n                \n\n\n\n\n\n\n索引分配\n单级索引分配方式\n事实上，在打开某个文件时，只需将该文件对应的盘块的编号调入内存即可，完全没有必要将整个 FAT 调入内存。为此，应该将每个文件所有的盘块号集中地放在一起，当访问到某个文件时，将该文件对应的盘块号一起调入内存即可，这就是索引分配的思想。\n它为每个文件分配一个索引块（表），将分配给该文件的所有盘块号都记录在该索引块中。\n\n假设盘块大小为 4KB，每个盘块号占 4B，则一个索引块中可存放 1024 个盘块号，若采用单级索引，则支持的最大文件为1024\\times 4KB=4MB。\n\n\n索引分配的优点是支持直接访问，当要访问第 i 块时，索引块的第 1 个条目指向的便是文件的第 i 个块。索引分配也不会产生外部碎片。\n缺点是索引块增加了额外的存储空间开销。\n索引块的主要问题是，每个文件必须有一个索引块，当文件很小时，比如只有数个盘块，该方式仍为之分配一个索引块，此时索引块的利用率很低；当文件很大时，若其盘块号需要占用若干索引块，此时可通过链指针将各索引块按序链接起来，但这种方法是低效的。\n\n多级索引分配方式\n显然，当文件太大而索引块太多时，应该为这些索引块再建立一级索引，称为主索引，将第一个索引块的盘块号、第二个索引块的盘块号填入该主索引表，这样，便形成了二级索引分配方式，其原理类似于内存管理中的多级页表。\n\n假设盘块大小为 4KB，每个盘块号占 4B，一个索引块中可存放 1024 个盘块号，若采用两级索引，则支持的最大文件为 1024\\times 1024\\times 4KB=4GB。\n\n\n查找时，通过主索引查找第二级索引，再通过第二级索引查找所需数据块。如果文件非常大，那么还可使用三级、四级索引分配方式。\n\n\n\n                  \n                  Tip\n                  \n                \n\n采用 K 层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要 K+1 次读磁盘操作。\n\n\n优点：极大加快了对大型文件的查找速度。\n缺点：当访问一个盘块时，其所要启动磁盘的次数随着索引级数的增加而增多，即使是对数量众多的小文件也是如此。\n混合索引分配方式\n为了能够较全面地照顾到小型、中型、大型和特大型文件，可采用混合索引分配方式。\n\n对于小文件，为了提高对众多小文件的访问速度，最好能将它们的每个盘块地址直接放入 FCB，这样就可以直接从 FCB 中获得该文件的盘块地址，即为直接寻址。\n对于中型文件，可以采用单级索引分配，需要先从 FCB 中找到该文件的索引表，从中获得该文件的盘块地址，即为一次间址。\n对于大型或特大型文件，可以采用两级和三级索引分配。\n\n\n文件目录\n\n目录结构\n\n\n单级目录结构\n在整个文件系统中只建立一张目录表，每个文件占一个目录项。\n\n当建立一个新文件时，必须先检索所有目录项，以确保没有“重名”的情况，然后在该目录中增设一项，将新文件的属性信息填入该项。\n当访问一个文件时，先按文件名在该目录中查找到相应的 FCB，经合法性检查后执行相应的操作。\n当删除一个文件时，先从该目录中找到该文件的目录项，回收该文件所占用的存储空间，然后清除该目录项。\n\n单级目录结构实现了“按名存取”，但是存在查找速度慢、文件不允许重名、不便于文件共享等缺点，而且对于多用户的操作系统显然是不适用的。\n\n\n\n两级目录结构\n为了克服单级目录所存在的缺点，可以采用两级方案，将文件目录分成主文件目录(Master\nFile Directory, MFD)和用户文件目录(User File Directory, UFD)两级。\n主文件目录项记录用户名及相应用户文件目录所在的存储位置。用户文件目录项记录该用户所有文件的 FCB。\n当某用户欲对其文件进行访问时，只需搜索该用户对应的 UFD，这既解决了不同用户文件的“重名”问题，又在一定程度上保证了文件的安全。\n两级目录结构提高了检索的速度，解决了多用户之间的文件重名问题，文件系统可以在目录上实现访问限制。但是两级目录结构缺乏灵活性，不能对文件分类。\n\n\n\n树形目录结构\n将两级目录结构加以推广，就形成了树形目录结构。它可以明显地提高对目录的检索速度和文件系统的性能。\n当用户要访问某个文件时，用文件的路径名标识文件，文件路径名是个字符串，由从根目录出发到所找文件通路上所有目录名与数据文件名用分隔符“/”链接而成。\n从根目录出发的路径称为绝对路径，系统中的每个文件都有唯一的路径名。\n由于一个进程在运行时，其所访问的文件大多局限于某个范围，当层次较多时，每次从根目录查询会浪费时间，于是可为每个进程设置一个当前目录（又称工作目录），此时进程对各文件的访问都只须相对于当前目录而进行，而不需要从根目录一层一层地检索，加快了文件的检索速度。\n树形目录结构可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。在树形目录中，不同性质、不同用户的文件，可以分别呈现在系统目录树的不同层次或不同子树中，很容易地赋予不同的存取权限。但是，在树形目录中查找一个文件，需要按路径名逐级访问中间节点，增加了磁盘访问次数，这无疑会影响查询速度。\n\n\n\n无环图目录结构\n树形目录结构能便于实现文件分类，但不便于实现文件共享，为此在树形目录结构的基础上加一些指向同一节点的有向边，使整个目录成为一个有向无环图。\n这种结构允许目录共享子目录或文件，同一个文件或子目录可以出现在两个或多个目录中。当某用户要求删除一个共享节点时，若系统只是简单地将它删除，则当另一共享用户需要访问时，会因无法找到这个文件而发生错误。为此，可为每个共享节点设置一个共享计数器，每当图中增加对该节点的共享链时，计数器加 1；每当某用户提出删除该节点时，计数器减 1。仅当共享计数器为 0 时，才真正删除该节点，否则仅删除请求用户的共享链。\n无环图目录结构方便地实现了文件的共享，但使得系统的管理变得更加复杂。\n\n\n\n目录的操作\n\n文件共享\n\n文件共享使多个用户共享同一个文件，系统中只需保留该文件的一个副本。若系统不能提供共享功能，则每个需要该文件的用户都要有各自的副本，会造成对存储空间的极大浪费。\n基于无环图目录结构可以实现文件共享，当建立链接关系时，必须将被共享文件的物理地址（盘块号）复制到相应的目录。如果某个用户向该文件添加新数据，且需要增加新盘块，那么这些新增的盘块只出现在执行操作的目录中，对其他共享用户是不可见的。\n基于索引结点的共享方式(硬链接)\n硬链接是基于索引节点的共享方式，它将文件的物理地址和属性等信息不再放在目录项中，而是放在索引节点中，在文件目录中只设置文件名及指向相应索引节点的指针。\n在用户 A 和 B 的文件目录中，都设置有指向共享文件的索引节点指针。在索引节点中还有一个链接计数 count，也称引用计数，表示链接到本索引节点（即文件）上的用户目录项的数目。当 count=2 时，表示有两个用户目录项链接到本文件上，即有两个用户共享此文件。\n\n用户 A 创建一个新文件时，他便是该文件的所有者，此时将 count 置为 1。用户 B 要共享此文件时，在 B 的目录中增加一个目录项，并设置一个指针指向该文件的索引节点。此时，文件主仍然是用户 A，count=2。\n如果用户 A 此时不再需要此文件，不能直接将其删除。因为若删除了该文件，也必然删除了该文件的索引节点，这样便会使用户 B 的指针悬空，而 B 可能正在此文件上执行写操作，此时将因此半途而废。因此用户 A 不能删除此文件，只是将该文件的 count 减 1，然后删除自己目录中的相应目录项。用户 B 仍可以使用该文件。\n当 count=0 时，表示没有用户使用该文件，才会删除该文件。\n基于符号链的共享方式(软链接)\n为使用户 B 能共享用户 A 的一个文件 F，可由系统创建一个 LINK 类型的新文件 L，并将文件 L 写入用户 B 的目录，以实现 B 的目录与文 件 F 的链接。文件 L 中只含有被链接文件 F 的路径名。这种链接方法称为符号链接或软链接，它类似于 Windows 系统中的快捷方式。\n当用户 B 访问文件 L 时，操作系统看到要读的文件属于 LINK 类型，则根据其中记录的路径名去查询文件 F，然后对 F 进行读/写操作，从而实现用户 B 对文件 F 的共享。\n\n利用符号链方式实现文件共享时，只有文件主才拥有指向其索引节点的指针。而共享该文件的其他用户只有该文件的路径名，并不拥有指向其索引节点的指针。这样，也就不会发生在文件主删除一个共享文件后留下一个悬空指针的情况。当文件主将一个共享文件删除后，若其他用户又试图通过符号链去访问它时，则会访问失败，于是再将符号链删除，此时不会产生任何影响。\n\n建立符号链接时，引用计数值直接设置为 1，不受被链接文件的影响。\n删除文件时，删除操作对于符号链接是不可见的，这并不影响文件系统，当以后再通过符号链接访问时，发现文件不存在，直接删除符号链接。\n\n在符号链的共享方式中，当其他用户读共享文件时，系统根据文件路径名依次查找目录，直至找到该文件的索引节点。因此，每次访问共享文件时，都可能要多次地读盘，增大了访问文件的开销。此外，符号链接也是一个文件，其索引节点也要耗费一定的磁盘空间。\n利用符号链实现网络文件共享时，只需提供该文件所在机器的网络地址及文件路径名。\n\n硬链接的查找速度要比软链接的快。\n\n文件系统\n文件系统结构\n文件系统提供高效和便捷的磁盘访问，以便允许存储、定位、提取数据。\n现代操作系统有多种文件系统类型，因此文件系统的层次结构也不尽相同。\n\n\n文件系统布局\n文件系统存放在磁盘上，多数磁盘划分为一个或多个分区，每个分区中有一个独立的文件系统。\n文件系统可能包括如下信息：启动操作系统的方式、总的块数、空闲块的数量和位置、目录结构以及各个具体文件等。\n简单描述如下：\n\n\n主引导记录(MasterBootRecord, MBR)\n位于磁盘的 0 号扇区，用来引导计算机，MBR 的后面是分区表，该表给出每个分区的起始和结束地址。表中的一个分区被标记为活动分区。当计算机启动时，BIOS 读入并执行 MBR。MBR 做的第一件事是确定活动分区，读入它的第一块，即引导块。\n\n\n引导块(boot block)\nMBR 执行引导块中的程序后，该程序负责启动该分区中的操作系统。每个分区都是统一从一个引导块开始，即使它不含有一个可启动的操作系统，也不排除以后会在该分区安装一个操作系统。Windows 系统称之为分区引导扇区。除了从引导块开始，磁盘分区的布局是随着文件系统的不同而变化的。\n\n\n超级块(super block)\n包含文件系统的所有关键信息，在计算机启动时，或者在该文件系统首次使用时，超级块会被读入内存。超级块中的典型信息包括分区的块的数量、块的大小、空闲块的数量和指针、空闲的 FCB 数量和 FCB 指针等。\n\n\n文件系统中空闲块的信息，可以用位示图或指针链接的形式给出。后面也许跟的是一组 1 节点，每个文件对应一个节点，i 节点说明了文件的方方面面。接着可能是根目录，它存放文件系统目录树的根部。最后，磁盘的其他部分存放了其他所有的目录和文件。\n\n\n\n\n\n\n外存空闲空间管理\n\n一个存储设备可以按整体用于文件系统，也可以细分。例如，一个磁盘可以划分为 2 个分区，每个分区都可以有单独的文件系统。包含文件系统的分区通常称为卷(volume)。卷可以是磁盘的一部分，也可以是整个磁盘，还可以是多个磁盘组成 RAID 集。\n\n在一个卷中，存放文件数据的空间（文件区）和 FCB 的空间（目录区）是分离的。由于存在很多种类的文件表示和存放格式，所以现代操作系统中一般都有很多不同的文件管理模块，通过它们可以访问不同格式的卷中的文件。卷在提供文件服务前，必须由对应的文件程序进行初始化，划分好目录区和文件区，建立空闲空间管理表格及存放卷信息的超级块。\n文件存储设备分成许多大小相同的物理块，并以块为单位交换信息，因此，文件存储设备的管理实质上是对空闲块的组织和管理，它包括空闲块的组织、分配与回收等问题。\n空闲表法\n空闲表法属于连续分配方式，它与内存的动态分区分配类似，为每个文件分配一块连续的存储空间。系统为外存上的所有空闲区建立一张空闲表，每个空闲区对应一个空闲表项，其中包括表项序号、该空闲区的第一个空闲盘块号、该空闲区的空闲盘块数等信息。再将所有空闲区按其起始盘块号递增的次序排列。\n\n\n盘块的分配\n空闲盘区的分配与内存的动态分配类似，也是采用首次适应算法、最佳适应算法等。例如，在系统为某新创建的文件分配空闲盘块时，先顺序地检索空闲盘块表的各表项，直至找到第一个其大小能满足要求的空闲区，再将该盘区分配给用户，同时修改空闲盘块表。\n\n\n盘块的回收\n在对用户所释放的存储空间进行回收时，也采用类似于内存回收的方法，即要考虑回收区是否与空闲盘块表中插入点的前区和后区相邻接，对相邻接者应予以合并。\n\n\n优点是具有较高的分配速度，可减少访问磁盘的 I/O 频率。对于较小的文件（1 ～ 5 个盘块），可以采用连续分配方式为文件分配几个相邻的盘块。\n\n空闲链表法\n空闲链表法是指将所有空闲盘区拉成一条空闲链，可分为以下两种。\n\n\n空闲盘块链\n空闲盘块链是指将磁盘上的所有空闲空间以盘块为单位拉成一条链。每个盘块都有指向下一个空闲盘块的指针。\n当用户请求分配存储空间时，系统从链首开始，依次摘下适当数目的空闲盘块分配给用户。\n当用户释放存储空间时，系统将回收的盘块依次插入空闲盘块链的末尾。\n空闲盘块链的优点是分配和回收一个盘块的过程非常简单。缺点是在为一个文件分配盘块时可能要重复操作多次，效率较低；又因它是以盘块为单位的，空闲盘块链会很长。\n\n\n\n空闲盘区链\n空闲盘区链是指将磁盘上的所有空闲盘区拉成一条链，每个盘区包含若干相邻的盘块。每个盘区含有下一个空闲盘区的指针和本盘区的盘块数。分配盘区的方法与内存的动态分区分配类似，通常采用首次适应算法。回收盘区时，同样也要将回收区与相邻接的空闲盘区合并。\n空闲盘区链的优缺点正好与空闲盘块链的相反，优点是分配与回收的效率较高，且空闲盘区链较短。缺点是分配与回收的过程比较复杂。\n\n\n\n位示图法\n位示图是利用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上的所有盘块都有一个二进制位与之对应。当其值为“0”时，表示对应的盘块空闲；为“1”时，表示已分配。这样，一个 mxn 位组成的位示图就可用来表示 mxn 个盘块的使用情况。\n\n盘块的分配\n\n顺序扫描位示图，从中找出一个或一组其值为“0”的二进制位。\n找到的一个或一组二进制位转换成与之对应的盘块号。\n修改位示图，令map[i,j]=1。\n\n\n盘块的回收\n\n回收盘块的盘块号转换成位示图中的行号和列号。\n修改位示图，令map[i,j]=0。\n\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n注意位示图的行和列是从 1 还是从 0 开始编号，计算方法要进行相应的调整。\n\n\n\n位示图法的优点是很容易在位示图中找到一个或一组相邻接的空闲盘块。由于位示图很小，占用空间少，因此可将它保存在内存中，从而节省许多磁盘启动的并销。\n位示图法的问题是位示图大小会随着磁盘容量的增加而增大，因此常用于小型计算机。\n成组链接法\n空闲表法、空闲链表法不适用于大型文件系统，因为空闲表或空闲链表可能过大。UNIX 系统中采用了成组链接法对磁盘空闲块进行管理。\n成组链接法将空闲盘块分成若干组，如 100 个盘块作为一组，每组的第一个盘块记录下一组的空闲盘块总数和空闲盘块号。这样，由各组的第一个盘块可以链接成一条链。第一组的空闲盘块总数和空闲盘块号保存在内存的专用栈中，称为空闲盘块号栈。\n简而言之，每组（除了最后一组）的第一块作为索引块，然后将这些索引块链接起来。\n\n\n虚拟文件系统\n\n虚拟文件系统(VFS)屏蔽了不同文件系统的差异和操作细节，向上为用户提供了文件操作的统一调用接口。当用户程序访问文件时，通过 VFS 提供的统一调用函数来操作不同文件系统的文件，而无须考虑具体的文件系统和实际的存储介质。\n\n虚拟文件系统采用了面向对象的思想，它抽象出一个通用的文件系统模型，定义了通用文件系统都支持的接口。新的文件系统只要支持并实现这些接口，即可安装和使用。为了实现虚拟文件系统，系统抽象了四种对象类型。每个对象都包含数据和函数指针，这些函数指针指向操作这些数据的文件系统的实现函数。\n\n\n超级块对象\n表示一个已安装（或称挂载）的特定文件系统。超级块对象对应于磁盘上特定扇区的文件系统超级块，用于存储已安装文件系统的元信息。其\n\n\n索引节点对象\n表示一个特定的文件。索引节点和文件是一对一的关系。只有当文件被访问时，才在内存中\n创建索引节点对象，每个索引节点对象都会复制磁盘索引节点包含的一些数据。\n\n\n目录项对象\n表示一个特定的目录项。目录项对象是一个路径的组成部分，它包含指向关联索引节点的指针，还包含指向父目录和指向子目录的指针。不同于前面两个对象，目录项对象在磁盘上没有对应的数据结构，而是 VFS 在遍历路径的过程中，将它们逐个解析成目录项对象的。\n\n\n文件对象\n表示一个与进程相关的已打开文件。可以通过调用 open 打开一个文件，通过调用 close 关闭一个文件。文件对象和物理文件的关系类似于进程和程序的关系。文件对象仅是进程视角上代表已打开的文件，它反过来指向其索引节点。文件对象包含与该文件相关联的目录项对象，包含该文件的文件系统、文件指针等，还包含在该文件对象上的一系列操作函数。\n\n\n\n\n虚拟文件系统的特点：\n\n\n向上层用户进程提供统一标准的系统调用接口，屏蔽底层具体文件系统的实现差异。\n\n\nVFS 要求下层的文件系统必须实现某些规定的函数功能，如：open/read/write。一个新的文件系统想要在某操作系统上被使用，就必须满足该操作系统 VFS 的要求。\n\n\n每打开一个文件，VFS 就在主存中新建一个 vnode，用统一的数据结构表示文件，无论该文件存储在哪个文件系统。\nvnode 只存在于主存中，而 inode 既会被调入主存，也会在外存中存储\n\n\n文件系统挂载\n如文件在使用前要打开那样，文件系统在进程使用之前必须先安装，也称挂载（Mounting)。\n将设备中的文件系统挂载到某个目录后，就可通过这个目录来访问设备上的文件。这里的设备指的是逻辑上的设备，如一个磁盘上的不同分区都可视为不同的设备。\n"},"计算机基础/计算机操作系统/5_输入输出管理":{"title":"I/O管理","links":[],"tags":["操作系统"],"content":"I/O 管理基础\nI/O 设备\n\nI/O 设备管理是操作系统设计中最凌乱也最具挑战性的部分。由于它包含了很多领域的不同设备及与设备相关的应用程序，因此很难有一个通用且一致的设计方案。\nI/O 设备分类\nI/O 设备是指可以将数据输入计算机的外部设备，或者可以接收计算机输出数据的外部设备。I/O 设备的类型繁多，从不同的角度可将它们分为不同的类型。\n\n\n\nI/O 接口\n\nI/O 接口（又称设备控制器）是 CPU 与设备之间的接口，以实现设备和计算机之间的数据交换。它接收发自 CPU 的命令，控制设备工作，使 CPU 能从繁杂的设备控制事务中解脱出来。\n设备控制器主要由三部分组成：\n\n\n设备控制器与 CPU 的接口\n用于实现 CPU 与设备控制器之间的通信。该接口有三类信号线：数据线、地址线和控制线。数据线传送的是读/写数据、控制信息和状态信息；地址线传送的是要访问 1/O 接口中的寄存器编号；控制线传送的是读/写等控制信号。\n\n\n设备控制器与设备的接口\n一个设备控制器可以连接一个或多个设备，因此控制器中有一个或多个设备接口。每个接口都可传输数据、控制和状态三种类型的信号。\n\n\nI/O 逻辑\n用于实现对设备的控制。它通过一组控制线与 CPU 交互，对从 CPU 收到的 I/O 命令进行译码。CPU 启动设备时，将启动命令发送给控制器，同时通过地址线将地址发送给控制器，由控制器的 I/O 逻辑对地址进行译码，并对所选设备进行控制。\n\n\n\n设备控制器的主要功能有：\n\n接收和识别命令，如磁盘控制器能接收 CPU 发来的读、写、查找等命令；\n数据交换，包括 CPU 和控制器之间的数据传输，以及控制器和设备之间的数据传输；\n标识和报告设备的状态，以供 CPU 处理；\n地址识别；\n数据缓冲；\n差错控制。\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n\n\n一个 I/0 控制器可能会对应多个设备；\n\n\n数据寄存器、控制寄存器、状态寄存器可能有多个（如：每个控制/状态寄存器对应一个具体的设备），且这些寄存器都要有相应的地址，才能方便 CPU 操作。\n\n\n\n\nI/O 接口的类型\n从不同的角度看，I/O 接口可以分为不同的类型。\n\n按数据传送方式（外设和接口一侧），可分为并行接口（一个字节或者一个字的所有位同时传送）和串行接口（一位一位地有序传送），接口要完成数据格式的转换。\n按主机访问 I/O 设备的控制方式，可分为程序查询接口、中断接口和 DMA 接口等。\n按功能选择的灵活性，可分为可编程接口（通过编程改变接口功能）和不可编程接口。\n\nI/O 端口\nI/O 端口是指设备控制器中可被 CPU 直接访问的寄存器，主要有以下三类寄存器。\n\n数据寄存器：用于缓存从设备送来的输入数据，或从 CPU 送来的输出数据。\n状态寄存器：保存设备的执行结果或状态信息，以供 CPU 读取。\n控制寄存器：由 CPU 写入，以便启动命令或更改设备模式。\n\nI/O 端口要想能够被 CPU 访问，就要对各个端口进行编址，每个端口对应一个端口地址。而对 I/O 端口的编址方式有与存储器独立编址和统一编址两种。\n\n\n\n独立编址\n独立编址是指为每个端口分配一个 I/O 端口号。\nI/O 端口的地址空间与主存地址空间是两个独立的地址空间，它们的范围可以重叠，相同地址可能属于不同的地址空间。普通用户程序不能对端口进行访问，只有操作系统使用特殊的 I/O 指令才能访问端口。\n优点：I/O 端口数比主存单元少得多，只需少量地址线，使得 I/O 端口译码简单，寻址速度更快。使用专用 I/O 指令，可使程序更加清晰，便于理解和检查。\n缺点：I/O 指令少，只提供简单的传输操作，所以程序设计的灵活性较差。此外，CPU 需要提供两组独立的存储器和设备的读/写控制信号，增加了控制的复杂性。\n\n\n统一编址\n统一编址又称内存映射 I/O，是指将主存地址空间分出一部分给 I/O 端口进行编址，I/O 端口和主存单元在同一地址空间的不同分段中，根据地址范围就能区分访问的是 I/O 端口还是主存单元，因此无须设置专门的 I/O 指令，用统一的访存指令就可访问 I/O 端口。\n优点：不需要专门的 IO 指令，使得 CPU 访问 IO 的操作更加灵活和方便，还使得端口有较大的编址空间。I/O 访问的保护机制可由虚拟存储管理系统来实现，无须专门设置。\n缺点：端口地址占用了部分主存地址空间，使主存的可用容量变小。此外，由于在识别 I/O 端口时全部地址线都需参加译码，使得译码电路更复杂，降低了寻址速度。\n\n\nI/O 控制方式\nI/O 控制是指控制设备和主机之间的数据传送。在 I/O 控制方式的发展过程中，始终贯穿看这样一个宗旨：尽量减少 CPU 对 I/O 控制的干预，将 CPU 从繁杂的 I/O 控制事务中解脱出来，以便其能更多地去执行运算任务。I/O 控制方式共有 4 种。\n\n程序直接控制方式\nCPU 对 I/O 设备的控制采取轮询的 I/O 方式，又称程序轮询方式。\nCPU 向设备控制器发出一条 I/O 指令，启动从 I/O 设备读取一个字（节），然后不断地循环测试设备状态（称为轮询），直到确定该字（节）已在设备控制器的数据寄存器中。于是 CPU 将数据寄存器中的数据取出，送入内存的指定单元，这样便完成了一个字（节）的 I/O 操作。\n这种方式简单且易于实现，但缺点也很明显。CPU 的绝大部分时间都处于等待 I/O 设备状态的循环测试中，CPU 和 I/O 设备只能串行工作，由于 CPU 和 I/O 设备的速度差异很大，导致 CPU 的利用率相当低。而 CPU 之所以要不断地测试 I/O 设备的状态，就是因为在 CPU 中未采用中断机构，使 I/O 设备无法向 CPU 报告它已完成了一个字（节）的输入操作。\n\n\n中断驱动方式\n中断驱动方式允许 I/O 设备主动打断 CPU 的运行并请求服务，从而“解放”CPU，使得 CPU 向设备控制器发出一条 I/O 指令后可以继续做其他有用的工作。\n\n\n从设备控制器的角度来看\n设备控制器从 CPU 接收一个读命令，然后从设备读数据。一旦数据读入设备控制器的数据寄存器，便通过控制线给 CPU 发出中断信号，表示数据已准备好，然后等待 CPU 请求该数据。设备控制器收到 CPU 发出的取数据请求后，将数据放到数据总线上，传到 CPU 的寄存器中。至此，本次 I/O 操作完成，设备控制器又可开始下一次 I/O 操作。\n\n\n从 CPU 的角度来看\n当前运行进程发出读命令，该进程将被阻塞，然后保存该进程的上下文，转去执行其他程序。在每个指令周期的末尾，CPU 检查中断信号。当有来自设备控制器的中断时，CPU 保存当前运行进程的上下文，转去执行中断处理程序以处理该中断请求。这时，CPU 从设备控制器读一个字的数据传送到寄存器，并存入主存。中断处理完后解除发出 I/O 命令的进程的阻塞状态，然后恢复该进程（或其他进程）的上下文，然后继续运行。\n\n\n相比于程序轮询 I/O 方式，在中断驱动 I/O 方式中，设备控制器通过中断主动向 CPU 报告 I/O 操作已完成，不再需要轮询，在设备准备数据期间，CPU 和设备并行工作，CPU 的利用率得到明显提升。\n但是，中断驱动方式仍有两个明显的问题：\n\n设备与内存之间的数据交换都必须经过 CPU 中的寄存器；\nCPU 是以字（节）为单位进行干预的，若将这种方式用于块设备的 I/O 操作，则显然是极其低效的。因此，中断驱动 I/O 方式的速度仍然受限。\n\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n中断 I/O 方式适用于键盘、针式打印机等字符型设备。\n\n\n\n\n                  \n                  Important\n                  \n                \n\n中断程序执行后，输入的数据存储在内核缓冲区；而系统调用执行后，输入的数据存储在用户缓冲区。\n以 C 语言中 scanf() 函数的执行过程为例，用户请求通过键盘输入数据，当程序执行到 scanf() 时，会触发系统调用，CPU 切换到内核态，执行系统调用服务例程，系统调用的内核程序会进行一些初始化操作，启动外设并同时阻塞该用户进程，直到键盘输入数据，键盘中断服务例程（实际上是驱动程序）会将数据从 I/O 接口（键盘控制器）中的数据寄存器取出并送至内核缓冲区，然后唤醒用户进程，用户进程被唤醒后进入就绪队列，等得到 CPU 运行后，再将内核缓冲区中的数据送至用户缓冲区，最后进行系统调用的返回。\n\n\nDMA 方式\nDMA（直接存储器存取）方式的基本思想是，在 I/O 设备和内存之间开辟直接的数据交换通路，彻底“解放”CPU。DMA 方式的特点如下：\n\n基本传送单位是数据块，而不再是字（节）。\n所传送的数据，是从设备直接送入内存的，或者相反，而不再经过 CPU。\n仅在传送一个或多个数据块的开始和结束时，才需要 CPU 干预。\n\n\n为了实现主机和控制器之间直接交换成块的数据，须在 DMA 控制器中设置如下 4 类寄存器：\n\n命令/状态寄存器(CR)：接收从 CPU 发来的 I/O 命令、有关控制信息，或设备的状态。\n内存地址寄存器(MAR)：在输入时，它存放将数据从设备传送到内存的起始目标地址；在输出时，它存放由内存到设备的内存源地址。\n数据寄存器(DR)：暂存从设备到内存或从内存到设备的数据。\n数据计数器(DC)：存放本次要传送的字（节）数。\n\n\n工作过程：CPU 接收到设备的 DMA 请求时，它向 DMA 控制器发出一条命令，同时设置 MAR 和 DC 初值，启动 DMA 控制器，然后继续其他工作。之后 CPU 就将 I/O 控制权交给 DMA 控制器，由 DMA 控制器负责数据传送。DMA 控制器直接与内存交互，每次传送一个字，这个过程不需要 CPU 参与。整个数据传送结束后，DMA 控制器向 CPU 发送一个中断信号。因此只有在传送开始和结束时才需要 CPU 的参与。\nDMA 的传送过程分为预处理、数据传送和后处理三个阶段。\n\n在预处理阶段，由 CPU 初始化 DMA 控制器中的有关寄存器、设置传送方向、测试并启动设备等。\n在数据传送阶段，完全由 DMA 控制，DMA 控制器接管系统总线。\n在后处理阶段，DMA 控制器向 CPU 发送中断请求，CPU 执行中断服务程序做 DMA 结束处理。\n\n\n将数据从磁盘读到内存的过程包括以下操作：\n初始化 DMA 控制器并启动磁盘 → 从磁盘传输一块数据到内存缓冲区 → DMA 控制器发出中断请求 → 执行“DMA 结束”中断服务程序。\n\nDMA 方式的优点：数据传输以“块”为单位，CPU 介入的频率进一步降低；数据传送不再经过 CPU 的寄存器，CPU 和设备的并行操作程度得到了进一步提升。\n\n通道控制方式\n\n\nI/O 软件层次结构\n为使复杂的 I/O 软件能具有清晰的结构、良好的可移植性和易适应性，目前普遍采用层次式结构的 I/O 软件。将系统中的设备管理模块分为若干层次，每层都是利用其下层提供的服务，完成输入/输出功能中的某些子功能，并屏蔽这些功能实现的细节，向高层提供服务。\n在层次式结构的 I/O 软件中，只要层次间的接口不变，对某一层次中的软件的修改都不会引起其下层或高层代码的变更，仅最低层才涉及硬件的具体特性。\n一个比较合理的层次划分如图所示。\n\n整个 I/O 软件可以视为具有 4 个层次的系统结构，各层次及其功能如下：\n\n\n用户层软件\n实现与用户交互的接口，用户可直接调用在用户层提供的、与 I/O 操作有关的库函数，对设备进行操作。\n通常大部分的 I/O 软件都在操作系统内核，但仍有一小部分在用户层，包括与用户程序链接在一起的库函数。用户层 I/O 软件必须通过一组系统调用来获取操作系统服务。\n\n\n\n设备独立性软件\n用于实现用户程序与设备驱动器的统一接口、设备命名、设备保护以及设备的分配与释放等，同时为设备管理和数据传送提供必要的存储空间。\n设备独立性也称设备无关性，其含义是指应用程序所用的设备不局限于某个具体的物理设备。为实现设备独立性而引入了逻辑设备和物理设备这两个概念。在应用程序中，使用逻辑设备名来请求使用某类设备；而在系统实际执行时，必须将逻辑设备名映射成物理设备名。\n使用逻辑设备名的好处是：\n\n增加设备分配的灵活性；\n易于实现 I/O 重定向，所谓 I/O 重定向，是指用于 I/O 操作的设备可以更换（重定向），而不必改变应用程序。为了实现设备独立性，必须再在驱动程序之上设置一层设备独立性软件。\n\n总体而言，设备独立性软件的主要功能可分为以下两个方面。\n\n执行所有设备的公有操作，包括：对设备的分配与回收；将逻辑设备名映射为物理设备名；对设备进行保护，禁止用户直接访问设备；缓冲管理；差错控制；提供独立于设备的大小统一的逻辑块，屏蔽设备之间信息交换单位大小和传输速率的差异。\n向用户层（或文件层）提供统一接口。无论何种设备，它们向用户所提供的接口应是相同的。例如，对各种设备的读/写操作，在应用程序中都统一使用 read/write 命令等。\n\n\n\n设备驱动程序\n与硬件直接相关，负责具体实现系统对设备发出的操作指令，驱动 I/O 设备工作的驱动程序。\n通常，每类设备配置一个设备驱动程序，它是 I/O 进程与设备控制器之间的通信程序，通常以进程的形式存在。若更换物理设备，则只需更换驱动程序，而无须修改应用程序。\n设备驱动程序向上层用户程序提供一组标准接口，设备具体的差别被设备驱动程序所封装，用于接收上层软件发来的抽象 I/O 要求，如 read 和 write 命令，转换为具体要求，发送给设备控制器，控制 I/O 设备工作；它也将由设备控制器发来的信号传送给上层软件，从而为 I/O 内核子系统隐藏设备控制器之间的差异。\n\n\n\n中断处理程序\n用于保存被中断进程的 CPU 环境，转入相应的中断处理程序进行处理，处理完毕再恢复被中断进程的现场后，返回到被中断进程。\n中断处理层的主要任务有：进行进程上下文的切换，对处理中断信号源进行测试，读取设备状态和修改进程状态等。由于中断处理与硬件紧密相关，对用户而言，应尽量加以屏蔽，因此应放在操作系统的底层，系统的其余部分尽可能少地与之发生联系。\n\n\n\n磁盘 I/O 操作中各层次的处理过程：\n\n当用户要读取某设备的内容时，通过操作系统提供的 read 命令接口，这就经过了用户层。\n操作系统提供给用户使用的接口一般是统一的通用接口，也就是几乎每个设备都可以响应的统一命令，如 read 命令，用户发出的 read 命令，首先经过设备独立层进行解析，然后交往下层。\n接下来，不同类型的设备对 read 命令的行为有所不同，如磁盘接收 read 命令后的行为与打印机接收 read 命令后的行为是不同的。因此，需要针对不同的设备，将 read 命令解析成不同的指令，这就经过了设备驱动层。\n命令解析完毕后，需要中断正在运行的进程，转而执行 read 命令，这就需要中断处理程序。\n最后，命令真正抵达硬件设备，硬件设备的控制器按照上层传达的命令操控硬件设备，完成相应的功能。\n\n\n应用程序 I/O 接口\n\nI/O 接口的分类（根据设备类型的不同）\n\n\n字符设备接口\n字符设备是指数据的存取和传输是以字符为单位的设备，如键盘、打印机等。基本特征是传输速率较低、不可寻址，并且在输入/输出时通常采用中断驱动方式。\n字符设备都属于独占设备，为此接口中还需要提供打开和关闭操作，以实现互斥共享。\n\n\n块设备接口\n块设备是指数据的存取和传输是以数据块为单位的设备，典型的块设备是磁盘。基本特征是传输速率较高、可寻址。磁盘设备的 I/O 常采用 DMA 方式。\n隐藏了磁盘的二维结构。在二维结构中，每个扇区的地址需要用磁道号和扇区号来表示。块设备接口将磁盘的所有扇区从 0 到 n-1 依次编号，这样，就将二维结构变为一种线性序列。\n将抽象命令映射为低层操作。块设备接口支持上层发来的对文件或设备的打开、读、写和关闭等抽象命令，该接口将上述命令映射为设备能识别的较低层的具体操作。\n内存映射接口通过内存的字节数组来访问磁盘，而不提供读/写磁盘操作。映射文件到内存的系统调用返回包含文件副本的一个虚拟内存地址。只在需要访问内存映像时，才由虚拟存储器实际调页。内存映射文件的访问如同内存读/写一样简单，极大地方便了程序员。\n\n\n网络设备接口\n现代操作系统都提供面向网络的功能，因此还需要提供相应的网络软件和网络通信接口，使计算机能够通过网络与网络上的其他计算机进行通信或上网浏览。\n许多操作系统提供的网络 I/O 接口为网络套接字接口，套接字接口的系统调用使应用程序创建的本地套接字连接到远程应用程序创建的套接字，通过此连接发送和接收数据。\n\n\n\n\n阻塞 I/O 和非阻塞 I/O\n\n\n阻塞 I/O 是指当用户进程调用 I/O 操作时，进程就被阻塞，并移到阻塞队列，I/O 操作完成后，进程才被唤醒，移到就绪队列。当进程恢复执行时，它收到系统调用的返回值，并继续处理数据。\n大多数操作系统提供的 I/O 接口都是采用阻塞 I/O。\n优点：操作简单，实现难度低，适合并发量小的应用开发。\n缺点：I/O 执行阶段进程会一直阻塞下去。\n\n\n非阻塞 1/O 是指当用户进程调用 I/O 操作时，不阻塞该进程，但进程需要不断询问 I/O 操作是否完成，在 I/O 执行阶段，进程还可以做其他事情。当问到 I/O 操作完成后，系统将数据从内核复制到用户空间，进程继续处理数据。\n优点：进程在等待 IO 期间不会阻塞，可以做其他事情，适合并发量大的应用开发。\n缺点：轮询方式询问 I/O 结果，会占用 CPU 的时间。\n\n\n\n\n设备独立性软件\n设备独立性软件\n也称与设备无关的软件，是 I/O 系统的最高层软件，它的下层是设备驱动程序，其界限因操作系统和设备的不同而有所差异。\n比如，一些本应由设备独立性软件实现的功能，也可能放在设备驱动程序中实现。这样的差异主要是出于对操作系统、设备独立性软件和设备驱动程序运行效率等多方面因素的权衡。总体而言，设备独立性软件包括执行所有设备公有操作的软件。\n高速缓存与缓冲区\n磁盘高速缓存(Disk Cache)\n操作系统中使用磁盘高速缓存技术来提高磁盘的 I/O 速度，对访问高速缓存要比访问原始磁盘数据更为高效。例如，正在运行进程的数据既存储在磁盘上，又存储在物理内存上，也被复制到 CPU 的二级和一级高速缓存中。\n不过，磁盘高速缓存技术不同于通常意义下的介于 CPU 与内存之间的小容量高速存储器，而是指利用内存中的存储空间来暂存从磁盘中读出的一系列盘块中的信息。因此，磁盘高速缓存逻辑上属于磁盘，物理上则是驻留在内存中的盘块。\n磁盘高速缓存在内存中分为两种形式：\n\n一种是在内存中开辟一个单独的空间作为缓存区，大小固定；\n一种是将未利用的内存空间作为一个缓冲池，供请求分页系统和磁盘 I/O 时共享；\n\n缓冲区(Buffer)\n\n缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区。\n在设备管理子系统中，引入缓冲区的目的主要如下：\n\n缓和 CPU 与 I/O 设备间速度不匹配的矛盾。\n减少对 CPU 的中断频率，放宽对 CPU 中断响应时间的限制。\n解决基本数据单元大小（数据粒度）不匹配的问题。\n提高 CPU 和 I/O 设备之间的并行性。\n\n\n缓冲区的实现方法如下：\n\n使用硬件作为缓冲区的成本较高，容量也较小，一般仅用在对速度要求非常高的场合（如存储器管理中所用的联想寄存器，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本)。\n一帮用内存作为缓冲区。\n\n根据系统设置缓冲区的个数，缓冲技术可以分为：单缓冲、双缓冲、循环缓冲区、\n单缓冲\n每当用户进程发出一个 I/O 请求，操作系统便在内存中为之分配一个缓冲区。通常，一个缓冲区的大小就是一个块。\n\n\n由于缓冲区是共享资源，因此使用时必须互斥。若 CPU 尚未取走缓冲区中的数据，则即使设备又生产出新的数据，也无法将其送入缓冲区，此时设备需要等待。\n当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出。\n\n在块设备输入时，假定从设备将一块数据输入到缓冲区的时间为 T，操作系统将该缓冲区中的数据传送到工作区的时间为 M，而 CPU 对这一块数据进行处理的时间为 C。\n\n在单缓冲区中，T 是可以和 C 并行的。\n\n\n\n当 T&gt;C 时，CPU 处理一块完数据后，暂时不能将下一块数据传送到工作区，必须等待缓冲区装满数据，再将下一块数据从缓冲区传送到工作区，平均处理一块数据的时间为 T+M。\n\n\n\n当 T&lt;C 时，缓冲区中装满数据后，暂时不能继续送入下一块数据，必须等待 CPU 处理完上一块数据，再将下一块数据从缓冲区传送到工作区，平均处理一块数据的时间为 C+M。\n\n\n\n采用单缓冲策略，处理一块数据平均耗时 Max(C,T)+M。\n双缓冲\n为了加快输入和输出速度，提高设备利用率，引入了双缓冲机制，也称缓冲对换，操作系统会在主存中分配两个缓冲区。\n当设备输入数据时，先将数据送入缓冲区 1，装满后便转向缓冲区 2。此时，操作系统可以从缓冲区 1 中取出数据，送入用户进程，并由 CPU 对数据进行处理。当缓冲区 1 中取出的数据处理完后，若缓冲区 2 已冲满，则操作系统又从缓冲区 2 中取出数据送入用户进程处理，而设备又可以开始将数据送入缓冲区 1。\n\n双缓冲机制提高了设备和 CPU 的并行程度。\n\n\n\n当 T&gt;C+M 时，说明设备输入的时间比数据传送和处理的时间多，可使设备连续输入。\n假设在某个时刻，缓冲区 1 是空的，缓冲区 2 是满的，缓冲区 2 开始向工作区传送数据，缓冲区 1 开始装入数据。传送并处理的时间为 C+M，但缓冲区 1 还未装满，必须等待缓冲区 1 装满数据，再将下一块数据从缓冲区 1 传送到工作区，平均处理一块数据的时间为 T。\n\n\n\n当 T&lt;C+M 时，说明设备输入的时间比数据传送和处理的时间少，可使 CPU 不必等待设备输入。\n假设在某个时刻，缓冲区 1 是空的，缓冲区 2 是满的，缓冲区 2 开始向工作区传送数据，缓冲区 1 开始装入数据。缓冲区 1 装满数据的用时为 T，必须等待缓冲区 2 中的数据传送并处理完后，才能将下一块数据从缓冲区 1 传送到工作区，平均处理一块数据的时间为 C+M。\n\n\n\n采用双缓冲策略，处理一个数据块的平均耗时为 Max(T,C+M)。\n\n\n                  \n                  使用单/双缓冲在通信时的区别 \n                  \n                \n\n\n\n\n\n循环缓冲\n在双缓冲机制中，当输入与输出的速度基本匹配时，能取得较好的效果。但若两者的速度相差甚远，则双缓冲区的效果不会太理想。为此，又引入了多缓冲机制，让多个缓冲区组成循环缓冲区的形式。\n循环缓冲包含多个大小相等的缓冲区，每个缓冲区中有一个链接指针指向下一个缓冲区，最后一个缓冲区指针指向第一个缓冲区，多个缓冲区链接成一个循环队列。循环缓冲中还需设置 in 和 out 两个指针，in 指向第一个可以输入数据的空缓冲区，out 指向第一个可以提取数据的满缓冲区。输入/输出时，in 和 out 指针沿链接方向循环移动。\n\n缓存池\n相比于缓冲区（仅是一块内存空间），缓冲池是包含一个用于管理自身的数据结构和一组操作函数的管理机制，用于管理多个缓冲区。缓冲池可供多个进程共享使用。\n缓冲池由多个系统公用的缓冲区组成，缓冲区按其使用状况可以分为：\n\n空缓冲队列，由空缓冲区链接而成的队列；\n输入队列，由装满输入数据的缓冲区链接而成的队列；\n输出队列，由装满输出数据的缓冲区所链接成的队列。\n\n此外还应具有 4 种工作缓冲区：\n\n用于收容输入数据的工作缓冲区(hin)\n用于提取输入数据的工作缓冲区(sin)\n用于收容输出数据的工作缓冲区(hout)\n用于提取输出数据的工作缓冲区(sout)\n\n\n缓冲池中的缓冲区有以下 4 种工作方式。\n\n收容输入：输入进程需要输入数据时，从空缓冲队列的队首摘下一个空缓冲区，作为收容输入工作缓冲区，然后将数据输入其中，装满后再将它挂到输入队列的队尾。\n提取输入：计算进程需要输入数据时，从输入队列的队首取得一个缓冲区，作为提取输入工作缓冲区，从中提取数据，用完该数据后将它挂到空缓冲队列的列尾。\n收容输出：计算进程需要输出数据时，从空缓冲队列的队首取得一个空缓冲区，作为收容输出工作缓冲区，当其中装满数据后，再将它挂到输出队列的队尾。\n提取输出：输出进程需要输出数据时，从输出队列的队首取得一个装满输出数据的缓冲区，作为提取输出工作缓冲区，当数据提取完后，再将它挂到空缓冲队列的队尾。\n\n高速缓存与缓冲区的对比\n高速缓存是可以保存数据拷贝的高速存储器，访问高速缓存比访问原始数据更高效，速度更快。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n区别高速缓存缓冲区存放存放的是低速设备上的某些数据的复制数据，即高速缓存上有的，低速设备上面必然有。存放的是低速设备传递给高速设备的数据（或相反），而这些数据在低速设备（或高速设备）上却不一定有备份，这些数据再从缓冲区传送到高速设备（或低速设备）。目的高速缓存存放的是高速设备经常要访问的数据，若高速设备要访问的数据不在高速缓存中，则高速设备就需要访问低速设备。高速设备和低速设备的通信都要经过缓冲区，高速设备永远不会直接去访问低速设备\n设备分配与回收\n\n设备分配是指根据用户的 I/O 请求分配所需的设备。分配的总原则是充分发挥设备的使用效率，尽可能地让设备忙碌，又要避免由于不合理的分配方法造成进程死锁。\n设备分配中的数据结构\n\n在系统中，可能存在多个通道，每个通道可以连接多个控制器，每个控制器可以连接多个物理设备。设备分配的数据结构要能体现出这种从属关系。\n\n\n设备控制表(DCT)：系统为每个设备配置一张 DCT。\n\n\n\n控制器控制表(COCT)：每个设备控制器都对应一张 COCT。操作系统根据 COCT 的信息对控制器进行操作和管理。每个控制器由一个通道控制，通过表项“与控制器连接的通道表指针”可以找到相应通道的信息。\n\n\n\n通道控制表(CHCT)：每个通道都对应一张 CHCT。操作系统根据 CHCT 的信息对通道进行操作和管理。一个通道可为多个控制器服务，通过表项“与通道连接的控制器表首址”可以找到该通道管理的所有控制器的信息。\n\n\n\n系统设备表(SDT)：整个系统只有一张 SDT。它记录已连接到系统中的所有物理设备的情况，每个物理设备对应一个表目。\n\n\n\n设备分配考虑的因素\n在多道程序系统中，进程数多于资源数，因此要有一套合理的分配原则，主要考虑的因素有设备的固有属性、设备的分配算法、设备分配的安全性以及设备的独立性。\n\n\n设备的固有属性\n独占设备：一个时段只能分配给一个进程（如打印机）。\n共享设备：可同时分配给多个进程使用（如磁盘），需要合理调度各个进程访问该设备的先后次序。\n虚拟设备：属于可共享设备，可将它同时分配给多个进程使用。\n\n\n设备分配算法\n针对设备分配，通常只采用以下两种分配算法：\nFCFS 算法：该算法根据各个进程对某个设备提出请求的先后次序，将这些进程排成一个设备请求队列，设备分配程序总是将设备首先分配给队首进程。\n最高优先级优先算法：在用该算法形成设备队列时，优先级高的进程排在设备队列前面而对于优先级相同的 I/O 请求，则按 FCFS 原则排队。\n\n\n设备分配中的安全性\n设备分配中的安全性是指在设备分配中应防止发生进程死锁。\n安全分配方式：每当进程发出 I/O 请求后，便进入阻塞态，直到其 I/O 操作完成时才被唤醒。这样，进程一旦获得某种设备后便会阻塞，不能再请求任何资源，而在它阻塞时也不保持任何资源。其优点是设备分配安全，缺点是 CPU 和 I/O 设备是串行工作的。\n不安全分配方式：进程在发出 I/O 请求后仍继续运行，需要时又会发出第二个、第三个 I/O 请求等。仅当进程所请求的设备已被另一进程占用时，才进入阻塞态。优点是一个进程可同时操作多个设备，使进程推进迅速；缺点是有可能造成死锁。\n\n\n\n\n                  \n                  Note\n                  \n                \n\n设备的类型决定了设备的固有属性，如独占性、共享性、可虚拟性等，不同类型的设备需要采用不同的分配方式，如独占分配、共享分配、虚拟分配等。\n设备的访问权限决定了哪些进程可以使用哪些设备，以保证系统的安全性和保密性，通常系统设备只能由系统进程或特权进程访问，用户设备只能由用户进程或授权进程访问。\n设备的占用状态决定了设备是否可以被分配给请求进程，以及如何处理等待进程，若设备空闲，则通常可以直接分配给请求进程；若设备忙，则需要将请求进程排入设备队列，并按照一定的算法进行调度。\n逻辑设备与物理设备的映射关系决定了如何通过逻辑地址访问物理地址，以提高系统的灵活性和可扩展性，通常系统会为每个物理设备分配一个逻辑名，并建立一个系统设备表来记录逻辑名与物理名之间的对应关系。\n\n\n设备分配步骤\n\n\n\n假脱机技术(SPOOLing)\n\n\n为了缓和 CPU 的高速性与 I/O 设备的低速性之间的矛盾，引入了假脱机技术。SPOOLing 的意思是外部设备同时联机操作，又称假脱机输入/输出操作，是操作系统中采用的一项将独占设备改造成共享设备的技术。\n该技术利用专门的外围控制机，将低速 I/O 设备上的数据传送到高速磁盘上，或者相反。当 CPU 需要输入数据时，便可直接从磁盘中读取数据；反之，当 CPU 需要输出数据时，也能以很快的速度将数据先输出到磁盘上。\n\n\n\n输入井和输出井\n在磁盘上开辟出的两个存储区域。输入井模拟脱机输入时的磁盘，用于收容 I/O 设备输入的数据。输出井模拟脱机输出时的磁盘，用于收容用户程序的输出数据。\n一个进程的输入（或输出）数据保存为一个文件，所有进程的输入（或输出）文件链接成一个输入（或输出）队列。\n\n\n输入缓冲区和输出缓冲区\n在内存中开辟的两个缓冲区。输入缓冲区用于暂存由输入设备送来的数据，以后再传送到输入井。输出缓冲区用于暂存从输出井送来的数据，以后再传送到输出设备。\n\n\n输入进程和输出进程\n输入进程用于模拟脱机输入时的外围控制机，将用户要求的数据从输入设备传送到输入缓冲区，再存放到输入井中。当 CPU 需要输入数据时，直接从输入井中读入内存。\n输出进程用于模拟脱机输出时的外围控制机，将用户要求输入的数据从内存传送到输出井，待输出设备空闲时，再将输出井中的数据经输出缓冲区输出至输出设备。\n\n\n井管理程序\n用于控制作业与磁盘井之间信息的交换。\n\n\n\n\n设备驱动程序接口\n为了实现上层应用与设备控制器之间的通信，设备驱动程序应具有以下功能：\n\n接收由上层软件发来的命令和参数，并将抽象要求转换为与设备相关的具体要求。例如，将抽象要求中的盘块号转换为磁盘的盘面号、磁道号及扇区号。\n检查用户 I/O 请求的合法性，了解设备的工作状态，传递与设备操作有关的参数，设置设备的工作方式。\n发出 I/O 命令，若设备空闲，则立即启动它，完成指定的 I/O 操作；若设备忙，则将请求者的 PCB 挂到设备队列上等待。\n及时响应由设备控制器发来的中断请求，并根据其中断类型，调用相应的中断处理程序进行处理。\n\n相比于普通的应用程序和系统程序，设备驱动程序具有以下差异：\n\n设备驱动程序将抽象的 I/O 请求转换成具体的 I/O 操作后，传送给设备控制器，并将设备控制器中记录的设备状态和 I/O 操作的完成情况及时地反馈给请求进程。\n设备驱动程序与设备采用的 I/O 控制方式紧密相关。因为不同的 I/O 控制方式需要不同的设备驱动程序来实现数据的传输和控制，例如中断驱动方式需要驱动设备能够响应中断信号，DMA 方式需要驱动程序能够设置 DMA 的控制器的寄存器，通道控制方式需要驱动程序能够执行通道指令等。\n设备驱动程序与硬件密切相关，对于不同类型的设备，应配置不同的设备驱动程序。所以目前很多设备驱动程序的基本部分已固化在 ROM 中。设备驱动程序应充许同时多次调用执行。\n\n为了使所有的设备驱动程序都有统一的接口，一方面，要求每个设备驱动程序与操作系统之间都有相同或相近的接口，以便更容易地添加一个新的设备驱动程序，同时更容易地编制设备驱动程序；另一方面，要将抽象的设备名转换为具体的物理设备名，并且进一步找到相应的设备驱动程序入口。此外，还应对设备进行保护，防止无权访问的用户使用设备。\n\n厂家在设计一个设备时，通常会为该设备编写驱动程序，主机需要先安装驱动程序，才能使用设备。当一个设备被连接到主机时，驱动程序负责初始化设备（如将设备控制器中的寄存器初始化）。\n设备的读/写操作本质就是在设备控制器和主机之间传送数据，而只有厂家知道设备控制器的内部实现，因此也只有厂家提供的驱动程序能控制设备的读/写操作。厂家会根据设备特性，在驱动程序中实现一种合适的 I/O 控制方式。\n\n\n\nI/O 核心子系统\n\n\n\n磁盘\n磁盘的结构\n\n磁盘(Disk)是表面涂有磁性物质的物理盘片，通过一个称为磁头的导体线圈从磁盘存取数据。在读/写操作期间，磁头固定，磁盘在下面高速旋转。\n磁盘盘面上的数据存储在一组同心圆中，称为磁道。每个磁道与磁头一样宽，一个盘面有上千个磁道。磁道又划分为几百个扇区，每个扇区固定存储大小（如 1KB），一个扇区称为一个盘块。相邻磁道及相邻扇区间通过一定的间隙分隔开，以避免精度错误。\n\n由于扇区按固定圆心角度划分，所以密度从最外道向里道增加，磁盘的存储能力受限于最内道的最大记录密度。\n所以为了提高磁盘的存储容量，充分利用磁盘外层磁道的存储能力，现代磁盘不再将内外磁道划分为相同数目的扇区，而将盘面划分为若干环带，同一环带内的所有磁道具有相同的扇区数，显然，外层环带的磁道拥有较内层环带的磁道更多的扇区。\n\n\n磁盘安装在一个磁盘驱动器中，它由磁头臂、用于旋转磁盘的转轴和用于数据输入/输出的电子设备组成。\n多个盘片垂直堆叠，组成磁盘组，每个盘面对应一个磁头，所有磁头固定在一起，与磁盘中心的距离相同且只能片上相对位置相同的磁道组成柱面。扇区是磁盘可寻址的最小单位，磁盘上能存储的物理块数目由扇区数、磁道数及磁盘面数决定，磁盘地址用“柱面号·盘面号·扇区号”表示。\n\n\n\n磁盘的管理\n初始化步骤\n\n\n低级格式化（物理格式化）\n一个新的磁盘只是一个磁性记录材料的空白盘。在磁盘可以存储数据之前，必须将它分成扇区，以便磁盘控制器能够进行读/写操作，这个过程称为低级格式化。\n每个扇区通常由头部、数据区域和尾部组成。头部和尾部包含了一些磁盘控制器的使用信息，其中利用磁道号、磁头号和扇区号来标志一个扇区，利用 CRC 字段对扇区进行校验。\n\n\n分区\n将磁盘分为由一个或多个柱面组成的分区（我们熟悉的 C 盘、D 盘等形式的分区）。每个分区的起始扇区和大小都记录在磁盘主引导记录的分区表中。每个分区可以作为一个独立的磁盘。\n\n\n逻辑格式化（高级格式化）\n对物理分区进行逻辑格式化，将初始文件系统数据结构存储到磁盘上，这些数据结构包括空闲空间和已分配空间，以及一个初始为空的目录，建立根目录、对保存空闲磁盘块信息的数据结构进行初始化。\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n因扇区的单位太小，为了提高效率，操作系统将多个相邻的扇区组合在一起，形成一簇。为了更高效地管理磁盘，一簇只能存放一个文件的内容，文件所占用的空间只能是簇的整数倍；如果文件大小小于一簇（甚至是 0 字节），也要占用一簇的空间。\n\n\n引导块\n计算机启动时需要运行一个初始化程序（自举程序），它初始化 CPU、寄存器、设备控制器和内存等，接着启动操作系统。为此，自举程序找到磁盘上的操作系统内核，将它加载到内存，并转到起始地址，从而开始操作系统的运行。\n自举程序通常存放在 ROM 中，为了避免改变自举代码而需要改变 ROM 硬件的问题，通常只在 ROM 中保留很小的自举装入程序，而将完整功能的引导程序保存在磁盘的启动块上，启动块位于磁盘的固定位置。具有启动分区的磁盘称为启动磁盘或系统磁盘。引导 ROM 中的代码指示磁盘控制器将引导块读入内存，然后开始执行，它可以从非固定的磁盘位置加载整个操作系统，并且开始运行操作系统。\n下面以 Windows 为例来分析引导过程。Windows 允许将磁盘分为多个分区，有一个分区为引导分区，它包含操作系统和设备驱动程序。Windows 系统将引导代码存储在磁盘的第 0 号扇区，它称为主引导记录（MBR）。引导首先运行 ROM 中的代码，这个代码指示系统从 MBR 中读取引导代码。除了包含引导代码，MBR 还包含一个磁盘分区表和一个标志（以指示从哪个分区引导系统）。当系统找到引导分区时，读取分区的第一个扇区，称为引导扇区，并继续余下的引导过程，包括加载各种系统服务。\n\n坏块\n由于磁盘有移动部件且容错能力弱，因此容易导致一个或多个扇区损坏。部分磁盘甚至在出厂时就有坏块。根据所用的磁盘和控制器，对这些块有多种处理方式。\n\n对于简单磁盘，如采用 IDE 控制器的磁盘，坏块可手动处理，如 MS-DOS 的 Format 命令执行逻辑格式化时会扫描磁盘以检查坏块。坏块在 FAT 表上会标明，因此程序不会使用它们。\n对于复杂的磁盘，控制器维护磁盘内的坏块列表。这个列表在出厂低级格式化时就已初始化，并在磁盘的使用过程中不断更新。低级格式化将一些块保留作为备用，操作系统看不到这些块。控制器可以采用备用块来逻辑地替代坏块，这种方案称为扇区备用。\n\n\n对坏块的处理实质上就是用某种机制使系统不去使用坏块。\n\n磁盘调度算法\n\n\n\n在磁盘的存取时间中，寻道时间占大头，它与磁盘调度算法密切相关；而延迟时间和传输时间都与磁盘旋转速度线性相关，所以转速是磁盘性能的一个非常重要的硬件参数，也很难从操作系统层面进行优化。因此，磁盘调度的主要目标是减少磁盘的平均寻道时间。\n先来先服务算法(FCFS)\n\nFirst Come First Served, FCFS\n\nFCFS 算法根据进程请求访问磁盘的先后顺序进行调度，这是一种最简单的调度算法。该算法的优点是具有公平性。\n\n若只有少量进程需要访问，且大部分请求都是访问簇聚的文件扇区，则有望达到较好的性能；\n若有大量进程竞争使用磁盘，则这种算法在性能上往往接近于随机调度。所以，实际磁盘调度中会考虑一些更为复杂的调度算法。\n\n\n最短寻找时间优先(SSTF)\n\nShortest Seek Time First, SSTF\n\nSSTF 算法每次选择调度的是与当前磁头最近的磁道，使每次的寻道时间最短。每次选择最小寻道时间并不能保证平均寻道时间最小，但能提供比 FCFS 算法更好的性能。这种算法会产生“饥饿”现象。\n\n扫描算法(SCAN)\nSSTF 算法产生饥饿的原因是“磁头可能在一个小范围内来回地移动”。为了防止这个问题，可以规定：只有磁头移动到最外侧磁道时才能向内移动，移动到最内侧磁道时才能向外移动，这就是 SCAN 算法的思想。\n由于磁头移动规律与电梯运行相似，因此又称电梯调度算法。SCAN 算法对最近扫描过的区域不公平，因此它在访问局部性方面不如 FCFS 算法和 SSTF 算法好。\n\n\n\n                  \n                  Tip\n                  \n                \n\n[2018 年 408 真题.30]\nSCAN 也会导致磁臂粘着\n\n\n循环扫描算法(C-SCAN)\n\nCircular SCAN, C-SCAN\n\n由于 SCAN 算法偏向于处理那些接近最里或最外的磁道的访问请求，所以使用改进型的 C-SCAN 算法来避免这个问题。C-SCAN 算法在 SCAN 算法的基础上规定磁头单向移动来提供服务，返回时直接快速移动至起始端而不服务任何请求。\n\nLOOK 调度算法\n\nC-LOOK 调度算法\n\n提高磁盘 I/O 速度\n\n采用磁盘高速缓存。\n调整磁盘请求顺序。\n提前读。在读磁盘当前块时，将下一磁盘块也读入内存缓冲区。\n延迟写。仅在缓冲区首部设置延迟写标志，然后释放此缓冲区并将其链入空闲缓冲区链表的尾部，当其他进程申请到此缓冲区时，才真正将缓冲区信息写入磁盘块。\n优化物理块的分布。除了上面介绍的扇区编号优化，当文件采用链接方式和索引方式组织时，应尽量将同一个文件的盘块安排在一个磁道上或相邻的磁道上，以减少寻道时间。另外，将若干盘块组成簇，按簇对文件进行分配，也可减少磁头的平均移动距离。\n虚拟盘。是指用内存空间去仿真磁盘，又叫 RAM 盘。常用于存放临时文件。\n采用磁盘阵列 RAID。由于可采用并行交叉存取，因此能大幅提高磁盘 I/O 速度。\n\n固态硬盘\n固态硬盘(SolidStateDisk, SSD)是一种基于闪存技术的存储器。\n它与 U 盘并无本质差别，只是容量更大，存取性能更好。一个 SSD 由一个或多个闪存芯片和闪存翻译层组成。闪存芯片替代传统磁盘中的机械驱动器，而闪存翻译层将来自 CPU 的逻辑块读/写请求翻译成对底层物理设备的读/写控制信号，因此闪存翻译层相当于扮演了磁盘控制器的角色。\n\n一个闪存由 B 块组成，每块由 P 页组成。通常，页的大小是 512B ～ 4KB，每块由 32 ～ 128 页组成，块的大小为 16KB ～ 512KB。数据是以页为单位读/写的。只有在一页所属的块整个被擦除后，才能写这一页。不过，一旦一个块被擦除，块中的每页就都可以直接再写一次。某个块进行了若干重复写后，就会磨损坏，不能再使用。\n随机写很慢，有两个原因。首先，擦除块比较慢，通常比访问页高一个数量级。其次，如果写操作试图修改一个包含已有数据的页 P，那么这个块中所有含有用数据的页都必须被复制到一个新块中，然后才能进行对页 P 的写操作。\n优点：它由半导体存储器构成，没有移动的部件，因此随机访问速度比机械磁盘要快很多，也没有任何机械噪声和震动，能耗更低、抗震性好、安全性高等。\n\n磨损均衡(Wear Leveling)\n固态硬盘也有缺点，闪存的擦写寿命是有限的，一般是几百次到几千次。如果直接用普通闪存组装 SSD，那么实际的寿命表现可能非常令人失望一一读/写数据时会集中在 SSD 的一部分闪存，这部分闪存的寿命会损耗得特别快。一旦这部分闪存损坏，整块 SSD 也就损坏了。\n为了弥补 SSD 的寿命缺陷，引入了磨损均衡。SSD 磨损均衡技术大致分为两种：\n\n动态磨损均衡：写入数据时，自动选择较新的闪存块。老的闪存块先歇一歇。\n静态磨损均衡：这种技术更为先进，就算没有数据写入，SSD 也会监测并自动进行数据分配，让老的闪存块承担无须写数据的存储任务，同时让较新的闪存块腾出空间，平常的读/写操作在较新的闪存块中进行。如此一来，各闪存块的寿命损耗就都差不多。\n"},"计算机基础/计算机组成原理/1_计算机系统概述":{"title":"计算机组成原理","links":[],"tags":["计算机组成原理"],"content":"计算机系统层次结构\n计算机系统的组成\n硬件系统和软件系统共同构成了一个完整的计算机系统。\n\n硬件：有形的物理设备，是计算机系统中实际物理装置的总称。\n软件：在硬件上运行的程序和相关的数据及文档。\n\n冯·诺依曼计算机\n冯·诺依曼机的基本工作方式是控制流驱动方式。\n特点：\n\n采用“存储程序”的工作方式。\n计算机硬件系统由运算器、存储器、控制器、输入设备和输出设备 这 5 大部件组成。\n指令和数据以同等地位存储在存储器中，形式上没有区别，但计算机应能区分它们。\n指令和数据均用二进制代码表示。\n指令由操作码和地址码组成，操作码指出操作的类型，地址码指出操作数的地址。\n以运算器为中心，输入/输出设备与存储器之间的数据传送通过运算器完成。\n\n“存储程序”的基本思想是：将事先编制好的程序和原始数据送入主存后才能执行，一旦程序被启动执行，计算机会自动逐条执行指令，直至程序执行结束。（按地址访问并顺序执行指令）\n\n\n现代计算机\n现代计算机通常把运算器和控制器集成在一个芯片上，合成中央处理器（CPU）。\n特点是以存储器为中心，使 I/O 操作尽可能地绕过 CPU，直接在 I/O 设备和存储器之间完成，以提高系统的整体运行效率。\n\n硬件\n\n输入和输出设备\n\n输入设备的：将程序和数据以机器所能识别和接受的信息形式输入计算机。\n输出设备的：将计算机处理的结果以人们所能接受的形式或其他系统所要求的信息形式输出。\n\n存储器\n存储器分为主存储器（内存储器）和辅助存储器（外存储器）。\nCPU 能够直接访问的存储器是主存储器。辅助存储器用于帮助主存储器记忆更多的信息，辅助存储器中的信息必须调入主存后，才能为 CPU 所访问。\n主存储器的工作方式是按存储单元的地址进行存取，这种存取方式称为按地址存取方式。\n\nMAR：Memory Address Register（存储地址寄存器）\nMDR：Memory Data Register（存储数据寄存器）\n\n\n\n\n                  \n                  Tip\n                  \n                \n\nMAR 与 MDR 虽然是存储器的一部分，但在现代计算机中却是存在于 CPU 中的；\n\n\n运算器\n运算器是计算机的执行部件，用于进行算术运算和逻辑运算。\n运算器的核心是算术逻辑单元（Arithmetic and Logical Unit, ALU）。\n\n控制器\n控制器是计算机的指挥中心，由其“指挥”各部件自动协调地进行工作。\n控制器由程序由以下三部分组成，\n\n\n控制单元（CU）：分析指令，指挥其他部件执行指令\n\n\n程序计数器（PC）：存放当前欲执行指令的地址，通过自动加 1 的功能，即可自动形成下一条指令的地址，它与主存的 MAR 之间有一条直接通路。\n\n“1”指一条指令的长度。\n\n\n\n指令寄存器（IR）：存放当前的指令，其内容来自主存的 MDR。\n指令中的操作码 OP 送至 CU，用以分析指令并发出各种微操作命令序列；而地址码 Ad 送往 MAR，用以取操作数。\n\n\n\n软件\n软件按其功能分类，可分为\n\n系统软件：一组保证计算机系统高效、正确运行的基础软件，通常作为系统资源提供给用户使用。\n应用软件：用户为解决某个应用领域中的各类问题而编制的程序。\n\n三个级别的语言\n\n\n机器语言\n又称二进制代码语言。机器语言是计算机唯一可以直接识别和执行的语言。\n\n\n汇编语言\n汇编语言用英文单词或其缩写代替二进制的指令代码，更容易为人们记忆和理解。\n使用汇编语言编辑的程序必须经过汇编程序的系统软件的翻译，将其转换为机器语言程序后，才能在计算机的硬件系统上执行。\n\n\n高级语言\n高级语言是为方便程序设计人员写出解决问题的处理方案和解题过程的程序。\n通常高级语言需要经过编译程序编译成汇编语言程序，然后经过汇编操作得到机器语言程序，或直接由高级语言程序翻译成机器语言程序。\n\n\n翻译程序有以下三类：\n\n汇编程序（汇编器）：将汇编语言程序翻译成机器语言程序。\n解释程序（解释器）：将源程序中的语句按执行顺序逐条翻译成机器指令并立即执行。\n编译程序（编译器）：将高级语言程序翻译成汇编语言或机器语言程序。\n\n\n软、硬件逻辑功能的等价性：对某一功能来说，既可以由硬件实现，又可以由软件实现，从用户的角度来看，它们在功能上是等价的。\n层次结构\n\n第 1 级是微程序机器层\n第 2 级是传统机器语言层\n第 3 级是操作系统层\n第 4 级是汇编语言层\n第 5 级是高级语言层\n\n\n工作过程\n\n\n\n                  \n                  Tip\n                  \n                \n\nCPU 区分指令和数据的依据：指令周期的不同阶段。\n通常，执行阶段取出的是数据，取值阶段取出的是指令。\n\n\n\n\n\n\n\n计算机性能指标\n\n字长\n字长是指计算机进行一次整数运算所能处理的二进制数据的位数。字长一般等于通用寄存器的位数或 ALU 的宽度，字长越长，数的表示范围越大，计算精度越高。\n计算机字长通常选定为字节（8 位）的整数倍。\n计算机位数就是指机器字长。字长会影响硬件造假。\n\n\n                  \n                  Tip\n                  \n                \n\n字：用来表示被处理信息的单位，用来度量数据类型的宽度，如 x86 机器中将一个字定义为 16 位。\n指令字长：一个指令字中包含的二进制代码的位数。指令字长一般取存储字长的整数倍，若指令字长等于存储字长的 2 倍，则需要 2 个访存周期来取出一条指令；若指令字长等于存储字长，则取指令周期等于机器周期。\n存储字长：一个存储单元存储的二进制代码的位数。\n\n\n主存容量\n主存容量 是指主存储器所能存储信息的最大容量，通常以字节来衡量，也可用字数 \\times 字长（如 512K \\times 16 位）来表示存储容量。\n\nCPU 性能指标\n\n在用于科学计算的计算机中，主要使用 MFLOPS 评估系统性能。\n数据通路带宽\n数据通路：各个子系统通过数据总线连接形成的数据传送路径。\n数据通路带宽：数据总线一次所能并行传送信息的位数。\n\n\n                  \n                  Tip\n                  \n                \n\n这里所说的数据通路宽度是指外部数据总线的宽度，它与 CPU 内部的数据总线宽度（内部寄存器的大小）有可能不同。\n\n\n吞吐量和响应时间\n吞吐量：系统在单位时间内处理请求的数量，主要取决于主存的存取周期。\n响应时间：从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结果的等待时间。\n\n吞吐量是评价计算机系统性能的综合参数。\n基准程序\n基准程序 是专门用来进行性能评价的一组程序，能够很好地反映机器在运行实际负载时的性能，可以通过在不同机器上运行相同的基准程序来比较在不同机器上的运行时间，从而评测其性能。对于不同的应用场合，应该选择不同的基准程序。\n专业术语\n系列机：具有基本相同的体系结构，使用相同基本指令系统的多个不同型号的计算机组成的一个产品系列。\n兼容：指软件或硬件的通用性。若运行在某个型号的计算机系统中的硬/软件也能应用于另一个型号的计算机系统时，则称这两台计算机在硬件或软件上存在兼容性。\n固件：将程序固化在 ROM 中组成的部件称为固件。固件是一种具有软件特性的硬件，吸收了软件/硬件各自的优点，其执行速度快于软件，灵活性优于硬件，是软/硬件结合的产物。\ntitle: 计算机组成原理\ntags:\n\n计算机组成原理\n\n\n计算机系统层次结构\n计算机系统的组成\n硬件系统和软件系统共同构成了一个完整的计算机系统。\n\n硬件：有形的物理设备，是计算机系统中实际物理装置的总称。\n软件：在硬件上运行的程序和相关的数据及文档。\n\n冯·诺依曼计算机\n冯·诺依曼机的基本工作方式是控制流驱动方式。\n特点：\n\n采用“存储程序”的工作方式。\n计算机硬件系统由运算器、存储器、控制器、输入设备和输出设备 这 5 大部件组成。\n指令和数据以同等地位存储在存储器中，形式上没有区别，但计算机应能区分它们。\n指令和数据均用二进制代码表示。\n指令由操作码和地址码组成，操作码指出操作的类型，地址码指出操作数的地址。\n以运算器为中心，输入/输出设备与存储器之间的数据传送通过运算器完成。\n\n“存储程序”的基本思想是：将事先编制好的程序和原始数据送入主存后才能执行，一旦程序被启动执行，计算机会自动逐条执行指令，直至程序执行结束。（按地址访问并顺序执行指令）\n\n\n现代计算机\n现代计算机通常把运算器和控制器集成在一个芯片上，合成中央处理器（CPU）。\n特点是以存储器为中心，使 I/O 操作尽可能地绕过 CPU，直接在 I/O 设备和存储器之间完成，以提高系统的整体运行效率。\n\n硬件\n\n输入和输出设备\n\n输入设备的：将程序和数据以机器所能识别和接受的信息形式输入计算机。\n输出设备的：将计算机处理的结果以人们所能接受的形式或其他系统所要求的信息形式输出。\n\n存储器\n存储器分为主存储器（内存储器）和辅助存储器（外存储器）。\nCPU 能够直接访问的存储器是主存储器。辅助存储器用于帮助主存储器记忆更多的信息，辅助存储器中的信息必须调入主存后，才能为 CPU 所访问。\n主存储器的工作方式是按存储单元的地址进行存取，这种存取方式称为按地址存取方式。\n\nMAR：Memory Address Register（存储地址寄存器）\nMDR：Memory Data Register（存储数据寄存器）\n\n\n\n\n                  \n                  Tip\n                  \n                \n\nMAR 与 MDR 虽然是存储器的一部分，但在现代计算机中却是存在于 CPU 中的；\n\n\n运算器\n运算器是计算机的执行部件，用于进行算术运算和逻辑运算。\n运算器的核心是算术逻辑单元（Arithmetic and Logical Unit, ALU）。\n\n控制器\n控制器是计算机的指挥中心，由其“指挥”各部件自动协调地进行工作。\n控制器由程序由以下三部分组成，\n\n\n控制单元（CU）：分析指令，指挥其他部件执行指令\n\n\n程序计数器（PC）：存放当前欲执行指令的地址，通过自动加 1 的功能，即可自动形成下一条指令的地址，它与主存的 MAR 之间有一条直接通路。\n\n“1”指一条指令的长度。\n\n\n\n指令寄存器（IR）：存放当前的指令，其内容来自主存的 MDR。\n指令中的操作码 OP 送至 CU，用以分析指令并发出各种微操作命令序列；而地址码 Ad 送往 MAR，用以取操作数。\n\n\n\n软件\n软件按其功能分类，可分为\n\n系统软件：一组保证计算机系统高效、正确运行的基础软件，通常作为系统资源提供给用户使用。\n应用软件：用户为解决某个应用领域中的各类问题而编制的程序。\n\n三个级别的语言\n\n\n机器语言\n又称二进制代码语言。机器语言是计算机唯一可以直接识别和执行的语言。\n\n\n汇编语言\n汇编语言用英文单词或其缩写代替二进制的指令代码，更容易为人们记忆和理解。\n使用汇编语言编辑的程序必须经过汇编程序的系统软件的翻译，将其转换为机器语言程序后，才能在计算机的硬件系统上执行。\n\n\n高级语言\n高级语言是为方便程序设计人员写出解决问题的处理方案和解题过程的程序。\n通常高级语言需要经过编译程序编译成汇编语言程序，然后经过汇编操作得到机器语言程序，或直接由高级语言程序翻译成机器语言程序。\n\n\n翻译程序有以下三类：\n\n汇编程序（汇编器）：将汇编语言程序翻译成机器语言程序。\n解释程序（解释器）：将源程序中的语句按执行顺序逐条翻译成机器指令并立即执行。\n编译程序（编译器）：将高级语言程序翻译成汇编语言或机器语言程序。\n\n\n软、硬件逻辑功能的等价性：对某一功能来说，既可以由硬件实现，又可以由软件实现，从用户的角度来看，它们在功能上是等价的。\n层次结构\n\n第 1 级是微程序机器层\n第 2 级是传统机器语言层\n第 3 级是操作系统层\n第 4 级是汇编语言层\n第 5 级是高级语言层\n\n\n工作过程\n\n\n\n                  \n                  Tip\n                  \n                \n\nCPU 区分指令和数据的依据：指令周期的不同阶段。\n通常，执行阶段取出的是数据，取值阶段取出的是指令。\n\n\n\n\n\n\n\n计算机性能指标\n\n字长\n字长是指计算机进行一次整数运算所能处理的二进制数据的位数。字长一般等于通用寄存器的位数或 ALU 的宽度，字长越长，数的表示范围越大，计算精度越高。\n计算机字长通常选定为字节（8 位）的整数倍。\n计算机位数就是指机器字长。字长会影响硬件造假。\n\n\n                  \n                  Tip\n                  \n                \n\n字：用来表示被处理信息的单位，用来度量数据类型的宽度，如 x86 机器中将一个字定义为 16 位。\n指令字长：一个指令字中包含的二进制代码的位数。指令字长一般取存储字长的整数倍，若指令字长等于存储字长的 2 倍，则需要 2 个访存周期来取出一条指令；若指令字长等于存储字长，则取指令周期等于机器周期。\n存储字长：一个存储单元存储的二进制代码的位数。\n\n\n主存容量\n主存容量 是指主存储器所能存储信息的最大容量，通常以字节来衡量，也可用字数 \\times 字长（如 512K \\times 16 位）来表示存储容量。\n\nCPU 性能指标\n\n在用于科学计算的计算机中，主要使用 MFLOPS 评估系统性能。\n数据通路带宽\n数据通路：各个子系统通过数据总线连接形成的数据传送路径。\n数据通路带宽：数据总线一次所能并行传送信息的位数。\n\n\n                  \n                  Tip\n                  \n                \n\n这里所说的数据通路宽度是指外部数据总线的宽度，它与 CPU 内部的数据总线宽度（内部寄存器的大小）有可能不同。\n\n\n吞吐量和响应时间\n吞吐量：系统在单位时间内处理请求的数量，主要取决于主存的存取周期。\n响应时间：从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结果的等待时间。\n\n吞吐量是评价计算机系统性能的综合参数。\n基准程序\n基准程序 是专门用来进行性能评价的一组程序，能够很好地反映机器在运行实际负载时的性能，可以通过在不同机器上运行相同的基准程序来比较在不同机器上的运行时间，从而评测其性能。对于不同的应用场合，应该选择不同的基准程序。\n专业术语\n系列机：具有基本相同的体系结构，使用相同基本指令系统的多个不同型号的计算机组成的一个产品系列。\n兼容：指软件或硬件的通用性。若运行在某个型号的计算机系统中的硬/软件也能应用于另一个型号的计算机系统时，则称这两台计算机在硬件或软件上存在兼容性。\n固件：将程序固化在 ROM 中组成的部件称为固件。固件是一种具有软件特性的硬件，吸收了软件/硬件各自的优点，其执行速度快于软件，灵活性优于硬件，是软/硬件结合的产物。\ntitle: 计算机组成原理\ntags:\n\n计算机组成原理\n\n\n计算机系统层次结构\n计算机系统的组成\n硬件系统和软件系统共同构成了一个完整的计算机系统。\n\n硬件：有形的物理设备，是计算机系统中实际物理装置的总称。\n软件：在硬件上运行的程序和相关的数据及文档。\n\n冯·诺依曼计算机\n冯·诺依曼机的基本工作方式是控制流驱动方式。\n特点：\n\n采用“存储程序”的工作方式。\n计算机硬件系统由运算器、存储器、控制器、输入设备和输出设备 这 5 大部件组成。\n指令和数据以同等地位存储在存储器中，形式上没有区别，但计算机应能区分它们。\n指令和数据均用二进制代码表示。\n指令由操作码和地址码组成，操作码指出操作的类型，地址码指出操作数的地址。\n以运算器为中心，输入/输出设备与存储器之间的数据传送通过运算器完成。\n\n“存储程序”的基本思想是：将事先编制好的程序和原始数据送入主存后才能执行，一旦程序被启动执行，计算机会自动逐条执行指令，直至程序执行结束。（按地址访问并顺序执行指令）\n\n\n现代计算机\n现代计算机通常把运算器和控制器集成在一个芯片上，合成中央处理器（CPU）。\n特点是以存储器为中心，使 I/O 操作尽可能地绕过 CPU，直接在 I/O 设备和存储器之间完成，以提高系统的整体运行效率。\n\n硬件\n\n输入和输出设备\n\n输入设备的：将程序和数据以机器所能识别和接受的信息形式输入计算机。\n输出设备的：将计算机处理的结果以人们所能接受的形式或其他系统所要求的信息形式输出。\n\n存储器\n存储器分为主存储器（内存储器）和辅助存储器（外存储器）。\nCPU 能够直接访问的存储器是主存储器。辅助存储器用于帮助主存储器记忆更多的信息，辅助存储器中的信息必须调入主存后，才能为 CPU 所访问。\n主存储器的工作方式是按存储单元的地址进行存取，这种存取方式称为按地址存取方式。\n\nMAR：Memory Address Register（存储地址寄存器）\nMDR：Memory Data Register（存储数据寄存器）\n\n\n\n\n                  \n                  Tip\n                  \n                \n\nMAR 与 MDR 虽然是存储器的一部分，但在现代计算机中却是存在于 CPU 中的；\n\n\n运算器\n运算器是计算机的执行部件，用于进行算术运算和逻辑运算。\n运算器的核心是算术逻辑单元（Arithmetic and Logical Unit, ALU）。\n\n控制器\n控制器是计算机的指挥中心，由其“指挥”各部件自动协调地进行工作。\n控制器由程序由以下三部分组成，\n\n\n控制单元（CU）：分析指令，指挥其他部件执行指令\n\n\n程序计数器（PC）：存放当前欲执行指令的地址，通过自动加 1 的功能，即可自动形成下一条指令的地址，它与主存的 MAR 之间有一条直接通路。\n\n“1”指一条指令的长度。\n\n\n\n指令寄存器（IR）：存放当前的指令，其内容来自主存的 MDR。\n指令中的操作码 OP 送至 CU，用以分析指令并发出各种微操作命令序列；而地址码 Ad 送往 MAR，用以取操作数。\n\n\n\n软件\n软件按其功能分类，可分为\n\n系统软件：一组保证计算机系统高效、正确运行的基础软件，通常作为系统资源提供给用户使用。\n应用软件：用户为解决某个应用领域中的各类问题而编制的程序。\n\n三个级别的语言\n\n\n机器语言\n又称二进制代码语言。机器语言是计算机唯一可以直接识别和执行的语言。\n\n\n汇编语言\n汇编语言用英文单词或其缩写代替二进制的指令代码，更容易为人们记忆和理解。\n使用汇编语言编辑的程序必须经过汇编程序的系统软件的翻译，将其转换为机器语言程序后，才能在计算机的硬件系统上执行。\n\n\n高级语言\n高级语言是为方便程序设计人员写出解决问题的处理方案和解题过程的程序。\n通常高级语言需要经过编译程序编译成汇编语言程序，然后经过汇编操作得到机器语言程序，或直接由高级语言程序翻译成机器语言程序。\n\n\n翻译程序有以下三类：\n\n汇编程序（汇编器）：将汇编语言程序翻译成机器语言程序。\n解释程序（解释器）：将源程序中的语句按执行顺序逐条翻译成机器指令并立即执行。\n编译程序（编译器）：将高级语言程序翻译成汇编语言或机器语言程序。\n\n\n软、硬件逻辑功能的等价性：对某一功能来说，既可以由硬件实现，又可以由软件实现，从用户的角度来看，它们在功能上是等价的。\n层次结构\n\n第 1 级是微程序机器层\n第 2 级是传统机器语言层\n第 3 级是操作系统层\n第 4 级是汇编语言层\n第 5 级是高级语言层\n\n\n工作过程\n\n\n\n                  \n                  Tip\n                  \n                \n\nCPU 区分指令和数据的依据：指令周期的不同阶段。\n通常，执行阶段取出的是数据，取值阶段取出的是指令。\n\n\n\n\n\n\n\n计算机性能指标\n\n字长\n字长是指计算机进行一次整数运算所能处理的二进制数据的位数。字长一般等于通用寄存器的位数或 ALU 的宽度，字长越长，数的表示范围越大，计算精度越高。\n计算机字长通常选定为字节（8 位）的整数倍。\n计算机位数就是指机器字长。字长会影响硬件造假。\n\n\n                  \n                  Tip\n                  \n                \n\n字：用来表示被处理信息的单位，用来度量数据类型的宽度，如 x86 机器中将一个字定义为 16 位。\n指令字长：一个指令字中包含的二进制代码的位数。指令字长一般取存储字长的整数倍，若指令字长等于存储字长的 2 倍，则需要 2 个访存周期来取出一条指令；若指令字长等于存储字长，则取指令周期等于机器周期。\n存储字长：一个存储单元存储的二进制代码的位数。\n\n\n主存容量\n主存容量 是指主存储器所能存储信息的最大容量，通常以字节来衡量，也可用字数 \\times 字长（如 512K \\times 16 位）来表示存储容量。\n\nCPU 性能指标\n\n在用于科学计算的计算机中，主要使用 MFLOPS 评估系统性能。\n数据通路带宽\n数据通路：各个子系统通过数据总线连接形成的数据传送路径。\n数据通路带宽：数据总线一次所能并行传送信息的位数。\n\n\n                  \n                  Tip\n                  \n                \n\n这里所说的数据通路宽度是指外部数据总线的宽度，它与 CPU 内部的数据总线宽度（内部寄存器的大小）有可能不同。\n\n\n吞吐量和响应时间\n吞吐量：系统在单位时间内处理请求的数量，主要取决于主存的存取周期。\n响应时间：从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结果的等待时间。\n\n吞吐量是评价计算机系统性能的综合参数。\n基准程序\n基准程序 是专门用来进行性能评价的一组程序，能够很好地反映机器在运行实际负载时的性能，可以通过在不同机器上运行相同的基准程序来比较在不同机器上的运行时间，从而评测其性能。对于不同的应用场合，应该选择不同的基准程序。\n专业术语\n系列机：具有基本相同的体系结构，使用相同基本指令系统的多个不同型号的计算机组成的一个产品系列。\n兼容：指软件或硬件的通用性。若运行在某个型号的计算机系统中的硬/软件也能应用于另一个型号的计算机系统时，则称这两台计算机在硬件或软件上存在兼容性。\n固件：将程序固化在 ROM 中组成的部件称为固件。固件是一种具有软件特性的硬件，吸收了软件/硬件各自的优点，其执行速度快于软件，灵活性优于硬件，是软/硬件结合的产物。\ntitle: 计算机组成原理\ntags:\n\n计算机组成原理\n\n\n计算机系统层次结构\n计算机系统的组成\n硬件系统和软件系统共同构成了一个完整的计算机系统。\n\n硬件：有形的物理设备，是计算机系统中实际物理装置的总称。\n软件：在硬件上运行的程序和相关的数据及文档。\n\n冯·诺依曼计算机\n冯·诺依曼机的基本工作方式是控制流驱动方式。\n特点：\n\n采用“存储程序”的工作方式。\n计算机硬件系统由运算器、存储器、控制器、输入设备和输出设备 这 5 大部件组成。\n指令和数据以同等地位存储在存储器中，形式上没有区别，但计算机应能区分它们。\n指令和数据均用二进制代码表示。\n指令由操作码和地址码组成，操作码指出操作的类型，地址码指出操作数的地址。\n以运算器为中心，输入/输出设备与存储器之间的数据传送通过运算器完成。\n\n“存储程序”的基本思想是：将事先编制好的程序和原始数据送入主存后才能执行，一旦程序被启动执行，计算机会自动逐条执行指令，直至程序执行结束。（按地址访问并顺序执行指令）\n\n\n现代计算机\n现代计算机通常把运算器和控制器集成在一个芯片上，合成中央处理器（CPU）。\n特点是以存储器为中心，使 I/O 操作尽可能地绕过 CPU，直接在 I/O 设备和存储器之间完成，以提高系统的整体运行效率。\n\n硬件\n\n输入和输出设备\n\n输入设备的：将程序和数据以机器所能识别和接受的信息形式输入计算机。\n输出设备的：将计算机处理的结果以人们所能接受的形式或其他系统所要求的信息形式输出。\n\n存储器\n存储器分为主存储器（内存储器）和辅助存储器（外存储器）。\nCPU 能够直接访问的存储器是主存储器。辅助存储器用于帮助主存储器记忆更多的信息，辅助存储器中的信息必须调入主存后，才能为 CPU 所访问。\n主存储器的工作方式是按存储单元的地址进行存取，这种存取方式称为按地址存取方式。\n\nMAR：Memory Address Register（存储地址寄存器）\nMDR：Memory Data Register（存储数据寄存器）\n\n\n\n\n                  \n                  Tip\n                  \n                \n\nMAR 与 MDR 虽然是存储器的一部分，但在现代计算机中却是存在于 CPU 中的；\n\n\n运算器\n运算器是计算机的执行部件，用于进行算术运算和逻辑运算。\n运算器的核心是算术逻辑单元（Arithmetic and Logical Unit, ALU）。\n\n控制器\n控制器是计算机的指挥中心，由其“指挥”各部件自动协调地进行工作。\n控制器由程序由以下三部分组成，\n\n\n控制单元（CU）：分析指令，指挥其他部件执行指令\n\n\n程序计数器（PC）：存放当前欲执行指令的地址，通过自动加 1 的功能，即可自动形成下一条指令的地址，它与主存的 MAR 之间有一条直接通路。\n\n“1”指一条指令的长度。\n\n\n\n指令寄存器（IR）：存放当前的指令，其内容来自主存的 MDR。\n指令中的操作码 OP 送至 CU，用以分析指令并发出各种微操作命令序列；而地址码 Ad 送往 MAR，用以取操作数。\n\n\n\n软件\n软件按其功能分类，可分为\n\n系统软件：一组保证计算机系统高效、正确运行的基础软件，通常作为系统资源提供给用户使用。\n应用软件：用户为解决某个应用领域中的各类问题而编制的程序。\n\n三个级别的语言\n\n\n机器语言\n又称二进制代码语言。机器语言是计算机唯一可以直接识别和执行的语言。\n\n\n汇编语言\n汇编语言用英文单词或其缩写代替二进制的指令代码，更容易为人们记忆和理解。\n使用汇编语言编辑的程序必须经过汇编程序的系统软件的翻译，将其转换为机器语言程序后，才能在计算机的硬件系统上执行。\n\n\n高级语言\n高级语言是为方便程序设计人员写出解决问题的处理方案和解题过程的程序。\n通常高级语言需要经过编译程序编译成汇编语言程序，然后经过汇编操作得到机器语言程序，或直接由高级语言程序翻译成机器语言程序。\n\n\n翻译程序有以下三类：\n\n汇编程序（汇编器）：将汇编语言程序翻译成机器语言程序。\n解释程序（解释器）：将源程序中的语句按执行顺序逐条翻译成机器指令并立即执行。\n编译程序（编译器）：将高级语言程序翻译成汇编语言或机器语言程序。\n\n\n软、硬件逻辑功能的等价性：对某一功能来说，既可以由硬件实现，又可以由软件实现，从用户的角度来看，它们在功能上是等价的。\n层次结构\n\n第 1 级是微程序机器层\n第 2 级是传统机器语言层\n第 3 级是操作系统层\n第 4 级是汇编语言层\n第 5 级是高级语言层\n\n\n工作过程\n\n\n\n                  \n                  Tip\n                  \n                \n\nCPU 区分指令和数据的依据：指令周期的不同阶段。\n通常，执行阶段取出的是数据，取值阶段取出的是指令。\n\n\n\n\n\n\n\n计算机性能指标\n\n字长\n字长是指计算机进行一次整数运算所能处理的二进制数据的位数。字长一般等于通用寄存器的位数或 ALU 的宽度，字长越长，数的表示范围越大，计算精度越高。\n计算机字长通常选定为字节（8 位）的整数倍。\n计算机位数就是指机器字长。字长会影响硬件造假。\n\n\n                  \n                  Tip\n                  \n                \n\n字：用来表示被处理信息的单位，用来度量数据类型的宽度，如 x86 机器中将一个字定义为 16 位。\n指令字长：一个指令字中包含的二进制代码的位数。指令字长一般取存储字长的整数倍，若指令字长等于存储字长的 2 倍，则需要 2 个访存周期来取出一条指令；若指令字长等于存储字长，则取指令周期等于机器周期。\n存储字长：一个存储单元存储的二进制代码的位数。\n\n\n主存容量\n主存容量 是指主存储器所能存储信息的最大容量，通常以字节来衡量，也可用字数 \\times 字长（如 512K \\times 16 位）来表示存储容量。\n\nCPU 性能指标\n\n在用于科学计算的计算机中，主要使用 MFLOPS 评估系统性能。\n数据通路带宽\n数据通路：各个子系统通过数据总线连接形成的数据传送路径。\n数据通路带宽：数据总线一次所能并行传送信息的位数。\n\n\n                  \n                  Tip\n                  \n                \n\n这里所说的数据通路宽度是指外部数据总线的宽度，它与 CPU 内部的数据总线宽度（内部寄存器的大小）有可能不同。\n\n\n吞吐量和响应时间\n吞吐量：系统在单位时间内处理请求的数量，主要取决于主存的存取周期。\n响应时间：从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结果的等待时间。\n\n吞吐量是评价计算机系统性能的综合参数。\n基准程序\n基准程序 是专门用来进行性能评价的一组程序，能够很好地反映机器在运行实际负载时的性能，可以通过在不同机器上运行相同的基准程序来比较在不同机器上的运行时间，从而评测其性能。对于不同的应用场合，应该选择不同的基准程序。\n专业术语\n系列机：具有基本相同的体系结构，使用相同基本指令系统的多个不同型号的计算机组成的一个产品系列。\n兼容：指软件或硬件的通用性。若运行在某个型号的计算机系统中的硬/软件也能应用于另一个型号的计算机系统时，则称这两台计算机在硬件或软件上存在兼容性。\n固件：将程序固化在 ROM 中组成的部件称为固件。固件是一种具有软件特性的硬件，吸收了软件/硬件各自的优点，其执行速度快于软件，灵活性优于硬件，是软/硬件结合的产物。\ntitle: 计算机组成原理\ntags:\n\n计算机组成原理\n\n\n计算机系统层次结构\n计算机系统的组成\n硬件系统和软件系统共同构成了一个完整的计算机系统。\n\n硬件：有形的物理设备，是计算机系统中实际物理装置的总称。\n软件：在硬件上运行的程序和相关的数据及文档。\n\n冯·诺依曼计算机\n冯·诺依曼机的基本工作方式是控制流驱动方式。\n特点：\n\n采用“存储程序”的工作方式。\n计算机硬件系统由运算器、存储器、控制器、输入设备和输出设备 这 5 大部件组成。\n指令和数据以同等地位存储在存储器中，形式上没有区别，但计算机应能区分它们。\n指令和数据均用二进制代码表示。\n指令由操作码和地址码组成，操作码指出操作的类型，地址码指出操作数的地址。\n以运算器为中心，输入/输出设备与存储器之间的数据传送通过运算器完成。\n\n“存储程序”的基本思想是：将事先编制好的程序和原始数据送入主存后才能执行，一旦程序被启动执行，计算机会自动逐条执行指令，直至程序执行结束。（按地址访问并顺序执行指令）\n\n\n现代计算机\n现代计算机通常把运算器和控制器集成在一个芯片上，合成中央处理器（CPU）。\n特点是以存储器为中心，使 I/O 操作尽可能地绕过 CPU，直接在 I/O 设备和存储器之间完成，以提高系统的整体运行效率。\n\n硬件\n\n输入和输出设备\n\n输入设备的：将程序和数据以机器所能识别和接受的信息形式输入计算机。\n输出设备的：将计算机处理的结果以人们所能接受的形式或其他系统所要求的信息形式输出。\n\n存储器\n存储器分为主存储器（内存储器）和辅助存储器（外存储器）。\nCPU 能够直接访问的存储器是主存储器。辅助存储器用于帮助主存储器记忆更多的信息，辅助存储器中的信息必须调入主存后，才能为 CPU 所访问。\n主存储器的工作方式是按存储单元的地址进行存取，这种存取方式称为按地址存取方式。\n\nMAR：Memory Address Register（存储地址寄存器）\nMDR：Memory Data Register（存储数据寄存器）\n\n\n\n\n                  \n                  Tip\n                  \n                \n\nMAR 与 MDR 虽然是存储器的一部分，但在现代计算机中却是存在于 CPU 中的；\n\n\n运算器\n运算器是计算机的执行部件，用于进行算术运算和逻辑运算。\n运算器的核心是算术逻辑单元（Arithmetic and Logical Unit, ALU）。\n\n控制器\n控制器是计算机的指挥中心，由其“指挥”各部件自动协调地进行工作。\n控制器由程序由以下三部分组成，\n\n\n控制单元（CU）：分析指令，指挥其他部件执行指令\n\n\n程序计数器（PC）：存放当前欲执行指令的地址，通过自动加 1 的功能，即可自动形成下一条指令的地址，它与主存的 MAR 之间有一条直接通路。\n\n“1”指一条指令的长度。\n\n\n\n指令寄存器（IR）：存放当前的指令，其内容来自主存的 MDR。\n指令中的操作码 OP 送至 CU，用以分析指令并发出各种微操作命令序列；而地址码 Ad 送往 MAR，用以取操作数。\n\n\n\n软件\n软件按其功能分类，可分为\n\n系统软件：一组保证计算机系统高效、正确运行的基础软件，通常作为系统资源提供给用户使用。\n应用软件：用户为解决某个应用领域中的各类问题而编制的程序。\n\n三个级别的语言\n\n\n机器语言\n又称二进制代码语言。机器语言是计算机唯一可以直接识别和执行的语言。\n\n\n汇编语言\n汇编语言用英文单词或其缩写代替二进制的指令代码，更容易为人们记忆和理解。\n使用汇编语言编辑的程序必须经过汇编程序的系统软件的翻译，将其转换为机器语言程序后，才能在计算机的硬件系统上执行。\n\n\n高级语言\n高级语言是为方便程序设计人员写出解决问题的处理方案和解题过程的程序。\n通常高级语言需要经过编译程序编译成汇编语言程序，然后经过汇编操作得到机器语言程序，或直接由高级语言程序翻译成机器语言程序。\n\n\n翻译程序有以下三类：\n\n汇编程序（汇编器）：将汇编语言程序翻译成机器语言程序。\n解释程序（解释器）：将源程序中的语句按执行顺序逐条翻译成机器指令并立即执行。\n编译程序（编译器）：将高级语言程序翻译成汇编语言或机器语言程序。\n\n\n软、硬件逻辑功能的等价性：对某一功能来说，既可以由硬件实现，又可以由软件实现，从用户的角度来看，它们在功能上是等价的。\n层次结构\n\n第 1 级是微程序机器层\n第 2 级是传统机器语言层\n第 3 级是操作系统层\n第 4 级是汇编语言层\n第 5 级是高级语言层\n\n\n工作过程\n\n\n\n                  \n                  Tip\n                  \n                \n\nCPU 区分指令和数据的依据：指令周期的不同阶段。\n通常，执行阶段取出的是数据，取值阶段取出的是指令。\n\n\n\n\n\n\n\n计算机性能指标\n\n字长\n字长是指计算机进行一次整数运算所能处理的二进制数据的位数。字长一般等于通用寄存器的位数或 ALU 的宽度，字长越长，数的表示范围越大，计算精度越高。\n计算机字长通常选定为字节（8 位）的整数倍。\n计算机位数就是指机器字长。字长会影响硬件造假。\n\n\n                  \n                  Tip\n                  \n                \n\n字：用来表示被处理信息的单位，用来度量数据类型的宽度，如 x86 机器中将一个字定义为 16 位。\n指令字长：一个指令字中包含的二进制代码的位数。指令字长一般取存储字长的整数倍，若指令字长等于存储字长的 2 倍，则需要 2 个访存周期来取出一条指令；若指令字长等于存储字长，则取指令周期等于机器周期。\n存储字长：一个存储单元存储的二进制代码的位数。\n\n\n主存容量\n主存容量 是指主存储器所能存储信息的最大容量，通常以字节来衡量，也可用字数 \\times 字长（如 512K \\times 16 位）来表示存储容量。\n\nCPU 性能指标\n\n在用于科学计算的计算机中，主要使用 MFLOPS 评估系统性能。\n数据通路带宽\n数据通路：各个子系统通过数据总线连接形成的数据传送路径。\n数据通路带宽：数据总线一次所能并行传送信息的位数。\n\n\n                  \n                  Tip\n                  \n                \n\n这里所说的数据通路宽度是指外部数据总线的宽度，它与 CPU 内部的数据总线宽度（内部寄存器的大小）有可能不同。\n\n\n吞吐量和响应时间\n吞吐量：系统在单位时间内处理请求的数量，主要取决于主存的存取周期。\n响应时间：从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结果的等待时间。\n\n吞吐量是评价计算机系统性能的综合参数。\n基准程序\n基准程序 是专门用来进行性能评价的一组程序，能够很好地反映机器在运行实际负载时的性能，可以通过在不同机器上运行相同的基准程序来比较在不同机器上的运行时间，从而评测其性能。对于不同的应用场合，应该选择不同的基准程序。\n专业术语\n系列机：具有基本相同的体系结构，使用相同基本指令系统的多个不同型号的计算机组成的一个产品系列。\n兼容：指软件或硬件的通用性。若运行在某个型号的计算机系统中的硬/软件也能应用于另一个型号的计算机系统时，则称这两台计算机在硬件或软件上存在兼容性。\n固件：将程序固化在 ROM 中组成的部件称为固件。固件是一种具有软件特性的硬件，吸收了软件/硬件各自的优点，其执行速度快于软件，灵活性优于硬件，是软/硬件结合的产物。"},"计算机基础/计算机组成原理/2_数据的表示和运算":{"title":"数据的表示和运算","links":[],"tags":["计算机组成原理"],"content":"数制与编码\n在计算机系统内部，所有信息都是用二进制进行编码的，这样做的原因有以下几点。\n\n二进制只有两种状态，使用有两个稳定状态的物理器件就可以表示二进制数的每一位，制造成本比较低。\n二进制位 1 和 0 正好与逻辑值“真”和“假”相对应，为计算机实现逻辑运算和程序中的逻辑判断提供了便利条件。\n二进制的编码和运算规则很简单，通过逻辑门电路能方便地实现算术运算。\n\n\n\n                  \n                  Tip\n                  \n                \n\n在计算机内部，数值数据的表示方法有以下两大类：\n\n\n直接用二进制数表示，分为有符号数和无符号数。\n有符号数又分为定点数表示和浮点数表示。无符号数用来表示无符号整数（如地址等信息）。\n\n\n二进制编码的十进制数，一般采用 BCD 码表示，用来表示整数。\n\n\n所以，计算机中的数值数据虽然都用二进制表示，但不全是二进制，也有用十进制表示的（在用户界面层或者编程语言中，程序员或用户可以使用十进制或其他进制来输入、显示或读取数据，尽管这些数据在计算机内部仍然是以二进制形式存储和运算）。例如在指令类型中，就分别有二进制加法指令和十进制加法指令（专门用于对 BCD 进行加法操作）。\n\n\n进位计数\n\n\n\n\n可以用后缀字母标识一个数的进位计数制\n\n用 B 表示二进制；\n用 O 表示八进制；\n用 D 表示十进制（通常直接省略）；\n用 H 表示十六进制，有时也用前缀 0x 表示十六进制数；\n\n\n进制转换\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n在计算机中，小数和整数不一样，整数可以连续表示，但小数是离散的，所以并不是每个十进制小数都可以准确地用二进制表示。但任意一个二进制小数都可以用十进制小数表示。\n\n\n真值和机器数\n种带 + 或 - 符号的数称为真值，真值是机器数所代表的实际值。\n在计算机中，通常将数的符号和数值部分一起编码，将数据的符号数字化，通常用“0”表示“正”，用“1”表示“负”。这种把符号“数字化”的数称为机器数。\n\nBCD\n\n\n\n定点数\n原码、反码、补码\n原码表示的优点：与真值的对应关系简单、直观，与真值的转换简单；用原码实现乘除运算比较简便。\n原码表示的缺点：0 的表示不唯一，有 ±0 两个编码；原码加减运算比较复杂。\n反码表示存在以下几个方面的不足：0 的表示不唯一，有 ±0 两个编码；表示范围比补码少一个最小负数。\n\n反码在计算机中很少使用，通常用作数码变换的中间表示形式。\n\n\n\n\n\n\n\n\n\n\n\n移码\n移码就是在真值 X（用补码表示）上加上一个常数（偏置值），相当于 X 在数轴上向正方向偏移了若干单位，这就是“移码”一词的由来。\n移码的定义：[x]移= 2^n^+x（-2^n^≤x &lt; 2^n^，其中机器字长为 n+1）\n假设字长为 8 位，则正数 x = +10101 的移码表示为 2^7^+10101 = 1000 0000 + 10101 = 1001 0101；x = -10101 的移码表示为 2^7^ + (-10101) = 0110 1011。\n移码具有以下特点：\n\n移码中零的表示唯一\n一个真值的移码和补码仅差一个符号位\n移码全 0 时，对应真值的最小值-2^n^；移码全 1 时，对应真值的最大值 2^n^-1。\n移码保持了数据原有的大小顺序，移码大真值就大，移码小真值就小。\n\n\n\n\n\n机器数的定点表示\n根据小数点的位置是否固定，在计算机中有两种数据格式：定点表示和浮点表示。\n在现代计算机中，通常用补码整数表示整数，用原码小数表示浮点数的尾数部分，用移码表示浮点数的阶码部分。\n因此，在定点数的编码和运算中不用考虑对应的定点数是小数还是整数，而只需关心它们的符号位和数值位即可。\n定点数的编码表示法主要有 4 种：原码、补码、反码和移码。\n\n\n\n\n\n\n\n无符号整数\n当一个编码的全部二进制位均为数值位而没有符号位时，该编码表示就是无符号整数，简称无符号数。\n此时，默认数的符号为正。因为无符号整数省略了一位符号位，所以在字长相同的情况下，它能表示的最大数比有符号整数能表示的大。一般在全部是正数运算且不出现负值结果的场合下，使用无符号整数表示，例如在计算机中，通常使用无符号数表示主存地址。\n\n\n\n\n无符号整数的“溢出”：对于无符号定点整数来说，若寄存器位数不够，则计算机运算过程中一般保留低 n 位，舍弃高位。这样，会产生以下两种结果：\n\n保留的低 n 位数不能正确表示运算结果。在这种情况下，意味着运算的结果超出了计算机所能表达的范围，有效数值进到了第 n+1 位，称此时发生了“溢出”现象。\n保留的低 n 位数能正确表达计算结果，即高位的舍去并不影响其运算结果。\n\n有符号整数\n将符号数值化，并将符号位放在有效数字的前面，就组成了有符号整数。\n补码表示有符号整数有其明显的优势：\n\n与原码和反码相比，0 的补码表示唯一。\n与原码和移码相比，补码运算规则比较简单，且符号位可以和数值位一起参加运算。\n与原码和反码相比，补码比原码和反码多表示一个最小负数。\n\n计算机中的有符号整数都用补码表示。\nC 语言中的整数类型\nC 语言中的整型数据就是定点整数，根据位数的不同，可分为\n\n字符型（char，8 位）\n短整型（short 或 short int，16 位）\n整型（int，32 位）\n长整型（long 或 long int，在 32 位机器中为 32 位，在 64 位机器中为 64 位）。\n\nchar 是整型数据中比较特殊的一种，其他如 short int / long 等不指定 signed / unsigned 时都默认是有符号整数，但 char 默认是无符号整数。\n无符号整数（unsigned short/int/long）的全部二进制位均为数值位，没有符号位，相当于数的绝对值。\nsigned / unsigned 整型数据都是按补码形式存储的。\nsigned 型的最高位代表符号位，而在 unsigned 型中表示数值位，因此这两者所表示的数据范围也有所不同。\nC 语言中的类型转换\n\n有符号数和无符号数的转换\n// short 型强制转换为 unsigned short\nshort x = -4321;\nunsigned short y = (unsigned short)x; // 61225\nshort x 在存储中以补码形式存储，存储内容为1,110 1111 0001 1111。当转换成 unsigned short 时，存储的二进制数据不变，因此 y 的二进制也是 1,110 1111 0001 1111，转换成十进制就是 61225。\n因此，有符号数转换为等长的无符号数时，符号位解释为数值的一部分，负数转换为无符号数时数值将发生变化。\n\n\n                  \n                  Tip\n                  \n                \n\n强制类型转换的结果是保持位值不变，仅改变了解释这些位的方式。\n\n\n// unsigned short 型转换到 short 型\nunsigned short x = 65535; // 1111 1111 1111 1111\nshort y = (short)x; // -1\n同理，无符号数转换为有符号数时最高位解释为符号位，也可能发生数值的变化。\n不同字长整数之间的转换\n大字长变量向小字长变量强制类型转换时，系统把多余的高位部分直接截断，低位部分直接赋值。\nint x = 165537; // int 型占用 4B x = 0x000286a1\nshort y = (short)x;// short 型占用 2B y = -31071 = 0x86a1\n \nint u = -34991; // x = 0xffff7751\nshort v = (short)u; // v = 30545 = 0x7751\n小字长到大字长的转换时，不仅要使相应的位值相等，还要对高位部分进行扩展。\n\n\n若原数字是无符号整数，则进行零扩展，扩展后的高位部分用 0 填充。\n\n\n若原数字不是无符号整数，则进行符号扩展，扩展后的高位部分用原数字符号位填充。\n例如，补码的扩充只需使用符号位补足即可，也就是说正数补码的扩充只要补 0，负数补码的扩充只需补 1。\n\n\nshort x = -4321;// x = 0xef1f\nint y = x;// y = -4321 = 0xffffef1f\n \nunsigned short u = (unsigned short)x; // u = 0xef1f\nunsigned int v = u;// v = 61215 = 0x0000ef1f\n\n\n                  \n                  Tip\n                  \n                \n\nchar 型为 8 位无符号整数，其在转换为 int 型时高位补 0 即可。\n\n\n运算方法和运算电路\n基本运算部件\n加法器\n一位全加器\n\n串行加法器\n\n并行加法器\n\n并行进位加法器\n\n\n带标志位的加法器\n\n\n\n\n零标志 ZF：ZF = 1 表示结果 F 为 0。对于无符号数和有符号数的运算，ZF 都有意义。\n\n\n溢出标志 OF：判断有符号数运算是否溢出，它是符号位进位与最高数位进位的异或结果。对于无符号数运算，OF 没有意义，通俗地说就是无法根据 OF 判断无符号数运算是否溢出。例如，无符号数加法 010+011 = 101，此时 0F = 1，但结果未溢出。\n\n\n符号标志 SF：表示结果的符号，即 F 的最高位。对于无符号数运算，SF 没有意义。\n\n\n进/借位标志 CF：表示无符号数运算时的进位/借位，判断无符号数是否发生溢出。加法时，CF = 1 表示结果溢出，因此 CF 等于进位输出 Cout。减法时，CF = 1 表示有借位，即不够减，故 CF 等于进位输出 Cout取反。例如，无符号数加法 110+011 最高位产生进位，无符号数减法 000-111 最高位产生借位，结果均发生溢出（即 CF = 1)。\n\n对于有符号数运算，CF 没有意义，也就是说根据 CF 无法判断有符号数运算是否溢出。但这不代表有符号数运算时 CF 没有值，因为 ALU 运算时不会管运算对象是有符号数还是无符号数。\n\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n假设给定两个数 x 和 y 和对应的 n 位补码 x补 和 y补，执行 x op y\n\n计算 OF：判断 x op y 的值是否在 n 位补码所能表示的范围，如果不在则发生溢出，OF = 1。\n计算 CF：将 x 和 y 转成对应的补码 x补 和 y补（如果给出了补码则跳过），然后直接将 x补 和 y补 当成无符号整数进行比较或计算。x - y 时，x补&lt;y补 则说明 CF = 1。x + y 时，x补+y补 的值溢出则 CF = 1。\n\n\n\n\nALU\nALU 是一种功能较强的组合逻辑电路，它能进行多种算术运算和逻辑运算。ALU 的核心是带标志加法器。\n\n逻辑运算\n\n\n\n移位运算\n当计算机中没有乘/除法运算电路时，可以通过加法和移位相结合的方法来实现乘/除法运算。\n对于任意二进制整数，\n\n左移一位，若不产生溢出，相当于乘以 2（与十进制数的左移一位相当于乘以 10 类似）；\n右移一位，若不考虑因移出而舍去的末位尾数，相当于除以 2；\n\n\n算术移位\n算术移位需要考虑符号位的问题，即将操作数视为有符号整数。\n计算机中的有符号整数都是用补码表示的，因此对于有符号整数的移位操作应采用补码算术移位方式。\n补码算术移位的规则：\n\n左移时，高位移出，低位补 0，若移出的高位不同于移位后的符号位，即左移前后的符号位不同，则发生溢出。\n右移时，低位移出，高位补符号位，若低位的 1 移出，则影响精度。\n\n\n\n\n\n逻辑移位\n无符号数逻辑左移时，若最高位移出的是 1，则发生溢出。\n\n\n\n溢出判断\n计算机发生溢出的的根本原因是计算机的字长有限，不能表示超过一定范围的数据。\n仅当两个符号相同的数相加或两个符号相异的数相减才可能产生溢出，如两个正数相加，而结果的符号位却为 1；一个负数减去一个正数，结果的符号位却为 0（结果为正）。\n\n采用一位符号位\n\n采用一位符号位根据数值位进位情况\n\n采用双符号位\n采用双符号位时，第一符号位表示最终结果的符号，第二符号位表示运算结果是否溢出。\n\n若第二位和第一位符号相同，则未溢出。\n若第二位和第一位符号不同，则溢出。\n\n若发生正溢出，则双符号位为 01\n若发生负溢出，则双符号位为 10\n\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n模 4 补码具有模 2 补码的全部优点且更易检查加减运算中的溢出问题。\n\n\n\n\n                  \n                  Note\n                  \n                \n\n变形补码，即用两个二进制位来表示数字的符号位，其余与补码相同。\n\n\n存储模 4 补码仅需一个符号位，因为任何一个正确的数值，模 4 补码的两个符号位总是相同的。只在把两个模 4 补码的数送往 ALU 完成加减运算时，才把每个数的符号位的值同时送到 ALU 的双符号位中，即只在 ALU 中采用双符号位。\n\n定点数的加减运算\n原码的加减运算\n在原码加减运算中，将符号位和数值位分开处理，具体的规则如下：\n\n\n加法规则：遵循“同号求和，异号求差”的原则，先判断两个操作数的符号位。\n具体来说，\n\n符号位相同，则数值位相加，结果符号位不变，若最高数值位相加产生进位，则发生溢出；\n符号位不同，则做减法，绝对值大的数减去绝对值小的数，结果符号位与绝对值大的数相同。\n\n\n\n减法规则：先将减数的符号取反，然后将被减数与符号取反后的减数按原码加法进行运算。\n\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n原码的加减运算规则比较复杂，因此 计算机采用的大多是补码加减运算。\n\n\n补码的加减运算\n补码运算的特点：\n\n按二进制运算规则运算，逢二进一。\n若做加法，两个数的补码直接相加；若做减法，则将被减数与减数的负数补码相加。\n符号位与数值位一起参与运算，加、减运算结果的符号位也在运算中直接得出。\n最终运算结果的高位丢弃，保留 n+1 位，运算结果亦为补码。\n\n\n补码加减运算器\n\n\n\n运算器本身 无法识别所处理的二进制串是有符号数还是无符号数，但我们可以 通过标志信息来区分有符号整数运算结果和无符号整数运算结果。\n无符号数大小的比较\n对于无符号数的运算，零标志 ZF、进/借位标志 CF 才有意义。\n假设有两个无符号数 A 和 B，下面以执行 A-B 为例来说明 ZF、CF 标志的几种可能情况：\n\n若 A = B，如 A - B = 011 - 011 = 000，此时结果为零 ZF = 1，无借位 CF = 0。\n若 A &gt; B，如 A - B = 010 - 001 = 001，此时结果非零 ZF = 0，无借位 CF = 0。\n若 A &lt; B，如 A - B = 000 - 001 = (1)000 - 001 = 111，此时 ZF = 0，有借位 CF = 1。\n\n可以得出结论：\n\n当 ZF = 1 时，说明 A = B。\n当 ZF = 0 且 CF = 0 时，说明 A &gt; B。\n当 CF = 1 时，说明 A &lt; B。\n\n有符号数大小的比较\n对于有符号数的运算，零标志 ZF、溢出标志 OF、符号标志 SF 才有意义。\n假设两个有符号数 A 和 B，用补码表示，以执行 [A]补 - [B]补为例来说明 ZF、OF、SF 标志的几种可能情况。\n\n若 A = B，如 [A]补 - [B]补 = 011 - 011 = [A]补 + [-B]补 = 011 + 101 = (1)000，此时结果为零 ZF = 1，最高位进位与次高位进位的异或结果 OF = 0，结果的最高位 SF = 0。\n若 A &gt; B，如 [A]补 - [B]补 = 010 - 001 = 010 + 111 = (1)001，此时 ZF = 0，OF = 0，SF = 0；又如 [A]补 - [B]补 = 011 - 101 = 011 + 011 = 110，此时 ZF = 0，OF = 1，SF = 1。\n若 A &lt; B，如 [A]补 - [B]补 = 000 - 001 = 000 + 111 = 111，此时 ZF = 0，OF = 0，SF = 1。又如 [A]补 - [B]补 = 101 - 011 = 101 + 101 = (1)010，此时 ZF = 0，OF = 1，SF = 0。\n\n可以得出结论：\n\n当 ZF = 1 时，说明 A = B。\n当 ZF = 0 时，且\n\n未发生溢出时，即 OF = 0 时，\n\n若 SF = 0，则表示结果非负，说明 A &gt; B。\n若 SF = 1，则表示结果为负，说明 A &lt; B；\n\n\n发生溢出时，即 OF = 1 时，\n\n若 SF = 1，则必然是 正数减去负数 发生 溢出导致结果为负，因此，当 OF = SF（或 OF ⊕ SF = O）且 ZF = O 时，说明 A &gt; B。\n若 SF = 0，则必然是 负数减去正数 发生 溢出导致结果为正，因此，当 OF ≠ SF（或 OF ⊕ SF = 1）且 ZF = 0 时，说明 A &lt; B。\n\n\n\n\n\n定点数的乘除运算\n手算乘法运算\n\n\n原码乘法运算\n原码乘法的特点是符号位与数值位是分开求的。\n原码乘法运算分为两步：\n\n乘积的符号位由**两个乘数的符号位“异或”**得到。\n乘积的数值位是两个乘数的绝对值之积。两个定点数的数值部分之积可视为两个无符号数的乘积。\n\n\n\n                  \n                  Tip\n                  \n                \n\n在原码一位乘法中，符号位不参与运算，符号位单独处理。\n\n\n\n\n\n\n\n\n\n\n\n\n补码乘法运算\n\n\n\n原码除法运算\n\n\n恢复余数法\n\n\n\n\n\n\n\n\n\n\n\n\n\n加减交替法（不恢复余数法）\n\n\n补码除法运算\n\n\n浮点数\n定点数可表示的数字范围有限，但我们不能无限制地增加数据的长度。\n\n格式\n浮点数表示法是指以适当的形式将比例因子表示在数据中，让小数点的位置根据需要而浮动。这样，在位数有限的情况下，既扩大了数的表示范围，又保持了数的有效精度。\n\n\nS：取值 0 或 1，用来决定浮点数的符号；\nM：尾数，二进制定点小数，一般用定点原码小数表示；\nE：阶码 或指数，二进制定点整数，用移码表示。\nR：基数（隐含），可以约定为 2、4、16 等。\n\n可见 浮点数由符号、尾数和阶码三部分组成。\n\n其中，\n\n第 0 位为符号 S；\n第 1 ～ 7 位为移码表示的阶码 E（偏置值为 64）；\n第 8 ～ 31 位为 24 位二进制原码小数表示的尾数 M；\n基数 R 为 2。\n\n\n\n                  \n                  Note\n                  \n                \n\n\n阶码的值反映浮点数的小数点的实际位置；\n阶码的位数反映浮点数的表示范围；\n尾数的位数反映浮点数的精度；在浮点数总位数不变的情况下，阶码位数越多，尾数位数越少；即表示的数的范围越大，精度越差（数变稀疏）；\n\n\n\n\n\n                  \n                  Note\n                  \n                \n\n基数是浮点数的进制，决定了阶码变化的权重。基数越大，阶码每变化一位，尾数小数点需要移动的位数越多，表示的数的绝对值就越大，范围就越大。\n但是，在浮点数的总位数不变的情况下，能表示的不同状态个数是一定的。若范围增大，则意味着浮点数的离散程度增大，相邻两个浮点数之间的间隔就越大，精度就越低。\n例如，假设符号为 S、尾数为 M、阶码为 E，则基数为 2 时的浮点数表示形式为 (-1)^s\\times M \\times 2^N，基数为 4 时的浮点数表示形式为 (-1)^s\\times M \\times 4^N，显然基数为 4 时的表示范围大，但数据的离散程度也增大，精度降低。\n\n\n\n\n                  \n                  用移码表示浮点数的阶码的好处 \n                  \n                \n\n\n浮点数进行加减运算时，要比较阶码的大小，移码比较大小更方便。\n检验移码的特殊值（0 和 max）时比较容易。\n\n\n\n\n表示范围\n原码是关于原点对称的，故浮点数的范围也是关于原点对称的。\n运算结果大于最大正数时称为正上溢，小于绝对值最大负数时称为负上溢，正上溢和负上溢统称上溢。数据一旦产生上溢，计算机必须中断运算操作，进行溢出处理。\n当运算结果在 0 至最小正数之间时称为正下溢，在 0 至绝对值最小负数之间时称为负下溢，正下溢和负下溢统称下溢。数据下溢时，浮点数值趋于零，计算机将其当作机器零处理。\n\n规格化\n为了在浮点数运算过程中尽可能多地保留有效数字的位数，使有效数字尽量占满尾数数位，必须在运算过程中对浮点数进行规格化操作。\n规格化操作，是指通过调整一个非规格化浮点数的尾数和阶码的大小，使非零浮点数在尾数的最高数位上保证是一个有效值。\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n基数不同，浮点数的规格化形式也不同。\n\n当基数为 2 时，原码规格化数的尾数最高位一定是 1。\n当基数为 4 时，原码规格化数的尾数最高两位不全为 0。\n\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n规格化浮点数的尾数小数点后的第一位一定是个非零数。\n因此，对于原码编码的尾数来说，只要看尾数的第一位是否为 1 就行；对于补码表示的尾数，只要看符号位和尾数最高位是否相反。\n需要注意的是，IEEE754 标准的浮点数尾数是用原码编码的。\n\n\nIEEE 754 标准\n格式\n\n基数隐含为 2；\n对于规格化的二进制浮点数，尾数的最高位总是 1，为了能使尾数多表示一位有效位，将这个 1 隐藏，称为隐藏位。因此 23 位尾数实际表示了 24 位有效数字。\nIEEE 754 规定隐藏位 1 的位置在小数点之前，例如，（12)10=(1100)2，将它规格化后结果为 1.1×2^3^，其中整数部分的“1”将不存储在 23 位尾数内。\n\n\n                  \n                  Tip\n                  \n                \n\n单精度与双精度浮点数都采用隐藏尾数最高位的方法，因而使浮点数的精度更高。\n\n\n在 IEEE754 标准中，指数用移码表示，但偏置值并不是通常 n 位移码所用的 2^n-1^，而是 2^n-1^-1。因此，单精度和双精度浮点数的偏置值分别为 127 和 1023。\n在存储浮点数阶码之前，偏置值要先加到阶码真值上。\n\n\n\n表示范围\n\n\n\n                  \n                  Note\n                  \n                \n\n对于位数相同的定点数和浮点数，可表示的浮点数个数和定点数的个数应该一样多（有时可能因为一个值有两个或多个编码对应，编码个数会有少量差异）。\n因为可表示的数据个数取决于编码所采用的位数。编码位数一定，编码出来的数据个数就是一定的。n 位编码只能表示 2^n^个数，所以对于相同位数的定点数和浮点数来说，可表示的数据个数应该一样多。\n\n\n阶码全 1 或全 0 的意义\n\n\n\n引入无穷大数的目的是，在计算过程出现异常的情况下使得程序能继续进行下去。\n规规格化数的特点是阶码为全 0，尾数高位有一个或几个连续的 0，但不全为 0。因此，非规格化数的隐藏位为 0，且单精度和双精度浮点数的指数分别为-126 或-1022。非规格化数可以用于处理阶码下溢。\n定点和浮点表示的区别\n\n\n数值的表示范围\n若定点数和浮点数的字长相同，则浮点表示法所能表示的数值范围远大于定点表示法。（浮点表示法的数值范围更大）\n\n\n精度\n对于字长相同 的定点数和浮点数来说，浮点数虽然扩大了数的表示范围，但精度降低了。（浮点数精度低）\n\n\n数的运算\n浮点数包括阶码和尾数两部分，运算时不仅要做尾数的运算，还要做阶码的运算，而且运算结果要求规格化，所以浮点运算比定点运算复杂。（浮点运算更复杂）\n\n\n溢出问题\n在定点运算中，当运算结果超出数的表示范围时，发生溢出；在浮点运算中，运算结果超出尾数表示范围却不一定溢出，只有规格化后阶码超出所能表示的范围时，才发生溢出。\n\n\n浮点数运算步骤\n\n\n                  \n                  Tip\n                  \n                \n\n现代计算机中的浮点数采用 IEEE754 标准，所以在进行两个浮点数的加减运算时，必须考虑原码的加减运算，因为 IEEE754 标准的浮点数尾数都采用原码表示。\n原码的加减运算可以有以下两种实现方式：\n\n转换为补码后，用补码加减法实现，结果再转换为原码。\n直接用原码进行加减运算，符号位和数值位分开处理。\n\n\n\n浮点数运算的特点是阶码运算和尾数运算分开进行。\n\n\n对阶\n对阶的目的是使两个操作数的小数点位置对齐，即使得两个数的阶码相等。\n为此，先求阶码差，然后以小阶码向大阶码看齐的原则，将阶码小的尾数右移一位（基数为 2），阶码加 1，直到两个数的阶码相等为止。\n尾数右移时，若舍弃有效位会产生误差，影响精度。为了保证运算的精度，尾数右移时，低位移出的位不要丢掉，应保留并参加尾数部分的运算。\n\n\n                  \n                  Tip\n                  \n                \n\n若采用大阶码向小阶码看齐的原则，则尾数需要左移，最高有效位被移出，导致结果出错。\n\n\n尾数加减\n将对阶后的尾数按定点原码小数的加（减）运算规则进行运算。\n因为 IEEE754 浮点数尾数中有一个隐藏位，因此在进行尾数加减时，必须将隐藏位还原到尾数部分。\n运算后的尾数不一定是规格化的，因此，浮点数的加减运算需要进一步进行规格化处理。\n尾数规格化\nIEEE754 规格化尾数的形式为 ±1.x..x。尾数相加减后会得到各种可能结果，例如：±1x.x···x 和 ±0.0···01x···x。\n\n右规：当结果为 ±1x.x···x 时，需要进行右规。尾数右移一位，阶码加 1。尾数右移时，最高位 1 被移到小数点前一位作为隐藏位，最后一位移出时，要考虑舍入。\n左规：当结果为 ±0.0···01x···x 时，需要进行左规。尾数每左移一位，阶码减 1。可能需要左规多次，直到将第一位 1 移到小数点左边。\n\n舍入\n\n\n\n                  \n                  Tip\n                  \n                \n\n舍入是浮点数的概念，定点数没有舍入的概念。\n舍入不一定产生误差，如向下舍入 11.00 到 11.0 时是没有误差的。\n\n\n在对阶和尾数右规时，可能会对尾数进行右移，为保证运算精度，一般将移出的部分低位保留下来，参加中间过程的运算，最后再将运算结果进行舍入，还原表示成 IEEE754 格式。\nIEEE754 提供了以下 4 种可选的舍入模式：\n\n\n就近舍入\n舍入为最近的可表示数。\n\n当运算结果是两个可表示数的非中间值时，实际上是“0 舍 1 入”方式（类似于十进制的“四舍五入”法）;\n当运算结果正好在两个可表示数的中间时，则选择结果为偶数。\n\n例如，计算 1.24\\times 10^5 + 5.04\\times 10^2（假定科学记数法的精度保留两位小数）\n\n若只采用 2 位保留位，则结果是 1.2400\\times 10^5 + 0.0050\\times 10^5 = 1.2450 \\times 10^5，这个结果在两个可表示数 1.24\\times 10^5 和 1.25\\times 10^5 的中间，采用就近舍入方式到偶数，则结果应该是 1.24\\times 10^5；\n若采用 3 位保留位，则结果是 1.24000\\times 10^5 + 0.00504\\times 10^5 = 1.24504 \\times 10^5，这个结果就不在 1.24\\times 10^5 和 1.25\\times 10^5 的中间，而更接近于 1.25\\times 10^5，采用就近舍入方式，则结果应该是 1.25\\times 10^5。\n\n\n\n正向舍入\n朝数轴 +\\infty 方向舍入，即取右边最近的可表示数。\n\n\n负向舍入\n朝数轴 -\\infty 方向舍入，即取左边最近的可表示数。\n\n\n截断法\n直接截取所需位数，丢弃后面的所有位，这种舍入处理最简单。对正数或负数来说，都是取更接近原点的那个可表示数，是一种趋向原点的舍入。\n\n\n溢出判断\n判断规格化后的阶码是否超出所能表示的范围。\n若一个正指数超过了最大允许值（127 或 1023），则发生指数上溢，产生异常。若一个负指数超过了最小允许值（-149 或-1074），则发生指数下溢，通常把结果按机器零处理。\n\n\n右规和尾数舍入\n数值很大的尾数舍入时，可能因为末位加 1 而发生尾数溢出，此时需要通过右规来调整尾数和阶码。\n右规时阶码加 1，导致阶码增大，因此需要判断是否发生了指数上溢。\n\n\n左规\n左规时阶码减 1，导致阶码减小，因此需要判断是否发生了指数下溢。\n其判断规则与指数上溢类似，左规一次，阶码减 1，然后判断阶码是否为全 0 来确定指数是否下溢。\n\n\n由此可见，浮点数的溢出并不是以尾数溢出来判断的，尾数溢出可以通过右规操作得到纠正。运算结果是否溢出主要看结果的指数是否发生了上溢，因此是由指数上溢来判断的。\n\n\n                  \n                  Note\n                  \n                \n\n某些题目中可能会指定尾数或阶码采用补码表示。\n通常可以采用双符号位，当尾数求和结果溢出（如尾数为 10.xxx 或 01.xxx）时，需右规一次；当结果出现 00.0xxx 或 11.1xxx 时，需要左规，直到尾数变为 00.1xxx 或 11.0×××。\n\n\nC 语言中的浮点数类型\nC 语言中的 float 型和 double 型分别对应于 IEEE754 单精度浮点数和双精度浮点数。long double 型对应于扩展双精度浮点数，但 long double 型的长度和格式随编译器和处理器类型的不同而有所不同。\n在 C 程序中，等式的赋值和判断会导致强制类型转换，以 char→int→long→double 和 float→double 最为常见，从前到后范围和精度都从小到大，转换过程没有损失。\n不同类型数的混合运算时，遵循的原则是“类型提升”，即较低类型转换为较高类型。例如：\n\nlong 型与 int 型一起运算时，需先将 int 型转换为 long 型，然后进行运算，结果为 long 型。\nfloat 型和 double 型一起运算，虽然两者同为浮点型，但精度不同，则仍需先将 float 型转换为 double 型后再进行运算，结果亦为 double 型。\n\n所有这些转换都是系统自动进行的，这种转换称为隐式类型转换。\n\n\n\n                  \n                  Tip\n                  \n                \n\n\nint 型转换为 float 型时，虽然不会发生溢出，但 float 型尾数连隐藏位共 24 位，当 int 型数的第 24 ～ 31 位非 0 时，无法精确转换成 24 位浮点数的尾数，需舍入处理，影响精度。\nint 型或 float 型转换为 double 型时，因 double 型的有效位数更多，因此能保留精确值。\ndouble 型转换为 float 型时，因 float 型的表示范围更小，因此大数转换时可能会发生溢出。此外，由于尾数有效位数变少，因此高精度数转换时会发生舍入。\nfloat 型或 double 型转换为 int 型时，因 int 型没有小数部分，因此数据会向 0 方向截断（仅保留整数部分），发生舍入。另外，因 int 型的表示范围更小，因此大数转换时可能会溢出。\n\n\n\n数据的存储和排列\n大小端模式\n在存储数据时，数据从低位到高位可以按从左到右排列，也可以按从右到左排列。因此，无法用最左或最右来表征数据的最高位或最低位，通常用最低有效字节(LSB) 和 最高有效字节(MSB) 来分别表示数据的低位和高位。\n\n\n\n                  \n                  Tip\n                  \n                \n\n大端：低位放大地址\n小端：低位放小地址\n\n\n边界对齐\n现代计算机都是按字节编址的，假设字长为 32 位，数据按边界对齐方式存放要求其存储地址是自身大小的整数倍，半字地址一定是 2 的整数倍，字地址一定是 4 的整数倍，这样无论所取的数据是字节、半字还是字，均可一次访存取出。\n当所存数据不满足上述要求时，可通过填充空白字节使其符合要求。这样做虽然会浪费一些存储空间，但可以提高存取数据的速度。\n当数据不按边界对齐方式存储时，半字长或字长的数据可能在两个存储字中，此时需要两次访存，并对高低字节的位置进行调整后才能得到所需数据，从而影响了系统的效率。\n\n结构体的小端、边界对齐存储\n在 C 语言的 struct 类型中，“边界对齐”有两个重要要求：\n\n每个成员按其类型的大小对齐，char 型的对齐值为 1，short 型的对齐值为 2，int 型的对齐值为 4，单位为字节；\nstruct 的长度必须是成员中最大对齐值的整数倍（不够就补空字节）。\n\n这样就能保证 struct 数组的每项都满足边界对齐的条件。\n\n之所以出现上面的结果，是因为编译器要使结构体成员在空间上对齐必须满足：\n\n每个成员存储的“起始地址%该成员的长度 = 0”，而结构体中的成员都是按定义的先后顺序排放的。\n结构体的长度也必须是最大成员长度的整数倍，即结构体也要对齐排放。\n\n\n边界对齐方式相对边界不对齐方式是一种空间换时间的思想。精简指令系统计算机 RISC 通常采用边界对齐方式，因为边界对齐方式取指令时间相同，因此能适应指令流水。"},"计算机基础/计算机组成原理/3_存储系统":{"title":"存储系统","links":["计算机基础/计算机操作系统/5_输入输出管理","计算机基础/计算机操作系统/3_内存管理"],"tags":["计算机组成原理"],"content":"存储器概述\n分类\n按在计算机中的作用(层次)分类\n\n\n主存储器\n简称主存，也称内存储器（内存），用来存放计算机运行期间所需的程序和数据，CPU 可以直接随机地对其进行访问，也可以和高速缓冲存储器（Cache）及辅助存储器交换数据。\n特点是容量较小、存取速度较快、每位的价格较高。\n\n\n辅助存储器\n简称辅存，也称外存储器或外存，用来存放当前暂时不用的程序和数据，以及一些需要永久性保存的信息。辅存的内容需要调入主存后才能被 CPU 访问。\n特点是容量大、存取速度较慢、单位成本低。\n\n\n高速缓冲存储器\n简称 Cache，位于主存和 CPU 之间，用来存放当前 CPU 经常使用的指令和数据，以便 CPU 能高速地访问它们。Cache 的存取速度可与 CPU 的速度相匹配，但存储容量小、价格高。现代计算机通常将它们制作在 CPU 中。\n\n\n按存储介质分类\n按存储介质，存储器可分为\n\n磁表面存储器（磁盘、磁带）；\n磁芯存储器；\n半导体存储器（MOS 型存储器、双极型存储器）；\n光存储器（光盘）；\n\n\n按存取方式分类\n\n\n随机存储器(RAM)\n存储器的任何一个存储单元都可以随机存取，而且存取时间与存储单元的物理位置无关。\n其优点是读/写方便、使用灵活，主要用作主存或高速缓冲存储器。\nRAM 又分为静态 RAM 和动态 RAM。\n\n\n只读存储器(ROM)\n存储器的内容只能随机读出而不能写入。信息一旦写入存储器就固定不变，即使断电，内容也不会丢失。\n因此，通常用它存放固定不变的程序、常数和汉字字库等。它与随机存储器可共同作为主存的一部分，统一构成主存的地址域。\n由 ROM 派生出的存储器也包含可反复重写的类型，ROM 和 RAM 的存取方式均为随机存取。\n广义上的只读存储器已可通过电擦除等方式进行写入，其“只读”的概念没有保留，但仍保留了断电内容保留、随机读取特性，但其写入速度比读取速度慢得多。\n\n\n串行访问存储器\n对存储单元进行读/写操作时，需按其物理位置的先后顺序寻址，包括顺序存取存储器（如磁带）和直接存取存储器（如磁盘、光盘）。\n\n顺序存取存储器的内容只能按某种顺序存取，存取时间的长短与信息在存储体上的物理位置有关，其特点是存取速度慢。\n直接存取存储器既不像 RAM 那样随机地访问任何一个存储单元，又不像顺序存取存储器那样完全按顺序存取，而是介于两者之间。存取信息时通常先寻找整个存储器中的某个小区域（如磁盘上的磁道)，再在小区域内顺序查找。\n\n\n\n\n\n                  \n                  Note\n                  \n                \n\n相联存储器是按内容或地址进行寻址的，价格较为昂贵。一般用来制作 TLB(快表)、相联 Cache 等。\n相联存储器的基本原理是把存储单元所存内容的某一部分作为检索项（即关键字项）去检索该存储器，并将存储器中与该检索项符合的存储单元内容进行读出或写入。\n\n\n\n\n按信息的可保存性分类\n\n具有破坏性读出性能的存储器，每次读出操作后，必须紧接一个再生的操作，以便恢复被破坏的信息。\n性能指标\n存储器有三个主要性能指标，即存储容量、单位成本和存储速度。这三个指标相互制约，设计存储器系统所追求的目标就是大容量、低成本和高速度。\n存储字数表示存储器的地址空间大小，字长表示一次存取操作的数据量。\n\n存取时间不等于存取周期，通常存取周期大于存取时间。\n这是因为对任何一种存储器，在读/写操作之后，总要有一段恢复内部状态的复原时间。对于破坏性读出的存储器，存取周期往往比存取时间大得多，因为存储器中的信息读出后需要马上进行再生。\n多层次存储系统\n为了解决存储系统大容量、高速度和低成本这三个相互制约的矛盾，在计算机系统中，通常采用多级存储器结构。\n存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。当 CPU 要从存储器中存取数据时，先访问 Cache，若不在 Cache 中，则访问主存，若不在主存中，则访问磁盘，此时，操作数从磁盘读出送到主存，然后从主存送到 Cache。\n\nCache—主存层：主要解决 CPU 和主存速度不匹配的问题，主存和 Cache 之间的数据调动是由硬件自动完成的，对所有程序员均是透明的。\n主存—辅存层：主要解决存储系统的容量问题，主存和辅存之间的数据调动是由硬件和操作系统共同完成的，对应用程序员是透明的。\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n在 Cache—主存层和主存—辅存层中，上一层中的内容都只是下一层中的内容的副本，也即 Cache（或主存）中的内容只是主存（或辅存）中的内容的一部分。\n\n\n主存储器\n存储器芯片内部结构\n\n\n存储体（存储矩阵）\n存储单元的集合，它由行选择线和列选择线来选择所访问单元，存储体的相同行、列上的多位（位平面数）同时被读出或写入。\n\n\n地址译码器\n将地址转换为译码输出线上的高电平，以便驱动相应的读/写电路。地址译码有单译码法（一维译码）和双译码法（二维译码）两种方式。\n\n单译码法：只有一个行译码器，同一行中所有存储单元的字线连在一起，同一行中的各单元构成一个字，被同时读出或写入。缺点是地址译码器的输出线数过多。\n双译码法：地址译码器分为 X 和 Y 方向两个译码器，在选中的行和列交叉点上能确定一个存储单元，这是 DRAM 芯片目前普遍采用的译码结构。\n\n\n\n\nI/O 控制电路\n控制被选中的单元的读出或写入，具有放大信息的作用。\n\n\n片选控制信号\n单个芯片容量太小，往往满足不了计算机对存储器容量的要求，因此需用一定数量的芯片进行存储器的扩展。在访问某个字时，必须“选中”该存储字所在的芯片，而其他芯片不被“选中”，因此需要有片选控制信号。\n\n\n读/写控制信号\n根据 CPU 给出的读命令或写命令，控制被选中单元进行读或写。\n\n\n\n\n\n\n\n随机存储器(RAM)\nRAM 分为 静态随机存储器(Static Random Access Memory, SRAM)和动态随机存储器(Dynamic Random Access Memory, DRAM)。\n主存储器主要由 DRAM 实现，靠近处理器的那一层(Cache)则由 SRAM 实现，它们都是易失性存储器。\nSRAM 工作原理\n通常把存放一个二进制位的物理器件称为存储元，它是存储器的最基本的构件。地址码相同的多个存储元构成一个存储单元。若干存储单元的集合构成存储体。\n静态随机存储器的存储元是用双稳态触发器（六晶体管 MOS）来记忆信息的，静态是指即使信息被读出后，它仍保持其原状态而不需要再生（非破坏性读出）。\nSRAM 的 存取速度快，但集成度低，功耗较大，价格昂贵，一般用于高速缓冲存储器。\n\nDRAM 工作原理\n与 SRAM 的存储原理不同，动态随机存储器是利用存储元电路中栅极电容上的电荷来存储信息的，DRAM 的基本存储元通常只使用一个晶体管，所以它比 SRAM 的密度要高很多。\n相对于 SRAM 来说，DRAM 具有集成度高、位价低和功耗低等优点，但 DRAM 的存取速度比 SRAM 慢，且必须定时刷新和读后再生，一般用于大容量的主存系统。\n\nDRAM 刷新\n\nDRAM 电容上的电荷一般只能维持 1 ～ 2ms，因此即使电源不断电，信息也会自动消失。此外，读操作会使其状态发生改变（破坏性读出），需读后再生，这也是称其为动态存储器的原因。刷新可以采用读出的方法进行，根据读出内容对相应单元进行重写，即读后再生。对同一行进行相邻两次刷新的时间间隔称为刷新周期，通常取 2ms。\n\n刷新简单来说就是重新给 DRAM 的电容充电。\n\n常用的刷新方式有以下 3 种：\n\n\n分散刷新\n将一个存储器系统的工作周期分为两部分：前半部分用于正常的读/写操作；后半部分用于刷新。\n这种刷新方式增加了系统的存取周期，如存储芯片的存取周期为 0.5us，则系统的存取周期为 1us。\n优点是没有死区；缺点是加长了系统的存取周期。\n\n\n集中刷新\n在一个刷新周期内，利用一段固定的时间，依次对存储器的所有行进行逐一再生，在此期间停止对存储器的读/写操作，称为死时间，也称访存死区。\n优点是读/写操作时不受刷新工作的影响；缺点是在集中刷新期间（死区）不能访问存储器。\n\n\n异步刷新\n结合了前两种方法，使得在一个刷新周期内每一行仅刷新一次。\n具体做法是将刷新周期除以行数，得到相邻两行之间刷新的时间间隔 t，每隔时间 t 产生一次刷新请求。这样就使“死时间”的分布更加分散，避免让 CPU 连续等待过长的时间。\n\n\n\nDRAM 的刷新需要注意以下问题：\n\n刷新对 CPU 是透明的，即刷新不依赖于外部的访问；\nDRAM 的刷新单位是行，由芯片内部自行生成行地址；\n刷新操作类似于读操作，但又有所不同；\n刷新时不需要选片，即整个存储器中的所有芯片同时被刷新；\n\n\n\n                  \n                  Tip\n                  \n                \n\n虽然 DRAM 的刷新和再生都是恢复数据，但刷新与再生的过程并不完全相同。刷新是以行为单位，逐行恢复数据的，而再生仅需恢复被读出的那些单元的数据。\n\n\nDRAM 芯片地址引脚复用\nDRAM 芯片容量较大，地址位数较多，为了减少芯片的地址引脚数，通常采用地址引脚复用技术，行地址和列地址通过相同的引脚分先后两次输入，这样地址引脚数可减少一半。\n\nDRAM 行列数优化原则\n假定有一个 2^n \\times b 位 DRAM 芯片的存储阵列，其行数为 r，列数为 c，则 2^n = r\\times c。存储阵列的地址位数为 n，其中行地址位数为 \\log_2{r}，列地址位数为 \\log_2{c}，则 n=\\log_2{r} + \\log_2{c}。\n由于 DRAM 芯片采用地址引脚复用技术，为减少地址引脚数，应尽量使行、列位数相同，即满足 \\left | r-c \\right | 最小。又由于 DRAM 按行刷新，为减少刷新开销，应使行数较少，因此还需满足 r\\leqslant c。\nDRAM 芯片读写周期\nDRAM 芯片读/写周期的时序图如下图所示。为了使芯片能正确接收行、列地址并实现读/写操作，各信号的时间关系应符合一定要求。读（写）周期时间 tRC（tWC）表示 DRAM 芯片进行两次连续读（写）操作时所必须间隔的时间。\n在读周期中，在 \\overline{RAS} 有效前将行地址送到芯片的地址引脚，\\overline{CAS} 滞后 \\overline{RAS} 一段时间，在 \\overline{CAS} 有效前再将列地址送到芯片的地址引脚，\\overline{RAS}、\\overline{CAS} 应分别至少保持 tRAS 和 tCAS 的时间。在读周期中 \\overline{WE} 为高电平，并在 \\overline{CAS} 有效前建立。\n在写周期中，行列选通信号的时序关系和读周期相同。在写周期中 \\overline{WE} 为低电平，同样在 \\overline{CAS} 有效前建立。为了保证数据可靠地写入，写数据必须在 \\overline{CAS}​ 有效前在数据总线上保持稳定。\n\nSRAM 和 DRAM 的比较\n\nSDRAM\n目前更常用的是 SDRAM（同步 DRAM） 芯片，其工作方式与传统 DRAM 的不同，传统 DRAM 与 CPU 采用异步方式交换数据，CPU 发出地址和控制信号后，经过一段延迟时间，数据才读出或写入，在读/写完成之前，CPU 不能做其他工作。而 SDRAM 与 CPU 采用同步方式交换数据，它将 CPU 发出的地址和控制信号锁存起来，CPU 在其读/写完成之前可进行其他操作。\nSDRAM 的每一步操作都在系统时钟的控制下进行，支持突发传输方式。第一次存取时给出首地址，同一行的所有数据都被送到行缓冲器，因此，以后每个时钟都可以连续地从 SDRAM 输出一个数据。\n行缓冲器通常用 SRAM 实现，用来缓存指定行中整行的数据，其大小为“列数 \\times 位平面数”。\n只读存储器(ROM)\n\nRead Only Memory\n\nROM 具有两个显著的优点：\n\n结构简单，所以位密度比可读/写存储器的高。\n具有非易失性，所以可靠性高。\n\n\n\n\n主存储器的基本组成\n下图是主存储器(MainMemory，MM)的基本框图，其中由一个个存储 0 或 1 的记忆单元（也称存储元件）构成的存储矩阵（也称存储体）是存储器的核心部件。存储元件是具有两种稳态的能表示二进制 0 和 1 的物理器件。\n为了存取存储体中的信息，必须对存储单元编号（也称编址）。编址单位是指具有相同地址的那些存储元件构成的一个单位，可以按字节编址，也可以按字编址。现代计算机通常采用字节编址方式，此时存储体内的一个地址中有 1 字节。\n\n指令执行过程中需要访问主存时，CPU 首先把被访问单元的地址送到 MAR 中，然后通过地址线将主存地址送到主存中的地址寄存器，以便地址译码器进行译码，选中相应单元，同时 CPU 将读/写信号通过控制线送到主存的读/写控制电路。\n若是写操作，则 CPU 同时将要写的信息送到 MDR 中，在读/写控制电路的控制下，经数据线将信号写入选中的单元；\n若是读操作，则主存读出选中单元的内容送至数据线，然后被送到 MDR 中。\nMDR 的位数与数据线的位数相同，MAR 的位数与地址线的位数相同。上图采用 64 位数据线，所以在按字节编址方式下，每次最多可以存取 8 个单元的内容。地址线的位数决定了主存地址空间的最大可寻址范围。\n\n\n                  \n                  Tip\n                  \n                \n\n数据线的位数通常等于存储字长，因此 MDR 的位数通常等于存储字长；若数据线的位数不等于存储字长，则 MDR 的位数由数据线的位数决定。\n\n\n多模块存储器\n多模块存储器是一种空间并行技术，利用多个结构完全相同的存储模块的并行工作来提高存储器的吞吐率。常用的有单体多字存储器和多体低位交叉存储器。\n\n\n\n                  \n                  Note\n                  \n                \n\nCPU 的速度比存储器快得多，若同时从存储器中取出 n 条指令，就可以充分利用 CPU 资源，提高运行速度。多体交叉存储器就是基于这种思想提出的。\n\n\n单体多字存储器\n在单体多字系统中，每个存储单元存储 m 个字，总线宽度也为 m 个字，一次并行读出 m 个字。\n在一个存取周期内，从同一地址取出 m 条指令，然后将指令逐条送至 CPU 执行，即每隔 1/m 存取周期，CPU 向主存取一条指令。这显然提高了单体存储器的工作速度。\n缺点：只有指令和数据在主存中连续存放时，这种方法才能有效提升存取速度。一旦遇到转移指令，或操作数不能连续存放时，这种方法的提升效果就不明显。\n多体并行存储器\n多体并行存储器由多体模块组成。每个模块都有相同的容量和存取速度，各模块都有独立的读/写控制电路、地址寄存器和数据寄存器。它们既能并行工作，又能交叉工作。\n多体并行存储器分为**高位交叉编址（顺序方式）和低位交叉编址（交叉方式）**两种。\n\n\n\n                  \n                  Tip\n                  \n                \n\n模块内的地址是连续的，存取方式仍是串行存取，因此高位交叉编址的多体存储器仍是顺序存储器。\n\n\n交叉存储器可以采用轮流启动或同时启动两种方式。\n\n\n轮流启动\n若每个模块一次读/写的位数正好等于数据总线位数，模块的存取周期为 T，总线周期为 r，为实现轮流启动方式，存储器交叉模块数 m 应大于或等于 \\frac{T}{r}​\n若当前访存地址所在模块内的上一次存取周期还没有完成，则会发生访存冲突，此时需延迟发生冲突的访问请求。\n\n\n\n同时启动\n若所有模块一次并行读/写的总位数正好等于数据总线位数，则可以同时启动所有模块进行读/写。\n设每个模块一次读/写的位数为 16 位，模块数 m = 4，数据总线位数为 64 位，4 个模块一共提供 64 位，正好构成一个存储字，因此应该同时启动 4 个模块进行并行读/写。\n\n\n主存储器与 CPU 的连接\n连接原理\n\n主存储器通过数据总线、地址总线和控制总线与 CPU 连接。\n数据总线的位数与工作频率的乘积正比于数据传输速率。\n地址总线的位数决定了可寻址的最大内存空间。\n控制总线（读/写）指出总线周期的类型和本次输入/输出操作完成的时刻。\n\n\n主存容量扩展\n位扩展\n位扩展是指对字长进行扩展（增加存储字长）。当 CPU 的系统数据线数多于存储芯片的数据位数时，必须对存储芯片扩位，使其数据位数与 CPU 的数据线数相等。\n位扩展的连接方式：各芯片的地址线、片选线和读/写控制线与系统总线相应并联；各芯片的数据线单独引出，分别连接系统数据线。各芯片同时工作。\n\n\n字扩展\n字扩展是指对存储字的数量进行扩展，而存储字的位数满足系统要求。系统数据线位数等于芯片数据线位数，系统地址线位数多于芯片地址线位数。\n字扩展的连接方式：各芯片的地址线与系统地址线的低位对应相连；芯片的数据线和读/写控制线与系统总线相应并联；由系统地址线的高位译码得到各芯片的片选信号。各芯片分时工作。\nCPU 要实现对存储单元的访问，首先要选择存储芯片，即进行片选；然后在选定的芯片中选择具体的存储单元，以进行数据的读/写，即进行字选。芯片内的字选通常是由 CPU 送出的 N 条低位地址线完成（N 由片内存储容量 2^N^决定）。片选信号的产生方法分为线选法和译码片选法。\n\n线选法\n线选法用除片内寻址外的高位地址线直接连接至各个存储芯片的片选端，当某位地址线信息为“0”时，就选中与之对应的存储芯片。这些片选地址线每次寻址时只能有一位有效，不允许同时有多位有效，这样才能保证每次只选中一个芯片（或芯片组）。\n优点：不需要地址译码器，线路简单。\n缺点：地址空间不连续，选片的地址线必须分时为低电平（否则不能工作），不能充分利用系统的存储器空间，造成地址资源的浪费。\n\n译码片选法\n译码片选法用除片内寻址外的高位地址线通过地址译码器产生片选信号。\n\n\n\n字位同时扩展法\n字位同时扩展是前两种扩展的组合，这种方式既增加存储字的数量，又增加存储字长。\n字位同时扩展的连接方式：将进行位扩展的芯片作为一组，各组的连接方式与位扩展的相同；由系统地址线高位译码产生若干片选信号，分别接到各组芯片的片选信号。\n\n\n存储器与 CPU 的连接\n\n\n合理选择存储芯片\n要组成一个主存系统，选择存储芯片是第一步，主要指存储芯片的类型（RAM 或 ROM）和数量的选择。\n通常选用 ROM 存放系统程序、标准子程序和各类常数，RAM 则是为用户编程而设置的。\n此外，在考虑芯片数量时，要尽量使连线简单、方便。\n\n\n地址线的连接\n存储芯片的容量不同，其地址线数也不同，而 CPU 的地址线数往往比存储芯片的地址线数要多。\n通常将\n\nCPU 地址线的低位与存储芯片的地址线相连，以选择芯片中的某一单元（字选），这部分的译码是由芯片的片内逻辑完成 的。\nCPU 地址线的高位则在扩充存储芯片时使用，用来选择存储芯片（片选），这部分译码由外接译码器逻辑完成。\n\n\n\n数据线的连接\nCPU 的数据线数与存储芯片的数据线数不一定相等，在相等时可直接相连；在不等时必须对存储芯片扩位，使其数据位数与 CPU 的数据线数相等。\n\n\n读/写命令线的连接\nCPU 读/写命令线一般可直接与存储芯片的读/写控制端相连，通常高电平为读，低电平为写。\n有些 CPU 的读/写命令线是分开的（读为 \\overline{RD}，写为 \\overline{WE}，均为低电平有效)，此时 CPU 的读命令线应与芯片的允许读控制端相连，而 CPU 的写命令线则应与芯片的允许写控制端相连。\n\n\n片选线的连接\n片选线的连接是 CPU 与存储芯片连接的关键。\n存储器由许多存储芯片叠加而成，哪一片被选中完全取决于该存储芯片的片选控制端 \\overline{CS} 是否能接收到来自 CPU 的片选有效信号。\n片选有效信号与 CPU 的访存控制信号 \\overline{MREQ}（低电平有效）有关，因为只有当 CPU 要求访存时，才要求选中存储芯片。若 CPU 访问 IO，则 \\overline{MREQ}​ 为高，表示不要求存储器工作。\n\n\n\n外部存储器\n\n此部分内容在 输入输出管理 中详细介绍\n\n磁盘存储器\n磁盘存储器是以磁盘为存储介质的存储器。\n磁记录原理：磁头和磁性记录介质相对运动时，通过电磁转换完成读/写操作。\n磁记录方式：通常采用调频制(FM)和改进型调频制(MFM)的记录方式。\n编码方法：按某种方案（规律），把一连串的二进制信息变换成存储介质磁层中一个磁化翻转状态的序列，并使读/写控制电路容易、可靠地实现转换。\n\n\n\n磁盘驱动器：驱动磁盘转动并在盘面上通过磁头进行读/写操作的装置（不属于 I/O 接口）。\n磁盘控制器：磁盘驱动器与主机的接口，负责接收并解释 CPU 发来的命令，向磁盘驱动器发出各种控制信号，并负责检测磁盘驱动器的状态。\n\n\n磁道号（柱面号）；磁头号（盘面号）\n\n\n\n                  \n                  Note\n                  \n                \n\n磁盘高速缓存(DiskCache)：在内存中开辟一部分区域，用于缓冲将被送到磁盘上的数据。因为 CPU 中没有那么多通用寄存器用于存放交换的数据，且磁盘与通用寄存器的速度相差过大，因此磁盘存储器通常直接和主存交换信息。\n优点：写磁盘时是按“簇”进行的，可以避免频繁地用小块数据写盘；有些中间结果数据在写回磁盘之前可被快速地再次使用。\n\n\n磁盘存储器以成批（组）方式进行数据读/写。\n\n\n\n\n磁盘格式化\n磁盘存储数据之前需要进行格式化。\n在磁盘的格式化过程中，要对磁盘划分扇区，每个扇区要写入一些控制信息，扇区尾部还要留有一定的空隙，这些均需占用一些存储空间，因此导致格式化后的实际容量比非格式化的容量要小。\n磁盘阵列(RAID)\n\nRAID0 把连续多个数据块交替地存放在不同物理磁盘的扇区中，几个磁盘交叉并行读/写，即条带化技术，这样不仅扩大了存储容量，还提高了磁盘存取速度，但 RAID0 没有容错能力。\n为了提高可靠性，RAID1 使两个磁盘同时进行读/写，互为备份，若一个磁盘出现故障，可从另一磁盘中读出数据。两个磁盘当一个磁盘使用，意味着容量减少一半。\n\n\nRAID 将多个物理盘组成像单个逻辑盘，不会影响磁记录密度，也不可能提高磁盘利用率。\n固态硬盘\n\n固态硬盘（SSD）是一种基于闪存技术的存储器。它与 U 盘并无本质差别，只是容量更大，存取性能更好。\n一个 SSD 由一个或多个闪存芯片和闪存翻译层组成。\n闪存芯片替代传统旋转磁盘中的机械驱动器，而闪存翻译层将来自 CPU 的逻辑块读/写请求翻译成对底层物理设备的读/写控制信号，因此，这个闪存翻译层相当于代替了磁盘控制器的角色。\n\n\n在上图中，一个闪存由 B 块组成，每块由 P 页组成。通常，页的大小是 512B ～ 4KB，每块由 32 ～ 128 页组成，块的大小为 16KB ～ 512KB。\n数据的读/写是以页为单位，而擦除则以块为单位。只有在一页所属的块整个被擦除后，才能写这一页。不过，一旦一个块被擦除，块中的每个页就都可以直接再写一次。某个块进行了若干次重复写之后，就会磨损坏，不能再使用。\n随机写很慢有两个原因：\n\n擦除块较慢，通常比访问页高一个数量级。\n若写操作试图修改一个包含已有数据的页 P，则这个块中所有含有用数据的页都必须被复制到一个新（擦除过的）块中，然后才能进行对页 P 的写操作。\n\n比起传统磁盘，SSD 有很多优点，它由半导体存储器构成，没有移动的部件，因而随机访问时间比机械磁盘要快很多，也没有任何机械噪声和振动，能耗更低，抗震性好，安全性高等。\n\n固态硬盘也有缺点，闪存的擦写寿命是有限的。若直接用普通闪存组装 SSD，读/写数据时会集中在 SSD 的一部分闪存，这部分闪存的寿命会损耗得特别快。一旦这部分闪存损坏，整块 SSD 也就损坏了。\nSSD 磨损均衡技术大致分为两种：\n\n动态磨损均衡：写入数据时，自动选择较新的闪存块。\n静态磨损均衡：这种技术更为先进，就算没有数据写入，SSD 也会监测并自动进行数据分配，让老的闪存块承担无须写数据的存储任务，同时让较新的闪存块腾出空间，平常的读/写操作在较新的闪存块中进行。\n\n高速缓冲存储器\n高速缓存 Cache 拥有比主存更快的速度，因此在 CPU 和主存之间设置 Cache 可以显著提高存储系统的效率。Cache 由 SRAM 组成，通常直接集成在 CPU 中。\n\n\n程序访问的局部性原理\n程序访问的局部性原理包括时间局部性和空间局部性。\n\n时间局部性：指最近的未来要用到的信息，很可能是现在正在使用的信息，因为程序中存在循环和需要多次重复执行的子程序段，以及对数组的存储和访问操作。\n空间局部性：指最近的未来要用到的信息，很可能与现在正在使用的信息在存储空间上是邻近的，因为指令通常是顺序存放、顺序执行的，数据一般也是以向量、数组等形式簇聚地存储的。\n\n高速缓冲技术就是利用局部性原理，把程序中正在使用的部分数据存放在一个高速的、容量较小的 Cache 中，使 CPU 的访存操作大多数针对 Cache 进行，从而提高程序的执行速度。\n\n工作原理\n为便于 Cache 与主存交换信息，Cache 和主存都被划分为大小相等的块，Cache 块也称 Cache 行，每块由若干字节组成，块的长度称为块长（也称行长）。\n因为 Cache 的容量远小于主存的容量，所以 Cache 中的块数要远少于主存中的块数，Cache 中仅保存主存中最活跃的若干块的副本。因此，可按照某种策略预测 CPU 在未来一段时间内欲访存的数据，将其装入 Cache。\n\n\n                  \n                  Tip\n                  \n                \n\n\n主存块太小，不能很好地利用空间局部性，从而导致 缺失率变高；\n主存块太大 会使得 Cache 行数变少，即 Cache 中可以存放主存块的位置变少，从而也会 降低命中率。\n\n因此，主存块大小应该适中，既不能太大，又不能太小，通常为几十字节到上百字节。\n\n\n\n\n当 CPU 发出读请求时，要到 Cache 中查看该主存地址是否在 Cache 中\n\n若访存地址在 Cache 中命中，就将此地址转换成 Cache 地址，直接对 Cache 进行读操作，与主存无关；\n若访存地址在 Cache 不命中，则仍需访问主存，并把此字所在的块一次性地从主存调入 Cache。若此时 Cache 已满，则需根据某种替换算法，用这个块替换 Cache 中原来的某块信息。整个过程全部由硬件实现。\n\n\n\n                  \n                  Tip\n                  \n                \n\nCPU 与 Cache 之间的数据交换以字为单位，而 Cache 与主存之间的数据交换则以 Cache 块为单位。\n\n\n当 CPU 发出写请求时，若 Cache 命中，有可能会遇到 Cache 与主存中的内容不一致的问题。因此若 Cache 命中，需要按照一定的写策略处理。\nCache 命中率\n\n\nCache 行的长度较大时，能充分利用程序访问的空间局部性，使一个较大的局部空间被一起调到 Cache 中，因而可以增加命中机会。但是，行长也不能太大，因为若未命中，则需花更多时间从主存读块。而且行长太大，Cache 项数变少，因而命中的可能性变小。\nCache 行的长度较小时，命中率会很低，但好处是存取块的代价较小。\nCache 和主存的映射方式\n由于 Cache 行数比主存块数少得多，因此主存中只有一部分块的信息可放在 Cache 中，因此在 Cache 中要为每块加一个标记位，指明它是主存中哪一块的副本。该标记的内容相当于主存中块的编号。为了说明 Cache 行中的信息是否有效，每个 Cache 行需要一个有效位。\nCache 行中的信息是主存中某个块的副本，地址映射是指把主存地址空间映射到 Cache 地址空间，即把存放在主存中的信息按照某种规则装入 Cache。\nCache 地址空间和主存地址空间相互独立，通过地址映射把主存地址空间映射到 Cache 地址空间。\n三种映射方式中，\n\n直接映射的每个主存块只能映射到 Cache 中的某一固定行；\n全相联映射可以映射到所有 Cache 行；\nN 路组相联映射可以映射到 N 行；\n\n当 Cache 大小、主存块大小一定时，\n\n直接映射的命中率最低，全相联映射的命中率最高。\n直接映射的判断开销最小、所需时间最短，全相联映射的判断开销最大、所需时间最长。\n直接映射标记所占的额外空间开销最少，全相联映射标记所占的额外空间开销最大。\n\n\n全相联映射\n主存中的每一块可以装入 Cache 中的任何位置，每行的标记用于指出该行来自主存的哪一块，因此 CPU 访存时需要与所有 Cache 行的标记进行比较。\n优点：Cache 块的冲突概率低，只要有空闲 Cache 行，就不会发生冲突；空间利用率高；命中率高；\n缺点：标记的比较速度较慢；实现成本较高，通常需采用按内容寻址的相联存储器。\n\n通常为每个 Cache 行都设置一个比较器，比较器位数等于标记字段的位数。\n访存时根据标记字段的内容来访问 Cache 行中的主存块，因而 其查找过程是一种“按内容访问”的存取方式，所以是一种“相联存储器”。这种方式的时间开销和硬件开销都较大，不适合大容量 Cache。\n\n\n                  \n                  Tip\n                  \n                \n\n[主存-外存]通常采用的是全相联映射，因为访问外存的代价很大，提高命中率才是关键。\n\n\n直接映射\n主存中的每一块只能装入 Cache 中的唯一位置。若这个位置已有内容，则产生块冲突，原来的块将无条件地被替换出去（无须使用替换算法）。\n直接映射实现简单，但不够灵活，即使 Cache 的其他许多地址空着也不能占用，这使得直接映射的块冲突概率最高，空间利用率最低。\n\n\n\n组相联映射\n将 Cache 分成 Q 个大小相等的组，每个主存块可以装入固定组中的任意一行，即组间采用直接映射、而组内采用全相联映射的方式。\n它是对直接映射和全相联映射的一种折中，当 Q=1 时变为全相联映射，当 Q=Cache​​ 行数时变为直接映射。\n路数越大，即每组 Cache 行的数量越大，发生块冲突的概率越低，但相联比较电路也越复杂。选定适当的数量，可使组相联映射的成本接近直接映射，而性能上仍接近全相联映射。\n若每组有 r 个 Cache 行，则称为 r 路组相联。\n\n\n直接映射因为每块只能映射到唯一的 Cache 行，因此只需设置 1 个比较器。而 r 路组相联映射需要在对应分组中与 r 个 Cache 行进行比较，因此需设置 r 个比较器。\nCache 容量计算\n每个  Cache 行对应一个标记项（包括有效位、脏位、替换算法位、标记位）。\n\n\n\n                  \n                  Tip\n                  \n                \n\n\n使用组相联映射时替换位为 \\log_2(\\text{路数})\n使用全相联映射时替换位为 \\log_2(\\text{行数})\n\n\n\n\n\n                  \n                  Note\n                  \n                \n\n在组相联中，将每组各行的标记项排成一行，将各组从上到下排列，构成一个二维的标记阵列。查找 Cache 时就是查找标记阵列的标记项是否符合要求。\n\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n\n如果题目说明不考虑一致性维护，意思是不考虑脏位。\n如果题目说明考虑一致性维护但使用的是直写法，意思考虑脏位但脏位的大小是 0bit，等同于不考虑脏位。\n如果题目说明使用的是直接映射方式，意思是不考虑替换算法位，因为直接映射方式无须使用替换算法。\n如何题目说明在替换 Cache 块时使用随机替换算法，意思是不考虑替换算法位，因为随机替换不需要替换算法位。\n\n\n\n\n\nCache 替换算法\n在采用全相联映射或组相联映射方式时，从主存向 Cache 传送一个新块，当 Cache 或 Cache 组中的空间已被占满时，就需要使用替换算法置换 Cache 行。\n而采用直接映射时，一个给定的主存块只能放到唯一的固定 Cache 行中，所以在对应 Cache 行已有一个主存块的情况下，新的主存块毫无选择地把原先已有的那个主存块替换掉，因而无须考虑替换算法。\n\n随机算法(RAND)\n\n先进先出算法(FIFO)\n\n近期最少使用算法(LRU)\n\n最不经常使用算法(LFU)\n\nCache 的一致性问题\n因为 Cache 中的内容是主存块副本，当对 Cache 中的内容进行更新时，就需选用写操作策略使 Cache 内容和主存内容保持一致。此时分两种情况。\n写命中\n对于 Cache 写操作命中，有两种处理方法：\n\n\n回写法(write-back)\n当 CPU 对 Cache 写命中时，只把数据写入 Cache，而不立即写入主存，只有当此块被替换出时才写回主存。这种方法减少了访存次数，但存在数据不一致的隐患。\n为了减少写回主存的次数，给每个 Cache 行设置一个修改位（脏位）。\n\n若修改位为 1，则说明对应 Cache 行中的块被修改过，替换时须写回主存。\n若修改位为 0，则说明对应 Cache 行中的块未被修改过，替换时无须写回主存。\n\n\n\n\n全写法（直写法、write-through）\n当 CPU 对 Cache 写命中时，必须把数据同时写入 Cache 和主存。当某一块需要替换时，就不必把这一块写回主存了，用新调入的块直接覆盖即可。\n\n\n优点：这种方法实现简单，能随时保持主存数据的正确性。\n缺点：增加了访存次数，降低了 Cache 的效率。\n\n写缓冲：为减少全写法直接写入主存的时间损耗，在 Cache 和主存之间加一个写缓冲。CPU 同时写数据到 Cache 和写缓冲中，写缓冲再将内容写入主存。写缓冲是一个 FIFO 队列，写缓冲可以解决速度不匹配的问题。但若出现频繁写时，会使写缓冲饱和溢出。\n\n\n\n\n写不命中\n对于 Cache 写操作不命中，有两种处理方法：\n\n\n写分配法(write-allocate)\n更新主存单元，然后把这个主存块调入 Cache。它试图利用程序的空间局部性，缺点是每次写不命中都要从主存读一个块到 Cache 中。\n\n\n\n非写分配法(not-write-allocate)\n只更新主存单元，而不把主存块调入 Cache。\n\n\n\n非写分配法通常与全写法合用，写分配法通常和回写法合用。\n多级 Cache\n随着指令流水技术的发展，需要将指令 Cache 和数据 Cache 分开设计，这就有了分离的 Cache 结构。\n统一 Cache 的优点是设计和实现相对简单，但由于执行部件存取数据时，指令预取部件要从同一 Cache 读指令，因此会引发冲突。采用分离的 Cache 结构可以解决这个问题，而且分离的指令和数据 Cache 还可以充分利用指令和数据的不同局部性来优化性能。\n现代计算机的 Cache 通常设立多级 Cache，假定设 2 级 Cache，按离 CPU 的远近可各自命名为 L1Cache、L2Cache，离 CPU 越远，访问速度越慢，容量越大。\n\n虚拟存储器\n主存和辅存共同构成了虚拟存储器，二者在硬件和系统软件的共同管理下工作。\n对于应用程序员而言，虚拟存储器是透明的。虚拟存储器具有主存的速度和辅存的容量。\n\n结合 内存分配与回收 阅读\n\n概念\n虚拟存储器将主存或辅存的地址空间统一编址，形成一个庞大的地址空间，在这个空间内，用户可以自由编程，而不必在乎实际的主存容量和程序在主存中实际的存放位置。\n用户编程允许涉及的地址称为虚地址或逻辑地址，虚地址对应的存储空间称为虚拟空间或程序空间。由于虚拟存储器的实际容量小于或等于主存和辅存的容量之和，因此逻辑地址的位数比物理地址的位数多。\n实际的主存单元地址称为实地址或物理地址，实地址对应的是主存地址空间，也称实地址空间。\n\n\n                  \n                  Tip\n                  \n                \n\n虚拟存储系统利用的是局部性原理，程序应当具有较好的局部。\n\n\n虚地址比实地址要大很多。\n\nCPU 使用虚地址时，先判断这个虚地址对应的内容是否已装入主存。\n\n若已在主存中，则通过地址变换，CPU 可直接访问主存指示的实际单元；\n若不在主存中，则把包含这个字的一页或一段调入主存后再由 CPU 访问。若主存已满，则采用替换算法置换主存中的交换块（页面）。\n\n虚拟存储器只能采用回写法：虚拟存储器也采用和 Cache 类似的技术，将辅存中经常访问的数据副本存放到主存中。但是缺页（或段）而访问辅存的代价很大，提高命中率是关键，因此虚拟存储机制采用全相联映射，每个虚页面可以存放到对应主存区域的任何一个空闲页位置。\n此外，当进行写操作时，不能每次写操作都同时写回磁盘，因而在处理一致性问题时，采用回写法。\n页式虚拟存储器\n\n\n优点：页面的长度固定，页表简单，调入方便。\n缺点：因为程序不可能正好是页面的整数倍，最后一页的零头将无法利用而造成浪费，并且页不是逻辑上独立的实体，所以处理、保护和共享都不及段式虚拟存储器方便。\n页表\n系统中每个进程有一个页表，页表中每个表项与一个虚页对应。\n\n有效位：也称装入位，用来表示对应页面是否在主存。\n\n若为 1，则表示该虚拟页已从外存调入主存，此时页表项存放该页的物理页号。\n若为 0，则表示没有调入主存，此时页表项可以存放该页的磁盘地址。\n\n\n脏位：也称修改位，用来表示页面是否被修改过，虚存机制中采用回写策略，利用脏位可判断替换时是否需要写回磁盘。\n引用位：也称使用位，用来配合替换策略 进行设置。\n\n\n缺页处理\n缺页是 CPU 在执行指令过程中进行取指令或读/写数据时发生的一种故障，属于内部异常。\n若页表项中的有效位为 0，则发生“缺页”异常，需要调用操作系统的缺页异常处理程序。\n缺页处理程序根据对应表项中的存放位置字段，将所缺页面从磁盘调入一个空闲的物理页框。若主存中没有空闲页框，还需要选择一个页面替换。在替换时还需要根据脏位确定是否要写回磁盘。缺页处理过程中需要对页表进行相应的更新。\n缺页处理完后要重新执行引起缺页发生的指令。\n地址转换\n在虚拟存储系统中，指令给出的地址是虚拟地址，因此当 CPU 执行指令时，要先将虚拟地址转换为主存物理地址，才能到主存中存取指令和数据。这个地址转换由操作系统来完成，但需要一部分硬件基础的支持，如快表、地址映射系统等。\n虚拟地址分为两个字段：高位为虚页号，低位为页内偏移地址。\n物理地址也分为两个字段：高位为物理页号，低位为页内偏移地址。\n由于两者的页面大小相同，因此页内偏移地址是相等的。虚拟地址到物理地址的转换是由页表实现的，页表是一张存放在主存中的虚页号和实页号的对照表。\n\n每个进程都有一个页表基址寄存器，存放该进程的页表首地址，据此找到对应的页表首地址，然后根据虚拟地址高位的虚拟页号找到对应的页表项，\n\n\n若装入位为 1，则取出物理页号，和虚拟地址低位的页内地址拼接，形成实际物理地址。\n\n\n若装入位为 0，说明缺页，需要操作系统进行缺页处理。\n\n\n\n\n快表(TLB)\n依据程序访问的局部性原理，在一段时间内总是经常访问某些页时，若把这些页对应的页表项存放在高速缓冲器组成的快表(TLB) 中，则可以明显提高效率。\n相应地把放在主存中的页表称为慢表(Page)。在地址转换时，首先查找快表，若命中，则无须访问主存中的页表。\n\n\n                  \n                  Tip\n                  \n                \n\n快表采用高速相联存储器，它的速度快来源于硬件本身，而不是依赖搜索算法来查找的；\n慢表存储在内存中，通常是依赖于查找算法。\n快表与慢表的命中率没有必然联系，快表仅是慢表的一个部分拷贝，不能够得到比慢表更多的结果。\n\n\n快表用 SRAM 实现，其工作原理类似于 Cache，通常采用全相联或组相联映射方式。TLB 表项由页表表项内容和 TLB 标记组成。\n\n全相联映射下，TLB 标记就是对应页表项的虚拟页号；\n组相联方式下，TLB 标记则是对应虚拟页号的高位部分，而虚拟页号的低位部分作为 TLB 组的组号。\n\n具有 TLB 和 Cache 的多级存储系统\n下图是一个具有 TLB 和 Cache 的多级存储系统，其中 Cache 采用二路组相联方式。\nCPU 给出一个 32 位的虚拟地址，TLB 采用全相联方式，每一项都有一个比较器，查找时将虚页号与每个 TLB 标记字段同时进行比较，\n\n若有某一项相等且对应有效位为 1，则 TLB 命中，此时可直接通过 TLB 进行地址转换；\n若未命中，则 TLB 缺失，需要访问主存去查页表。\n\n下图中所示的是两级页表方式，虚页号被分成页目录索引和页表索引两部分，由这两部分得到对应的页表项，从而进行地址转换，并将相应表项调入 TLB，若 TLB 已满，则还需要采用替换策略。\n完成由虚拟地址到物理地址的转换后，Cache 机构根据映射方式将物理地址划分成多个字段，然后根据映射规则找到对应的 Cache 行或组，将对应 Cache 行中的标记与物理地址中的高位部分进行比较，若相等且对应有效位为 1，则 Cache 命中，此时根据块内地址取出对应的字送给 CPU。\n\n\n在一个具有 TLB 和 Cache 的多级存储系统中，CPU 一次访存操作可能涉及 TLB、页表、Cache、主存和磁盘的访问，访问过程如下图所示。\nCPU 访存过程中存在三种缺失情况：\n\nTLB 缺失：要访问的页面的页表项不在 TLB 中；\nCache 缺失：要访问的主存块不在 Cache 中；\nPage 缺失：要访问的页面不在主存中。\n\n\n由于 TLB 只是页表的一部分副本，因此 Page 缺失时，TLB 也必然缺失。同理，Cache 也只是主存的一部分副本，页表未命中意味着信息不在主存，因此 Page 缺失时，Cache 也必然缺失。\n\n\n第 1 种组合无须访问主存；\n第 2 种和第 3 种组合都需要访问一次主存；\n第 4 种组合需要访问两次主存；\n第 5 种组合发生“缺页异常”，需要访问磁盘，并且至少访问两次主存。\n\n\n\n                  \n                  Tip\n                  \n                \n\n\nCache 缺失处理由硬件完成；\n缺页处理由软件完成，操作系统通过“缺页异常处理程序”来实现；\nTLB 缺失既可以用硬件，又可以用软件来处理。\n\n\n\n段式虚拟存储器\n段式虚拟存储器中的段是按程序的逻辑结构划分的，各个段的长度因程序而异。\n把虚拟地址分为两部分：段号和段内地址。\n虚拟地址到实地址之间的变换是由段表来实现的。段表是程序的逻辑段和在主存中存放位置的对照表。段表的每行记录与某个段对应的段号、装入位、段起点和段长等信息。因为段的长度可变，所以段表中要给出各段的起始地址与段的长度。\nCPU 根据虚拟地址访存时，首先根据段表基地址与段号拼接成对应的段表项，然后根据该段表项的装入位判断该段是否已调入主存（装入位为“1”，表示该段已调入主存；装入位为“0”，表示该段不在主存中）。已调入主存时，从段表读出该段在主存中的起始地址，与段内地址（偏移量）相加，得到对应的主存实地址。\n\n因为段本身是程序的逻辑结构所决定的一些独立部分，因而分段对程序员来说是不透明的，而分页对程序员来说是透明的，程序员编写程序时不需知道程序将如何分页。\n段式虚拟存储器的\n\n优点：段的分界与程序的自然分界相对应，因而具有逻辑独立性，使得它易于编译、管理、修改和保护，也便于多道程序的共享；\n缺点：因为段长度可变，分配空间不便，容易在段间留下碎片，不好利用，造成浪费。\n\n段页式虚拟存储器\n在段页式虚拟存储器中，把程序按逻辑结构分段，每段再划分为固定大小的页，主存空间也划分为大小相等的页，程序对主存的 调入、调出仍以页为基本交换单位。\n每个程序对应一个段表，每段对应一个页表，段的长度必须是页长的整数倍，段的起点必须是某一页的起点。\n虚地址分为段号、段内页号、页内地址三部分。\nCPU 根据虚地址访存时，\n\n首先根据段号得到段表地址；\n然后从段表中取出该段的页表起始地址，与虚地址段内页号合成，得到页表地址；\n最后从页表中取出实页号，与页内地址拼接形成主存实地址。\n\n段页式虚拟存储器的\n\n优点：兼具页式和段式虚拟存储器的优点，可以按段实现共享和保护。\n缺点：在地址变换过程中需要两次查表，系统开销较大。\n\n虚拟存储器与 Cache 的比较\n\n相同之处\n\n最终目标都是为了提高系统性能，两者都有容量、速度、价格的梯度。\n都把数据划分为小信息块，并作为基本的交换单位，虚存系统的信息块更大。\n都有地址映射、替换算法、更新策略等问题。\n都依据局部性原理应用“快速缓存”的思想，将活跃的数据放在相对高速的部件中。\n\n\n不同之处\n\nCache 解决系统速度，而虚拟存储器解决主存容量。\nCache 全由硬件实现，是硬件存储器，对所有程序员透明；而虚拟存储器由 OS 和硬件共同实现，是逻辑上的存储器，对系统程序员不透明，但对应用程序员透明。\n对于不命中性能影响，因为 CPU 的速度约为 Cache 的 10 倍，主存的速度为硬盘的 100 倍以上，因此虚拟存储器系统不命中时对系统性能影响更大。\nCPU 与 Cache 和主存都建立了直接访问的通路，而辅存与 CPU 没有直接通路。也就是说在 Cache 不命中时主存能和 CPU 直接通信，同时将数据调入 Cache；而虚拟存储器系统不命中时，只能先由硬盘调入主存，而不能直接和 CPU 通信。\n\n\n"},"计算机基础/计算机组成原理/4_指令系统":{"title":"指令系统","links":[],"tags":["计算机组成原理"],"content":"指令系统\n指令集体系结构\n机器指令（简称指令）是指示计算机执行某种操作的命令。\n一台计算机的所有指令的集合构成该机的指令系统（指令集）。\n指令系统是指令集体系结构(ISA, Instruction Set Architecture)中最核心的部分，ISA 完整定义了软件和硬件之间的接口，是机器语言或汇编语言程序员所应熟悉的。\nISA 规定的内容主要包括：\n\n指令的格式，寻址方式，操作类型，以及每种操作对应的操作数的相应规定。\n操作数的类型，操作数寻址方式，以及大/小端存放方式。\n程序可访问的寄存器编号、个数和位数，存储空间的大小和编址方式。\n指令执行过程的控制方式等，包括程序计数器、条件码定义等。\n\n\nISA 规定了机器级程序的格式，机器语言或汇编语言程序员必须对机器的 ISA 非常熟悉。\n\n指令字长\n\n指令字长是指一条指令所包含的二进制代码的位数，其取决于操作码的长度、地址码的长度和地址码的个数。\n指令字长与机器字长没有固定的关系，它既可以等于机器字长，又可以大于或小于机器字长。但为了硬件设计方便，指令字长一般取字节或存储字长的整数倍，而不一定都和存储字长一样大。\n通常根据指令长度可以将指令分为：\n\n单字长指令：指令长度等于机器字长的指令。\n半字长指令：指令长度等于半个机器字长的指令。\n双字长指令：指令长度等于两个机器字长的指令。\n\n\n\n                  \n                  Tip\n                  \n                \n\n指令长度的不同会导致取指令时间开销的不同。例如，单字长指令只需访存 1 次就能将指令完整取出；而双字长指令则需访存 2 次才能完整取出，耗费 2 个存取周期。\n\n\n在一个指令系统中，\n\n定长指令字结构：所有指令的长度都是相等的。定字长指令的执行速度快，控制简单。\n变长指令字结构：各种指令的长度随指令功能而异。\n\n因为主存一般是按字节编址的，所以指令字长通常为字节的整数倍。\n指令的格式\n指令的基本格式\n\n\n\n                  \n                  Tip\n                  \n                \n\n现代计算机都采用字节编址方式，即一个内存单元只能存放一字节的信息。一个操作数（如 char、int、float、double）可能是 8 位、16 位、32 位或 64 位等，因此可能占用 1 个、2 个、4 个或 8 个内存单元。也就是说，一个操作数可能有多个内存地址对应。\n有两种不同的地址指定方式：大端方式和小端方式。\n\n大端方式：指令中给出的地址是操作数最高有效字节(MSB)所在的地址。\n小端方式：指令中给出的地址是操作数最低有效字节(LSB)所在的地址。\n\n总之就是选择 MSB 和 LSB 中的较小的值\n\n\n零地址指令\n\n零地址的运算类指令仅用在堆栈计算机中。\n\n\n                  \n                  Tip\n                  \n                \n\n堆栈指令的访存次数，取决于采用的是软堆栈还是硬堆栈。\n\n若是软堆栈（堆栈区由内存实现），则对于双目运算需要访问 4 次内存：取指令、取源数 1、取源数 2、存结果。\n若是硬堆栈（堆栈区由寄存器实现），则只需在取指令时访问一次内存。\n\n\n\n一地址指令\n\n二地址指令\n\n三地址指令\n\n四地址指令\n\n定长操作码指令格式\n指令系统中所有指令的操作码长度都相同。\n一般 n 位操作码字段的指令系统最大能够表示 2^n^ 条指令。\n\n优点：简化计算机硬件设计，提高指令译码和识别速度 很有利。当计算机字长为 32 位或更长时，这是常规用法。\n缺点：指令数量增加时会占用更多固定位，留给表示操作数地址的位数受限。\n\n扩展操作码指令格式\n为了在指令字长有限的前提下仍保持比较丰富的指令种类，可采取可变长度操作码，即指令系统中各指令的操作码长度可变。\n最常见的变长操作码方法是扩展操作码，它使操作码的长度随地址码的减少而增加，不同地址数的指令可具有不同长度的操作码，从而在满足需要的前提下，有效地缩短指令字长。\n\n优点：指令字长有限的前提下仍保持比较丰富的指令种类。\n缺点：加了指令译码和分析的难度，使控制器的设计复杂化。\n\n\n\n除这种安排外，还有其他多种扩展方法，如形成 15 条三地址指令、12 条二地址指令、63 条一地址指令和 16 条零地址指令，共 106 条指令。\n\n通常情况下，对使用频率较高的指令分配较短的操作码，对使用频率较低的指令分配较长的操作码，从而尽可能减少指令译码和分析的时间。\n指令的操作类型\n\n\n\n                  \n                  Tip\n                  \n                \n\n调用指令和转移指令的区别：执行调用指令时必须保存下一条指令的地址（返回地址），当子程序执行结束时，根据返回地址返回到主程序继续执行；而转移指令则不返回执行。\n\n\n指令的寻址方式\n寻址方式是指寻找指令或操作数有效地址的方式，即确定本条指令的数据地址及下一条待执行指令的地址的方法。\n采用不同寻址方式的目的是为了缩短指令字长，扩大寻址空间，提高编程的灵活性，但这也提高了指令译码的复杂度。\n指令寻址\n寻找下一条将要执行的指令地址称为指令寻址。\n顺序寻址\n通过程序计数器 PC 加 1 条指令的长度，自动形成下一条指令的地址。\nPC 自增的大小与编址方式、指令字长有关。\n\n\n\n跳跃寻址\n通过转移类指令实现，可以实现程序的无条件转移和条件转移。\n跳跃是指由本条指令给出下条指令地址的计算方式，而是否跳跃可能受到状态寄存器的控制。\n跳跃的方式分为：\n\n绝对转移：地址码直接指出转移目标地址。\n相对转移：地址码指出转移目的地址相对于当前 PC 值的偏移量。\n\n由于 CPU 总是根据 PC 的内容去主存取指令的，因此转移指令执行的结果是修改 PC 值，下一条指令仍然通过 PC 给出。\n\n数据寻址\n数据寻址是指如何在指令中表示一个操作数的地址，或怎样计算出操作数的地址。\n数据寻址的方式较多，为区别各种方式，通常在指令字中设置一个寻址特征字段，用来指明属于哪种寻址方式（其位数决定了寻址方式的种类）。CPU 也是通过这来区分某个寄存器中存放的是操作数还是操作数的地址。\n\n指令中的地址码字段并不代表操作数的真实地址，这种地址称为形式地址(A)。形式地址结合寻址方式，可以计算出操作数在存储器中的真实地址，这种地址称为有效地址(EA, effective address)。\n\n\n                  \n                  Tip\n                  \n                \n\n(A)表示地址为 A 的数值，A 既可以是寄存器编号，又可以是内存地址。\n\n\n各常见指令寻址方式的特点和适用情况：\n\n立即寻址：操作数获取便捷，通常用于给寄存器赋初值。\n直接寻址：相对于立即寻址，缩短了指令长度。\n间接寻址：扩大了寻址范围，便于编制程序，易于完成子程序返回。\n寄存器寻址：指令字较短，指令执行速度较快。\n寄存器间接寻址：扩大了寻址范围。\n基址寻址：扩大了操作数寻址范围，适用于多道程序设计，常用于为程序或数据分配存储空间。\n变址寻址：主要用于处理数组问题，适合编制循环程序。\n相对寻址：用于控制程序的执行顺序、转移等。\n\n\n直接寻址\n指令字中的形式地址 A 就是操作数的真实地址 EA。\n\n\n优点：简单，不需要专门计算操作数的地址，指令 在 执行阶段 仅需访存一次。\n缺点：A 的位数限制了该指令操作数的寻址范围，操作数的地址不易修改。\n\n\n\n                  \n                  Tip\n                  \n                \n\n一条指令的执行分为取指令和执行指令。取指令需要一次访存。\n\n\n间接寻址\n间接寻址是相对于直接寻址而言的，指令的地址字段给出的不是操作数的真正地址，而是操作数有效地址所在主存单元的地址，也就是操作数地址的地址，即 EA = (A)。\n\n\n优点：可扩大寻址范围（有效地址 EA 的位数大于形式地址 A 的位数），便于编制程序（用间接寻址可方便地完成子程序返回）。\n缺点：指令在执行阶段要多次访存，例如一次间接寻址需 2 次访存；由于执行速度较慢，一般为了扩大寻址范围时，通常采用寄存器间接寻址。\n\n寄存器寻址\n与直接寻址的原理一样，只是把访问主存改为访问寄存器，指令的地址字段给出的是操作数所在寄存器的编号，即 EA = Ri，其操作数在由 Ri 所指的寄存器内。\n\n\n优点：指令在执行阶段不用访存，只访问寄存器，执行速度快；寄存器数量远小于内存单元数，所以地址码位数较少，指令字长较短；\n缺点：寄存器价格昂贵，CPU 的寄存器数量有限。\n\n\n\n                  \n                  Note\n                  \n                \n\n由于寄存器寻址的指令字长较短，因此想要缩短指令中某个地址段的位数可以使用这种方法。\n\n\n寄存器间接寻址\n这种方式综合了间接寻址和寄存器寻址各自的特点，指令字中的 Ri 所指寄存器给出的不是一个操作数，而是操作数所在主存单元的地址，即 EA = (Ri)。\n\n\n相比间接寻址，这种方式既扩大了寻址范围，又减少了访存次数，在执行阶段仅需访存 1 次。\n相比寄存器寻址，这种方式在执行阶段需要访存获得操作数。\n\n隐含寻址\n不明显地给出操作数的地址，而是隐含操作数的地址。\n例如，单地址的指令格式就隐含约定第二个操作数由累加器（ACC）提供，指令中只明显指出第一个操作数的地址。因此，累加器（ACC）对单地址指令格式来说是隐含寻址。\n\n\n优点：有利于缩短指令字长，可以简化地址结构。\n缺点：需增加存储操作数或隐含地址的硬件。\n\n立即寻址\n指令字中的地址字段指出的不是操作数的地址，而是操作数本身，也称立即数，采用补码表示。\n图中#表示立即寻址特征，A 就是操作数。\n\n\n优点：指令在执行阶段不访存，指令执行速度最快。\n缺点：A 的位数限制了立即数的范围。\n\n偏移寻址\n\n\n\n                  \n                  Tip\n                  \n                \n\n设基址/变址/PC 的值为 B，若题目显式说明形式地址 A 是补码表示，则计算 EA 时有两种方法（存疑）：\n\n\n将补码 A 扩展到与 B 位数相同，然后相加，忽略溢出。\n\nC000 0000H + FFFF FF00H = 1 BFFF FF00H（加上补码，有溢出）\n但 FF00H = -0100H，C000 0000H - 0100H = BFFF FF00H（与原码进行加减，无溢出）\n\n\n\n\n\n将补码 A 转化为原码，然后再根据补码 A 的符号数进行加减。\n\nF000 0000H + (-00EEH) = EFFF FF12H（与原码进行加减，无溢出）\n但 FF12H 扩展后是 FFFF FF12H，F000 0000 + FFFF FF12H = 1 EFFF FF12H（加上补码，有溢出）\n\n\n\n\n\n\n\n基址寻址\n基址寻址是指将基址寄存器(BR, base address register) 的内容加上指令字中的形式地址 A 而形成操作数的有效地址，即 EA = (BR) + A。\n其中基址寄存器既可采用专用寄存器，又可指定某个通用寄存器作为基址寄存器。\n\n基址寄存器是面向操作系统的，其内容由操作系统或管理程序确定，主要用于解决程序逻辑空间与存储器物理空间的无关性。\n在程序执行过程中，基址寄存器的内容不变（作为基地址），形式地址可变（作为偏移量）。采用通用寄存器作为基址寄存器时，可由用户决定哪个寄存器作为基址寄存器，但其内容仍由操作系统确定。\n优点：可以扩大寻址范围（基址寄存器的位数大于形式地址 A 的位数）；用户不必考虑自己的程序存于主存的具体位置，因此有利于多道程序设计，并可用于编制浮动程序，但偏移量（形式地址 A）的位数较短。\n\n基址寄存器对于汇编程序员是可见的。\n\n变址寻址\n变址寻址是指将变址寄存器 (IX, index register) 的内容加上指令字中的形式地址 A 而形成操作数的有效地址，即 EA = (IX) + A，其中 IX 为变址寄存器（专用），也可用通用寄存器作为变址寄存器。\n\n变址寄存器是面向用户的，在程序执行过程中，变址寄存器的内容可由用户改变（作为偏移量），形式地址 A 不变（作为基地址）。\n优点：可扩大寻址范围（变址寄存器的位数大于形式地址 A 的位数）；偏移量（变址寄存器 IX）的位数足以表示整个存储空间。\n\n变址寻址与基址寻址本质上的区别：\n\n基址寻址面向系统，主要用于为多道程序或数据分配存储空间，因此基址寄存器的内容通常由操作系统或管理程序确定，在程序的执行过程中其值不可变，而指令字中的 A 是可变的。\n变址寻址面向用户，主要用于处理数组问题，在变址寻址中，变址寄存器的内容由用户设定，在程序执行过程中其值可变，而指令字中的 A 是不可变的。\n\n\n相对寻址\n相对寻址是把 PC 的内容加上指令格式中的形式地址 A 而形成操作数的有效地址，即 EA = (PC) + A，其中 A 是相对于当前 PC 值的偏移量（即相对于下一条要执行的指令的地址），可正可负，补码表示。\nA 的位数决定操作数的寻址范围。\n\n\n                  \n                  Note\n                  \n                \n\n对于转移指令 JMPA，若指令的地址为 X，且占 2B，则在取出该指令后，PC 的值会增 2，即 (PC)=X+2，这样在执行完该指令后，会自动跳转到 X+2+A 的地址继续执行。\n\n\n\n优点：操作数的地址不是固定的，它随 PC 值的变化而变化，且与指令地址之间总是相差一个固定的偏移量，因此便于程序浮动。\n\n相对寻址广泛应用于转移指令。\n\n\n\n堆栈寻址\n堆栈是存储器（或寄存器组）中一块特定的、按后进先出(LIFO)原则管理的存储区，该存储区中读/写单元的地址是用一个特定寄存器给出的，该寄存器称为堆栈指针(SP, Stack Pointer)。\n堆栈可分为硬堆栈和软堆栈两种：\n\n硬堆栈：使用寄存器作为堆栈，硬堆栈的成本较高，不适合做大容量的堆栈。\n软堆栈：从主存中划出一段区域来做堆栈，这种方法是最合算且最常用的。\n\n在采用堆栈结构的计算机中，大部分指令表面上都表现为无操作数指令的形式，因为操作数地址都隐含使用了 SP。因此在读/写堆栈的前后都伴有自动完成对 SP 的加减操作。\n\n程序的机器级代码表示\n\n常用汇编指令\n相关寄存器\nx86 处理器中有 8 个 32 位的通用寄存器。为了向后兼容，EAX、EBX、ECX 和 EDX 的高两位字节和低两位字节可以独立使用，E 表示 Extended，表示 32 位的寄存器。\n例如，EAX 的低两位字节称为 AX，而 AX 的高低字节又可分别作为两个 8 位寄存器，分别称为 AH 和 AL。\n\n除 EBP 和 ESP 外，其他几个寄存器的用法是比较灵活的。\n汇编指令格式\n一般有两种不同的汇编格式：AT&amp;T 格式和 Intel 格式（统考要求掌握的是 Intel 格式）。\n\n常用指令\n汇编指令通常可分为数据传送指令、算术和逻辑运算指令和控制流指令，下面以 Intel 格式为例，介绍一些常用的指令。\n数据传送指令\n\n\nmov 指令\n将第二个操作数（寄存器的内容、内存中的内容或常数值）复制到第一个操作数（寄存器或内存）。\n双操作数指令的两个操作数不能都是内存，即 mov 指令不能用于直接从内存复制到内存，若需在内存之间复制，可先从内存复制到一个寄存器，再从这个寄存器复制到内存。\n\n\npush 指令\n将操作数压入内存的栈，常用于函数调用。\nESP 是栈顶，入栈前先将 ESP 值减 4，然后将操作数压入 ESP 指示的地址。\n\n栈中元素固定是 32 位\n栈增长方向与内存地址增长方向相反\n\n\n\npop 指令\npush 指令相反，pop 指令执行的是出栈工作，出栈前先将 ESP 指示的地址中的内容出栈，然后将 ESP 值加 4。\n\n\n算术和逻辑运算指令\n\n\n\n                  \n                  Note\n                  \n                \n\n若乘法操作溢出，则编译器置溢出标志 OF = 1，以使 CPU 调用溢出异常处理程序。\n\n\n\n控制流指令\n\n\n\n选择语句的机器级表示\n\n\n                  \n                  Tip\n                  \n                \n\n在 Intelx86 处理器中程序计数器 PC(ProgramCounter)通常被称为 IP(Instruction Pointer)。\n\n\n\n\n循环语句的机器级表示\n\n\n过程调用的机器级表示\n\n访问栈帧\n每个过程都有自己的栈区，称为栈帧，因此，一个栈由若干栈帧组成，寄存器 EBP 指示栈帧的起始位置，寄存器 ESP 指示栈顶，栈从高地址向低地址增长。\n\n过程执行时，ESP 会随着数据的入栈而动态变化，而 EBP 固定不变。当前栈帧的范围在 EBP 和 ESP 指向的区域之间。\n\n\n\n切换栈帧\n\nwww.bilibili.com/video/BV1ps4y1d73V\n\n\n\n\n\n\n传递参数\n\nwww.bilibili.com/video/BV1ps4y1d73V\n\n\n\n\n\nCISC 和 RISC\n\n复杂指令系统计算机 (CISC): Complex Instruction Set Computer\n精简指令系统计算机 (RISC): Reduced Instruction Set Computer\n\n\n\nCISC 的主要特点如下\n\n指令系统复杂庞大，指令数目一般为 200 条以上。\n指令的长度不固定，指令格式多，寻址方式多。\n可以访存的指令不受限制。\n各种指令使用频度相差很大。\n各种指令执行时间相差很大，大多数指令需多个时钟周期才能完成。\n控制器大多数采用微程序控制。有些指令非常复杂，以至于无法采用硬连线控制。\n难以用优化编译生成高效的目标代码程序。\n\n\nRISC 的主要特点如下\n\n选取使用频率最高的一些简单指令，复杂指令的功能由简单指令的组合来实现。\n指令长度固定，指令格式种类少，寻址方式种类少。\n只有 LOAD/STORE（取数/存数）指令访存，其余指令的操作都在寄存器之间进行。\nCPU 中通用寄存器的数量相当多。\n一定采用指令流水线技术，大部分指令在一个时钟周期内完成。\n以硬布线控制为主，不用或少用微程序控制。\n特别重视编译优化工作，以减少程序执行时间。\n\n\n\n从指令系统兼容性看，CISC 大多能实现软件兼容，即高档机包含了低档机的全部指令，并可加以扩充。但 RISC 简化了指令系统，指令条数少，格式也不同于老机器，因此大多数 RISC 机不能与老机器兼容。\n"},"计算机基础/计算机组成原理/5_中央处理器":{"title":"中央处理器","links":["计算机基础/计算机操作系统/2_进程与线程"],"tags":["计算机组成原理"],"content":"CPU\n功能\n\nCPU 的具体功能包括：\n\n指令控制：完成取指令（也称取指）、分析指令和执行指令的操作，即程序的顺序控制。\n操作控制：产生完成一条指令所需的操作信号，把各种操作信号送到相应的部件，从而控制这些部件按指令的要求正确执行。\n时间控制：严格控制各种操作信号的出现时间、持续时间及出现的时间顺序。\n数据加工：对数据进行算术和逻辑运算。\n中断处理：对运行过程中出现的异常情况和中断请求进行处理。\n\n基本结构\n运算器\n运算器主要功能是根据控制器送来的命令，对数据执行算术运算（加、减、乘、除）、逻辑运算（与、或、非、异或、移位、求补等）或条件测试（用于设置 ZF、SF、OF 和 CF 等标志位，作为条件转移的判断条件）。\n运算器主要由以下部分组成：\n\n\n算术逻辑单元(ALU)\n\n\n暂存寄存器\n用于暂存从数据总线或通用寄存器送来的操作数，以便在取出下一个操作数时将其同时送入 ALU。暂存寄存器对应用程序员是透明的（不可见）。\n\n\n累加寄存器(ACC)\n一个通用寄存器，用于暂时存放 ALU 运算的结果。\n\n\n通用寄存器组(GPRs)\n用于存放操作数（包括源操作数、目的操作数及中间结果）和各种地址信息 等，如 AX、BX、CX、DX、SP 等。其位数与机器字长相等，因此便于操作控制。在指令中要指定寄存器的编号，才能明确是对哪个寄存器进行访问。SP 是堆栈指针，用于指示栈顶的地址。\n\n\n程序状态字寄存器(PSW)\n每个标志位通常由一位触发器来保存，这些标志位组合在一起称为程序状态字。程序状态字的各位表征程序和机器的运行状态。程序状态字寄存器对用户不透明。\n由算术/逻辑运算指令或测试指令的运行结果而建立的各种状态信息，一种是状态标志，如溢出标志(OF)、符号标志(SF)、零标志(ZF)、进位标志(CF)等；另一种是控制标志，如中断标志、陷阱标志等。\n\n\n移位寄存器(SR)\n不但可用来存放操作数，而且在控制信号的作用下，寄存器中的数据可根据需要向左或向右移位。\n\n\n计数器(CT)：控制乘除运算的操作步数。\n\n\n\n\n控制器\n控制器的全部功能是取指令、分析指令和执行指令，执行指令就是发出有关操作控制信号。\n控制器的主要功能是执行指令，每条指令的执行是由控制器发出的一组微操作实现的。\n控制器的工作原理是，根据指令操作码、指令的执行步骤（微命令序列）和条件信号来形成当前计算机各部件要用到的控制信号。计算机整机各硬件系统在这些控制信号的控制下协同运行，产生预期的执行结果。控制器是整个系统的指挥中枢，在控制器的控制下，运算器、存储器和输入/输出设备等功能部件构成一个有机的整体，根据指令的要求指挥全机协调工作。\n控制器主要由以下部分组成：\n\n程序计数器(PC, Program Counter)：用于指出欲执行指令在主存储器中的存放地址。若 PC 和主存储器均按字节编址，则 PC 的位数等于主存储器地址位数。CPU 根据 PC 的内容从主存储器中取指令，然后送入指令寄存器。指令通常是顺序执行的，因此 PC 具有自动加 1 的功能（这里的**“1”是指一条指令的字节数**）；当遇到转移类指令时，PC 的新值由指令计算得到。\n指令寄存器(IR, Instruction register)：用于保存当前正在执行的指令，IR 的位数等于指令字长。\n指令译码器(ID, Instruction Decoder)\n存储器地址寄存器(MAR)：用于存放要访问的主存储器单元的地址，MAR 的位数等于主存储器地址线数，它反映了最多可寻址的存储单元的个数。\n存储器数据寄存器(MDR)：用于存放向主存储器写入的信息或从主存储器读出的信息，MDR 的位数等于存储字长。当 CPU 和主存储器交换信息时，都要用到 MAR 和 MDR。\n微操作信号发生器(CU, Control Unit)：产生微操作命令序列\n时序电路\n\n\n\n指令执行过程\n指令周期\n指令周期：CPU 每取出并执行一条指令所需的全部时间，不同指令的指令周期可能不同。\n机器周期是指令执行中每步操作（如取指令、存储器读、存储器写等）所需要的时间，每个机器周期的长度可变。\n指令周期通常可用若干机器周期来表示，机器周期又叫 CPU 周期。\n一个机器周期又包含若干时钟周期（也称为节拍、T 周期或 CPU 时钟周期，它是 CPU 操作的最基本单位，每个指令周期一定大于或等于一个 CPU 时钟周期）。\n\n\n                  \n                  Note\n                  \n                \n\n总线周期：一次总线操作所需的时间，通常为一个或多个时钟周期。\n存取周期：存储器进行一次读或写操作所需的时间称为存储器的读/写时间，而连续启动两次独立的读或写操作（如连续两次读操作）所需的最短时间称为存取周期。机器周期通常由存取周期确定。\n\n\n\n\n                  \n                  Note\n                  \n                \n\n时钟脉冲信号的宽度称为时钟周期，时钟周期的倒数为机器主频。\n时钟脉冲信号由机器脉冲源发出的脉冲信号经整形和分频后形成，时钟周期以相邻状态单元间组合逻辑电路的最大延迟为基准确定。\n\n\n\n每个指令周期内的机器周期数可以不等，每个机器周期内的节拍数也可以不等。\n\n对于无条件转移指令 JIMP X，在执行时不需要访问主存，只包含取指阶段（包括取指和分析）和执行阶段，所以其指令周期仅包含取指周期和执行周期。\n对于间接寻址的指令，为了取操作数，需要先访问一次主存，取出有效地址，然后访问主存，取出操作数，所以还需包括间址周期。间址周期介于取指周期和执行周期之间。\n当 CPU 采用中断方式实现主机和 I/O 设备的信息交换时，CPU 在每条指令执行结束前，都要发中断查询信号，若有中断请求，则 CPU 进入中断响应阶段，也称中断周期。\n\n\n指令字长一般都取存储字长的整数倍，若指令字长等于存储字长的 2 倍，则需要两次访存，取指周期等于机器周期的 2 倍；若指令字长等于存储字长，则取指周期等于机器周期。\n\n这样，一个完整的指令周期可包括取指、间址、执行和中断 4 个周期。\n\n\n当 CPU 执行指令时，首先进入取指周期，从 PC 指出的主存单元中取出指令，送至指令寄存器，同时 PC 加“1”以作为下一条指令的地址。当遇到转移指令等改变执行顺序的指令时，在 PC 加“1”后会重新计算并更新 PC 值。\n然后判断是否有间接寻址，如果有，那么进入间址周期以获取操作数的有效地址。\n之后进入执行周期，完成取操作数、执行运算和存操作数的任务。\n执行周期结束后，如果 CPU 检测到中断请求，则进入中断周期，此时需要关中断、保存断点、修改 PC 值为中断服务程序的入口地址，并转向中断服务程序。\n\n\nCPU 区分指令和数据的依据：指令周期的不同阶段。通常，执行阶段取出的是数据，取值阶段取出的是指令。\n\n\n指令周期的数据流\n取值周期\n取指周期的任务是根据 PC 中的内容从主存中取出指令代码并存放在 IR 中。\n取指操作是自动进行的，控制器不需要得到相应的指令。\n\n不同长度的指令，其取指操作可能是不同的。例如，双字指令、三字指令与单字指令的取指操作是不同的。\n间址周期\n间址周期的任务是取操作数有效地址。将指令中的地址码送到 MAR 并送至地址总线，此后 CU 向存储器发出读命令，以获取有效地址并存至 MDR。\n\n\n\n                  \n                  Tip\n                  \n                \n\nAd(IR) 表示取出 IR 中存放的指令字的地址字段。\n\n\n执行周期\n执行周期的任务是取操作数，并根据 IR 中的指令字的操作码通过 ALU 操作产生执行结果。\n不同指令的执行周期操作不同，因此没有统一的数据流向。\n中断周期\n中断周期的任务是处理中断请求。\n假设程序断点存入堆栈中，并用 SP 指示栈顶地址，而且进栈操作是先修改栈顶指针，后存入数据。\n\n\n\n                  \n                  Tip\n                  \n                \n\n中断周期中的进栈操作是将 SP 减“1”。这和传统意义上的进栈操作相反，原因是计算机中的堆栈都是向低地址方向增长，所以进栈操作是减“1”而不是加“1”。\n\n\n指令执行方案\n\n\n单周期处理器\n单周期处理器对所有指令都选用相同的执行时间来完成。\n此时每条指令都在一个时钟周期内完成（即 CPI = 1），指令之间串行执行，即下一条指令只能在前一条指令执行结束后才能启动。因此，指令周期取决于执行时间最长的指令的执行时间。对于那些本来可以在更短时间内完成的指令，仍要使用这个较长的周期来完成，会降低整个系统的运行速度。\n\n单周期处理器不能使用单总线结构数据通路，因为单总线结构数据通路将所有寄存器的输入/输出端都链接在一条公共通路上，一个时钟周期只允许一次操作，无法完成指令的所有操作。\n\n\n\n多周期处理器\n多周期处理器对不同类型的指令选用不同的执行步骤。\n指令需要几个周期就为其分配几个周期，因此可选用不同个数的时钟周期来完成不同指令的执行过程（即 CPI &gt; 1），不再要求所有指令占用相同的执行时间。\n多指令周期方案中指令之间仍是串行执行。\n\n\n流水线处理器\n流水线处理器采用指令之间并行执行的方案，其追求的目标是力争在每个时钟周期完成一条指令的执行过程（只在理想情况下才能达到该效果，此时 CPI = 1。\n这种方案通过在每个时钟周期启动一条指令，尽量让多条指令同时运行，但各自处在不同的执行步骤中。\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n单周期 CPU 执行任何指令的时间不一定都会小于多周期 CPU，这取决于单周期 CPU 和多周期 CPU 的时钟周期的长短，以及该指令在多周期 CPU 下所需的时钟周期数。\n\n\n数据通路\n功能\n不论 CPU 的内部结构多么复杂，它都可视为由数据通路(Data Path)和控制部件(Control Unit)两大部分组成。\n\n数据通路不包含控制部件。\n\n数据通路：数据在指令执行过程中所经过的路径，包括路径上的部件。ALU、通用寄存器、状态寄存器、Cache、MMU、浮点运算逻辑、异常和中断处理逻辑等都是指令执行时数据流经的部件，都属于数据通路的一部分。数据通路描述了信息从哪里开始，中间经过哪些部件，最后被传送到哪里。\n数据通路中数据流动路径由控制部件控制，控制部件根据每条指令功能的不同，生成对数据通路的控制信号。\n组成\n组成数据通路的元件主要分为组合逻辑元件（操作元件）和时序逻辑元件（状态元件）两类。\n组合逻辑元件（操作元件）\n组合逻辑元件不含存储信号的记忆单元，任何时刻产生的输出仅取决于当前的输入。组合电路不受时钟信号的控制，输出与输入之间无反馈通路，信号是单向传输的。\n数据通路中常用的组合逻辑元件有加法器、算术逻辑单元(ALU)、译码器、多路选择器、三态门等。\n\n时序逻辑元件（状态元件）\n任何时刻的输出不仅与该时刻的输入有关，还与该时刻以前的输入有关，因而时序电路必然包含存储信号的记忆单元。此外，时序电路必须在时钟节拍下工作。\n各类寄存器和存储器，如通用寄存器组、程序计数器、状态/移位/暂存/锁存寄存器等，都属于时序逻辑元件。\n基本结构\n数据通路结构直接影响 CPU 内各种信息的传送路径，数据通路不同，指令执行过程的微操作序列的安排也不同，它关系着微操作信号形成部件的设计。\nCPU 内部单总线方式\n\nwww.bilibili.com/video/BV1ps4y1d73V\n\n将 ALU 及所有寄存器都连接到一条内部公共总线上，称为单总线结构的数据通路。这种结构比较简单，但数据传输存在较多的冲突现象，性能较低。\n\n\n                  \n                  Tip\n                  \n                \n\n此总线在 CPU 内部，注意不要把它与连接 CPU、存储器和外设的系统总线相混淆。\n\n内部总线是指同一部件，如 CPU 内部连接各寄存器及运算部件之间的总线。\n系统总线是指同一台计算机系统的各部件，如 CPU、内存、通道和各类 I/O 接口间互相连接的总线。\n\n\n\n\n\n上图中\n\n\nGPRs 为通用寄存器组，rs、rd 分别为所读、写的通用寄存器的编号；\n\n\nY 和 Z 为暂存器；\n\n\nFR 为标志寄存器，用于存放 ALU 产生的标志信息。\n\n\n带箭头的虚线表示控制信号，字母加“in”表示该部件允许写入，字母加“out”表示该部件允许输出。MDRin 表示内部总线上信息写入 MDR，MDRout 表示 MDR 的内容送入内部总线。\n\n\n能输出到总线的部件均通过一个三态门与内部总线相连，用于控制该部件与内部总线之间数据通路的连接与断开。\n\n\n\n                  \n                  Tip\n                  \n                \n\n在单总线的 CPU 中，ALU 的一个输入端与总线相连，另一个输入端需通过一个寄存器与总线相连。而且输出端也需通过一个暂存器（用来暂存结果的寄存器）与总线相连。\n因为 ALU 是一个组合逻辑电路，其运算过程中必须保持两个输入端的内容不变。此外，ALU 的输出端若直接与内部总线相连，则其输出又会通过总线反馈到输入端，影响运算结果。\n\n\n\n\n例题\n\n\n\n\nCPU 内部多总线方式\nCPU 内部有两条或更多的总线时，构成双总线结构或多总线结构。将所有寄存器的输入端和输出端都连接到多条公共通路上，相比之下单总线中一个时钟内只允许传送一个数据，因而指令执行效率很低，因此采用多总线方式，同时在多个总线上传送不同的数据，提高效率。\n专用数据通路方式\n根据指令执行过程中的数据和地址的流动方向安排连接电路，避免使用共享的总线，性能较高，但硬件量大。\n\n控制器\n\n\n\nFE: fetch\nIND: In Direct\nEX: executive\nINT: intrrupt\n\n\n结构\n\n\n运算器部件通过数据总线与内存储器、输入设备和输出设备传送数据。\n输入输出设备通过接口电路与总线相连接。\n内存储器、输入设备和输出设备从地址总线接收地址信息，从控制总线得到控制信号，通过数据总线与其他部件传送数据。\n控制器部件从数据总线接收指令信息，从运算器部件接收指令转移地址，送出指令地址到地址总线，还要向系统中的部件提供它们运行所需要的控制信号。\n\n功能\n控制器是计算机系统的指挥中心，\n\n从主存中取出一条指令，并指出下一条指令在主存中的位置。\n对指令进行译码或测试，产生相应的操作控制信号，以便启动规定的动作。\n指挥并控制 CPU、主存、输入设备和输出设备之间的数据流动方向。\n\n根据控制器产生微操作控制信号的方式的不同，控制器可分为硬布线控制器和微程序控制器，两类控制器中的 PC 和 IR 是相同的，但确定和表示指令执行步骤的办法及给出控制信号的方案是不同的。\n硬布线控制器\n硬布线控制器由复杂的组合逻辑门电路和触发器构成，也称组合逻辑控制器，其原理是根据指令的要求、当前的时序及内外部的状态，按时间的顺序发送一系列微操作控制信号。\n指令的操作码是决定控制单元 (CU) 发出不同控制信号的关键。为了简化 CU 的逻辑，将存放在 IR 的 n 位操作码经过译码电路产生 2^n^ 个输出，每种操作码对应一个输出送至 CU。\n如果将指令译码器和节拍发生器从 CU 中分离出来，便可得到如图所示的简化的控制单元框图。\n\n控制单元（CU）的输入信号来源 如下：\n\n\n经指令译码器译码产生的指令信息\n现行指令的操作码决定了不同指令在执行周期所需完成的不同操作，它与时钟配合产生不同的控制信号。\n\n\n时序系统产生的机器周期信号和节拍信号\n为了使控制单元按一定的先后顺序、一定的节奏发出各个控制信号，控制单元必须受时钟控制。\n\n\n来自执行单元的反馈信息即标志（次要因素）\n控制单元有时需依赖 CPU 当前所处的状态产生控制信号，如 BAN 指令，控制单元要根据上条指令的结果是否为负来产生不同的控制信号。\n\n\n\n设计\n\n分析每个阶段的微操作序列\n\n安排微操作时序\n取址周期\n\n间址周期\n\n执行周期\n\n电路设计\n\n\n\n\n\n\n特点\n硬布线控制的功能由逻辑门组合实现，其速度主要取决于电路延迟，因此高速计算机中的关键核心部件 CPU 往往采用硬布线逻辑实现。因此，RISC 一般都选用硬布线控制器。\n指令越多，修改、设计、扩充和实现就越困难。\n指令系统功能越全，微操作命令就越多，电路也就越庞杂，调试就更困难。\n微程序控制器\n\n微程序、微指令、微命令\n\n微程序的设计思想就是将每条机器指令编写成一个微程序，每个微程序包含若干微指令，每条微指令对应一个或几个微操作命令。\n因此，执行一条指令的过程就是执行一个微程序的过程，所以一个微程序的周期对应一个指令周期。这些微程序存储在一个控制存储器(CM)中。目前，大多数计算机都采用微程序设计技术。\n\n微指令是若干微命令的集合，一条微指令通常至少包含两大部分信息：\n\n操作控制字段，也称微操作码字段，用于产生某一步操作所需的各种操作控制信号。\n顺序控制字段，也称微地址码字段，用于控制产生下一条要执行的微指令地址。\n\n微周期是指从控制存储器中取出并执行一条微指令所需的全部时间，通常为一个时钟周期。\n\n微命令：在微程序控制的计算机中，控制部件向执行部件发出的各种控制命令或者控制信号称为微命令，它是构成控制序列的最小单位。例如，打开或关闭某个控制门的电位信号、某个寄存器的打入脉冲等。执行部件收到微命令后所进行的操作称为微操作，微命令和微操作是一一对应的。\n微命令有相容性和互斥性之分：\n\n相容性微命令：指那些可以同时出现、共同完成某一些微操作的微命令；\n互斥性微命令：指在机器中不允许同时出现的微命令。若同时出现可能会引起总线冲突，也有可能是其他原因。\n\n\n\n                  \n                  Tip\n                  \n                \n\n硬布线控制器中也有微命令与微操作的概念，并非微程序控制器的专有概念。\n\n\n微程序和程序是两个不同的概念：\n\n\n程序是指令的有序集合，用于完成特定的功能。\n\n\n微程序是微指令的有序集合，用于描述机器指令，一条指令的功能由一段微程序来实现。\n\n\n微程序实际上是机器指令的实时解释器，是由计算机设计者事先编制好并存放在控制存储器中的，一般不提供给用户。对于程序员来说，系统中微程序的结构和功能是透明的，无须知道。\n程序最终由机器指令组成，并且由软件设计人员事先编制好并存放在主存储器或者辅助存储器中。\n\n\n                  \n                  Tip\n                  \n                \n\n\n主存储器用于存放程序和数据，在 CPU 外部，由 ROM 和 RAM 实现（主要是 RAM） 。\n控制存储器用于存放微程序，在 CPU 内部，用 ROM 实现。存放微指令的控制存储器的单元地址称为微地址。\n\n\n\n结构\n\n工作过程\n实际上就是在微程序控制器的控制下计算机执行机器指令的过程，这个过程可描述为：\n\n执行取指令公共操作。在机器开始运行时，自动地将取指微程序的入口地址送入 \\mu PC，并从 CM 中读出相应的微指令并送入 \\mu IR 。取指微程序的入口地址一般为 CM 的 0 号单元，取指微程序执行完成后，从主存中取出的机器指令就已存入指令寄存器中。\n由机器指令的操作码字段通过微地址形成部件产生该机器指令所对应的微程序的入口地址，并送入 \\mu PC。\n从 CM 中逐条取出对应的微指令并执行。\n执行完对应于一条机器指令的一个微程序后，又回到取指微程序的入口地址，继续第 1 步，以完成取下一条机器指令的公共操作。\n\n以上是一条机器指令的执行过程，如此周而复始，直到整个程序执行完毕。\n原理\n\n\n微指令设计\n微指令的编码方式\n直接编码方式\n直接编码法无须进行译码，微指令的操作控制字段中每一位都代表一个微命令。\n设计微指令时，选用或不选用某个微命令，只要将表示该微命令的对应位设置成 1 或 0 即可。每个微命令对应并控制数据通路中的一个微操作。\n\n优点是简单、直观，执行速度快，操作并行性好。\n缺点是微指令字长过长，n 个微命令就要求微指令的操作字段有 n 位，造成控制存储器容量过大。\n\n\n字段直接编码方式\n将微指令的操作控制字段分成若干小字段，把互斥性微命令放在同一字段中，把相容性微命令放在不同字段中，每个字段独立编码，每种编码代表一个微命令且各字段编码含义单独定义，与其他字段无关。\n\n优点是可以缩短微指令字长。\n缺点是比直接编码方式慢，因为要通过译码电路后再发出微命令。\n\n\n字段间接编码方式\n一个字段的某些微命令需由另一个字段中的某些微命令来解释，由于不是靠字段直接译码发出的微命令，因此称为字段间接编码，也称隐式编码。\n这种方式可进一步缩短微指令字长，但因削弱了微指令的并行控制能力，因此通常作为字段直接编码方式的一种辅助手段。\n\n微指令的地址形成方式\n\n\n\n                  \n                  Tip\n                  \n                \n\n断定法是指在微指令（后继地址字段）中直接明确指出下一条微指令的地址，这样相当于每条都是转移微指令，此外，还有一些其他如条件测试和转移控制字段，也用于控制微指令的寻址。因此，后继微指令地址可由微程序设计者指定，或者根据微指令所规定的转移控制字段控制产生。\n\n\n微指令格式\n\n一条水平型微指令能定义并执行几种并行的基本操作；而一条垂直型微指令只能定义并执行一种基本操作。\n水平型微指令和垂直型微指令的比较如下：\n\n水平型微指令并行操作能力强、效率高、灵活性强；垂直型微指令则较差。\n水平型微指令执行一条指令的时间短；垂直型微指令执行的时间长。\n用水平型微指令编写的微程序，微指令字较长但微程序短；垂直型微指令正好相反。\n水平型微指令难以掌握；而垂直型微指令与机器指令比较相似，相对容易掌握。\n\n\n\n                  \n                  Tip\n                  \n                \n\n垂直型微指令是一种微指令格式，相比于水平型微指令而言的，并不是指令格式垂直表示。\n垂直型微指令的特点是在微指令中设置了微操作码字段，结构类似于机器指令格式。\n控制信号经过编码产生 是一种控制字段的编码方法，属于水平型微指令，强调并行控制功能是一种控制字段的设计目标，适合水平型微指令而不适合垂直型微指令。\n\n\n微程序控制单元设计\n\n\n\n\n硬布线与微程序的比较\n\n硬布线控制器需要结合各个微操作的节拍安排，综合分析，写出逻辑表达式，再设计成逻辑电路图，因此时序系统比较复杂；而微程序只需按照节拍的安排，顺序执行微指令，因此时序系统比较简单。\nQ&amp;A\n\n取指令阶段完成的任务是将现行指令从主存中取出并送至指令寄存器，这个操作是公共的操作，是每条指令都要进行的，与具体的指令无关，所以不需要操作码的控制。\n微处理器是相对于一些大型处理器而言的，与微程序控制器没有必然联系。不管是采用微程序控制器，还是采用硬布线控制器，微机的 CPU 都是微处理器。\n\\mu PC 无法取代 PC，因为它只在微程序中指向下一条微指令地址的寄存器。因此 \\mu PC 也必然不可能知道这段微程序执行完毕后下一条是什么指令。\n\n异常和中断\n\n中断屏蔽方法\n\n现代计算机中都配有完善的异常和中断处理系统，CPU 的数据通路中有相应的异常检测和响应逻辑，外设接口中有相应的中断请求和控制逻辑，操作系统中有相应的中断服务程序。\n这些中断硬件电路和中断服务程序有机结合，共同完成异常和中断的处理过程。\n基本概念\n由 CPU 内部产生的意外事件被称为异常，也称内中断。异常是 CPU 执行一条指令时，由 CPU 在其内部检测到的、与正在执行的指令相关的同步事件；\n由来自 CPU 外部的设备向 CPU 发出的中断请求被称为中断，也称外中断，通常用于信息的输入和输出。中断是一种典型的由外部设备触发的、与当前正在执行的指令无关的异步事件。\n异常和中断处理过程的描述如下：\n\n若 CPU 在执行用户程序的第 i 条指令时检测到一个异常事件，或者执行第 i 条指令后发现一个中断请求信号，则 CPU 打断当前程序，然后转去执行相应的异常或中断处理程序。即内容异常的响应发生在指令执行过程中。\n若异常或中断处理程序能够解决相应的问题，则在异常或中断处理程序的最后，CPU 通过执行异常或中断返回指令，回到被打断的用户程序的第 i 条指令或第 i+1 条指令继续执行；若异常或中断处理程序发现是不可恢复的致命错误，则终止用户程序。\n\n通常情况下，对异常和中断的具体处理过程由操作系统（和驱动程序）完成。\n异常分类\n异常是由 CPU 内部产生的意外事件，分为：\n\n硬故障中断：由硬连线出现异常引起的，如存储器校验错、总线错误等。\n程序性异常：也称软件中断，是指在 CPU 内部因执行指令而引起的异常事件，如整除 0、溢出、断点、单步跟踪、非法指令、栈溢出、地址越界、缺页等。\n\n按异常发生原因和返回方式的不同，可分为故障、自陷和终止。\n故障(Fault)\n指在引起故障的指令启动后、执行结束前被检测到的异常事件。\n例如，\n\n指令译码时，出现“非法操作码“或“除数为 0”等；这种情况因为无法通过异常处理程序恢复故障，因此不能回到原断点执行，必须终止进程的执行。\n取数据时，发生“缺段”，“缺页” 等；这种异常事件经处理后可将所需的段或页面从磁盘调入主存，回到发生故障的指令继续执行，断点为当前发生故障的指令。\n\n自陷(Trap)\n自陷也称陷阱或陷入，它是预先安排的一种“异常”事件，就像预先设定的“陷阱”一样。\n通常的做法是：事先在程序中用一条特殊指令或通过某种方式设定特殊控制标志来人为设置一个“陷阱”，当执行到被设置了“陷阱”的指令时，CPU 在执行完自陷指令后，自动根据不同“陷阱”类型进行相应的处理，然后返回到自陷指令的下一条指令执行。\n\n\n                  \n                  Tip\n                  \n                \n\n当自陷指令是转移指令时，并不是返回到下一条指令执行，而是返回到转移目标指令执行。\n\n\n\n\n                  \n                  Note\n                  \n                \n\n在 x86 机器中，用于程序调试“断点设置”和单步跟踪的功能就是通过陷阱机制实现的。\n\n\n此外，系统调用指令、条件自陷指令等都属于陷阱指令，执行到这些指令时，无条件或有条件地自动调出操作系统内核程序进行执行。故障异常和自陷异常属于程序性异常（软件中断）。\n终止(Abort)\n如果在执行指令的过程中发生了使计算机无法继续执行的硬件故障，如控制器出错、存储器校验错、总线错误等，那么程序将无法继续执行，只能终止，此时，调出异常服务程序来重启系统。\n这种异常与故障和自陷不同，不是由特定指令产生的，而是随机发生的。\n终止异常和外中断属于硬件中断。\n中断分类\n中断是指来自 CPU 外部、与 CPU 执行指令无关的事件 引起的中断，包括 I/O 设备发出的 I/O 中断（如键盘输入、打印机缺纸等），或发生某种特殊事件（如用户按 Esc 键、定时器计数时间到）等。\n外部 I/O 设备通过特定的中断请求信号线向 CPU 提出中断请求，CPU 每执行完一条指令就检查中断请求信号线，如果检测到中断请求，则进入中断响应周期。\n中断可分为可屏蔽中断和不可屏蔽中断。\n\n\n                  \n                  Tip\n                  \n                \n\n\n若根据识别中断服务程序地址的方式，可分为向量中断和非向量中断；\n若根据中断处理过程是否允许被打断，还可分为单重中断和多重中断。\n\n\n\n可屏蔽中断\n通过可屏蔽中断请求线 INTR 向 CPU 发出的中断请求。\nCPU 可以通过在中断控制器中设置相应的屏蔽字来屏蔽它或不屏蔽它，被屏蔽的中断请求将不被送到 CPU。\n不可屏蔽中断\n通过专门的不可屏蔽中断请求线 NMI 向 CPU 发出的中断请求，通常是非常紧急的硬件故障，如电源掉电等。\n这类中断请求信号不可被屏蔽，以让 CPU 快速处理这类紧急事件。\n中断和异常联系\n中断和异常在本质上是一样的，但它们之间有以下两个重要的不同点：\n\n“缺页”或“溢出”等异常事件是由特定指令在执行过程中产生的，而中断不和任何指令相关联，也不阻止任何指令的完成。\n异常的检测由 CPU 自身完成，不必通过外部的某个信号通知 CPU。对于中断，CPU 必须通过中断请求线获取中断源的信息，才能知道哪个设备发生了何种中断。\n\n所有的异常和中断事件都是由硬件检测发现的。\n异常和中断响应过程\nCPU 执行指令时，如果发生了异常或中断请求，必须进行相应的处理。\n从 CPU 检测到异常或中断事件，到调出相应的处理程序，整个过程称为异常和中断响应。\nCPU 对异常和中断响应的过程可分为：\n\n\n关中断\n在保存断点和程序状态期间，不能被新的中断打断，因此要禁止响应新的中断，即关中断。\n通常通过设置“中断允许”(IF)触发器来实现，若 IF 置为 1，则为开中断，表示允许响应中断；若 IF 置为 0，则表示关中断，表示不允许响应中断。\n\n\n保存断点和程序状态\n为了能在异常和中断处理后正确返回到被中断的程序继续执行，必须将程序的断点（返回地址）送到栈或特定寄存器中。通常保存在栈中，这是为了支持异常或中断的嵌套。\n\n“陷阱”类异常的断点为陷阱指令下一条指令的地址\n“故障”类异常的断点为当前发生异常的指令的地址\n终止”类异常的断点可以是当前指令或下一条指令的地址\n外部中断的断点是当前刚执行完的指令的地址下一条指令的地址\n\n异常和中断处理后可能还要回到被中断的程序继续执行，被中断时的程序状态字寄存器 PSW 的内容也需要保存在栈或特定寄存器中，在异常和中断返回时恢复到 PSW 中。\n\n\n识别异常和中断并转到相应的处理程序\n异常和中断源的识别有软件识别和硬件识别两种方式。\n异常和中断源的识别方式不同，异常大多采用软件识别方式，而中断可以采用软件识别方式或硬件识别方式。\n\n软件识别方式：指 CPU 设置一个异常状态寄存器，用于记录异常原因。操作系统使用一个统一的异常或中断查询程序，按优先级顺序查询异常状态寄存器，以检测异常和中断类型，先查询到的先被处理，然后转到内核中相应的处理程序。\n硬件识别方式：也称向量中断，异常或中断处理程序的首地址称为中断向量，所有中断向量都存放在中断向量表中。每个异常或中断都被指定一个中断类型号。在中断向量表中，类型号和中断向量一一对应，因而可以根据类型号快速找到对应的处理程序。\n\n\n\n整个响应过程是不可被打断的。中断响应过程结束后，CPU 就从 PC 中取出对应中断服务程序的第一条指令开始执行，直至中断返回，这部分任务是由 CPU 通过执行中断服务程序完成的，整个中断处理过程是由软/硬件协同实现的。\n\n\n                  \n                  Tip\n                  \n                \n\n异常和中断的处理过程基本是相同的，这也是有些教材将两者统称为中断的原因。\n但是在有些细节上 CPU 对于异常和中断的响应处理并不一样。例如，检测到中断请求后，CPU 必须通过“中断回答信号启动中断控制器进行中断查询，以确定当前发出的优先级最高的中断请求，并通过数据线获取相应的中断类型号；而对于异常，CPU 无须进行中断回答。\n\n\n指令流水线\n可从两方面提高处理机的并行性：\n\n时间上的并行技术：将一个任务分解为几个不同的子阶段，每个子阶段在不同的功能部件上并行执行，以便在同一时刻能够同时执行多个任务，进而提升系统性能，这种方法被称为流水线技术。\n空间上的并行技术：在一个处理机内设置多个执行相同任务的功能部件，并让这些功能部件并行工作，这样的处理机被称为 超标量处理机。\n\n现代计算机普遍采用指令流水线技术，同一时刻有多条指令在 CPU 的不同功能部件中并发执行，大大提高了功能部件的并行性和程序的执行效率。\n\n\n                  \n                  Tip\n                  \n                \n\n流水 CPU 和多媒体 CPU 无必然联系。多媒体 CPU 是指能够处理多种媒体数据（如图像、音频、视频等）的 CPU，它通常具有特殊的指令集和功能部件，与流水 CPU 的概念不同。\n\n\n基本概念\n一条指令的执行过程可分解为若干阶段，每个阶段由相应的功能部件完成。如果将各阶段视为相应的流水段，则指令的执行过程就构成了一条指令流水线。\n流水线各个阶段\n假设一条指令的执行过程分为如下 5 个阶段（也称功能段或流水段）：\n\n取指(IF, Fetch)：从指令存储器或 Cache 中取指令。\n译码/读寄存器(ID, Decode)：操作控制器对指令进行译码，同时从寄存器堆中取操作数。\n执行/计算地址(EX, Execute)：执行运算操作或计算地址。\n访存(MEM, Memory)：对存储器进行读/写操作，包括修改 PC。\n写回(WB, Writeback)：将指令执行结果写回寄存器堆。\n\n流水线对指令集的要求\n为了利于实现指令流水线，指令集应具有如下特征：\n\n指令长度应尽量一致，有利于简化取指令和指令译码操作。否则，取指令所花的时间长短不一，使得取指部件极其复杂，并且也不利于指令译码。\n指令格式应尽量规整，尽量保证源寄存器的位置相同，有利于在指令未知时就可取寄存器操作数，否则须译码后才能确定指令中各寄存器编号的位置。\n采用 LOAD/STORE 型指令，其他指令都不能访问存储器，这样可把 LOAD/STORE 指令的地址计算和运算指令的执行步骤规整在同一个周期中，有利于减少操作步骤。\n数据和指令在存储器中“按边界对齐”存放。这样，有利于减少访存次数，使所需数据在一个流水段内就能从存储器中得到。\n\n流水线的实现\n设计原则\n在单周期实现中，虽然不是所有指令都必须经历完整的 5 个阶段，但只能以执行速度最慢的指令作为设计其时钟周期的依据，单周期 CPU 的时钟频率取决于数据通路中的最长路径。\n流水线设计的原则：\n\n\n指令流水段个数以最复杂指令所用的功能段个数为准；\n\n\n流水段的长度或者流水段时间以最复杂的操作所花的时间为准。\n假设某条指令的 5 个阶段所花的时间分别如下：取指：200ps；译码：100ps；执行：150ps：访存：200ps：写回：100ps，串行执行时该指令的总执行时间为 750ps。但若按照流水线设计原则，则每个流水段的长度为 200ps，每条指令的执行时间为 1000ps，反而比串行执行时增加了 250ps。\n假设某程序有 N 条指令，单周期处理机所用的时间为 Nx750ps，而流水线处理机所用的时间为(N+4)x200ps。由此可见，流水线方式并不能缩短单条指令的执行时间，但对于整个程序来说执行效率得到了大幅提高。\n\n\n\n\n                  \n                  Note\n                  \n                \n\n1,000 ps (皮秒) = 1 ns (纳秒)\n1,000,000,000 ns (纳秒) = 1 s (秒)\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n指令流水线中每个流水段的时间单位为一个时钟周期。\n假设流水段的长度为 200ps，则 CPU 时钟周期为 200ps。若还有其它需要花费的时间也应该加上，例如流水段寄存器延时为 20ps，则此时 CPU 时钟周期为 220ps。\n\n\n逻辑结构\n每个流水段后面都要增加一个流水段寄存器，用于锁存本段处理完的所有数据，以保证本段的执行结果能在下个时钟周期给下一流水段使用。\n\n\n一条指令会依次进入 IF、ID、EX、MEM、WB 五个功能段进行处理，第一条指令进入 WB 段后，各流水段都包含一条不同的指令，流水线中将同时存在 5 条不同的指令并行执行。\n各种寄存器和数据存储器均采用统一时钟 CLK 进行同步，每来一个时钟，各段处理完的数据都将锁存到段尾的流水段寄存器中，作为后段的输入。同时，当前段也会收到前段通过流水段寄存器传递过来的数据。\n在某个时钟周期内，不同的流水段受不同指令的控制信号控制，执行不同指令的不同功能段，在指令译码阶段由控制器产生指令各流水段的所有控制信号，分别在随后的各个时钟周期内被使用，因此随后各流水段寄存器都要保存相应的控制信号，并通过流水段寄存器传递到下一个流水段。\n\n\n                  \n                  Tip\n                  \n                \n\n每条指令的取指令阶段和指令译码阶段的功能都相同，是公共流水段，且控制信号是指令译码之后才产生的，因此这两个阶段不需要控制信号。\n\n\n不同流水段寄存器存放的信息不同，因此流水段寄存器位数不一定相同。\n流水段寄存器对用户程序是透明的，用户程序不能通过指令指定访问哪个流水段寄存器。\n流水线的表示方法\n指令执行过程图\n主要用于分析指令执行过程以及影响流水线的因素。\n\n从图看出，理想情况下，每个时钟周期都有一条指令进入流水线，每个时钟周期都有一条指令完成，每条指令的时钟周期数（即 CPI）都为 1。\n时空图\n在时空图中，横坐标表示时间，它被分割成长度相等的时间段 T；纵坐标为空间，表示当前指令所处的功能部件。\n在图中，第一条指令 1 在时刻 0 进入流水线，在时刻 5T 流出流水线。第二条指令 L 在时刻 T 进入流水线，在时刻 6T 流出流水线。以此类推，每隔一个时间 T 就有一条指令进入流水线，从时刻 5T 开始每隔一个时间 T 就有一条指令流出流水线。\n\n从图中可看出，在时刻 10T 时，流水线上便有 6 条指令流出。若采用串行方式执行，在时刻 10T 时，只能执行 2 条指令，可见使用流水线方式成倍地提高了计算机的速度。\n只有大量连续任务不断输入流水线，才能充分发挥流水线的性能，而指令的执行正好是连续不断的，非常适合采用流水线技术。对于其他部件级流水线，如浮点运算流水线，同样也仅适合于提升浮点运算密集型应用的性能，对于单个运算是无法提升性能的。\n流水线的冒险与处理\n在指令流水线中，可能会遇到一些情况使得后续指令无法正确执行而引起流水线阻塞，这种现象称为流水线冒险。\n不同类型指令在各流水段的操作是不同。\n\n结构冒险\n由不同指令在同一时刻争用同一功能部件而形成的冲突，也称结构冲突 / 资源冲突，即由硬件资源竞争造成的冲突。\n\n例如，指令和数据通常都存放在同一存储器中，在第 4 个时钟周期，第 i 条 LOAD 指令进入 MEM 段时，第 i+3 条指令的 IF 段也要访存取指令，此时会发生访存冲突，为此可在前一条指令访存时，暂停（一个时钟周期）取后一条指令的操作，如图所示。\n当然，如果第 i 条指令不是 LOAD 指令，在 MEM 段不访存，也就不会发生访存冲突。\n\n解决办法：\n\n\n前一指令访存时，使后一条相关指令（及其后续指令）阻塞若干个时钟周期，直到不会产生冒险为止。\n\n\n\n设置多个独立的部件。例如，对于寄存器访问冲突，可将寄存器的读口和写口独立开来；对于访存冲突，单独设置数据存储器和指令存储器。\n\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n在现代 Cache 机制中，L1 级 Cache 通常采用数据 Cache 和指令 Cache 分离的方式，从而也就避免了资源冲突的发生。\n\n\n数据冒险\n数据冒险也称数据相关。\n引起数据冒险的原因是，后面指令用到前面指令的结果时，前面指令的结果还没有产生。\n在以非乱序执行的流水线中，所有数据冒险都是由于前面指令写结果之前，后面指令就需要读取而造成的，这种数据冒险称为 写后读(ReadAfterWrite, RAW) 冲突。\nI1 add R1, R2, R3 # (R2)+(R3)→R1\nI2 sub R4, R1, R5 # (R1)-(R5)→R4\n在写后读（RAW）冲突中，指令 I2 的源操作数是指令 I1 的目的操作数。正常的读/写顺序是由指令 I1 先写入 R1，再由指令 I2 来读 R1。在非流水线中，这种先写后读的顺序是自然维持的。但在流水线中，由于重叠操作，读/写的先后顺序关系发生了变化，如图所示。\n\n\n\n                  \n                  Tip\n                  \n                \n\n通常分析是否存在数据冒险，只需要从某一条指令开始观察该指令“写”了某个寄存器，并观察后续相邻的 3 条指令是否“读”了同一个寄存器。若发现此类情况，则存在数据冒险。\n\n\n\n解决数据冒险的办法：\n\n\n延迟执行相关指令\n把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期，直到数据相关问题消失后再继续执行。\n可分为软件插入空操作“nop”指令和硬件阻塞(stall)两种方法，确保其 ID 段在”写寄存器指令”的 WB 段之后。\n为此，可以暂停 sub 指令 3 个时钟周期，直至前面 add 指令的结果生成，如图所示。\n\n\n对于 I1 和 I2 的数据相关问题，还可以通过将寄存器的写口和读口分别控制在前、后半个时钟周期内操作，使前半周期写入 R1 的值在后半周期马上被读出，在一个周期内读/写寄存器不会产生冲突，这样 I1 的 WB 段和 I2 的 ID 段就可重叠执行，从而只需延迟 2 个时钟周期。\n\n\n\n采用转发（旁路）技术\n设置相关转发通路，不等前一条指令把计算结果写回寄存器，下一条指令也不再从寄存器读，而将数据通路中生成的中间数据直接转发到 ALU 的输入端。\n如图所示，指令 I1 在 EX 段结束时已得到 R1 的新值，被存放到 EX/MEM 流水段寄存器中，因此可以直接从该流水段寄存器中取出数据返送到 ALU 的输入端，这样，在指令 I2 执行时 ALU 中用的就是 R1 的新值。\n\n增加转发通路后，相邻两条运算类指令之间、相隔一条的两个运算类指令之间的数据相关带来的数据冒险问题就都能解决了。\n\n转发（旁路）技术可以解决大部分数据冒险，但不能解决由 Load 指令写寄存器引 起的 Load-use 数据冒险。\n\n\n\nLoad-use 数据冒险的处理\n如果 Load 指令与其后紧邻的运算类指令存在数据相关问题（如：Load 指令写某个寄存器，相邻的后一条指令读同一个寄存器），则无法通过转发技术来解决，通常把这种情况称为 Load-use 数据冒险。\n对于下列两条指令，Load 指令只有在 MEM 段结束时才能得到主存中的结果，然后送 MEM/WB 流水段寄存器，在 WB 段的前半周期才能存入 R2 的新值，但随后的 add 指令在 EX 阶段就要取 R2 的值，因此，得到的是旧值。\nI2 load r2, 12, (r1) # M[(r1)+12]→(r2)\nI3 add r4, r3, r2 # (r3)+(r2)→(r4)\n对于 Load-use 数据冒险，最简单的做法是由编译器在 add 指令之前插入一条 nop 指令，这样在 add 指令的 EX 段就可以从 MEM/WB 流水段寄存器中取出 Load 指令的最新结果，如图所示。\n\n当然，最好的办法是在程序编译时进行优化，通过调整指令顺序 以避免出现 load-use 现象。\n\n\n控制冒险\n指令通常是顺序执行的，但当遇到改变指令执行顺序的情况，例如执行转移或返回指令、发生中断或异常时，会改变 PC 值，从而造成断流，也称控制冲突。\n对于由转移指令引起的冲突，最简单的处理方法就是推迟后续指令的执行。通常把因流水线阻塞带来的延迟时钟周期数称为延迟损失时间片 C。\n在下列指令中，假设 R2 存放常数 N，R1 的初值为 1，bne 指令在 EX 段通过计算设置条件码，并在 MEM 段确定是否将 PC 值更新为转移目的地址，因此仅当 bne 指令执行到第 5 个时钟结束时才能将转移目标地址送 PC。\nI1 loop:add R1,R1,1 # (R1)+1→R1\nI2 bne R1,R2,loop # if(R1)!=(R2) goto loop\n为此，在数据通路检测到分支指令后，可以在分支指令后插入 C（此处 C =3）条 nop 指令，如图所示。\n\n\n\n                  \n                  为什么只需要延后 3 个时钟 \n                  \n                \n\n\n\n\n控制冒险解决办法：\n\n\n对于由转移指令引起的冲突，可采用和解决数据冲突相同的软件插入“nop”指令 和硬件阻塞(stall) 的方法。\n比如，延迟损失多少时间片，就插入多少条 nop 指令。\n\n\n对转移指令进行分支预测，尽早生成转移目标地址。\n分支预测分为：\n\n静态预测技术：也称静态预测，假定分支总是不发生或者总是发生，每次预测结果是一样的。\n动态预测技术：根据之前条件跳转的比较结果来预测，根据局部性原理，其预测成功率通常比静态预测技术高。\n\n预测错误时，已被错误放入流水线执行的指令必须被舍弃。\n\n\n\n\n                  \n                  Tip\n                  \n                \n\nCache 缺失的处理过程也会引起流水线阻塞。\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n流水段的数量越多，意味着在转移结果确定之前，可能取出更多的错误指令，从而需要更多的时间和资源来处理这些错误指令。即流水段的数量越多，控制冒险引发的开销就越多。\n\n\n流水线性能指标\n吞吐率\n流水线的吞吐率是指在单位时间内流水线所完成的任务数量，或输出结果的数量。\n流水线吞吐率(TP)的最基本公式为 TP=\\frac{n}{T_k}，n 是任务数，T_k 是处理完 n 个任务所用的总时间。\n在输入流水线中的任务连续的理想情况下，一条 k 段流水线能在 k+n-1 个时钟周期内完成 n 个任务，流水线的吞吐率为 TP=\\frac{n}{(k+n-1)\\Delta t}\n连续输入的任务数 n\\longrightarrow \\infty 时，得最大吞吐率 TP_{max}=\\frac{1}{\\Delta t}。\n\n加速比\n完成同样一批任务，不使用流水线与使用流水线所用的时间之比。\n流水线加速比(S)的基本公式为 S=\\frac{T_0}{T_k}，T_0 表示不使用流水线的总时间，T_k 表示使用流水线的总时间。\n一条 k 段流水线完成 n 个任务所需的时间为 T=(k+n-1)\\Delta t。顺序执行 n 个任务时，所需的总时间为 T=kn\\Delta t。将 T 和 T 值代入上式，得出流水线的加速比为 S=\\frac{kn}{k+n-1}。\n连续输入的任务数 n\\longrightarrow \\infty 时，得最大加速比为 S_{max}=k。\n效率\n流水线的设备利用率称为流水线的效率。\n在时空图上，流水线的效率定义为完成 n 个任务占用的时空区有效面积与 n 个任务所用的时间与 k 个流水段所围成的时空区总面积之比。\n\n高级流水线技术\n超标量流水线技术\n也称动态多发射技术，每个时钟周期内可并发多条独立指令，以并行操作方式将两条或多条指令编译并执行，为此需配置多个功能部件和指令译码电路，以及多个寄存器和总线。\n在简单的超标量 CPU 中，指令是按顺序发射执行的。为了更好地提高并行性能，多数超标量 CPU 都结合动态流水线调度技术，通过动态分支预测等手段，指令不按顺序执行，这种方式称为乱序执行。\n\n\n该技术本质上是用空间换时间。\n\n超长指令字技术\n也称静态多发射技术，由编译程序挖掘出指令间潜在的并行性，将多条能并行操作的指令组合成一条具有多个操作码字段的超长指令字（可达几百位），为此需要采用多个处理部件。\n\n超流水线技术\n流水线功能段划分得越多，时钟周期就越短，指令吞吐率也就越高，因此超流水线技术是通过提高流水线主频的方式来提升流水线性能的。但是，流水线级数越多，用于流水寄存器的开销就越大，因而流水线级数是有限制的，并不是越多越好。\n\n超流水线 CPU 在流水线充满后，每个时钟周期还是执行一条指令，CPI = 1，但其主频更高；\n多发射流水线 CPU 每个时钟周期可以处理多条指令，CPI &lt; 1，但其成本更高、控制更复杂。\n常见的五类指令执行过程\n\nwww.bilibili.com/video/BV1ps4y1d73V\n\n\n运算类指令\n\nLOAD 指令\n\nSTORE 指令\n\n条件转移指令\n\n无条件转移指令\n\nQ&amp;A\n\n多处理器\n\n多处理器基本概念\n基于指令流的数量和数据流的数量，将计算机体系结构分为 SISD、SIMD、MISD 和 MIMD 四类。\n常规的单处理器属于 SISD，而常规的多处理器属于 MIMD。\n单指令流单数据流(SISD)结构\n\nSingle Instruction Single Data stream\n\n特性：各指令序列只能并发、不能并行，每条指令处理一两个数据。不是数据级并行技术。\n硬件组成：一个处理器 + 一个主存储器。若采用指令流水线，需设置多个功能部件，采用多模块交叉存储器。\n\n\n\n                  \n                  Note\n                  \n                \n\n标量流水处理机属于 SISD 结构。\n\n\n单指令流多数据流(SIMD)结构\n\nSingle Instruction Multiple Data\n\n特性：各指令序列只能并发、不能并行，但每条指令可同时处理很多个具有相同特征的数据。是一种数据级并行技术。\n硬件组成：一个指令控制部件（CU） + 多个处理单元/执行单元（如 ALU） + 多个局部存储器 + 一个主存储器。每个执行单元有各自的寄存器组、局部存储器、地址寄存器。不同执行单元执行同一条指令，处理不同的数据。\n\n\n\n                  \n                  Note\n                  \n                \n\n阵列处理器就是属于 SIMD 结构。\n\n\n多指令流单数据流(MISD)结构\nMISD 是指同时执行多条指令，处理同一个数据，实际上不存在这样的计算机。\n多指令流多数据流(MIMD)结构\n\nMultiple InstructionStream Multiple Data\n\n特性：各指令序列并行执行，分别处理多个不同的数据。是一种线程级并行、甚至是线程级以上并行技术。\n可以分为：\n\n\n多处理器系统\n各处理器之间，可以通过 LOAD/STORE 指令，访问同一个主存储器，可通过主存相互传送数据。\n一台计算机内，包含多个处理器 + 一个主存储器，一多个处理器共享单一的物理地址空间。\n\n\n\n多计算机系统\n各计算机之间，不能通过 LOAD/STORE 指令直接访问对方的存储器，只能通过“消息传递”相互传送数据。\n由多台计算机组成，因此拥有多个处理器 + 多个主存储器。每台计算机拥有各自的私有存储器，物理地址空间相互独立。\n\n\n\n向量处理器(SIMD 思想的进阶应用)\n特性：一条指令的处理对象是“向量”。擅长对向量型数据并行计算、浮点数运算，常被用于超级计算机中，处理科学研究中巨大运算量\n硬件组成：多个处理单元，多组“向量寄存器”。主存储器应采用“多个端口同时读取 ” 的交叉多模块存储器。主存储器大小限定了机器的解题规模，因此要有大容量的、集中式的主存储器。\n\n多核处理器基本概念\n多核处理器是指将多个处理单元集成到单个 CPU 中，每个处理单元称为一个核(core)，通常也称片上多处理器。每个核既可以有自己的 Cache，又可以共享同一个 Cache，所有核通常共享主存储器。\n双核技术是指将两个一样的 CPU 集成到一个封装内或者直接将两个 CPU 做成一个芯片。\n下图是一个不共享 Cache 的双核 CPU 结构。\n\n\n\n                  \n                  Tip\n                  \n                \n\n多核处理器属于 MIMD 架构。\n\n\n硬件多线程基本概念\n\n在传统 CPU 中，线程的切换包含一系列开销，频繁地切换会极大影响系统的性能，为了减少线程切换过程中的开销，便诞生了硬件多线程。\n在支持硬件多线程的 CPU 中，必须为每个线程提供单独的通用寄存器组、单独的程序计数器等，线程的切换只需激活选中的寄存器，从而省略了与存储器数据交换的环节，大大减少了线程切换的开销。\n\n\n                  \n                  Tip\n                  \n                \n\n硬件多线程技术也可以用于单核处理器。\n\n\n硬件多线程有 3 种实现方式：\n\n\n细粒度多线程\n多个线程之间轮流交叉执行指令，多个线程之间的指令是不相关的，可以乱序并行执行。\n在这种方式下，处理器能在每个时钟周期切换线程。例如，在时钟周期 i，将线程 A 中的多条指令发射执行；在时钟周期 i+1，将线程 B 中的多条指令发射执行。\n\n\n粗粒度多线程\n连续几个时钟周期都执行同一线程的指令序列，仅在当前线程出现了较大开销的阻塞时，才切换线程，如 Cache 缺失。\n在这种方式下，当发生流水线阻塞时，必须清除被阻塞的流水线，新线程的指令开始执行前需要重载流水线，因此，线程切换的开销比细粒度多线程更大。\n\n\n同时多线程\n同时多线程(SMT)是上述两种多线程技术的变体。它在实现指令级并行的同时，实现线程级并行，也就是说，它在同一个时钟周期中，发射多个不同线程中的多条指令执行。\n\n\n\n\n共享内存多处理器的基本概念\n具有共享的单一物理地址空间的多处理器称为共享内存多处理器 (SMP)。\n处理器通过存储器中的共享变量互相通信，所有处理器都能通过存取指令访问存储器的任何位置。即使这些系统共享同一个物理地址空间，它们仍然可在自己的虚拟地址空间中单独地运行程序。\n单一地址空间的多处理器有两种类型：\n\n\n统一存储访问(UMA)多处理器\n每个处理器对所有存储单元的访问时间是大致相同的，即访问时间与哪个处理器提出访存请求及访问哪个字无关。\nUMA 构架由于所有 CPU 共享相同的内存，增加 CPU 路数会加大访存冲突，通常 2 或 4 路的性能最好。\nUMA 构架中所有 CPU 共享同一内存空间，每个 CPU 的 Cache 中都是共享内存中的一部分副本，因此各 CPU 的 Cache 一致性是需要解决的重要问题。\n\n\n非统一存储访问(NUMA)多处理器\n某些存储器的访存速度要比其他的快，具体取决于哪个处理器提出访问请求及访问哪个字，这是由于主存被分割分配给了不同处理器。\nNUMA 理论上支持无限扩展。\n\n\n超线程\n超线程技术是在一个 CPU 中，提供两套线程处理单元，让单个处理器实现线程级并行。\n超线程技术在 CPU 内部仅复制必要的线程资源来让两个线程同时运行，能并行执行两个线程，模拟实体双核。\n虽然采用超线程技术能够同时执行两个线程，但是当两个线程同时需要某个资源时，其中一个线程必须暂时挂起，直到这些资源空闲后才能继续运行。因此，超线程的性能并不等于两个 CPU 的性能。而且，超线程技术的 CPU 需要芯片组、操作系统和应用软件的支持，才能发挥该项技术的优势。"},"计算机基础/计算机组成原理/6_总线":{"title":"总线","links":[],"tags":["计算机组成原理"],"content":"早期计算机的各部件之间是通过单独的连线互连的，这种方式称为分散连接。\n但是，随着 I/O 设备的种类和数量越来越多，为了更好地解决 I/O 设备和主机之间连接的灵活性，计算机的结构从分散连接发展为总线连接。\n总线概念\n\n\n定义\n总线是一组能为多个部件分时和共享的公共信息传送线路。\n分时和共享是总线的两个特点。\n\n分时：同一时刻只允许有一个部件向总线发送信息，若系统中有多个部件，则它们只能分时地向总线发送信息。\n共享：总线上可以挂接多个部件，各个部件之间互相交换的信息都可通过这组线路分时共享，多个部件可同时从总线上接收相同的信息。\n\n设备\n总线上所连接的设备，按其对总线有无控制功能可分为主设备和从设备两种。\n\n主设备：指发出总线请求且获得总线控制权的设备。\n从设备：指被主设备访问的设备，它只能响应从主设备发来的各种总线命令。\n\n特性\n\n机械特性（尺寸、形状）\n电气特性（传输方向和有效的电平范围）\n功能特性（每根传输线的功能）\n时间特性（信号和时序的关系）\n\n总线分类\n按功能层次分类\n片内总线\n芯片内部的总线，用于 CPU 芯片内部各寄存器之间及寄存器与 ALU 的连接。\n系统总线\n计算机系统内各功能部件（CPU、主存、I/O 接口）之间相互连接的总线。\n分类\n按系统总线传输信息内容的不同，又可分为 3 类：数据总线、地址总线、控制总线。\n\n\n数据总线：用来在各部件之间传输数据、指令和中断类型号等，它是双向传输总线，数据总线的位数反映一次能传送的数据的位数。\n\n\n                  \n                  Tip\n                  \n                \n\n各个功能部件通过数据总线连接形成的数据传输路径称为数据通路。数据通路表示的是数据流经的路径，而数据总线是数据传输的媒介。\n\n\n\n\n地址总线：用来指出数据总线上源数据或目的数据所在的主存单元或 I/O 端口的地址，它是单向传输总线，地址总线的位数反映最大的寻址空间。\n由于地址总线是单向的，是从 CPU 发出的，因此从主存中取出的地址是无法通过地址总线传给 CPU，而是通过数据总线传给 CPU。\n\n\n控制总线：用来传输各种命令、反馈和定时信号，典型的控制信号包括时钟、复位、总线请求/允许、中断请求/回答、存储器读/写、I/O 读、I/O 写、传输确认等。\n\n\n\n结构\n单总线结构\n单总线结构将 CPU、主存、I/O 设备（通过 I/O 接口）都挂在一组总线上，允许 I/O 设备之间、I/O 设备与主存之间直接交换信息。\nCPU 与主存、CPU 与外设之间都可以通过总线直接进行信息交换，而无须经过中间设备的干预。\n单总线并不是指只有一根信号线。\n\n优点：结构简单，成本低，易于接入新的设备。\n缺点：带宽低、负载重，多个部件只能争用唯一的总线，且不支持并发传送操作。\n\n\n双总线结构\n双总线结构有两条总线：一条是主存总线，用于在 CPU、主存和通道之间传送数据；另一条是 I/O 总线，用于在多个外部设备与通道之间传送数据。\n\n优点：将低速 I/O 设备从原单总线上分离出来，实现了存储器总线和 IO 总线分离。\n缺点：需要增加通道等硬件设备。\n\n\n三总线结构\n三总线结构是在计算机系统各部件之间采用 3 条各自独立的总线来构成信息通路，这三条总线分别为主存总线、IO 总线和直接内存访问(DMA)总线。\n\n主存总线：用于在 CPU 和内存之间传送地址、数据和控制信息。\nI/O 总线：用于在 CPU 和各类外设之间通信。\nDMA 总线：用于在内存和高速外设之间直接传送数据。\n\n优点：提高了 I/O 设备的性能，使其更快地响应命令，提高系统吞吐量。\n缺点：任意时刻只能使用一种总线，系统工作效率较低。\n\n四总线结构\n\nI/O 总线\n主要用于连接中低速的 I/O 设备，通过 I/O 接口与系统总线相连接，目的是将低速设备与高速总线分离，以提升总线的系统性能，常见的有 USB、PCI 总线。\n通信总线\n计算机系统之间或计算机系统与其他系统（如远程通信设备、测试设备）之间传送信息的总线，通信总线也称外部总线。\n按时序控制方式分类\n同步总线\n总线上连接的部件或设备通过统一的时钟进行同步，在规定的时钟节拍内进行规定的总线操作，来完成部件或设备之间的信息传输。\n一次总线事务不一定在一个时钟周期内完成，即时钟频率不一定等于工作频率。\n异步总线\n总线上连接的部件或设备没有统一的时钟，而以信号握手的方式来协调各部件或设备之间的信息传输，总线操作时序不是固定的。\n每次握手的过程完成一次通信，一次通信往往会交换多位数据。\n按数据传输方式分类\n串行总线\n只有一条双向传输或两条单向传输的数据线，数据按比特位串行顺序传输，其效率低于并行总线。\n\n优点：对数据线的要求不太高，因此适合长距离通信。应用于计算机内部时，可以节省布线空间。\n缺点：在数据发送和接收的时候要进行拆卸和装配，要考虑串行—并行转换的问题。\n\n\nUSB 就是通用串行总线。\n\n并行总线\n有多条双向传输的数据线，可以实现多比特位的同时传输，其效率比串行总线更高。\n\n\n优点：总线的逻辑时序比较简单，电路实现起来比较容易。\n\n\n缺点：各条数据线的传输特点可能存在一些差异，比如有的信息位可能会延迟，并且数据线之间相互干扰还会造成传输错误，因此并行总线适合近距离通信。\n工作频率较高时，并行的信号线之间会产生严重干扰对每条线等长的要求也越高，所以无法持续提升工作频率。\n信号线数量多，占用更多的布线空间。\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n并行总线并不一定总比串行总线快，因为串行总线可通过不断提高工作频率来提高传输速度，使其速度最终超越并行总线的速度。\n\n\n总线性能指标\n\n\n总线时钟周期：即机器的时钟周期。计算机有一个统一的时钟，以控制整个计算机的各个部件，总线也要受此时钟的控制。\n\n\n总线时钟频率：即机器的时钟频率，它为时钟周期的倒数。\n\n\n总线传输周期：即总线周期，指一次总线操作所需的时间，包括申请阶段、寻址阶段、传输阶段和结束阶段。\n总线传输周期通常由若干总线时钟周期构成。多数情况下，一个总线周期包含多个总线时钟周期；有的时候，一个总线周期就是一个总线时钟周期；有的时候，一个总线时钟周期可包含多个总线周期\n\n\n总线工作频率：总线上各种操作的频率，为总线周期的倒数，实际上指1 秒内传送几次数据。\n\n若总线周期 = N 个时钟周期，则总线的工作频率 = 时钟频率/N；\n若一个时钟周期可以传送 K 次数据，则总线工作频率 = 总线时钟频率\\times K。\n\n\n\n总线宽度：总线宽度也称总线位宽，是总线上能够同时传输的数据位数，通常指数据总线的根数，如 32 根称为 32 位总线。\n\n\n总线带宽：单位时间内总线上最多可传输数据的位数，通常用每秒传送信息的字节数来衡量，单位可用字节/秒(B/s)表示。\n总线带宽 = 总线工作频率\\times(总线宽度/8)(B/s) = (总线宽度/8)/总线周期(B/s)。\n\n\n                  \n                  Tip\n                  \n                \n\n在计算实际的有效数据传输率时，要用实际传输的数据量除以耗时，即要排除校验位之类的信息。\n\n\n\n\n                  \n                  Important\n                  \n                \n\n总线带宽（最大传输速率）是指在理想情况下，即所有总线周期都在传输数据的情况下的传输速率，不需要考虑每个总线事务的具体情况。只有在计算平均数据传输率时才需要考虑每个总线事务的具体情况。\n\n\n\n\n                  \n                  Note\n                  \n                \n\n\n\n\n\n\n总线复用：总线复用是指一种信号线在不同的时间传输不同的信息。\n例如，有些总线没有单独的地址线，地址信息通过数据线来传送，这种情况称为地址/数据线复用。因此可以使用较少的线传输更多的信息，从而节省空间和成本。\n\n\n\n信号线数：地址总线、数据总线和控制总线3 种总线数的总和称为信号线数。\n\n\n总线事务\n从请求总线到完成总线使用的操作序列称为总线事务，它是在一个总线周期中发生的一系列活动。\n典型的总线事务包括请求操作、仲裁操作、地址传输、数据传输和总线释放。\n\n请求阶段：主设备（CPU 或 DMA）发出总线传输请求，并且获得总线控制权。\n仲裁阶段：总线仲裁机构决定将下一个传输周期的总线使用权授予某个申请者。\n寻址阶段：主设备通过总线给出要访问的从设备地址及有关命令，启动从模块。\n传输阶段：主模块和从模块进行数据交换，可单向或双向进行数据传送。\n释放阶段：主模块的有关信息均从系统总线上撤除，让出总线使用权。\n\n\n总线上的数据传送方式分为非突发方式和突发方式两种。\n\n\n非突发传送方式\n在每个传送周期内都先传送地址，再传送数据，主、从设备之间通常每次只能传输一个字长的数据。\n\n\n突发（猝发）传送方式\n能够进行连续成组数据的传送，其寻址阶段发送的是连续数据单元的首地址，在传输阶段传送多个连续单元的数据，每个时钟周期可以传送一个字长的信息，但是不释放总线，直到一组数据全部传送完毕后，再释放总线。\n\n\n总线定时\n总线定时是指总线在双方交换数据的过程中需要时间上配合关系的控制，这种控制称为总线定时，其实质是一种协议或规则，主要有同步、异步、半同步和分离式四种定时方式。\n同步定时方式\n所谓同步定时方式，是指系统采用一个统一的时钟信号来协调发送和接收双方的传送定时关系。\n时钟产生相等的时间间隔，每个间隔构成一个总线周期。\n在一个总线周期中，发送方和接收方可以进行一次数据传送。因为采用统一的时钟，每个部件或设备发送或接收信息都在固定的总线传送周期中，一个总线的传送周期结束，下一个总线的传送周期开始。\n\n\n优点：传送速度快，具有较高的传输速率；总线控制逻辑简单。\n缺点：主从设备属于强制性同步；不能及时进行数据通信的有效性检验，可靠性较差。\n\n同步通信适用于总线长度较短及总线所接部件的存取时间比较接近的系统。\n\n同步串行通信方式是发送方时钟直接控制接收方时钟，使双方完全同步的一种逐位传输的通信方式。\n使用同步串行通信时，由于收发双方的时钟严格一致，因此仅在数据块的头尾处添加了开始和结束标记，传输效率较高，但实现的硬件设备也更复杂，所以较少采用。\n异步定时方式\n在异步定时方式中，没有统一的时钟，也没有固定的时间间隔，完全依靠传送双方相互制约的“握手”信号来实现定时控制。\n通常，主设备提出交换信息的“请求”信号，经接口传送到从设备；从设备接到主设备的请求后，通过接口向主设备发出“回答”信号。\n\n优点：总线周期长度可变，能保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换，自动适应时间的配合。\n缺点：比同步控制方式稍复杂一些，速度比同步定时方式慢。\n\n根据**“请求”和“回答”信号的撤销是否互锁**，异步定时方式又分为以下 3 种类型。\n\n\n不互锁方式\n主设备发出“请求”信号后，不必等到接到从设备的“回答”信号，而是经过一段时间便撤销“请求”信号。\n从设备在接到“请求”信号后，发出“回答”信号，并经过一段时间后自动撤销“回答”信号。\n双方不存在互锁关系。速度最快，可靠性最差。\n\n\n\n半互锁方式\n主设备发出“请求”信号后，必须在接到从设备的“回答”信号后，才撤销“请求”信号，有互锁的关系。\n从设备在接到“请求”信号后，发出“回答”信号，但不必等待获知主设备的“请求”信号已经撤销，而是隔一段时间后自动撤销“回答”信号，不存在互锁关系。\n\n\n\n全互锁方式\n主设备发出“请求”信号后，必须在从设备“回答”后才撤销“请求”信号。\n从设备发出“回答”信号后，必须在获知主设备“请求”信号已撤销后，再撤销其“回答”信号。\n双方存在互锁关系。速度最慢，可靠性最高。\n\n\n\n现在越来越多的总线采用异步串行通信方式，使用异步串行通信时，由于收发双方时钟不严格一致，因此每个字符都要用开始位和停止位作为字符开始和结束的标志，从而保证数据传输的准确性。异步串行通信的第一位是开始位，表示字符传送的开始。\n当通信线上没有数据传送时处于逻辑“1”状态，当发送方要发送一个字符时，首先发出一个逻辑“0”信号，即开始位。接收方检测到这个逻辑低电平后，就开始准备接收数据位。\n在字符传送过程中，数据位从最低位开始，一位一位地传输。当字符发送完后，就可以发送奇偶校验位（可选），以用于有限的差错检测。在奇偶位或数据位之后发送的是停止位，表示一个字符数据的结束。\n半同步定时方式\n半同步定时方式保留了同步定时和异步定时的特点。\n\n同步：发送方用系统时钟前沿发信号；接收方用系统时钟后沿判断识别。\n异步：允许不同速度的设备和谐地工作\n\n在统一时钟的基础上增设一条 Wait 响应信号线。\n例如，某个半同步总线总是从某个时钟开始，在每个时钟到来时，采样 Wait 信号，若无效，则说明数据未准备好，下个时钟到来时，再采样 Wait 信号，直到检测到有效，再去数据线上取数据。\n\n\n优点：控制方式比异步定时简单，各模块在系统时钟的控制下同步工作，可靠性较高。\n缺点：系统时钟频率不能太高，所以从整体上来看，系统工作的速度不是很高。\n\n半同步定时适用于系统工作速度不高，但又包含了由许多速度差异较大的各类设备组成的简单系统。\n分离式定时方式\n\n分离式定时方式将总线事务分解为请求和应答两个子过程。\n\n在第一个子过程中，主设备 A 获得总线使用权后，将命令、地址等信息发到总线上，经总线传输后由从设备 B 接收。此过程占用总线的时间很短，主设备一旦发送完，立即释放总线，以便其他设备使用。\n在第二个子过程中，设备 B 收到设备 A 发来的有关命令后，将设备 A 所需的数据准备好后，便由设备 B 申请总线使用权，一旦获准，设备 B 便将相应的数据送到总线上，由设备 A 接收。\n\n上述两个子过程都只有单方向的信息流，每个设备都变为主设备。\n\n优点：在不传送数据时释放总线，使总线可接受其他设备的请求，不存在空闲等待时间。\n缺点：控制复杂，开销也大。\n"},"计算机基础/计算机组成原理/7_IO系统":{"title":"I/O 系统","links":[],"tags":["计算机组成原理"],"content":"I/O 系统基本概念 *\n\n\n输入/输出系统\n输入/输出是以主机为中心而言的，将信息从外部设备传送到主机称为输入，反之称为输出。\n输入/输出系统解决的主要问题是对各种形式的信息进行输入和输出的控制。\n\n\nI/O 控制方式\n\n程序查询方式：由 CPU 通过程序不断查询 I/O 设备是否已做好准备，从而控制 I/O 设备与主机交换信息。\n程序中断方式：只在 I/O 设备准备就绪并向 CPU 发出中断请求时才予以响应。\nDMA 方式：主存和 I/O 设备之间有一条直接数据通路，当主存和 I/O 设备交换信息时，无须调用中断服务程序\n通道方式：在系统中设有通道控制部件，每个通道都挂接若干外设，主机在执行 I/O 命令时，只需启动有关通道，通道将执行通道程序，从而完成 I/O 操作。\n\n\n\n外部设备\n\n输入设备\n输出设备\n外部存储器（辅存）\n\n\n\nI/O 接口\nI/O 接口：也称I/O 控制器、设备控制器，是主机和外设之间的交接界面，可以通过接收主机发送的 I/O 控制信号实现主机和外设之间的信息交换。\n\n打印机适配器、网络控制器、可编程中断控制器等属于 I/O 接口。\n\n功能\nI/O 接口的主要功能如下：\n\n\n进行地址译码和设备选择：CPU 送来选择外设的地址码后，接口必须对地址进行译码以产生设备选择信息，使主机能和指定外设交换信息。\n\n\n实现主机和外设的通信联络控制：解决主机与外设时序配合问题，协调不同工作速度的外设和主机之间交换信息，以保证整个计算机系统能统一、协调地工作。\n\n\n实现数据缓冲：CPU 与外设之间的速度往往不匹配，为消除速度差异，接口必须设置数据缓冲寄存器，用于数据的暂存，以避免因速度不一致而丢失数据。\n\n\n信号格式的转换：外设与主机两者的电平、数据格式都可能存在差异，接口应提供主机与外设的信号格式的转换功能，如电平转换、并/串或串/并转换、模/数或数/模转换等。\n\n\n传送控制命令和状态信息：CPU 要启动某外设时，通过接口中的命令寄存器向外设发出启动命令；外设准备就绪时，则将“准备好”状态信息送回接口中的状态寄存器，并反馈给 CPU。外设向 CPU 提出中断请求时，CPU 也应有相应的响应信号反馈给外设。\n\n\n基本结构\n\n\n数据缓冲寄存器：用来暂存与 CPU 或内存之间传送的数据信息;\n状态寄存器：用来记录接口和设备的状态信息;\n控制寄存器：用来保存 CPU 对外设的控制信息;\n数据线：传送读/写数据、状态信息、控制信息和中断类型号。\n地址线：传送要访问 I/O 接口中的寄存器的地址。\n控制线：传送读/写控制信号，以确认是读寄存器还是写寄存器，此外控制线还会传送中断请求和响应信号、仲裁信号和握手信号。\n\n\n\n                  \n                  Tip\n                  \n                \n\n状态寄存器和控制寄存器传送方向相反，访问时间错开，因此可将它们合二为一。换句话说，状态端口和控制端口可以共用同一个寄存器。\n\n\nI/O 接口中的I/O 控制逻辑的任务：\n\n对控制寄存器中的命令字进行译码，并将译码得到的控制信号通过外设界面控制逻辑送到外设；\n将数据缓冲寄存器的数据发送到外设或从外设接收数据到数据缓冲寄存器；\n收集外设状态到状态寄存器；\n\n对数据缓冲寄存器、状态/控制寄存器的访问操作是通过相应的指令来完成的，通常称这类指令为 I/O 指令，I/O 指令只能在操作系统内核的底层 I/O 软件中使用，它们是一种特权指令。\n\n\n                  \n                  Tip\n                  \n                \n\n主机和外设之间的连接通路是：CPU 和主存——I/O 总线——I/O 接口——通信总线（电缆）——I/O 接口——外设。\n\n\n工作原理\n\n\n\n                  \n                  Tip\n                  \n                \n\n对打印机的中断控制过程通常是：\nCPU 先将需要打印的字符编码送到打印控制接口（也称打印适配器）中，打印控制接口再将字符编码转换为点阵信息，然后通过电缆传送到打印机，以控制打印针头在何处进行打印。\n同时，打印控制接口需要将“初始化”“选通”“自动走纸”等控制信息通过电缆传送到打印机，并通过电缆把打印机的“联机”“忙”“缺纸”等状态信号取到打印控制接口，以供 CPU 读取。\n中断请求信号是打印控制接口通过中断控制器发送给 CPU 的，因此不在打印控制接口和打印机之间进行交换。\n\n\nI/O 端口编址\nI/O 端口是指 I/O 接口电路中可被 CPU 直接访问的寄存器，主要有数据端口、状态端口和控制端口。\n通常，CPU 能够对数据端口中的数据进行读/写操作；但对状态端口中的外设状态只能进行读操作，对控制端口中的各种控制命令只能进行写操作。I/O 端口要想能够被 CPU 访问，就必须要对各个端口进行编址，每个端口对应一个端口地址。\n编址方式：\n\n\n独立编址\n独立编址也称 I/O 映射方式，是指对所有的 I/O 端口单独进行编址。\nI/O 端口的地址空间与主存地址空间是两个独立的地址空间，它们的范围可以重叠，相同地址可能属于不同的地址空间。因此需设置专门的 I/O 指令来表明访问的是 I/O 地址空间，I/O 指令的地址码给出 I/O 端口号。\n优点：I/O 端口数比主存单元数少得多，只需少量地址线，使得 I/O 端口译码简单，寻址速度更快。使用专用 I/O 指令，可使得程序更加清晰，便于理解和检查。\n缺点：I/O 指令少，只提供简单的传输操作，所以程序设计的灵活性较差。CPU 需要提供存储器读/写、I/O 设备读/写两组控制信号，增大了控制的复杂性。\n\n\n                  \n                  Tip\n                  \n                \n\nI/O 指令是指令系统的一部分，是机器指令的一类，但其为了反映与 I/O 设备交互的特点，格式和其他通用指令相比有所不同。\n\n\n\n\n统一编址\n统一编址也称存储器映射方式，是指把主存地址空间分出一部分给 I/O 端口进行编址，I/O 端口和主存单元在同一地址空间的不同分段中，根据地址范围就能区分访问的是 I/O 端口还是主存单元，因此无须设置专门的 I/O 指令，用统一的访存指令就可访问 I/O 端口，并靠指令不同的地址码区分不同的 I/O 设备和存储单元。\n优点：不需要专门的 IO 指令，使得 CPU访问 I/O 的操作更加灵活和方便，还使端口有较大的编址空间。I/O 访问的保护机制可由虚拟存储管理系统来实现，无须专门设置。\n缺点：端口地址占用了部分主存地址空间，使主存可用容量变小。由于在识别 I/O 端口时全部地址线都需要参加译码，使得译码电路变得更复杂，降低了译码速度。\n\n\n\nI/O 接口类型\n从不同的角度看，I/O 接口可以分为不同的类型。\n\n按数据传送方式，可分为并行接口（一字节或一个字的所有位同时传送）和串行接口（一位一位地有序传送），接口要完成数据格式的转换。\n按主机访问 I/O 设备的控制方式，可分为程序查询接口、中断接口和DMA 接口等。\n按功能选择的灵活性，可分为可编程接口（通过编程改变接口功能）和不可编程接口。\n\nI/O 方式\n输入/输出系统实现主机与 I/O 设备之间的数据传送，可以采用不同的控制方式，各种方式在代价、性能、解决问题的着重点等方面各不相同，常用的 I/O 方式有程序查询、程序中断和 DMA 等。\n\n程序查询方式\n\nwww.bilibili.com/video/BV1ps4y1d73V\n\n信息交换的控制直接由 CPU 执行程序实现。程序查询方式接口中设置一个数据缓冲寄存器（数据端口）和一个设备状态寄存器（状态端口）。\n主机进行 IO 操作时，先读取设备的状态并根据设备状态决定下一步操作究竞是进行数据传送还是等待。\n在程序查询方式中，CPU 与外设串行工作，传送与主程序串行工作。\n\n\n程序查询方式可分为如下两类：\n\n独占查询：一旦设备被启动，CPU 就一直持续查询接口状态，CPU 花费 100%的时间用于 I/O 操作，此时外设和 CPU 完全串行工作。\n定时查询：CPU 周期性地查询接口状态，每次总是等到条件满足才进行一个数据的传送，传送完成后返回到用户程序。定时查询的时间间隔与设备的数据传输速率有关。\n\n程序中断方式\n程序中断基本概念\n程序中断是指在计算机执行程序的过程中，出现某些急需处理的异常情况或特殊请求，CPU 暂时中止现行程序，而转去对这些异常情况或特殊请求进行处理，处理完毕后再返回到原程序的断点处，继续执行原程序。\n中断技术主要功能有：\n\n实现 CPU 与 I/O 设备的并行工作。\n处理硬件故障和软件错误。\n实现人机交互，用户干预机器需要用到中断系统。\n实现多道程序、分时操作，多道程序的切换需借助于中断系统。\n实时处理需要借助中断系统来实现快速响应。\n实现应用程序和操作系统（管态程序）的切换，称为软中断。\n多处理器系统中各处理器之间的信息交流和任务切换。\n\n\n程序中断方式的思想：\nCPU 在程序中安排好在某个时机启动某台外设，然后 CPU 继续执行当前的程序，不需要像查询方式那样一直等待外设准备就绪。\n一旦外设完成数据传送的准备工作，就主动向 CPU 发出中断请求。在可以响应中断的条件下，CPU 暂时中止正在执行的程序，转去执行中断服务程序为外设服务，在中断服务程序中完成一次主机与外设之间的数据传送，实现 CPU 的通用寄存器和外设接口中的寄存器之间的直接数据交换。\n传送完成后，CPU 返回原来的程序。此时，外设和 CPU 又开始并行工作。\n\n\n\n                  \n                  Tip\n                  \n                \n\n通常外设准备数据的时间 &gt; 中断处理时间。\n以输入设备为例，设备为进程准备的数据会先写入设备控制器的缓冲区（缓冲区的大小是有限的），缓冲区没写满一次就向 CPU 发送一次中断请求，CPU 响应并处理中断的过程就是将缓冲区的数据“取走”的过程，因此若是若外设准备数据的时间小于中断处理时间，则可能导致外设往缓冲区写入数据的速度快于 CPU 从缓冲区中取走数据的速度，从而导致缓冲区的数据被覆盖，进而导致数据丢失。\n\n\n从宏观上看，虽然程序中断方式克服了程序查询方式中 CPU 的等待现象，提高了 CPU 的利用率。\n但从微观操作分析，CPU 在处理中断时，仍需暂停原程序的运行，尤其是当高速设备频紧成批地与主存交换信息时，需要不断打断 CPU 执行现行程序而去执行中断服务程序。\n总的来说，在中断方式中，CPU 与外设并行工作，传送与主程序是串行工作的。\n\n程序中断的工作流程\n\nwww.bilibili.com/video/BV1ps4y1d73V\n\n中断请求\n中断源是请求 CPU 中断的设备或事件，一台计算机允许有多个中断源。每个中断源向 CPU 发出中断请求的时间是随机的。\n为记录中断事件并区分不同的中断源，中断系统需对每个中断源设置中断请求标记触发器，当其状态为“1”时，表示该中断源有请求。这些触发器可组成中断请求标记寄存器，该寄存器可集中在 CPU 中，也可分散在各个中断源中。\n通过 INTR 线发出的是可屏蔽中断，通过 NMI 线发出的是不可屏蔽中断。\n可屏蔽中断的优先级最低，在关中断模式下不被响应。不可屏蔽中断用于处理紧急和重要的事件，如时钟中断、电源掉电等，其优先级最高，其次是内部异常，即使在关中断模式下也被响应。\n\n\n                  \n                  Tip\n                  \n                \n\n因为 CPU 无法对发生的中断请求立即进行处理，因此需要在 I/O 接口中设置中断触发器，以保存是哪些外设发出了中断请求，等 CPU 当前的指令周期结束后，响应中断并进行处理。\n\n\n中断响应过程\nCPU 响应中断的条件\nCPU 在满足一定的条件下响应中断源发出的中断请求，并经过一些特定的操作，转去执行中断服务程序。\nCPU 响应中断必须满足以下 3 个条件：\n\n中断源有中断请求。\nCPU 允许中断及开中断（异常和不可屏蔽中断不受此限制）。\n一条指令执行完毕（异常不受此限制），且没有更紧迫的任务。\n\nI/O 设备的就绪时间是随机的，而 CPU 在统一的时刻即每条指令执行结束时，采样中断请求信号（开中断的情况下），以获取 I/O 的中断请求，也就是说，CPU 响应中断的时间是在每条指令执行阶段的结束时刻。\n因此在每条指令执行结束时（而不是执行过程中），CPU 统一扫描各个中断源，检查有无中断请求。\n\n\n                  \n                  Warning\n                  \n                \n\n这里说的中断仅指 I/O 中断，异常不属于此类情况。异常是在指令执行过程中检测的。\n\n\n中断响应判优\n由于许多中断源提出中断请求的时间都是随机的，因此当多个中断源同时提出请求时，需通过中断判优逻辑来确定响应哪个中断源的请求，中断响应的判优通常是通过硬件排队器（或中断查询程序）实现的。\n\n\n一般来说，不可屏蔽中断 &gt; 内部异常 &gt; 可屏蔽中断；\n在内部异常中，硬件故障 &gt; 软件中断；DMA 中断请求 &gt; I/O 设备的中断请求；\n在 IO 传送类中断请求中，高速设备 &gt; 低速设备；输入设备 &gt; 输出设备；实时设备 &gt; 普通设备。\n\n\n中断优先级包括\n\n\n响应优先级：CPU 响应中断请求的先后顺序，由硬件线路或查询程序的查询顺序决定，不可动态改变。它反映的是多个中断同时请求时哪个先被响应，即中断服务程序开始执行的顺序。\n\n\n处理优先级：多重中断的实际优先级处理次序，可以利用中断屏蔽技术动态调整，从而可以灵活地调整中断服务程序的优先级，使中断处理更加灵活。在多重中断系统中，中断处理优先级决定了本中断是否能打断正在执行的中断服务程序，决定了多个中断服务程序执行完的次序。\n\n\n\n若不使用中断屏蔽技术，则处理优先级和响应优先级相同。\n\n现代计算机一般使用中断屏蔽技术，每个中断源都有一个屏蔽触发器(MASK)，1 表示屏蔽该中断源的请求，0 表示可以正常请求，所有屏蔽触发器组合在一起便构成一个屏蔽字寄存器，屏蔽字寄存器的内容称为屏蔽字。\n\n\n图中所指的优先级是处理优先级而不是响应优先级。\n\n\n中断响应处理过程\nCPU 响应中断后，经过某些操作，转去执行中断服务程序。\n这些操作是由硬件直接实现的，我们将它称为中断隐指令。中断隐指令并不是指令系统中的一条真正的指令，只是一种虚拟的说法，本质上是硬件的一系列自动操作。\n它所完成的操作如下：\n\n\n关中断：CPU 响应中断后，首先要保护程序的断点和现场信息，在保护断点和现场的过程中，CPU 不能响应更高级中断源的中断请求。否则，若断点或现场保存不完整，在中断服务程序结束后，就不能正确地恢复并继续执行现行程序。\n\n\n保存断点：为保证在中断服务程序执行完后能正确地返回到原来的程序，必须将原程序的断点（指令无法直接读取的PC和PSW的内容）保存在栈或特定寄存器中。\n\n\n                  \n                  Tip\n                  \n                \n\n异常指令通常并没有执行成功，异常处理后要重新执行，所以异常断点通常是当前指令的地址，中断的断点则是下一条指令的地址。\n\n\n\n\n引出中断服务程序：识别中断源，将对应的服务程序入口地址送入程序计数器 PC。有两种方法识别中断源：硬件向量法、软件查询法。\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n在中断响应周期中，采用硬件方法保护并更新 PC 内容，而不由软件完成，这样可以避免因为软件保存和恢复 PC 内容而造成的时间开销和错误风险，提高中断处理的效率和正确性。\n\n\n中断向量\n中断识别分为向量中断和非向量中断两种。\n每个中断源都有一个唯一的类型号，每个中断类型号都对应一个中断服务程序，每个中断服务程序都有一个入口地址，即中断向量，CPU 必须找到入口地址。\n\n\n                  \n                  Note\n                  \n                \n\n把系统中的全部中断向量集中存放到存储器的某个区域内，这个存放中断向量的存储区就称为中断向量表，中断向量表由操作系统初始化。\n\n\n\n\n                  \n                  Note\n                  \n                \n\n中断服务程序是处理器处理的紧急事件，可理解为一种服务，是事先编好的某些特定的程序，一般属于操作系统的模块，以供调用执行。\n\n\nCPU 响应中断后，通过识别中断源获得中断类型号，然后据此计算出对应中断向量的地址；再根据该地址从中断向量表中取出中断服务程序的入口地址，并送入程序计数器 PC，以转去执行中断服务程序，这种方法被称为中断向量法，采用中断向量法的中断被称为向量中断。\n中断向量由硬件产生，并且不同的中断源对应不同的中断服务程序，因此通过该方法，可以较快速地识别中断源。\n\n中断请求和响应信号是在 I/O 总线的控制线上传送的。CPU 响应某一中断后，就从数据线上获取该中断源的中断类型号，并据此计算对应中断向量在中断向量表中的位置。\n中断完整处理过程\n程序中断过程是由硬件（称中断隐指令）和中断服务程序共同完成的。\n\n中断处理流程如下：\n\n\n关中断\n\n\n保存断点：保存 PC 和 PCW 寄存器\n\n\n中断服务程序寻址\n\n\n保存现场和屏蔽字：进入中断服务程序后首先要保存现场和中断屏蔽字，现场信息是指用户可见的工作寄存器（通常就是通用寄存器）的内容，它存放程序执行到断点处的现行值。\n\n\n开中断：允许更高级中断请求得到响应，以实现中断嵌套。\n\n\n执行中断服务程序：这是中断请求的目的。\n\n\n关中断：保证在恢复现场和屏蔽字时不被中断。\n\n\n恢复现场和屏蔽：将现场和屏蔽字恢复到原来的状态。\n\n\n开中断、中断返回：中断服务程序的最后一条指令通常是一条中断返回指令，使其返回到原程序的断点处，以便继续执行原程序。但与无条件转移指令不同的是，它不仅要修改 PC 值，而且要将 CPU 中的所有寄存器都恢复到中断前的状态。\n\n\n其中，1 ～ 3 由中断隐指令（硬件自动）完成；4 ～ 9 由中断服务程序完成。\n\n\n                  \n                  Tip\n                  \n                \n\n现场和断点，这两类信息都不能被中断服务程序破坏。\n\n由于现场信息用指令可直接访问，因此通常在中断服务程序中通过指令把它们保存到栈中，即由软件实现。换句话说，在 CPU 响应中断的时候，通用寄存器的内容由中断服务程序保存。\n断点信息由 CPU 在中断响应时自动保存到栈或指定的寄存器中，即由硬件实现。\n\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n若是单重中断（或称单级中断），则在上述流程中去掉 5 和 7 即可。\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n允许中断触发器置 0 表示关中断，在中断响应周期由硬件自动完成，即中断隐指令完成。\n虽然关中断指令也能实现关中断的功能，但在中断响应周期，关中断是由中断隐指令完成的。在恢复现场和屏蔽字的时候则由关中断指令来完成的。\n\n\n多重中断\n在 CPU 执行中断服务程序的过程中，若又出现了新的优先级更高的中断请求，而 CPU 对新的中断请求不予响应，则称这种中断为单重中断。\n若 CPU 暂停现行的中断服务程序，转去处理新的中断请求，则称这种中断为多重中断，也称中断嵌套。\nCPU 要具备多重中断的功能，必须满足下列条件：\n\n在中断服务程序中提前设置开中断指令。\n优先级别高的中断源有权中断优先级别低的中断源。\n\n\nDMA 方式\n\nwww.bilibili.com/video/BV1ps4y1d73V\n\nDMA(Direct Memory Access) 方式是一种完全由硬件进行成组信息传送的控制方式，它具有程序中断方式的优点，即在数据准备阶段，CPU 与外设并行工作。\nDMA 方式在外设与内存之间开辟了一条“直接数据通路”，信息传送不再经过 CPU，降低了 CPU 在传送数据时的开销，因此称为直接存储器存取方式。\n由于数据传送不经过 CPU，因此不需要保护、恢复 CPU 现场等操作。这种方式适用于磁盘、显卡、声卡、网卡等高速设备大批量数据的传送，它的硬件开销比较大。\n在 DMA 方式中，中断的作用仅限于故障和正常传送结束时的处理。\n特点\n主存和 DMA 接口之间有一条直接数据通路。由于 DMA 方式传送数据不需要经过 CPU，因此不必中断现行程序，I/O 与主机并行工作，程序和传送并行工作。\nDMA 方式具有下列特点：\n\n它使主存与 CPU 的固定联系脱钩，主存既可被 CPU 访问，又可被外设访问。\n在数据块传送时，主存地址的确定、传送数据的计数等都由硬件电路直接实现。\n主存中要开辟专用缓冲区，以及时提供和接收外设的数据。\nDMA 传送速度快，CPU 和外设并行工作，提高了系统效率。\nDMA 在传送开始前要通过程序进行预处理，结束后要通过中断方式进行后处理。\n\n\n\n                  \n                  Tip\n                  \n                \n\n只有具有 DMA 接口的设备才能产生 DMA 请求，即使当前设备是高速设备或需要与主机批量交换数据，若没有 DMA 接口的话，也不能产生 DMA 请求。\n\n\nDMA 控制器的组成\n\n在 DMA 方式中，对数据传送过程进行控制的硬件称为 DMA 控制器（DMA 接口）。\n当 I/O 设备需要进行数据传送时，通过 DMA 控制器向 CPU 提出 DMA 传送请求，CPU 响应之后将让出系统总线，由 DMA 控制器接管总线进行数据传送。\n主要功能如下：\n\n接受外设发出的 DMA 请求，并向 CPU 发出总线请求。\nCPU 响应并发出总线响应信号，DMA 接管总线控制权，进入 DMA 操作周期。\n确定传送数据的主存起始地址及长度，并自动修改主存地址计数和传送长度计数。\n规定数据在主存和外设间的传送方向，发出读/写等控制信号，执行数据传送操作。\n向 CPU 报告 DMA 操作结束。\n\n\n在 DMA 传送过程中，DMA 控制器接管系统总线。而当 DMA 传送结束后，将恢复 CPU 的切权利并开始执行其操作。由此可见，DMA 控制器必须具有控制系统总线的能力。\n\n\n                  \n                  Tip\n                  \n                \n\nDMA 控制器不仅能为高速设备服务，也能同时为多个慢速外设服务，例如多路型 DMA 控制器。\n\n\nDMA 传送过程\n\n\n\n预处理\n由 CPU 完成一些必要的准备工作。\n首先，初始化 DMA 控制器中的有关寄存器、设置传送方向、测试并启动设备等。然后，CPU 继续执行原程序，直到 I/O 设备准备好发送的数据（输入情况）或接收的数据（输出情况）时，I/O 设备向 DMA 控制器发送 DMA 请求，再由 DMA 控制器向 CPU 发出总线请求（这两个过程也可统称 DMA 请求），用以传输数据。即 DMA 请求：I/O 设备 → DMA 控制器 → CPU\n\n\n                  \n                  Tip\n                  \n                \n\n每个机器周期结束后或总线空闲，CPU 就可以响应 DMA 请求。\n\n\n\n\n                  \n                  Note\n                  \n                \n\nDMA 传送前是由设备驱动程序设置传送参数。每类设备都配置一个设备驱动程序，设备驱动程序向上层用户程序提供一组标准接口，负责实现对设备发出各种具体操作指令，用户程序不能直接和 DMA 打交道。\n\n\n\n\n数据传送\nDMA 以数据块为基本传送单位。\nDMA 占用总线后的数据输入/输出操作都是通过循环来实现的，这一循环也是由 DMA 控制器实现的，即数据传送阶段完全由 DMA（硬件）控制。\n\n\n后处理\nDMA 控制器向 CPU 发送中断请求，CPU 执行中断服务程序做 DMA 结束处理，包括校验数据（出错则转诊断程序）等后处理工作。\n在 DMA 方式下，整个数据块的传送过程都不需要 CPU 参与，CPU 只在最初的 DMA 控制器初始化和最后的 DMA 结束处理时才介入，因此 CPU 用于 I/O 的开销非常小。\n\n\n\n\n                  \n                  Tip\n                  \n                \n\nDMA 方式只是在后处理阶段需要用中断方式请求 CPU 做结束处理，但在整个数据传送过程，并不需要中断请求。\n\n\n\nDMA 传送方式\n主存和 I/O 设备之间交换信息时，不通过 CPU。但当 I/O 设备和 CPU 同时访问主存时，可能发生冲突，为了有效地使用主存，DMA 与 CPU 通常采用以下 3 种方式使用主存。\n停止 CPU 访存\n当 I/O 设备有 DMA 请求时，由 DMA 接口向 CPU 发送一个停止信号，使 CPU 放弃总线控制权，停止访问主存，直到 DMA 传送一块数据结束。\n数据传送结束后，DMA 接口通知 CPU 可以使用主存，并把总线控制权交回给 CPU。\n\n优点：控制简单，适用于数据传输速率很高的 I/O 设备实现成组数据的传送。\n缺点：DMA 在访问主存时，CPU 基本上处于不工作状态。\nDMA 与 CPU 交替访存\n将 CPU 的工作周期分成两个时间片，一个给 CPU 访存，另一个给 DMA 访存，这样在每个 CPU 周期内，CPU 和 DMA 就都可以轮流访存。\n这种方式适用于 CPU 的工作周期比主存存取周期长的情况。例如，若 CPU 的工作周期是 1.2us，主存的存取周期小于 0.6us，则可将一个 CPU 周期分为 C 和 C 两个周期，其中 C 专供 DMA 访存，C2 专供 CPU 访存。\n这种方式不需要申请、建立和归还总线使用权，总线使用权是通过 C 和 C 分时控制的。\n\n优点：不需要总线控制权的申请、建立和归还过程，具有很高的传送速率。\n缺点：相应的硬件逻辑变得更复杂。\n周期挪用\n由于 I/O 访存的优先级高于 CPU 访存（I/O 不立即访存就可能丢失数据），因此由 I/O 设备挪用一个存取周期，传送完一个数据字后立即释放总线。\nCPU 对 DMA 的响应可在指令执行过程中的任何两个存取周期之间。\n它是一种单字传送方式。\n当 I/O 设备有 DMA 请求时，会遇到 3 种情况：\n\n此时 CPU 不在访存，因此 I/O 的访存请求与 CPU 未发生冲突；\nCPU 正在访存，此时必须待存取周期结束后，CPU 再将总线占有权让出；\nI/O 和 CPU 同时请求访存，出现访存冲突，此时 CPU 要暂时放弃总线占有权。\n\n\n优点：既实现了 I/O 传送，又较好地发挥了主存与 CPU 的效率。\n缺点：每挪用一个主存周期，DMA 接口都要申请、建立和归还总线控制权。\nDMA 方式和中断方式的区别\n\nQ&amp;A\n"},"计算机基础/计算机网络/1_计算机网络体系结构":{"title":"计算机网络体系结构","links":[],"tags":["计算机网络"],"content":"概念\n一般认为，计算机网络是一个将众多分散的、自治的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。\n计算机网络（简称网络）由若干结点(node)和连接这些结点的链路(link)组成。\n网络中的结点可以是计算机、集线器、交换机或路由器等。网络之间还可通过路由器互连，构成一个覆盖范围更广的计算机网络，这样的网络称为互连网(internet)。\n\n于是，我们可以这样理解：网络把许多计算机连在一起，而互连网则把许多网络通过路由器连在一起。\n\n\n\n\n                  \n                  internet 和 Internet 的区别 \n                  \n                \n\n\ninternet（互连网）：一个通用名词，泛指由多个计算机网络互连而成的计算机网络。在这些网络之间可以使用任意的通信协议作为通信规则，不一定非要使用 TCP/IP 协议。\nInternet（互联网或因特网）：一个专用名词，指当前全球最大的、开放的、由众多网络和路由器互连而成的特定计算机网络，它采用TCP/IP 协议族作为通信规则。\n\n\n\n\n因特网简介 *\n\n\n\n\n组成\n从不同的角度看，可将计算机网络的组成分为如下几类。\n\n\n从组成部分看，计算机网络主要由硬件、软件、协议三大部分组成。\n\n硬件：主要由主机（也称端系统）、通信链路（如双绞线、光纤）、交换设备（如路由器、交换机等）和通信处理机（如网卡）等组成。\n软件：主要包括各种实现资源共享的软件和方便用户使用的各种工具软件（如 E-mail 程序、FTP 程序、聊天程序等）。\n协议：计算机网络的核心，如同交通规则制约汽车驾驶一样，协议规定了网络传输数据时所遵循的规范。\n\n\n\n从工作方式看，计算机网络可分为边缘部分和核心部分。\n\n边缘部分：由所有连接到互联网上的供用户直接使用的主机组成，用来进行通信和资源共享；\n核心部分：由大量网络和连接这些网络的路由器组成，它为边缘部分提供连通性和交换服务。\n\n\n\n\n从功能组成看，计算机网络由通信子网和资源子网组成。\n\n通信子网：由各种传输介质、通信设备和相应的网络协议组成，它使网络具有数据传输、交换、控制和存储的能力，实现联网计算机之间的数据通信。\n资源子网：实现资源共享功能的设备及其软件的集合，向网络用户提供共享其他计算机上的硬件资源、软件资源和数据资源的服务。\n\n\n\n功能\n主要有以下 5 大功能\n\n\n数据通信\n数据通信是计算机网络最基本和最重要的功能，用来实现联网计算机之间各种信息的传输，并联系分散在不同地理位置的计算机，进行统一的调配、控制和管理。\n\n\n资源共享资源\n共享既可是软件共享、数据共享，又可是硬件共享。它使计算机网络中的资源互通有无、分工协作，从而极大地提高了硬件资源、软件资源和数据资源的利用率。\n\n\n分布式处理\n当计算机网络中的某个计算机系统负荷过重时，可将其处理的某个复杂任务分配给网络中的其他计算机系统，从而利用空闲计算机资源来提高整个系统的利用率。\n\n\n提高可靠性\n计算机网络中的各台计算机可以通过网络互为替代机。\n\n\n负载均衡\n将工作任务均衡地分配给计算机网络中的各台计算机。\n\n\n数据交换方式\n在网络核心部分起重要作用的是路由器（router），它对收到的分组进行存储转发来实现分组交换。要了解分组交换的原理，首先就要学习电路交换的相关概念。\n电路交换\n最典型的电路交换网是传统电话网。\n从通信资源分配的角度看，交换就是按照某种方式动态地分配传输线路的资源。\n电路交换分为三步：连接建立、数据传输和连接释放。\n在进行数据传输前，两个结点之间必须先建立一条专用（双方独占）的物理通信路径（由通信双方之间的交换设备和链路逐段连接而成），该路径可能经过许多中间结点。在数据传输过程中，这一物理通信路径始终被用户独占，直到通信结束后才被释放。\n\n在电路交换的整个通信阶段，比特流连续地从源点直达终点，就好像在一个管道中传送。\n电路交换技术的优 点如下：\n\n通信时延小：因为通信线路为通信双方专用，数据直达，所以传输时延非常小。\n有序传输：双方通信时按发送顺序传送数据，不存在失序问题。\n没有冲突：不同的通信双方拥有不同的信道，不会出现争用物理信道的问题。\n适用范围广：电路交换既适用于传输模拟信号，又适用于传输数字信号。\n实时性强：通信双方之间的物理通路一旦建立，双方就可随时通信。\n控制简单：电路交换的交换设备（交换机等）及控制均较简单。\n\n电路交换技术的缺点如下：\n\n建立连接时问长：电路交换的平均连接建立时间对计算机通信来说太长。\n线路利用率低：物理通路被通信双方独占，即使线路空闲，也不能供其他用户使用。\n灵活性差：物理通路中的任何一点出现故障，就必须重新拨号建立新的连接。\n难以规格化：不同类型、不同规格、不同速率的终端很难相互进行通信。\n难以实现差错控制：中间结点不具备存储和检验数据的能力，无法发现并纠正错误。\n\n注意，在电路交换中，电路建立后，除源结点和目的结点外，电路上的任何结点都采取“直通方式”接收数据和发送数据，即不存在存储转发所耗费的时间。\n报文交换\n报文交换是分组交换的前身。\n数据交换的单位是报文，用户数据加上源地址、目的地址等信息后，后封装成报文（message）。\n报文交换采用存储转发技术，整个报文先传送到相邻的结点，全部存储后查找转发表，转发到下一个结点，如此重复，直至到达目的结点。\n每个报文都可单独选择到达目的结点的路径。\n报文交换技术的优点如下：\n\n无须建立连接：通信前无须建立连接，没有建立连接时延，用户可随时发送报文。\n动态分配线路：交换设备存储整个报文后，选择一条合适的空闲线路，转发报文。\n线路可靠性高：若某条传输路径发生故障，则可重新选择另一条路径传输数据。\n线路利用率高：报文在哪段链路上传送时才占用这段链路的通信资源。\n提供多目标服务：一个报文可以同时发送给多个目的地址。\n\n报文交换技术的缺点如下：\n\n转发时延高：交换结点要将报文整体接收完后，才能查找转发表转发到下一个结点。\n缓存开销大：报文的大小没有限制，这就要求交换结点拥有较大的缓存空间。\n错误处理低效：报文较长时，发生错误的概率相对更大，重传整个报文的代价也很大。\n\n分组交换\n分组交换也采用存储转发技术，但解决了报文交换中报文过长的问题。\n若报文太长，则对交换结点的缓存容量就有很大的需求，在错误处理方面也比较低效。\n源结点在发送之前，先把较长的报文划分成若干较小的等长数据段，在每个数据段前面添加一些由必要控制信息（如源地址、目的地址和编号信息等）组成的首部，构成分组(Packet)。\n\n源结点将分组发送到分组交换网中，分组交换网中的分组交换机收到一个分组后，先将其缓存，然后从其首部中提取目的地址，据此查找自己的转发表，再后将分组转发给下一个分组交换机。经过多个分组交换机的存储转发后，分组最终到达目的结点。\n\n分组交换技术的优点如下：\n\n无建立时延：通信前无须建立连接，没有建立连接时延，用户可随时发送分组。\n线路利用率高：分组在哪段链路上传送时才占用这段链路的通信资源。相比采用电路交换传送突发式的计算机数据，分组交换的通信线路利用率大大提高。\n简化了存储管理（相对于报文交换）：因为分组的长度固定，相应缓冲区的大小也固定，在交换结点中存储器的管理通常被简化为对缓冲区的管理，相对比较容易。\n加速传输：分组是逐个传输的，可以使后一个分组的存储操作与前一个分组的转发操作并行，这种流水线方式减少了报文的传输时间。此外，传输一个分组比传输一次报文所需的缓冲区小得多，这样，因缓冲区不足而等待发送的概率及时间必然也少得多。\n减小了出错概率和重发数据量：因为分组较短，其出错概率必然减小，所以每次重发的数据量也就大大减少，这样不仅提高了可靠性，而且减小了传输时延。\n\n分组交换技术的缺点如下：\n\n存在存储转发时延：尽管分组交换比报文交换的传输时延小，但相对于电路交换仍存在存储转发时延，且其结点交换机必须具有更强的处理能力。\n需要传输额外的信息量：每个小数据段都要加上控制信息以构成分组，这使得传送的信息量增大了 5%～ 10%，进而使得控制复杂，降低了通信效率，增大了处理的时延。\n当分组交换网采用数据报服务时，可能出现失序、丢失或重复分组的情况，分组到达目的结点时，要对分组按编号进行排序等工作，而这些工作很麻烦。若采用虚电路服务，则虽然没有失序问题，但有呼叫建立、数据传输和虚电路释放三个过程。\n\n比较\n当要传送的数据量很大且其传送时间远大于呼叫时间时，采用电路交换较为合适。\n当端到端的通路由多段链路组成时，采用分组交换传送数据较为合适。从提高整个网络的信道利用率看，报文交换和分组交换优于电路交换，其中分组交换比报文交换的时延小，尤其适合计算机之间的突发式数据通信。\n\n分类\n按分布范围分类\n\n\n广域网(WAN)\n广域网的任务是提供长距离通信，运送主机所发送的数据，其覆盖范围通常是直径为几十到几千千米的区域。\n广域网是互联网的核心部分。连接广域网的各结点交换机的链路一般都是高速链路，具有较大的通信容量。\n\n\n城域网(MAN)\n城域网的覆盖范围可以跨越几个街区甚至整个城市，覆盖区域的直径为 5 ～ 50km。\n城域网大多采用以太网技术，因此有时也常并入局域网的范围讨论。\n\n\n局域网(LAN)\n局域网一般用主机通过高速线路相连，覆盖范围较小，通常是直径为几十到几千米的区域。\n传统上，局域网使用广播技术，而广域网使用交换技术。\n\n\n个人区域网(PAN)\n个人区域网是指在个人工作的地方将消费电子设备（如平板电脑、智能手机等）用无线技术连接起来的网络，也称无线个人区域网(WPAN)。\n\n\n\n按传输技术分类\n\n\n广播式网络\n所有联网计算机都共享一个公共通信信道。\n当一台计算机利用共享通信信道发送报文分组时，所有其他计算机都会“收听”到这个分组。接收到该分组的计算机将通过检查目的地址来决定是否接收该分组。\n局域网基本上都采用广播式通信技术，广域网中的无线、卫星通信网络也采用广播式通信技术。\n\n\n点对点网络\n每条物理线路连接一对计算机。\n若通信的两台主机之间没有直接连接的线路，则它们之间的分组传输就要通过中间结点进行存储和转发，直至目的结点。\n\n\n按拓扑结构分类\n网络拓扑结构是指由网中结点（路由器、主机等）与通信线路之间的几何关系表示的网络结构，主要指通信子网的拓扑结构。\n按网络的拓扑结构，可分为总线形、星形、环形和网状网络等。星形、总线形和环形网络多用于局域网，网状网络多用于广域网。\n\n\n总线形网络\n用单根传输线把计算机连接起来。\n优点是建网容易、增/减结点方便、节省线路。\n缺点是重负载时通信效率不高、总线任意一处对故障敏感。\n\n\n\n星形网络\n每个终端或计算机都以单独的线路与中央设备相连。中央设备一般是交换机或路由器。\n优点是便于集中控制和管理。\n缺点是成本高、中央设备对故障敏感。\n\n\n\n环形网络\n所有计算机接口设备连接成一个环。环形网络最典型的例子是令牌环局域网。环既可以是单环，又可以是双环，环中信号是单向传输的。\n\n\n\n网状网络\n一般情况下，每个结点至少有两条路径与其他结点相连，多用在广域网中。其有规则型和非规则型两种。\n优点是可靠性高。\n缺点是控制复杂、线路成本高。\n\n\n\n以上 4 种基本的网络拓扑结构可以互连为更复杂的网络。\n按使用者分类\n\n\n公用网(PublicNetwork)\n指电信公司出资建造的大型网络。\n“公用”的意思是指所有愿意按电信公司的规定缴纳费用的人都可使用这种网络。\n\n\n专用网(PrivateNetwork)\n指某个部门为满足本单位特殊业务的需要而建造的网络。\n这种网络不向本单位外的人提供服务，如铁路、电力、军队等部门的专用网。\n\n\n按传输介质分类\n传输介质可分为有线和无线两大类，因此网络可分为有线网络和无线网络。\n有线网络又可分为双绞线网络、同轴电缆网络等，而无线网络又可分为蓝牙、微波、无线电等类型。\n性能指标\n性能指标从不同方面度量计算机网络的性能。\n\n\n速率(Speed)\n指连接到网络上的结点在数字信道上传送数据的速率，即每秒传送多少个比特，也称数据传输速率、数据传输率、数据率或比特率，单位为b/s(比特/秒)或 bits(有时也写为bps)。\n\n\n\n\n带宽(Bandwidth)\n带宽原本表示通信线路允许通过的信号频率范围，单位是赫兹(Hz)。\n但在计算机网络中，带宽表示网络的通信线路所能传送数据的能力，是数字信道所能传送的“最高数据传输速率”的同义语，单位是比特/秒(b/s)。\n\n\n\n吞吐量(Throughput)\n指单位时间内通过某个网络（或信道、接口）的实际数据量。吞吐量常用在对实际网络的测量中，受网络带宽的限制。\n\n\n\n时延(Delay)\n指数据（一个报文或分组）从网络（或链路）的一端传送到另一端所需的总时间，它由 4 部分构成：发送时延、传播时延、处理时延和排队时延。\n\n\n\n发送时延，也称传输时延\n结点将分组的所有比特推向链路所需的时间，即从发送分组的第一个比特算起，到该分组的最后一个比特发送完毕所需的时间。\n发送时延=分组长度/发送速率\n\n\n传播时延\n电磁波在信道（传输介质）中传播一定的距离所花的时间，即一个比特从链路的一端传播到另一端所需的时间。\n传播时延=信道长度/电磁波在信道上的传播速率\n\n传输时延是路由器将分组推出所需的时间，是分组长度和链路传输速率的函数。\n传播时延是一个比特从一台路由器传播至另一台路由器所需的时间，是两台路由器之间距离的函数，而与分组长度或链路传输速率无关。\n\n\n\n处理时延\n数据在交换结点为存储转发而进行的一些必要处理所花的时间。\n例如，分析分组的首部、从分组中提取数据、差错检验或查找合适的路由等。\n\n\n排队时延\n分组在进入路由器后要先在输入队列中排队等待处理。路由器确定转发端口后，还要在输出队列中排队等待转发。这就产生了排队时延。\n\n\n因此，数据在网络中经历的总时延就是以上 4 部分时延之和：总时延=发送时延+传播时延+处理时延+排队时延处理时延和排队时延通常可忽略不计（除非另有说明）。\n\n\n\n\n\n\n\n\n\n\n时延带宽积\n指发送端发送的第一个比特即将到达终点时，发送端已发出了多少比特，又称以比特为单位的链路长度，即时延带宽积=传播时延 x 信道带宽。\n\n如图所示，考虑一个代表链路的圆柱形管道，其长度表示链路的传播时延，横截面积表示链路带宽，则时延带宽积表示该管道可以容纳的比特数量。\n\n\n\n往返时延(Round-TripTime, RTT)\n指从发送端发出一个短分组，到发送端收到来自接收端的确认（接收端收到数据后立即发送确认）总共经历的时延。\n在互联网中，往返时延还包括各中间结点的处理时延、排队时延及转发数据时的发送时延。\n\n\n\n信道利用率（链路利用率）\n用以指出某个信道有百分之多少的时间是有数据通过的。\n信道利用率=有数据通过时间/（有+无）数据通过时间\n网络利用率是指网络中所有链路的链路利用率的加权平均。\n根据排队论可知，当某链路的利用率增大时，该链路引起的时延就会迅速增加。当网络的通信量较少时，产生的时延并不大，但在网络通信量不断增大时，分组在交换节点（路由器或交换机）中的排队时延会随之增大，因此网络引起的时延就会增大。\n令D_0表示网络空闲时的时延，D表示网络当前的时延，U表示网络利用率。\n\n\n\n丢包率\n分组丢失主要有以下两种情况：\n\n分组在传输过程中出现误码，被传输路径中的节点交换机（例如路由器）或目的主机检测出误码而丢弃。\n节点交换机根据丢弃策略主动丢弃分组。\n\n丢包率可以反映网络的拥塞情况。\n\n\n计算机网络体系结构\n定义\n计算机网络的各层及其协议的集合称为网络的体系结构(Architecture)。换言之，计算机网络的体系结构就是这个计算机网络及其所应完成的功能的精确定义。\n体系结构是抽象的，而实现则是具体的，是真正在运行的计算机硬件和软件。\n计算机网络体系结构通常都具有可分层的特性，它将复杂的大系统分成若干较容易实现的层次。\n\n分层的基本原则如下：\n\n每层都实现一种相对独立的功能，降低大系统的复杂度。\n各层之间的接口自然清晰，易于理解，相互交流尽可能少。\n各层功能的精确定义独立于具体的实现方法，可以采用最合适的技术来实现。\n保持下层对上层的独立性，上层单向使用下层提供的服务。\n整个分层结构应能促进标准化工作。\n\n专业术语\n\n实体\n在计算机网络分层结构中，第 n 层中的活动元素通常称为第 n 层实体。具体来说，实体指任何可发送或接收信息的硬件或软件进程，通常是某个特定的软件模块。\n不同机器上的同一层称为对等层，同一层的实体称为对等实体。\n\n第 n 层实体实现的服务为第 n+1 层所用。在这种情况下，第 n 层称为服务提供者，第 n+1 层则服务于用户。\n在计算机网络体系结构中，对等层之间传送的数据单位称为该层的协议数据单元(PDU)，第 n 层的 PDU 记为 n-PDU。\n各层的 PDU 都分为数据和控制信息两部分:\n\n服务数据单元(SDU)：为完成用户所要求的功能而传送的数据。第 n 层的 SDU 记为 n-SDU。\n协议控制信息(PCI)：控制协议操作的信息。第 n 层的 PCI 记为 n-PCI。\n\n每层的协议数据单元都有一个通俗的名称，如物理层的 PDU 称为比特流，数据链路层的 PDU 称为帧，网络层的 PDU 称为分组，传输层的 PDU 称为报文段。\n\n当在各层之间传输数据时，将从第 n+1 层收到的 PDU 作为第 n 层的 SDU，加上第 n 层的 PCI，就封装成了第 n 层的 PDU，交给第 n-1 层后作为 SDU 发送，接收方接收时做相反的处理，因此可知三者的关系为 n-SDU + n-PCI = n-PDU =(n-1)-SDU。\n\n具体地，层次结构的含义包括如下几方面：\n\n第 n 层的实体不仅要使用第 n-1 层的服务来实现自身定义的功能，而且要向第 n+1 层提供本层的服务，该服务是第 n 层及其下面各层提供的服务总和。\n最低层只提供服务，是整个层次结构的基础；最高层面向用户提供服务。\n上一层只能通过相邻层间的接口使用下一层的服务，而不能调用其他层的服务。\n当两台主机通信时，对等层在逻辑上有一个直接信道，表现为能直接将信息传送到对方。\n\n协议\n要在网络中做到有条不紊地交换数据，就必须遵循一些事先约定好的规则，其规定了所交换数据的格式及有关的同步问题。\n为了在网络中进行数据交换而建立的这些规则、标准或约定称为网络协议(NetworkProtocol)，是控制在对等实体之间进行通信的规则的集合，是水平的。\n\n不对等实体之间是没有协议的，如用 TCP/IP 协议栈通信的两个结点 A 和结点 B，结点 A 的传输层和结点 B 的传输层之间存在协议，但结点 A 的传输层和结点 B 的网络层之间不存在协议。\n协议由语法、语义和同步三部分组成:\n\n\n语法\n数据与控制信息的格式。\n例如，TCP 报文段格式就是由 TCP 协议的语法定义的。\n\n\n\n语义\n即需要发出何种控制信息、完成何种动作及做出何种应答。\n例如，在建立 TCP 连接的三次握手时所执行的操作就是由 TCP 协议的语义定义的。\n\n\n同步（或时序）\n执行各种操作的条件、时序关系等，即事件实现顺序的详细说明。\n例如，建立 TCP 连接的三次握手操作的时序关系就是由 TCP 协议的同步定义的。\n\n\n接口\n同一结点内相邻两层的实体交换信息的逻辑接口称为服务访问点（ServiceAccessPoint，SAP)。每层只能为紧邻的层之间定义接口，而不能跨层定义接口。服务是通过 SAP 提供给上层使用的，第 n 层的 SAP 就是第 n+1 层可以访问第 n 层服务的地方。例如，在本书描述的 5 层体系结构中，数据链路层的服务访问点为帧的“类型”字段，网络层的服务访问点为 IP 数据报的“协议”字段，传输层的服务访问点为“端口号”字段。\n服务\n服务是指下层为紧邻的上层提供的功能调用，是垂直的。\n对等实体在协议的控制下，使得本层能为上层提供服务，但要实现本层协议，还需要使用下层提供的服务。\n\n当上层使用下层提供的服务时，必须与下层交换一些命令，这些命令称为服务原语。\nOSI 参考模型将原语划分为四类：\n\n请求(Request)：由服务用户发往服务提供者，请求完成某项工作。\n指示(Indication)：由服务提供者发往服务用户，指示用户做某件事情。\n响应(Response)：由服务用户发往服务提供者，作为对指示的响应。\n证实(Confirmation)：由服务提供者发往服务用户，作为对请求的证实。\n\n这四类原语用于不同的功能，如建立连接、传输数据和断开连接等。有应答服务包括全部四类原语，而无应答服务则只有请求和指示两类原语。\n协议和服务概念上是不一样的。\n\n首先，只有本层协议的实现才能保证向上一层提供服务。本层的服务用户只能看见服务而无法看见下面的协议，即下面的协议对上层的服务用户是透明的。\n其次，协议是“水平的”，即协议是控制对等实体之间通信的规则。但是，服务是“垂真的”，即服务是由下层通过层间接口向上层提供的。\n另外，并非在一层内完成的全部功能都称为服务，只有那些能够被高一层实体“看得见”的功能才称为服务。\n\n计算机网络提供的服务可按以下三种方式分类:\n\n\n面向连接服务与无连接服务\n\n\n在面向连接服务中，通信前双方必须先建立连接，分配相应的资源（如缓冲区），以保证通信能正常进行，传输结束后释放连接和占用的资源。\n因此这种服务可分为连接建立、数据传输和连接释放三个阶段。例如，TCP 就是一种面向连接服务的协议。\n\n\n在无连接服务中，通信前双方不需要先建立连接，需要发送数据时可直接发送，将每个带有目的地址的包（报文分组）传送到线路上，由系统选定路线进行传输。\n这种服务常被描述为“尽最大努力交付”，是一种不可靠的服务。例如，IP、UDP 就是一种无连接服务的协议。\n\n\n\n\n可靠服务和不可靠服务\n\n可靠服务是指网络具有纠错、检错、应答机制，能保证数据正确、可靠地传送到目的地。\n不可靠服务是指网络只是尽量让数据正确、可靠地传送到目的地，是一种尽力而为的服务。\n\n对于提供不可靠服务的网络，其网络的正确性、可靠性要由应用或用户来保障。例如，用户收到信息后要判断信息的正确性，若不正确，则用户就要把出错信息报告给信息的发送者，以便发送者采取纠正措施。通过用户的这些措施，可将不可靠服务变成可靠服务。\n\n\n有应答服务和无应答服务\n\n\n有应答服务是指接收方在收到数据后向发送方给出相应的应答，该应答由传输系统内部自动实现，而不由用户实现。发送的应答既可以是肯定应答，又可以是否定应答，通常在接收到的数据有错误时发送否定应答。\n例如，文件传输服务就是一种有应答服务。\n\n\n无应答服务是指接收方收到数据后不自动给出应答。若需要应答，则由高层实现。\n例如，对于 WWW 服务，客户端收到服务器发送的页面文件后不给出应答。\n\n\n\n\n常见的三种计算机网络体系结构\n\nOSI 参考模型\n\n开放系统互连参考模型（OSI/RM)，通常简称为 OSI 参考模型。\nOSI 参考模型有 7 层，自下而上依次为物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。\n低三层统称通信子网，是为联网而附加的通信设备，完成数据的传输功能；\n高三层统称资源子网，相当于计算机系统，完成数据的处理等功能。\n传输层承上启下。\n\nOSI 参考模型不仅划分了层次结构，还定义了各层可能提供的服务，但并未规定协议的具体实现，而是描述了一些概念和原则，用来协调和组织各层所用的协议。\n\n\n物理层(PhysicalLayer)\n物理层的传输单位是比特。\n实现比特流在传输介质上的透明传输；\n\n\n\n数据链路层(DataLinkLayer)\n数据链路层的传输单位是帧。\n将有差错的物理线路变成无差错的数据链路，实现相邻结点之间即点到点的数据传输，并保证数据正确的顺序和完整性。\n实现了物理寻址、组帧、流量控制、差错检验、数据重发等功能。\n\n\n网络层和传输层才具有拥塞控制的功能。\n\n\n\n网络层(NetworkLayer)(网际层/IP 层)\n网络层的传输单位是数据报。\n控制报文通过网络的路由选择。\n实现流量控制、拥塞控制、差错控制和网际互连等功能。\n支持无连接和面向连接的通信。\n\n\n\n传输层(TransportLayer)(运输层)\n负责主机中两个进程之间的通信。\n为端到端连接提供可靠的传输服务，即为端到端连接提供流量控制、差错控制、服务质量、数据传输管理等服务。\n仅支持面向连接的通信。\n传输层的协议有 TCP、UDP。\n\n\n\n会话层(SessionLayer)\n会话层的两个主要服务是会话管理和同步。\n会话层使用检验点使通信会话在通信失效时从检验点继续恢复通信，实现数据同步。\n\n\n表示层(PresentationLayer)\n解决不同主机上信息表示不一致的问题。\n数据压缩、加密和解密、格式转换。\n\n\n应用层(ApplicationLayer)\n提供用户与网络的接口。\n应用层为特定类型的网络应用提供访问 OSI 参考模型环境的手段。\n用户的实际应用多种多样，这就要求应用层采用不同的应用协议来解决不同类型的应用要求，因此应用层是最复杂的一层，使用的协议也最多。\n典型的协议有用于文件传送的 FTP、用于电子邮件的 SMTP、用于万维网的 HTTP 等。\n\n\n\n\n\n\n                  \n                  数据链路层和传输层通信的区别 \n                  \n                \n\n数据链路层提供的是点到点通信，传输层提供的是端到端通信，两者不同。\n\n点到点可理解为主机和主机之间的通信，一个点是指一个硬件地址或 IP 地址，网络中参与通信的主机是通过硬件地址或 IP 地址来标识的；\n端到端通信是指运行在不同主机内的两个进程之间的通信，一个进程由一个端口来标识，所以称为端到端通信。\n\n\n\n\n\n                  \n                  流量控制 \n                  \n                \n\n流量控制指的是通过限制发送方发出的数据流量，使得其发送速率不超过接收方接收速率的一种技术。\n流量控制功能可存在于数据链路层及其之上的各层中。目前提供流量控制功能的主要是数据链路层、网络层和传输层。\n不过，各层的流量控制对象不一样，各层的流量控制功能是在各层实体之间进行的。数据链路层是相邻结点之间的流量控制，网络层是整个网络中的流量控制，传输层是端到端的流量控制。\n\n\nTCP/IP 模型\nTCP/IP 模型从低到高依次为网络接口层、网际层、传输层和应用层。\nTCP/IP 因为得到广泛应用而成为事实上的国际标准。\n\n\n\n网络接口层\n表示与物理网络的接口，但实际上 TCP/IP 本身并未真正描述这一部分，只是指出主机必须使用某种协议与网络连接，以便在其上传输 IP 分组。网络接口层的作用是从主机或结点接收 IP 分组，并将它们发送到指定的物理网络上。\n\n\n网际层\nTCP/IP 体系结构的关键部分。\n向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。\n网际层将分组发往任何网络，并为其独立地选择合适的路由，但不保证各个分组有序地到达，各个分组的有序和可靠交付由高层负责。网际层定义了标准的分组格式和协议，即 IP。\n仅有无连接的通信。\n\n\n传输层\nTCP/IP 模型的传输层提供端到端的通信，并且负责差错控制和流量控制，可以提供可靠的面向连接服务或不可靠的无连接服务。\n传输层主要使用以下两种协议：\n\n传输控制协议(TransmissionControlProtocol, TCP)：它是面向连接的，传输数据之前必须先建立连接，能够提供可靠的交付。数据传输的单位是报文段。\n用户数据报协议(UserDatagramProtocol, UDP)：它是无连接的，不保证提供可靠的交付，只能提供“尽最大努力交付”。数据传输的单位是用户数据报。\n\n\n\n应用层\n包含所有的高层协议，如虚拟终端协议(Telnet)、文件传输协议(FTP)、域名解析服务(DNS)、电子邮件协议(SMTP)和超文本传输协议(HTTP)。\n\n\n\n区别\n"},"计算机基础/计算机网络/2_物理层":{"title":"物理层","links":[],"tags":["计算机网络"],"content":"物理层概述\n实现功能\n\n接口特性\n物理层考虑的是如何在连接各种计算机的传输介质上传输比特流，而不指具体的传输介质。\n网络中的硬件设备和传输介质的种类繁多，通信方式也各不相同。物理层应尽可能屏蔽这些差异，让数据链路层感觉不到这些差异，使数据链路层只需考虑如何完成本层的协议和服务。\n物理层的主要任务是确定与传输介质的接口有关的一些特性：\n\n机械特性：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等。\n电气特性：指明在接口电缆的各条线上的电压范围、传输速率和距离限制等。\n功能特性：指明某条线上出现的某一电平的电压的意义，以及每条线的功能。\n过程特性：也称规程特性，指明对不同功能的各种可能事件的出现顺序。\n\n\n传输媒体\n传输媒体是计算机网络设备之间的物理通路，也称为传输介质或传输媒介。传输媒体并不包含在计算机网络体系结构中。\n\n分类\n\n同轴电缆\n同轴电缆由内导体、绝缘层、网状编织屏蔽层和塑料外层构成。\n因为外导体屏蔽层的作用，所以同轴电缆具有良好的抗干扰特性而被广泛用于传输较高速率的数据。\n\n双绞线\n双绞线是最常用的传输介质，在局域网和传统电话网中普遍使用。\n双绞线由两根采用一定规则并排绞合、相互绝缘的铜导线组成。绞合可减少对相邻导线的电磁干扰。\n为了进一步提高抗电磁干扰的能力，还可在双绞线的外面加上一层金属丝编织成的屏蔽层，这就是屏蔽双绞线(STP)。无屏蔽层的双绞线称为非屏蔽双绞线(UTP)。\n\n双绞线的价格便宜，模拟传输和数字传输都可使用双绞线，通信距离一般为几千米到数十千米。\n双绞线的带宽取决于铜线的粗细和传输的距离。\n距离太远时，对于模拟传输，要用放大器放大衰减的信号；对于数字传输，要用中继器来对失真的信号进行整形。\n在局域网领域基本上都采用双绞线作为传输介质。\n\n光纤\n光纤通信是指利用光导纤维（简称光纤）传递光脉冲来进行通信。有光脉冲表示 1，无光脉冲表示 0。可见光的频率约为 10MHz，因此光纤通信系统的带宽极大。\n\n光纤主要由纤芯和包层构成，纤芯很细，包层较纤芯有较低的折射率，光波通过纤芯进行传导。当光线从高折射率的介质射向低折射率的介质时，其折射角将大于入射角。因此，只要入射角大于某个临界角，就会出现全反射，即光线碰到包层时就会折射回纤芯，这个过程不断重复，光也就沿着光纤传输下去。\n\n\n\n利用光的全反射特性，可让从不同角度入射的多条光线在一根光纤中传输，这种光纤称为多模光纤，多模光纤的光源为发光二极管。光脉冲在多模光纤中传输时逐渐展宽，造成失真，因此多模光纤只适合近距离传输。\n\n当光纤的直径减小到只有一个光的波长时，光纤就像一根波导那样，可使光线一直向前传播，而不产生多次反射，这样的光纤就是单模光纤。\n单模光纤的纤芯很细，制造成本较高。同时，单模光纤的光源是定向性很好的半导体激光器，因此单模光纤的衰减较小，可传输数千米甚至数十千米而不必采用中继器，适合远距离传输。\n\n光纤不仅具有通信容量非常大的优点，而且具有如下特点：\n\n传输损耗小，中继距离长，对远距离传输特别经济。\n抗雷电和电磁干扰性能好，在有大电流脉冲干扰的环境下这尤为重要。\n无串音干扰，保密性好，不易被窃听或截取数据。\n体积小，重量轻，在现有电缆管道已拥塞不堪的情况下这特别有利。\n\n\n\n无线传输介质\n\n\n无线电波\n无线电波具有较强的穿透能力，可以传输很长的距离，因此广泛用于通信领域，如无线手机通信、计算机网络中的无线局域网（WLAN）等。\n因为无线电波使信号向所有方向散播，所以有效距离范围内的接收设备无须对准某个方向，就可与无线电波发射者进行通信连接，大大简化了通信连接。这也是无线电波传输的最重要优点之一。\n\n\n\n微波、红外线和激光\n目前高带宽的无线通信主要使用三种技术：微波、红外线和激光，它们都需要在发送方和接收方之间有一条视线通路，有很强的方向性，沿直线传播。\n\n微波通信的频率较高，频段范围也很宽，载波频率通常为 2 ～ 40GHz，因此通信信道的容量大。与通常的无线电波不同，微波通信的信号是沿直线传播的，因此在地面上的传播距离有限，超过一定距离后就要使用中继站来接力。\n\n卫星通信利用地球同步卫星作为中继来转发微波信号，可以克服地面微波通信距离的限制 3 三颗相隔 120° 的同步卫星几乎就能覆盖整个地球表面，因此基本能实现全球通信。卫星通信的优点是通信容量大、距离远、覆盖广，缺点是保密性差、端到端传播时延长。\n\n\n不同的是，红外通信和激光通信将要传输的信号分别转换为各自的信号格式，即红外光信号和激光信号，再直接在空间中传播。\n\n\n\n传输方式\n数据传输方式分为串行传输和并行传输。\n\n\n串行传输\n逐比特地按序依次传输。适用于长距离通信，如计算机网络。\n\n\n\n并行传输\n若干比特通过多个通信信道同时传输。适用于近距离通信，常用于计算机内部，如 CPU 与主存之间。\n\n\n\n\n\n从通信双方信息的交互方式看，可分为三种基本方式：\n\n\n单向通信\n只有一个方向的通信而没有反方向的交互，如无线电广播、电视广播等。\n\n\n\n半双工通信\n通信双方都可发送或接收信息，但任何一方都不能同时发送和接收信息。\n\n\n\n全双工通信\n通信双方可同时发送和接收信息。单向通信只需一个信道，而半双工通信或全双工通信都需要两个信道，每个方向一个信道。\n\n\n\n\n\n\n通信基本概念\n数据、信号、码元\n通信的目的是传输信息，如文字、图像和视频等。\n数据是指传送信息的实体。\n信号是数据的电气或电磁表现，是数据在传输过程中的存在形式。\n数据和信号都有模拟或数字之分：\n\n模拟数据（或模拟信号）的取值是连续的：\n数字数据（或数字信号）的取值是离散的。\n\n在通信系统中，常用一个固定时长的信号波形（数字脉冲）表示一位 k 进制数字，代表不同离散数值的基本波形就称为码元。\n码元是数字通信中数字信号的计量单位，这个时长内的信号称为 k 进制码元，而该时长称为码元宽度。1 码元可携带若干比特的信息量。例如，在使用二进制编码时，只有两种不同的码元：一种代表 0 状态，另一种代表 1 状态。\n\n信源、信道、信宿\n数据通信系统主要划分为信源、信道和信宿三部分。\n信源是产生和发送数据的源头，信宿是接收数据的终点，它们通常都是计算机或其他数字终端装置。\n信道是信号的传输介质，一条双向通信的线路包含一个发送信道和一个接收信道。\n发送端信源发出的信息需要通过变换器转换成适合在信道上传输的信号，而通过信道传输到接收端的信号首先由反变换器转换成原始信息，然后发送给信宿。\n\n噪声源是信道上的噪声及分散在通信系统其他各处的噪声的集中表示。\n\n\n\n信道按传输信号形式的不同，分为传送模拟信号的模拟信道和传送数字信号的数字信道两大类；\n\n\n信道按传输介质的不同，分为无线信道和有线信道。\n\n\n\n信道上传送的信号有基带信号和宽带信号之分。\n\n基带信号首先将数字信号 1 和 0 直接用两种不同的电压表示，然后送到数字信道上传输（称为基带传输）。\n宽带信号首先将基带信号进行调制，形成频分复用模拟信号，然后送到模拟信道上传输（称为宽带传输）。\n\n速率，波特、带宽\n速率是指数据传输速率，表示单位时间内传输的数据量，常有两种描述形式。\n\n\n码元传输速率\n又称波特率，表示单位时间内数字通信系统所传输的码元数（也称调制速率或符号速率），单位是波特(Baud)。\n1 波特表示数字通信系统每秒传输 1 个码元。\n码元既可以是多进制的，又可以是二进制的，码元速率与进制数无关。\n\n\n信息传输速率\n又称比特率，表示单位时间内数字通信系统传输的二进制码元数（即比特数），单位是比特/秒(b/s)。\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n波特和比特是两个不同的概念，但波特率与比特率在数量上又有一定的关系。若一个码元携带n比特的信息量，则波特率 M Baud 对应的比特率为 Mn b/s。\n\n\n在模拟信号系统中，带宽（又称频率带宽）用来表示某个信道所能传输信号的频率范围，即最高频率与最低频率之差，单位是赫兹(Hz)。\n在计算机网络中，带宽用来表示网络的通信线路所能传输数据的能力，即最高数据率；显然，此时带宽的单位不再是 Hz，而是 b/s。\n编码与调制\n信号是数据的具体表示形式，数据无论是数字的还是模拟的，为了传输的目的，都要转换成信号。\n将数据转换为模拟信号的过程称为调制，将数据转换为数字信号的过程称为编码。\n\n数字数据可通过数字发送器转换为数字信号传输，也可通过调制器转换成模拟信号传输；同样，模拟数据可通过 PCM 编码器转换成数字信号传输，也可通过放大器调制器转换成模拟信号传输。\n这样，就形成了如下 4 种编码与调制方式。\n数字数据-(编码)→ 数字信号\n数字数据编码为数字信号数字数据编码用于基带传输中，即在基本不改变数字数据信号频率的情况下，直接传输数字信号。\n具体用什么样的数字信号表示 0 及用什么样的数字信号表示 1，就是所谓的编码。编码的规则有多种，只要能有效区分 0 和 1 即可。\n\n常用的数字数据编码有以下 5 种\n\n\n归零编码(RZ, Return Zero Code)\n用高电平表示 1、低电平表示 0（或者相反），每个码元的中间均跳变到零电平（归零），接收方根据该跳变调整本方的时钟基准，这就为收发双方提供了自同步机制。\n因为归零需要占用一部分带宽，所以传输效率受到了一定的影响。\n\n\n\n非归零编码(NRZ, Non Return Zero Code)\n与 RZ 编码的区别是不用归零，一个时钟全部用来传输数据，编码效率最高。\n\n但 NRZ 编码的收发双方存在同步问题，为此需要双方都带有时钟线。\n\n\n\n反向非归零编码(NRZI, Non Return Zero Inverted Code)\n与 NRZ 编码的区别是用电平的跳变表示 0、电平保持不变表示 1。\n跳变信号本身可作为一种通知机制。这种编码方式集成了前两种编码的优点，既能传输时钟信号，又能尽量不损失系统带宽。\nUSB2.0 的编码方式就是 NRZI 编码。\n\n\n曼彻斯特编码\n每个码元的中间都发生电平跳变，电平跳变既作为时钟信号（用于同步），又作为数据信号。\n可用向下跳变表示 1、向上跳变表示 0，或者采用相反的规定。\n\n\n\n                  \n                  Tip\n                  \n                \n\n曼彻斯特编码的每个比特需要两个信号周期，信号率是数据率的 2 倍，编码效率是 50%。\n因为以太网采用曼彻斯特编码，每位数据（1 比特，对应信息传输速率）都需要两个电平（两个脉冲信号，对应码元传输速率）来表示，因此波特率是数据率的 2 倍。\n因此若有一个以太网的波特率是40MBaud，则数据率为\\frac{40}{2} Mb/s=20Mb/s。\n\n\n\n\n差分曼彻斯特编码\n每个码元的中间都发生电平跳变，与曼彻斯特编码不同的是，电平跳变仅表示时钟信号，而不表示数据。\n数据的表示在于每个码元开始处是否有电平跳变，无跳变表示 1，有跳变表示 0。\n\n差分曼彻斯特编码拥有更强的抗干扰能力。\n在传输大量连续 1 或连续 0 的情况下，差分曼彻斯特编码信号比曼彻斯特编码信号的变化少。\n在噪声干扰环境下，检测有无跳变比检测跳变方向更不容易出错，因此差分曼彻斯特编码信号比曼彻斯特编码信号更易于检测。\n在传输介质接线错误导致高低电平翻转的情况下，差分曼彻斯特编码仍然有效。\n\n\n曼彻斯特编码和差分曼彻斯特编码在每个码元的中间都发生电平跳变，相当于将一个码元一分为二，编码速率是码元速率的 2 倍，二者所占的频带宽度是原始基带宽度的 2 倍。\n标准以太网使用曼彻斯特编码，而差分曼彻斯特编码则用于宽带高速网中。\n模拟数据-(编码)→ 数字信号\n主要包括三个步骤，即采样、量化和编码，常用于对音频信号进行编码的 PCM 编码。\n首先介绍采样定理：在将模拟信号转换成数字信号时，假设原始信号中的最大频率为 f，那么采样率 f 采必须大于或等于最大频率 f 的 2 倍，才能保证采样后的数字信号完整保留原模拟信号的信息。\n\n采样定理又称奈奎斯特定理。\n\n\n采样：对模拟信号进行周期性扫描，将时间上连续的信号变成时间上离散的信号。\n量化：将采样得到的电平幅值按照一定的分级标度转换为对应的数值并取整，这样就将连续的电平幅值转换为了离散的数字量。采样和量化的实质就是分割和转换。\n编码：将量化得到的离散整数转换为与之对应的二进制编码。\n\n数字数据-(调制)→ 模拟信号\n数字数据调制技术在发送端将数字信号转换为模拟信号，而在接收端将模拟信号还原为数字信号，分别对应于调制解调器的调制和解调过程。\n\n\n\n调幅(AM)或幅移键控(ASK)\n通过改变载波的振幅来表示数字信号 1 和 0。例如，用有载波和无载波输出分别表示 1 和 0。这种方式比较容易实现，但抗干扰能力差。\n\nA , Amplitude\n\n\n若有 n 种幅度则说明 1 码元可以携带 \\log_2n 个 bit。\n\n\n\n调频(FM)或频移键控(FSK)\n通过改变载波的频率来表示数字信 号 1 和 0。例如，用频率 f 和频率分别表示 1 和 0。这种方式容易实现，抗干扰能力强，目前应用较广泛。\n\nF , Frequency\n\n\n若有 n 种频率则说明 1 码元可以携带 \\log_2n 个 bit。\n\n\n\n调相(PM)或相移键控(PSK)\n通过改变载波的相位来表示数字信号 1 和 0，又分为绝对调相和相对调相。例如，用相位 0 和 π 分别表示 1 和 0，是一种绝对调相方式。\n\nP , Phase\n\n\n若有 n 种相位则说明 1 码元可以携带 \\log_2n 个 bit。\n\n\n\n正交幅度调制(QAM)\n在频率相同的前提下，将 AM 与 PM 结合起来，形成叠加信号。\n设波特率为B，采用m个相位，每个相位有n种振幅，则该 QAM 的数据传输速率R为R=Blog_2(mn)（单位为 b/s）\n\n若有 m个相位，每个相位有n种振幅则说明 1 码元可以携带 \\log_2{(nm)} 个 bit。\n\n\n\n模拟数据-(调制)→ 模拟信号\n为了实现传输的有效性，可能需要较高的频率。这种调制方式还可使用频分复用(FDM)技术，充分利用带宽资源。电话机和本地局交换机采用模拟信号传输模拟数据的编码方式。\n信道的极限容量\n任何实际的信道都不是理想的，信号在信道上传输时会不可避免地产生失真。\n\n但是，只要接收端能够从失真的信号波形中识别出原来的信号，这种失真对通信质量就没有影响。但是，若信号失真很严重，则接收端就无法识别出每个码元。\n\n奈奎斯特定理(奈氏准则)\n具体的信道所能通过的频率范围总是有限的。\n信号中的许多高频分量往往不能通过信道，否则在传输中就会衰减，导致接收端收到的信号波形失去码元之间的清晰界限，这种现象称为码间串扰。\n奈奎斯特定理规定：在理想低通（没有噪声、带宽有限）信道中，为了避免码间串扰，极限码元传输速率（波特率）为\n2W\\quad Baud\n其中W是信道的频率带宽（单位为 Hz），Baud是波特率（单位为码元/秒）。\n若用 V 表示每个码元的离散电平数目（码元的离散电平数目是指有多少种不同的码元，若有 16 种不同的码元，则需要 4 个二进制位，因此数据传输速率是码元传输速率的 4 倍），则极限数据率为\n\\text{理想低通信道下的极限数据传输速率}=2Wlog_2V\\quad (b/s)\n对于奈氏准则，有以下结论：\n\n在任何信道中，码元传输速率是有上限的。若传输速率超过上限，则会出现严重的码间串扰问题，使得接收端不可能完全正确地识别码元。\n信道的频带越宽（即通过的信号高频分量越多），就越可用更高的速率有效地传输码元。\n奈氏准则给出了码元传输速率的限制，但并未限制信息传输速率，即未对一个码元可以对应多少个二进制位给出限制。\n\n因为码元传输速率受奈氏准则制约，所以要提高数据传输速率，就要设法使每个码元携带更多比特的信息量，此时需要采用多元制的调制方法。\n香农定理\n实际的信道会有噪声，噪声是随机产生的。\n香农定理给出了带宽受限且有高斯噪声干扰的信道的极限数据传输速率，当用该速率传输数据时，不会产生误差。香农定理定义为\nC=W\\log_2{(1+ \\frac{S}{N})}\\quad (b/s)\n式中，C为信道的极限信息传输速率(b/s)，W为信道的频率带宽(Hz)，S为信道内所传输信号的平均功率，N为信道内的高斯噪声功率。\n信噪比，即信号的平均功率与噪声的平均功率之比，计算公式为\n\\text{信噪比}=10\\log_{10}(\\frac{S}{N})\\quad dB\n例如，当\\frac{S}{N}=10时，信噪比为10dB；而当\\frac{S}{N}=1000时，信噪比为30dB。\n\n\n对于香农定理，有以下结论：\n\n信道的带宽或信道中的信噪比越大，信息的极限传输速率越高。\n对一定的传输带宽和一定的信噪比，信息传输速率的上限是确定的。\n只要信息传输速率低于信道的极限传输速率，就能找到某种方法实现无差错的传输。\n香农定理得出的是极限信息传输速率，实际信道能达到的传输速率要比它低不少。\n\n\n\n\n                  \n                  信噪比 S/N 和 10log(s/N)的区别 \n                  \n                \n\n若噪声功率为 1，信号功率为 100\n\n数字形式表示示，信噪比为 100/1=100。\n分贝形式表示，信噪比为10\\log_{10}(\\frac{100}{1})=20dB。\n\n二者在数值上等价。区别在于，前者没有单位，后者必须加 dB（分贝）。采用分贝表示的原因是为了更方便表示。\n\n\n区别\n\n\n奈氏准则指出，码元传输的速率是受限的，不能任意提高，否则接收端就不能正确判定码元所携带的比特数据（因为码元之间存在相互干扰）。\n奈氏准则是在理想条件下推导出来的。但在实际条件下，最高码元传输速率要比理想条件下得出的数值小很多。\n值得注意的是，奈氏准则并未限制信息传输速率。要提高信息传输速率，就必须使每个码元能够携带许多比特的信息。但是，码元所载的比特数确定后，信道的极限数据率也就确定了。\n\n\n香农定理给出了信息传输速率的极限，即对于一定的传输带宽(Hz)和一定的信噪比，信息传输速率的上限是确定的，这个极限不能突破。\n要想提高信息传输速率，要么设法提高传输线路的带宽，要么设法提高信道的信噪比，此外没有其他任何办法。\n\n\n奈氏准则只考虑了带宽与极限码元传输速率之间的关系，而香农定理不仅考虑了带宽，也考虑了信噪比。这从另一个侧面表明，一个码元对应的二进制位数是有限的。\n\n\n                  \n                  Tip\n                  \n                \n\n若题目中给出了码元与比特数之间的关系，则需受两个公式计算最大数据传输速率应受两者共同限制。\n\n\n物理层设备\n中继器\n中继器的主要功能是整形、放大并转发信号，以消除信号经过一长段电缆后产生的失真和衰减，使信号的波形和强度达到所需的要求，进而扩大网络传输的距离。其原理是信号再生（而非简单地放大衰减的信号）。\n中继器有两个端口，数据从一个端口输入，从另一个端口发出。端口仅作用于信号的电气部分，而不管是否有错误数据或不适于网段的数据。\n中继器是用来扩大网络规模的最简单的廉价互连设备。\n中继器两端的网络部分是网段，而不是子网，使用中继器连接的几个网段仍是一个局域网。中继器若出现故障，则对相邻两个网段的工作都产生影响。\n因为中继器工作在物理层，所以不能连接两个具有不同速率的局域网。当物理层互连时，各种网络的数据传输速率若不同，则可能出现以下两种情况：\n\n发送方的速率高于接收方，接收方来不及接收导致溢出（因为物理层没有流量控制)，数据丢失。\n接收方的速率高于发送方，不会出现数据丢失的情况，但效率极低。\n\n\n\n                  \n                  Tip\n                  \n                \n\n若某个网络设备有存储转发功能，则认为它能连接两个不同的协议；若该网络设备无存储转发功能，则认为它不能连接两个不同的协议。所以中继器不能连接不同速率的局域网，也不能连接不同数据链路层协议的局域网（连接后要能达到正常通信的目的）。但中继器可以连接不同介质的局域网，如光纤和双绞线，只要它们具有相同的速率和协议。\n物理层互连成功，只表明这两个网段之间可相传送物理层信号，但物理层设备只能转发物理信号，不能识别数据链路层协议，所以并不证可以互相传送数据链路层的帧。因此，仅要求物理层互连时数据链路层协议可以不同，但要达到在数据链路层互通的目的，就要求数据链路层协议也要相同，不然无法正常通信。\n\n\n从理论上讲，中继器的使用数目是无限的，网络因而也可无限延长。但事实上这是不可能的，因为网络标准中对信号的延迟范围做了具体规定，中继器只能在该范围内进行有效的工作，否则会引起网络故障。\n\n\n                  \n                  Tip\n                  \n                \n\n放大器和中继器都起放大作用，只不过放大器放大的是模拟信号，其原理是放大衰减的信号，而中继器放大的是数字信号，其原理是整形再生衰减的信号。\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n中继器或集线器有“5-4-3 规则”，其中“5”表示 5 个网段，“4”表示 4 个中继器或集线器，“3”表示 3 个网段为主机段。也就是说，在一个由中继器或集线器互连的网络中，任意发送方和接收方最多只能经过 4 个中继器、5 个网段。\n\n\n集线器\n集线器(Hub)实质上是一个多端口的中继器。\n当 Hub 工作时，一个端口接收到数据信号后，因为信号在从端口到 Hub 的传输过程中已有衰减，所以 Hub 便对该信号进行整形放大，使之再生（恢复）到发送时的状态，紧接着转发到其他所有（除输入端口外）处于工作状态的端口。\n若同时有两个或多个端口输入，则输出时将发生冲突，致使这些数据都无效。\n从 Hub 的工作方式可以看出，它在网络中只起信号放大和转发作用，目的是扩大网络的传输范围，而不具备信号的定向传送能力，即信息传输的方向是固定的，是标准的共享式设备。\n集线器将多个设备连接在以它为中心的结点上，因此使用它的网络在物理拓扑上属于星形结构。集线器不具备交换机所具有的交换表，所以它发送数据时是没有针对性的，而采用广播方式发送。因此，使用集线器的星形以太网逻辑上仍然是总线网。\nHub 的每个端口连接的是同一网络的不同网段，同时 Hub 也只能在半双工状态下工作，网络的吞吐率因而受到限制。\n集线器不能分割冲突域，集线器的所有端口都属于同一个冲突域。\n集线器在一个时钟周期内只能传输一组信息，当一台集线器连接的机器数目较多且多台机器经常需要同时通信时，将导致信息冲突，使得集线器的工作效率很差。例如，一个带宽为 10Mb/s 的集线器上连接了 8 台计算机，当这 8 台计算机同时工作时，每台计算机所真正拥有的带宽为 10/8Mb/s=1.25Mb/s。"},"计算机基础/计算机网络/3_数据链路层":{"title":"数据链路层","links":[],"tags":["计算机网络"],"content":"数据链路层概述\n数据链路层使用的信道主要有两种：\n\n点对点信道，使用一对一的通信方式。PPP 协议则是目前使用最广泛的点对点协议。\n广播信道，这种信道上连接的主机很多，使用一对多的广播通信方式。采用共享广播信道的有线局域网普遍使用 CSMA/CD 协议，而无线局域网则使用 CSMA/CA 协议。\n\n\n\n下面介绍点对点信道的一些基本概念，某些概念对广播信道也是适用的。\n\n\n链路\n指从一个结点到相邻结点的一段物理线路。\n当进行数据通信时，两台计算机之间的通信路径往往要经过许多段这样的链路。可见链路只是一条路径的组成部分。\n\n\n\n数据链路\n当在一条链路上传送数据时，除了需要链路本身，还需要一些必要的通信协议来控制这些数据的传输，把实现这些协议的硬件和软件加到链路上，就构成了数据链路。\n有时也把上面所说的链路称为物理链路，而把数据链路称为逻辑链路。\n\n\n帧\n数据链路层对等实体之间进行逻辑通信的协议数据单元。\n数据链路层把网络层下交的数据构成帧发送到链路上，并把接收到的帧中的数据取出并上交给网络层。\n\n\n数据链路层连接的建立、维持和释放过程称为链路管理，它主要用于面向连接的服务。\n链路两端的结点要进行通信，必须首先确认对方已处于就绪状态，并交换一些必要的信息以对帧序号初始化，然后才能建立连接，在传输过程中要能维持连接，而在传输完毕后要释放该连接。\n数据链路层通常可以为网络层提供如下三种服务：\n\n\n无确认的无连接服务\n源主机发送帧时不需要先建立链路连接，目的主机收到帧时不需要发回确认。\n数据传输的可靠性由高层负责。适用于误码率较低的信道，如以太网。\n\n\n有确认的无连接服务\n源主机发送帧时不需先建立链路连接，但目的主机收到帧时必须发回确认。\n源主机在所规定的时间内未收到确定信号时，就重传丢失的帧，以提高传输的可靠性。\n该服务适用于误码率较高的信道，如无线通信。\n\n\n有确认的面向连接服务\n帧传输过程分为三个阶段：建立链路、传输帧、释放链路。\n目的主机对收到的每一个帧都要返回确认。\n该服务适用于可靠性要求较高的场合。\n\n有连接就一定要有确认，即不存在无确认的面向连接的服务。\n\n\n\n封装成帧与透明传输\n封装成帧\n\n\n封装成帧是指在一段数据的前后分别添加首部和尾部，构成帧，帧是数据链路层的数据传送单元。\n\n\n                  \n                  Tip\n                  \n                \n\n组帧时既要加首部，又要加尾部的原因是，在网络中信息是以帧为最小单位进行传输的，所以接收方要正确地接收帧，就必须清楚该帧在一串比特流中从哪里开始到哪里结束（因为接收方收到的是一串比特流，没有首部和尾部是不能正确区分帧的）。\n而分组（即 IP 数据报）仅是包含在帧中的数据部分，所以不需要加尾部来定界。\n\n\n帧长等于帧的数据部分长度加上首部和尾部的长度。首部和尾部中含有很多控制信息，它们的一个重要作用是确定帧的界限，即帧定界，使得接收方能从接收到的二进制比特流中区分出帧的起始与终止，即帧同步。\n在通信过程中，检测到帧标识位 F 即认为其是帧的开始，然后一旦检测到帧标识位 F 即表示帧的结束。\n\n为了提高帧的传输效率，应当使帧的数据部分的长度尽可能地大于首部和尾部的长度，但随着帧长的增加，传输差错发生的概率也随之提高，发生差错时重传的代价也越大，因此每种链路层协议都规定了帧的数据部分的长度上限，即最大传送单元。\n\n透明传输\n若在数据中恰好出现与帧定界符相同的比特组合（会误认为“传输结束”而丢弃后面的数据），则要采取有效的措施来解决这个问题，即透明传输。更确切地说，透明传输是指不论所传的数据是什么样的比特组合，都能够按原样无差错地在这个数据链路上传输。\n\n发送方依据一定的规则将网络层递交的分组封装成帧（也称组帧）。\n数据链路层之所以要将比特组合成以帧为单位传输，是为了在出错时只重发出错的帧，而不必重发全部数据，从而提高效率。组帧主要解决帧定界、帧同步、透明传输等问题。实现组帧的方法通常有以下 4 种。\n字符计数法\n字符计数法是指在帧首部使用一个计数字段来记录该帧所含的字节数（包括计数字段自身所占用的 1 个字节）。\n\n当接收方读出帧首部的字节计数值时，就知道后面跟随的字节数，从而确定帧结束位置。因为帧与帧之间是连续传输的，所以也能确定下一帧的开始位置。\n字节填充法\n字节填充法使用特定字节来定界一帧的开始与结束。为了使信息位中出现的特殊字符不被误判为帧的首尾定界符，可在特殊字符之前填充一个转义字符 ESC 来加以区分，以实现数据的透明传输。接收方收到转义字符后，就知道其后面紧跟的是数据信息，而不是控制信息。\n帧的数据段中出现帧结束或者开始字符，则发送方在每个 EOT 或 SOH 字符前再插入一个 ESC 字符，接收方收到数据后会自己删除这个插入的 ESC 字符，结果仍得到原来的数据。这也正是字符填充法名称的由来。\n若转义字符 ESC 也出现在数据中，则解决方法仍是在转义字符前插入一个转义字符。\n\n零比特填充法\n零比特填充法充许数据帧包含任意个数的比特，它使用一个特定的比特串 0111 1110 来标志一帧的开始和结束。\n为了不使数据字段中出现的比特流 01111110 被误判为帧的首尾标志，发送方先扫描整个数据字段，每遇到 5 个连续的“1”，就自动在其后插入一个“0”。经过这种比特填充后，就可保证数据字段中不会出现 6 个连续的“1”。接收方做该过程的逆操作，即每收到 5 个连续的“1”，就自动删除后面紧跟的“0”，以恢复原始数据。\n在数据链路层早期使用的 HDLC 协议中，便是采用这种比特填充的首尾标志法来实现透明传输的。\n\n零比特填充法很容易由硬件来实现，性能优于字节填充法。\n违规编码法\n在物理层进行比特编码时，常采用违规编码法。\n例如，曼彻斯特编码方法将数据比特“1”编码成“高-低”电平对，将数据比特“0”编码成“低-高”电平对，而“高-高”电平对和“低一低”电平对在数据比特中是违规的（即没有采用），因此可借用这些违规编码序列来定界帧的起始和终止。局域网 IEEE802 标准就采用了这种方法。\n违规编码法不采用任何填充技术便能实现数据的透明传输，但只适用于采用冗余编码的特殊编码环境。因为字符计数法中计数字段的脆弱性和字节填充法实现上的复杂性与不兼容性，所以目前较常用的组帧方法是零比特填充法和违规编码法。\n差错控制\n因为信道噪声等原因，帧在传输过程中可能会出现错误，这些错误分为位错和帧错。\n\n位错：帧中某些位出现差错，通常采用循环余检验（CRC）来发现位错。\n帧错：帧丢失、帧重复或帧失序等错误，它们都属于传输差错。\n\n过去 OSI 的观点是：必须让数据链路层向上提供可靠传输。因此在 CRC 检错的基础上，增加了帧编号、确认和重传机制。收到正确的帧就要向发送方发送确认。发送方在一定期限内若未收到对方的确认，就认为出现了差错，因此进行重传，直到收到确认为止。\n现在，在通信质量较差的无线传输中，数据链路层依然使用确认和重传机制，向上提供可靠的传输服务。对于通信质量良好的有线链路，数据链路层已不再使用确认和重传机制，即不要求向上提供可靠传输的服务，而仅需进行 CRC 检错，目的是将有差错的帧丢弃，保证上交的帧都是正确的，而对出错的帧的重传任务则由高层协议（如传输层 TCP 协议）完成。\n实际通信链路都不是理想的，比特在传输过程中可能产生差错，1 可能变成 0，0 也可能变成 1，这就是比特差错。比特差错是传输差错中的一种。\n通常利用编码技术进行差错控制，主要有两类：自动重传请求(AutomaticRepeatreQuest, ARQ)和前向纠错(ForwardErrorCorrection, FEC)。在 ARQ 方式中，当接收方检测到差错时，就设法通知发送方重发，直到收到正确的数据为止。在 FEC 方式中，接收方不但能发现差错，而且能确定错误的位置并加以纠正。\n因此，差错控制又可分为检错编码和纠错编码。\n检错编码\n检错编码都采用余编码技术，核心思想是在有效数据（信息位）被发送前，按某种关系附加一定的余位，构成一个符合某一规则的码字后发送。\n当要发送的有效数据变化时，相应的余位也随之变化，使得码字遵从不变的规则。\n接收方根据收到的码字是否仍符合原规则来判断是否出错。\n常见的检错编码有奇偶检验码和循环冗余码。\n奇偶校验码\n奇偶检验码是奇检验码和偶检验码的统称，是一种最基本的检错码。\n它由 n-1 位数据和 1 位检验位组成，检验位的取值（0 或 1）将使整个检验码中“1”的个数为奇数或偶数。只能检查出奇数个比特的错误。\n\n\n奇检验码：附加一个检验位后，码长为 n 的码字中**“1”的个数为奇数**。\n\n\n\n偶检验码：附加一个检验位后，码长为 n 的码字中**“1”的个数为偶数**。\n\n\n\n循环冗余码(CRC)\n数据链路层广泛使用循环余码(Cyclic Redundancy Code, CRC)检错技术。\nCRC 检验码可以检测出所有的单比特错误。\n循环冗余码检错的基本思想：\n\n\n收发双方约定生成多项式 G(x)（最高位和最低位必须为 1)。k 位位串可视为阶数为 k-1 的多项式的系数序列。例如，可用多项式x^3+x^2+1表示位串 1101。\n\n\n发送方基于待发送的数据和 G(x)，计算出余码，将余码附加到数据后面一起发送。\n\n\n接收方收到数据和冗余码后，通过 G(x)来计算收到的数据和冗余码是否产生差错。\n\n\n\n\n假设一个待传送 m 位的数据，CRC 运算产生一个 r 位的余码，称为帧检验序列(FCS)。这样形成的帧将由 m+r 位组成。在所要发送的数据后面增加 r 位余码，虽然增大了传输开销，但是可以进行差错检测，这种代价往往是值得的。\n这个带检验码的帧刚好能被预先确定的多项式 G(x)整除。接收方用相同的多项式去除收到的帧，若无余数，则认为无差错。\n\n计算余码的步骤如下：\n\n\n假设 G(x)的阶为 r，在数据后面加 r 个 0。\n\n\n\n利用模 2 除法，用 G(x)对应的二进制串去除 ① 中计算得出的数据串，得到的余数即为余码（共 r 位，前面的 0 不可省略）。\n\n\n\n\n\n发送方的 FCS 生成和接收方的 CRC 检验都是由硬件实现的，.处理非常迅速，不会影响数据的传输。\n若在传输过程中无差错，则经过 CRC 检验后得出的余数 R 肯定为 O。但是，若出现误码，则余数 R 仍为 O 的概率极低。因此，通过 CRC 检错技术，可以近似地认为“凡是接收方数据链路层接受的帧均无差错”。也就是说，凡是接收方数据链路层接受的帧，我们都能以非常接近 1 的概率认为这些帧在传输过程中未产生差错；而接收方丢弃的帧虽然曾经收到，但最终因为有差错而被丢弃，即未被接受。\n\n\n                  \n                  Tip\n                  \n                \n\n循环冗余码(CRC)是具有纠错功能的，只是数据链路层仅使用了它的检错功能，检测到帧出错则直接丢弃，是为了方便协议的实现。\n\n\n纠错编码*\n最常见的纠错编码是海明码，其实现原理是在有效信息位中加入几个检验位形成海明码，并把海明码的每个二进制位分配到几个奇偶检验组中。某一位出错后，就会引起有关的几个检验位的值发生变化，这不但可以发现错位，而且能指出错位的位置，为自动纠错提供依据。\n现以数据码 1010 为例讲述海明码的编码原理和过程。\n\n\n确定海明码的位数\n设 n 为有效信息的位数，k 为检验位的位数，则信息位 n 和检验位 k 应满足\nn+k≤2^k-1\n\n设信息位为D_4D_3D_2D_1(1010)，共 4 位，检验位为P_3P_2P_1，共 3 位，对应的海明码为H_7H_6H_5H_4H_3H_2H_1。\n\n\n确定检验位的分布\n规定检验位P_i在海明位号为2^{i-1}的位置上，其余各位为信息位，因此有：\nP_1的海明码位号为2^0=1，即H_1为P_1\nP_2的海明码位号为2^1=2，即H_2为P_2\nP_3的海明码位号为2^2=4，即H_4为P_3\n将信息位按原来的顺序插入，则海明码各位的分布如下：\n\n\n\n分组以形成检验关系\n每个数据位用多个检验位进行检验，但要满足条件：被检验数据位的海明位号等于检验该数据位的各检验位海明位号之和。\n另外，检验位不需要再被检验。\n\n\n\n检验位取值\n检验位 P 的值为第 i 组（由该检验位检验的数据位）所有位求异或。\n所以，1010 对应的海明码为 1010010。\n\n\n\n海明码的检验原理\n每个检验组分别利用检验位和参与形成该检验位的信息位进行奇偶检验检查，构成 k 个检验方程：\n\n若S_3S_2S_1的值为“000”，则说明无错；否则说明出错，且这个数就是错误位的位号，如S_3S_2S_1=001，说明第 1 位出错，即 H 出错，直接将该位取反就达到了纠错的目的。\n\n\n可靠传输机制\n流量控制\n因为链路两端结点的工作速率和缓存空间存在差异，所以发送方的发送能力可能大于接收方的接收能力，此时若不适当限制发送方的发送速率，前面来不及接收的帧将被后面不断发送来的帧“淹没”，造成帧的丢失而出错。\n因此，流量控制实际上就是限制发送方的发送速率，使之不超过接收方的接收能力。\n数据链路层和传输层均有流量控制的功能，它们都用到了滑动窗口协议，但也有所区别，主要体现如下：\n\n\n控制的对象不同\n数据链路层控制的是相邻结点之间的流量，而传输层控制的是端到端的流量。\n\n\n控制手段不同\n数据链路层的控制手段是接收方收不下就不返回确认。传输层的控制手段是接收方通过确认报文段中的窗口值来调整发送方的发送窗口。\n\n\n可靠传输概念\n\n可靠传输是指发送方发送的数据都能被接收方正确地接收，通常采用确认和超时重传两种机制来实现。\n\n确认是指接收方每收到发送方发来的数据帧，都要向发送方发回一个确认帧，表示已正确地收到该数据帧。\n超时重传是指发送方在发送一个数据帧后就启动一个计时器，若在规定时间内没有收到所发送数据帧的确认帧，则重发该数据帧，直到发送成功为止。\n\n使用这两种机制的可靠传输协议称为自动重传请求(ARQ)，它意味着重传是自动进行的，接收方不需要对发送方发出重传请求。在 ARQ 协议中，数据帧和确认帧都必须编号，以区分确认帧是对哪个帧的确认，以及哪些帧还未确认。\nARQ 协议分为三种：停止-等待(Stop-and-Wait)协议、后退 N 帧(Go-Back-N)协议和选择重传(SelectiveRepeat)协议。这三种可靠传输协议的基本原理并不仅限于数据链路层，还可应用到其上各层。\n可靠传输服务并不局限于数据链路层，其他各层均可选择实现可靠传输。可靠传输的实现比较复杂，开销比较大，是否使用可靠传输取决于应用需求。\n在有线网络中，链路的误码率较低，为了降低开销，并不要求数据链路层向其上层提供可靠传输服务，即使出现了误码，可靠传输的问题也由其上层处理。而无线网络的链路易受干扰，误码率较高，因此要求数据链路层必须向其上层提供可靠传输服务。\n\n\n可靠传输实现\n停止-等待协议(S-W)\n\nwww.bilibili.com/video/BV1NT411g7n6\n\n发送方每次只允许发送一个帧，接收方每接收一个帧都要反馈一个应答信号，表示可以接收下一帧，发送方收到应答信号后才能发送下一帧。\n若发送方没有收到接收方反馈的应答信号，则需要一直等待。发送方每发送完一个帧，就进入等待接收方确认信息的过程中，因而传输效率很低。\n\n在停止-等待协议中，除数据帧丢失外，还可能出现以下两种差错：\n\n\n到达接收方的数据帧可能已遭破坏，接收方利用前面介绍的差错检测技术检出后，简单地将该帧丢弃。\n为了应付这种可能的情况，发送方装备了计时器。在一个帧发送后，发送方等待确认，当计时器超时的时候，若仍未收到确认，则重发该数据帧。如此重复，直到该数据帧正确到达为止。\n\n\n\n数据帧正确而确认帧被破坏，此时接收方已收到正确的数据帧，但发送方收不到确认帧，因此发送方会重传已被接收的数据帧，接收方收到相同的数据帧时会丢弃该帧，并重传一个该帧对应的确认帧。\n\n\n\n对于停止-等待协议，因为每发送一个数据帧就停止并等待，所以用 1 比特来编号就已足够。\n发送的帧交替地用 0 和 1 来标识，确认帧分别用 ACK0 和 ACK1 来表示，当收到的确认帧有误时，就重传已发送的数据帧。若连续出现相同序号的数据帧，则表明发送方进行了超时重传。若连续出现相同序号的确认帧，则表明接收方收到了重复帧。\n\n此外，为了超时重传和判定重复帧的需要，发送方和接收方都要设置一个帧缓冲区。当发送方发送完数据帧时，必须在其发送缓存中保留该数据帧的副本，这样才能在出现差错时进行重传。只有在收到对方发来的确认帧 ACK 后，方可清除该副本。\n停止-等待协议的优点是简单，缺点是信道利用率太低。为了提高传输效率，产生了连续 ARQ 协议（后退 N 帧协议和选择重传协议），发送方可连续发送多个帧，而不是每发完一个帧就停止等待确认。\n信道利用率是指信道的效率。从时间角度看，信道效率是对发送方而言的，是指发送方在一个发送周期（从发送方开始发送分组到收到第一个确认分组所需的时间）内，有效发送数据的时间与整个发送周期之比。\n\n\n\n后退 N 帧协议(GBN)\n\n\n在后退 N 帧协议中，发送方可在未收到确认帧的情况下，将序号在发送窗口内的多个数据帧全部发送出去。\n后退 N 帧的含义是：发送方发送 N 个数据帧后，若发现这 N 个帧的前一个数据帧在计时器超时的时候仍未收到其确认信息，则该帧被判为出错或丢失，此时发送方不得不重传该出错帧及随后的 N 个帧。这意味着，接收方只允许按顺序接收帧。\n发送方每发送完一个数据帧，就要为该帧设置超时计时器。因为连续发送了许多帧，所以确认帧必须指明是对哪个帧的确认。\n为了降低开销，GBN 协议允许接收方进行累积确认，即允许接收方不需要每收到一个正确的数据帧就立即发回一个确认帧，而可在连续收到多个正确的数据帧后，对最后一个数据帧发回确认信息，也就是说，对某个数据帧的确认就代表该数据帧和之前所有的帧均已正确无误地收到。\n\nwww.bilibili.com/video/BV1NT411g7n6\n\n\n\n\n连续 ARQ 协议采用流水线传输，即发送方可连续发送多个分组。这样，只要发送窗口足够大，就可使信道上有数据持续流动。显然，这种方式能获得很高的信道利用率。\n假设连续 ARQ 协议的发送窗口为 n，即发送方可连续发送 n 个分组，分为两种情况：\n\n\nnT_D&lt;T_D+RTT+T_A：即在一个发送周期内可以发送完 n 个分组，信道利用率为\nU=\\frac{nT_D}{T_D+RTT+T_A}\n\n\nnT_D &gt;= T_D+RTT+T_A：即在一个发送周期内发不完（或刚好发完）n 个分组，对于这种情况，只要不发生差错，发送方就可不间断地发送分组，信道利用率为 1。\n\n\n“信道平均（实际）数据传输速率 = 信道利用率 x 信道带宽（最大数据传输速率）”，或者“信道平均（实际）数据传输速率=发送周期内发送的数据量/发送周期”。\n\n选择重传协议(SR)\n\nwww.bilibili.com/video/BV1NT411g7n6\n\n为了进一步提高信道的利用率，可以设法只重传出现差错和计时器超时的数据帧，但此时必须加大接收窗口，以便先收下失序但正确到达且序号仍落在接收窗口内的那些数据帧，等到所缺序号的数据帧收齐后，再一并送交上层。这就是选择重传协议。\n为了使发送方仅重传出错的帧，接收方不能再采用累积确认，而要对每个正确接收的数据帧逐一进行确认。\n显然，选择重传协议比后退 N 帧协议更复杂，且接收方需要设置足够的帧缓冲区来暂存那些失序但正确到达且序号落在接收窗口内的数据帧。帧缓冲区的数目等于接收窗口的大小而非序号数目，因为接收方不能接收序号在窗口下界以下或窗口上界以上的帧。\n每个发送缓冲区对应一个计时器，当计时器超时的时候，缓冲区的帧就重传。另外，选择重传协议还采用了比上述其他协议更有效的差错处理策略，即一旦接收方检测到某个数据帧出错，就向发送方发送一个否定帧 NAK，要求发送方立即重传 NAK 指定的数据帧。\n\n一般情况下，W_R和W_T的大小是相同的。\n\n区别\n\n\n\n                  \n                  Tip\n                  \n                \n\n在一个数据帧的发送时间和发送周期固定的情况下，发送的数据帧越多则最大信道利用率就越大。显然在这种情况下，停等 &lt; 选择重传 &lt; GBN。\n\n\n介质访问控制\n介质访问控制所要完成的主要任务是，为使用介质的每个结点隔离来自同一信道上其他结点所传送的信号，以协调活动结点的传输。\n用来决定广播信道中信道分配的协议属于数据链路层的一个子层，称为介质访问控制(MediumAccessControl，MAC)子层。\n\n静态划分信道：信道划分介质访问控制\n动态分配信道：随机访问介质访问控制、轮询访问介质访问控制\n\n信道划分\n信道划分介质访问控制将使用同一传输介质的多个设备的通信隔离开来，把时域和频域资源合理地分配给这些设备。\n信道划分介质访问控制通过复用技术实现。所谓复用就是在一条传输媒体上同时传输多路用户的信号。\n\n当传输介质的带宽超过传输单个信号所需的带宽时，通过在条介质上传输多个信号，还能提高传输系统的利用率。\n信道划分的实质是通过分时、分频、分码等方法，将原来的一个广播信道，逻辑上分为几个用于在两个结点之间进行通信的互不干扰的子信道，即将广播信道转变为若干个点对点信道。\n\n频分复用(FDM)\n频分复用(FrequencyDivision Multiplexing，FDM)是指将信道的总频带划分为多个子频带，每个子频带作为一个子信道，每对用户使用一个子信道进行通信。\n所有用户在同一时间占用不同的频带资源。每个子信道分配的频带可不相同，但它们的总和不能超过信道的总频带。\n在实际应用中，为了防止子信道之间互相干扰，相邻信道间还要加入“隔离频带”。\n\n频分复用的优点在于充分利用了传输介质的带宽，系统效率较高，实现也较容易。\n时分复用(TDM)\n时分复用(TimeDivision Multiplexing，TDM)是指将信道的传输时间划分为一段段等长的时间片，称为TDM 帧。每个用户在每个 TDM 帧中占用固定序号的时隙，每个用户所占用的时隙周期性地出现（其周期就是 TDM 的长度），所有用户在不同的时间占用同样的信道资源。\n\nTDM 帧实际上是一段固定长度的时间，它与数据链路层的帧不是同一个概念。\n从某个时刻来看，时分复用信道上传送的仅是某对用户之间的信号；从某段时间来看，传送的是按时间分割的复用信号。因为时分复用是按固定次序给用户分配时隙的，当用户在某段时间暂无数据传输时，其他用户也无法使用这个暂时空闲的线路资源，所以时分复用后的信道利用率不高。\n统计时分复用(StatisticTDM，STDM)又称异步时分复用，它是对 TDM 的一种改进。STDM 帧与 TDM 帧不同，它并不固定分配时隙，而按需动态分配时隙，当用户有数据要传送时，才会分配到 STDM 帧中的时隙，因此可以提高线路的利用率。\n波分复用(WDM)\n波分复用(WavelengthDivisionMultiplexing，WDM)即光的频分复用，它在一根光纤中传输多种不同波长（频率）的光信号，因为波长不同，各路光信号互不干扰，最后用光分用器将各路波长分解出来。因为光波处于频谱的高频段，有很大的带宽，所以可以实现多路的波分复用。\n\n码分复用(CDM)\n码分复用(CodeDivisionMultiplexing，CDM)是采用不同的编码来区分各路原始信号的一种复用方式。与 FDM 和 TDM 不同，它既共享信道的频率，又共享时间。\n实际上，更常用的名词是码分多址(Code Division Multiple Access，CDMA)，其原理是将每个比特时间再划分成 m 个短的时间槽，称为码片(Chip)，通常 m 的值是 64 或 128。\n码分复用技术具有频谱利用率高、抗干扰能力强、保密性强、语音质量好等优点，还可以减少投资及降低运行成本，主要用于无线通信系统，特别是移动通信系统。\n\n\n\n\n\n\n\n\n随机访问\n在随机访问协议中，不采用集中控制方式解决发送信息的次序问题，所有用户都能根据自己的意愿随机地发送信息，占用信道的全部速率。\n在总线形网络中，当有两个或多个用户同时发送信息时，就会产生帧冲突（也称碰撞），导致所有冲突用户的发送均以失败告终。为了解决随机访问发生的冲突，每个用户需要按照一定的规则反复地重传它的帧，直到该帧无冲突地通过，这些规则就是随机访问介质访问控制协议，其核心思想是：胜利者通过争用获得信道，进而获得信息的发送权。\n因此，随机访问介质访问控制协议又称争用型协议。\n可见，采用随机访问控制机制，则结点之间的通信既不共享时间，又不共享空间。因此，随机介质访问控制实质上是一种将广播信道转换为点到点信道的机制。\nALOHA 协议\nALOHA 协议分为纯 ALOHA 协议和时隙 ALOHA 协议两种。\n\n\n纯 ALOHA 协议\n基本思想：当总线形网络中的任何站点需要发送数据时，可以不进行任何检测就发送数据。若在一段时间内未收到确认，则该站点就认为传输过程中发生了冲突。发送站点需要等待一段时间后再发送数据，直至发送成功。\n每个站均可自由地发送数据帧，假定所有帧都是定长的，帧长不用比特而用发送这个帧所需的时间来表示，图中用 T 表示这段时间。\n\n在图中，当站 1 发送帧 1 时，其他站都未发送数据，所以站 1 的发送必定是成功的。但随后站 2 和站 N-1 发送的帧 2 和帧 3 在时间上重叠了一部分（即发生了冲突）。发生冲突的各站都必须进行重传，但并不能马上进行重传，因为这样做必然导致继续发生冲突。因此，让各站等待一段随机的时间，然后进行重传。若再次发生冲突，则需要再等待一段随机的时间，直到重传成功为止。图中其余一些帧的发送情况是，帧 4 发送成功，而帧 5 和帧 6 发生冲突。\n纯 ALOHA 网络的吞吐量很低，为了克服这个缺点，便产生了时隙 ALOHA 协议。\n\n\n时隙 ALOHA 协议\n时隙 ALOHA 协议同步各站点的时间，将时间划分为一段段等长的时隙(SIot)，规定站点只能在每个时隙开始时才能发送帧，发送一帧的时间必须小于或等于时隙的长度。\n这样做避免了用户发送数据的随意性，降低了产生冲突的可能性，提高了信道的利用率。\n\n每个帧到达后，一般都要在缓存中等待一段小于时隙 T 的时间，才能发送出去。当在一个时隙内有两个或两个以上的帧到达时，在下一个时隙将产生冲突。冲突后重传的策略与纯 ALOHA 协议的情况相似。\n\n\nCSMA 协议\nALOHA 网络发生冲突的概率很大。若每个站点在发送前都先监听公用信道，发现信道空闲后再发送，则会大大降低冲突的可能性，从而提高信道的利用率，载波监听多路访问(CarrierSenseMultipleAccess，CSMA)协议依据的正是这一思想。\nCSMA 协议是在 ALOHA 协议基础上提出的一种改进协议，它与 ALOHA 协议的主要区别是多了一个载波监听装置。\n根据监听方式和监听到信道忙后的处理方式的不同，CSMA 协议分为三种。\n\n\n1-坚持 CSMA\n基本思想：当站点要发送数据时，首先监听信道；若信道空闲，则立即发送数据；若信道忙，则继续监听直至信道空闲。\n\n“坚持”的含义是监听到信道忙时，继续坚持监听信道；\n“1”的含义是监听到信道空闲时，立即发送帧的概率为 1。\n\n\n\n非坚持 CSMA\n基本思想：当站点要发送数据时，首先监听信道；若信道空闲，则立即发送数据；若信道忙，则放弃监听，等待一个随机的时间后，再重新监听。\n非坚持 CSMA 协议在监听到信道忙时就放弃监听，因此降低了多个站点等待信道空闲后同时发送数据导致冲突的概率，但也增加了数据在网络中的平均时延。\n\n\np-坚持 CSMA\n只适用于时分信道。\n基本思想：当站点要发送数据时，首先监听信道；若信道忙，则持续监听（即等到下一个时隙再监听），直至信道空闲；若信道空闲，则以概率 p 发送数据，以概率 1-p 推迟到下一个时隙再继续监听；直到数据发送成功。\n\np-坚持 CSMA 检测到信道空闲后，以概率 p 发送数据，以概率 1-p 推迟到下一个时隙继续监听，目的是降低 1-坚持 CSMA 中多个站点检测到信道空闲时同时发送帧的冲突概率。\n采用坚持“监听”的目的是，克服非坚持 CSMA 中因随机等待造成的延迟时间较长的缺点。\n因此，P 坚持 CSMA 协议是非坚持 CSMA 协议和 1-坚持 CSMA 协议的折中。\n\n\n\n\nCSMA/CD 协议\n\nwww.bilibili.com/video/BV1NT411g7n6\n\n载波监听多路访问/冲突检测(CSMA/CD)协议是 CSMA 协议的改进方案，适用于总线形网络或半双工网络环境。\n\n载波监听：指每个站点在发送前和发送过程中都必须不停地检测信道。站点要在发送数据前先监听信道，只有信道空闲时才能发送。\n\n在发送前检测信道是为了获得发送权；\n在发送过程中检测信道是为了及时发现发送的数据是否发生冲突。\n\n\n冲突检测：边发送边监听，若监听到了冲突，则立即停止数据发送，等待一段随机时间后，重新开始尝试发送数据。\n\n\nCSMA/CD 的工作流程可简单地概括为“先听后发，边听边发，冲突停发，随机重发”。\n使用 CSMA/CD 协议的共享总线以太网上的各站点，只是尽量避免碰撞并在出现碰撞时做出退避后重发的处理，但不能完全避免碰撞。\n\n\n                  \n                  Tip\n                  \n                \n\n对于全双工网络，因为全双工采用两条信道，分别用来发送和接收，在任何时候，发收双方都可以发送或接收数据，不可能产生冲突，所以不需要 CSMA/CD 协议。\n从另一个角度来说，在使用 CSMA/CD 协议时，由于正在发送帧的站点必须“边发送帧边检测碰撞”，因此站点不可能同时进行发送和接收，也就是不可能进行全双工通信，而只能进行半双工通信（双向交替通信）。\n\n\n载波监听检测到总线空闲，但总线并不一定空闲。\n\n\nwww.bilibili.com/video/BV1NT411g7n6\n\n\n\n站点从发送帧开始，最多经过时长2\\tau（即\\delta \\rightarrow 0）就可检测出所发送的帧是否遭遇了碰撞。因此，共享总线以太网的==端到端往返时间2\\tau被称为争用期==或碰撞窗口，它是一个非常重要的参数。站点从发送帧开始，经过争用期2\\tau这段时间还没有检测到碰撞，就可以肯定这次发送不会产生碰撞。\n从争用期的概念可以看出，共享总线以太网上的每一个站点从发送帧开始，到之后的一小段时间内，都有可能遭遇碰撞，而这一小段时间的长短是不确定的，它取决于另一个发送帧的站点与本站点的距离，但不会超过总线的端到端往返传播时延，即一个争用期2\\tau 。\n很显然，总线的长度越长，网络中站点数量越多，发生碰撞的概率就越大。因此，共享以太网的总线长度不能太长，接入的站点数量也不能太多。\n\nA 站发送一个很短的帧，但在发送完之前并未检测出冲突。假定这个帧在继续向前传播到达目的站之前和别的站发送的帧发生了冲突，因此目的站将收到有差错的帧。然而，发送站却不知道发生了冲突，因此不会重传这个帧。\n\n为了避免发生这种情况，以太网规定了一个最短帧长（争用期内可发送的数据长度）。最短帧长的计算公式为\n\\text{最短帧长}=\\text{总线传播时延}\\times \\text{数据传输速率}\\times 2\n\n\n在使用 CSMA/CD 协议的共享总线以太网中，正在发送帧的站点一边发送帧一边检测碰撞，当检测到碰撞时就立即停止发送，退避一段随机时间后再重新发送。\n共享总线以太网中的各站点采用截断二进制指数退避(Truncated Binary Exponential Backoff)算法确定冲突后重传的时机，它让发生冲突的站点在停止发送后，推迟一个随机的时间再重新发送。\n算法思想：\n\n确定基本退避时间，一般取 2 倍的总线端到端的传播时延2\\tau。\n从离散的整数集合中随机取出一个数，记为r，重传所需推迟的时间就是r倍的争用期，即2r \\tau。\n当重传达 16 次仍不成功时，说明网络太拥挤，认为该帧永远无法正确发出，抛弃该帧并向高层报告出错。\n\n\n截断二进制指数退避算法可使重传需要推迟的平均时间随重传次数的增大而增大（也称动态退避），因此能降低发生冲突的概率，有利于整个系统的稳定。\n\n\n\nCSMA/CA 协议\nCSMA/CD 协议已成功用于使用有线连接的局域网，但在无线局域网环境下不能简单地搬用 CSMA/CD 协议，特别是冲突检测部分，主要有两个原因：\n\n\n接收信号的强度往往远小于发送信号的强   度，且在无线介质上信号强度的动态变化范围很大，因此若要实现冲突检测，则硬件上的花费会过大。\n\n\n即使能够在硬件上实现碰撞检测功能，但由于无线电波传播的特殊性（存在隐蔽站问题），还会出现无法检测到碰撞的情况，因此实现碰撞检测并没有意义。\n\n站 A 和站 B 都在 AP 的覆盖范围内，但站 A 和站 B 相距较远，彼此都听不见对方。当站 A 和站 B 检测到信道空闲时，都向 AP 发送数据，导致冲突发生，这就是隐蔽站问题。\n\n\n无线局域网不再实现碰撞检测功能，而是将冲突检测改为冲突避免(CollisionAvoidance，CA)，即使用 CSMA/CA 协议。\n“冲突避免”并不是指协议可以完全避免冲突，而是指协议的设计要尽量降低冲突发生的概率。因为 802.11 无线局域网不使用冲突检测，一旦站点开始发送一个帧，就会完全发送该帧，但冲突存在时仍发送整个帧（尤其是长数据帧）会严重降低网络的效率，所以要采用冲突避免技术来降低冲突的概率。\n为了尽量避免冲突，802.11 标准规定，所有站完成发送后，必须等待一段很短的时间（继续监听）才能发送下一帧。这段时间称为帧间间隔(InterFrameSpace, IFS)。\n帧间间隔的长短取决于该站要发送的帧的类型。802.11 标准使用了下列三种 IFS。\n\n\nSIFS（短 IFS）：最短的 IFS，用来分隔属于一次对话的各帧，使用 SIFS 的帧类型有 ACK 帧、CTS 帧、分片后的数据帧，以及所有回答 AP 探询的帧等。\n\n\nPIFS（点协调 IFS）：中等长度的 IFS，在 PCF 操作中使用。\n\n\nDIFS（分布式协调 IFS）：最长的 IFS，用于异步帧竞争访问的时延。\n802.11 标准还采用了虚拟载波监听机制，即让源站将它要占用信道的持续时间（包括目的站发回 ACK 帧所需的时间）及时通知给所有其他站，以便使所有其他站在这段时间内都停止发送，这样就大大减少了冲突的机会。\n\n\n“虚拟载波监听”表示其他站并未监听信道，而是因收到了源站的通知才不发送数据，这种效果就像是其他站都监听了信道。\n\n\n当某个站在发送帧时，很可能有多个站都在监听信道并等待发送帧，一旦信道空闲，这些站几乎同时发送帧而产生碰撞。为了避免上述情况，所有要发送帧的站检测到信道从忙转为空闲后，都要执行退避算法。这样不仅可以减少发生碰撞的概率，还可避免某个站长时间占用无线信道。\n当且仅当检测到信道空闲且这个数据帧是要发送的第一个数据帧时，才不使用退避算法，其他所有情况都必须使用退避算法，具体为：\n\n在发送第一个帧之前检测到信道忙；\n每次重传；\n每次成功发送后要发送下一帧。\n\n\nCSMA/CA 算法的归纳如下：\n\n若站点最初有数据要发送（而非发送不成功再进行重传），且检测到信道空闲，那么在等待时间 DIFS 后，就发送整个数据帧。\n否则，站点执行 CSMA/CA 退避算法，选取一个随机退避值。一旦检测到信道忙，退避计时器就保持不变。只要信道空闲，退避计时器就进行倒计时。\n当退避计时器减至 0 时（这时信道只可能是空闲的），站点就发送整个帧并等待确认。\n发送站若收到确认，就知道已发送的帧被目的站正确接收。这时要发送第二帧，就要从步骤 2 开始，执行 CSMA/CA 退避算法，随机选定一段退避时间。\n\n若发送站在规定时间（由重传计时器控制）内未收到确认帧 ACK，就必须重传该帧，再次使用 CSMA/CA 协议争用该信道，直到收到确认，或经过若干次重传失败后放弃发送。\n\n\n为了避免隐蔽站问题，802.11 标准允许发送站对信道进行预约。\n源站要发送数据帧之前，先监听信道，若信道空闲，则等待时间 DIFS 后，广播一个请求发送 RTS(RequestToSend)控制帧，它包括源地址、目的地址和这次通信所需的持续时间。若 AP 正确收到 RTS 帧，且信道空闲，则等待时间 SIFS 后，向源站发送一个允许发送 CTS(ClearToSend)控制帧，它也包括这次通信所需的持续时间，源站收到 CTS 帧后，再等待时间 SIFS，就可发送数据帧。\n\n若 AP 正确收到了源站发来的数据，则等待时间 SIFS 后就向源站发送确认帧 ACK。AP 覆盖范围内的其他站听到 CTS 帧后，将在 CTS 帧中指明的时间内抑制发送。\nCTS 帧有两个目的：给源站明确的发送许可；指示其他站在预约期内不要发送。\n\n\n源站在 RTS 帧中填写的所需占用信道的持续时间，是从 RTS 帧发送完毕后，到目的站最后发送完 ACK 帧为止的时间，即“SIFS+CTS+SIFS+数据帧+SIFS+ACK”。\nAP 在 CTS 帧中填写的所需占用信道的持续时间，是从 CTS 帧发送完毕，到目的站最后发送完 ACK 帧为止的时间，即“SIFS+数据帧+SIFS+ACK”。\n\n使用 RTS 帧和 CTS 帧进行信道预约会带来额外的开销。但由于 RTS 帧和 CTS 帧都很短，发生碰撞的概率、碰撞产生的开销以及本身的开销都很小。对于一般的数据帧，其发送时延往往远大于传播时延（因为是局域网），碰撞的概率很大，且一旦发生碰撞而导致数据帧重发，则浪费的时间就很多，因此用很小的代价对信道进行预约往往是值得的。\n由于 RTS 帧和 CTS 帧都会携带通信需要持续的时间，这与之前介绍过的数据帧可以携带通信所需持续时间的虚拟载波监听机制是一样的，因此使用 RTS 帧和 CTS 帧进行信道预约，也属于虚拟载波监听机制。\n\n\n                  \n                  CSMA/CD 与 CSMA/CA 区别 \n                  \n                \n\n\nCSMA/CD 可以检测冲突，但无法避免；CSMA/CA 发送数据的同时不能检测信道上有无冲突，本结点处没有冲突并不意味着在接收结点处就没有冲突，只能尽量避免。\n传输介质不同。CSMA/CD 用于总线形以太网，CSMA/CA 用于无线局域网 802.1la/b/g/n 等。\n检测方式不同。CSMA/CD 通过电缆中的电压变化来检测：而 CSMA/CA 采用能量检测、载波检测和能量载波混合检测三种检测信道空闲的方式。\n\nCSMA/CA 在发送数据帧之前先广播告知其他站点，让其他站点在某段时间内不要发送数据帧，以免发生冲突。CSMA/CD 在发送数据帧之前监听，边发送边监听，一旦发生冲突，就立即停止发送。\n\n\n轮询访问：令牌传递协议\n在轮询访问中，用户不能随机地发送信息，而要通过一个集中控制的监控站，以循环方式轮询每个结点，再决定信道的分配。典型的轮询访问控制协议是令牌传递协议。\n在令牌传递协议中，一个令牌沿着环形总线在各站之间依次传递。令牌是一个特殊的控制帧，它本身并不包含信息，仅控制信道的使用，确保同一时刻只有一个站独占信道。\n当环上的一个站希望发送帧时，必须等待令牌。站点只有取得令牌后才能发送帧，因此令牌环网络不会发生冲突（因为令牌只有一个）。\n站点发送完一帧后，应释放令牌，以便让其他站使用。因为令牌在网环上是按顺序依次传递的，所以对所有入网计算机而言，访问权是公平的。\n\n令牌环网络中令牌和数据的传递过程如下：\n\n当网络空闲时，环路中只有令牌帧在循环传递。\n当令牌传递到有数据要发送的站点时，该站点就修改令牌中的一个标志位，并在令牌中附加自已需要传输的数据，将令牌变成一个数据帧，然后将这个数据帧发送出去。\n数据帧沿着环路传输，接收到的站点一边转发数据，一边查看帧的目的地址。若目的地址和自己的地址相同，则接收站就复制该数据帧，以便进一步处理。\n数据帧沿着环路传输，直到到达该帧的源站点，源站点收到自己发出去的帧后便不再转发。同时，通过检验返回的帧来查看数据传输过程中是否出错，若出错则重传。\n源站点传送完数据后，重新产生一个令牌，并传递给下一站点，交出信道控制权。\n\n令牌传递协议非常适合负载很高的广播信道，即多个结点在同一时刻发送数据概率很大的信道。若这样的信道采用随机介质访问控制，则发生冲突的概率很大，而采用令牌传递协议则可以很好地满足各站点间的通信需求。\n令牌传递协议既不共享时间，又不共享空间；它实际上在随机访问介质访问控制的基础上，限定了有权发送数据的结点只能有一个。\n即使是广播信道也可通过介质访问控制机制，使广播信道变为逻辑上的点对点信道，所以说数据链路层研究的是“点到点”之间的通信。\n局域网\n基本概念\n局域网(LocalAreaNetwork，LAN)是指在一个较小的地理范围（如一所学校）内，将各种计算机、外部设备和数据库系统等通过双绞线、同轴电缆等连接介质互相连接起来，组成资源和信息共享的计算机互连网络。\n主要特点如下：\n\n为一个单位所拥有，且地理范围和站点数目均有限。\n所有站点共享较高的总带宽（即较高的数据传输速率）。\n较低的时延和较低的误码率。\n各站为平等关系而非主从关系。\n能进行广播和多播。\n\n局域网的特性主要由三个要素决定：拓扑结构、传输介质、介质访问控制方式，其中最重要的是介质访问控制方式，它决定着局域网的技术特性。\n三种特殊的局域网拓扑实现如下：\n\n以太网（目前使用范围最广)：逻辑拓扑是总线形结构，物理拓扑是星形结构。\n令牌环（TokenRing，IEEE802.5）：逻辑拓扑是环形结构，物理拓扑是星形结构。\nFDDI（光纤分布数字接口，IEEE802.8）：逻辑拓扑是环形结构，物理拓扑是双环结构。\n\nIEEE802 标准定义的局域网参考模型只对应于 OSI 参考模型的数据链路层和物理层，并将数据链路层拆分为两个子层：逻辑链路控制(LLC)子层和介质访问控制(MAC)子层。\n\nMAC 子层，它向上层屏蔽对物理层访问的各种差异，主要功能包括：组帧和拆卸帧、比特传输差错检测、透明传输。\nLLC 子层，与传输介质无关，它向网络层提供无确认无连接、面向连接、带确认无连接、高速传送四种不同的连接服务类型。\n\n\n\n                  \n                  Tip\n                  \n                \n\n广播式网络使用共享的广播信道进行通信，通常是局域网的一种通信方式（局域网工作在数据链路层），因此可以不需要网络层，也就不存在路由选择问题。但数据链路层使用物理层的服务必须通过服务接入点，数据链路层向高层提供服务也必须通过服务接入点。\n\n\n以太网(802.3)\n以太网规约的第一个版本是 DIX V1。之后，它被修改为第二版规约 DIX Ethernet V2，是世界上第一个局域网产品的规约。严格来说，以太网是指符合 DIX Ethernet V2 标准的局域网，但 DIX Ethernet V2 标准与 IEEE 802.3 标准的差别很小，因此通常将802.3 局域网简称为以太网。\n以太网是目前最流行的有线局域网技术。以太网逻辑上采用总线形拓扑结构构，物理拓扑是星形或拓展星形结，所有计算机共享同一条总线，信息以广播方式发送，以太网使用 CSMA/CD 方式对总线进行访问控制（只有当以太网工作于半双工方式下时）。\n以太网采用两项措施来简化通信：\n\n采用无连接的工作方式，既不对发送的数据帧编号，又不要求接收方发送确认，即以太网尽最大努力交付数据，提供的是不可靠服务，对差错的纠正则由高层完成；\n发送的数据都使用曼彻斯特编码的信号，每个码元的中间出现一次电压转换，接收方利用这种电压转换方便地将位同步信号提取出来。\n\n局域网仅工作在 OSI 参考模型的物理层和数据链路层，且以太网是局域网的一种实现形式，因此可以认为以太网参考模型一般只包含物理层和数据链路层。\n网卡\n\n计算机与外界局域网的连接是通过主板上嵌入的一块网络适配器(Adapter)，又称网络接口卡(NetworkInterfaceCard，NIC)实现的。\n适配器上装有处理器和存储器，工作在数据链路层。适配器和局域网的通信是通过电缆或双绞线以串行方式进行的，而适配器和计算机的通信则是通过计算机的 I/O 总线以并行方式进行的。因此，适配器的重要功能就是进行数据的串并转换。\n\n适配器不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码及数据缓存等功能。因此实现的功能主要在物理层和数据链路层。\n当适配器收到正确的帧时，就使用中断来通知该计算机，并交付协议栈中的网络层。当计算机要发送 IP 数据报时，就由协议栈把 IP 数据报向下交给适配器，组帧后发送到局域网。\n当网卡收到一个帧时，首先检查该帧的目的 MAC 地址是否与当前网卡的物理地址相同，若相同，则做下一步处理；若不同，则直接丢弃，并不需要向网络层报告错误消息。\nMAC 地址\n\nIEEE 802 标准为局域网规定了一种 48 位的全球地址，是指局域网上的每台计算机中固化在适配器的 ROM 中的地址，称为物理地址或MAC 地址，这个地址用于控制主机在网络上的数据通信。\n全世界所有的局域网适配器都具有不同的地址，一台计算机只要没有更换适配器，不管其地理位置如何变化，其 MAC 地址都不会变化。\n\nMAC 地址长 6 字节，一般用由连字符（或冒号）分隔的 12 个十六进制数表示。高 24 位为厂商代码，低 24 位为厂商自行分配的适配器序列号。\n\n当路由器通过适配器连接到局域网时，适配器上的 MAC 地址就用来标志路由器的某个接口。路由器若同时连接到两个网络上，则它需要两个适配器和两个 MAC 地址。\n适配器从网络上每收到一个 MAC 帧，首先都要用硬件检查 MAC 帧中的目的地址。若是发往本站的帧，则收下，否则丢弃该帧。\n“发往本站的帧”包括以下三种帧：\n\n单播帧（一对一）：即收到的帧的目的地址与本站的 MAC 地址相同。\n广播帧（一对全体）：即发送给本局域网上所有站点的（全 1 地址）。\n多播帧（一对多）：即发送给本局域网上一部分站点的帧。\n\n\nMAC 帧\n\n\n\n\n\n前导码分为两个字段：\n\n第一个字段是 7 字节的前同步码，用来实现 MAC 帧的比特同步；\n第二个字段是 1 字节的帧开始定界符，表示后面的信息就是 MAC 帧。\n\n以太网帧不需要帧结束定界符，因为当以太网传送帧时，各帧之间必须有一定的间隙。因此，接收方只要找到帧开始定界符，其后面连续到达的比特流就都属于同一个帧。\n实际上，以太网采用了违规编码法的思想，因为以太网使用曼彻斯特编码，所以每个码元中间都有一次电压的跳变。发送方发完一个帧后，发送方网络接口上的电压不再变化，这样接收方就能很容易地找到帧的结束位置，这个位置往前数 4 字节就是 FCS 字段，于是就能确定数据字段的结束位置。\n高速以太网\n速率达到或超过 100Mb/s 的以太网称为高速以太网\n\n\n\n100BASE-T以太网\n在双绞线上传送 100Mb/s 基带信号的星形拓扑以太网，它仍然使用 CSMA/CD 协议，又称快速以太网。既支持全双工方式，又支持半双工方式，可在全双工方式下工作而无冲突发生，因此在全双工方式下不使用 CSMA/CD 协议。\n100BASE-T 的 MAC 帧格式仍然是 802.3 标准规定的帧格式。保持最短帧长不变，但将一个网段的最大长度减小到 100m。\n\n100 表示 100Mb/s，Base 表示采用基带传输，T 表示传输介质是双绞线（若为 F 则表示使用光纤）。\n\n\n\n吉比特以太网\n又称千兆以太网，允许在 1Gb/s 速率下以全双工和半双工两种方式工作。在半双工方式下使用 CSMA/CD 协议，而在全双工方式不使用 CSMA/CD 协议。与 10BASE-T 和 100BASE-T 技术向后兼容。\n使用 802.3 协议规定的帧格式。使用双绞线或光纤作为传输介质。\n\n\n10 吉比特以太网\n10 吉比特以太网的帧格式与 10Mb/s、100Mb/s 和 1Gb/s 以太网的帧格式完全相同，还保留了 802.3 标准规定的以太网最小帧长和最大帧长，以便升级和向后兼容。\n只工作在全双工方式，不存在争用问题，当然也不使用 CSMA/CD 协议。\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n高速以太网的 MAC 帧和标准以太网的 MAC 格式完全相同。\n\n\n共享式以太网（集线器）\n早期的传统以太网是使用粗同轴电缆的共享总线以太网，后来发展到使用价格相对便宜的细同轴电缆。当初认为这种连接方法既简单又可靠，因为在那个时代普遍认为有源器件不可靠，而无源的电缆线才是最可靠的。然而，实践证明这种使用无源电缆线和大量机械接口的总线型以太网并不像人们想象的那么可靠。\n\n在使用细同轴电缆的共享总线以太网之后，以太网发展出来了一种使用大规模集成电路来替代总线、并且可靠性非常高的设备，叫作集线器(Hub)。站点连接到集线器的传输媒体也转而使用更便宜、更灵活的双绞线电缆。\n\n集线器的一些主要特点如下：\n\n使用集线器的以太网虽然物理拓扑是星型的，但在逻辑上仍然是一个总线网。总线上的各站点共享总线资源，使用的还是 CSMA/CD 协议。\n集线器只工作在物理层，它的每个接口仅简单地转发比特，并不进行碰撞检测。碰撞检测的任务由各站点中的网卡负责。\n集线器一般都有少量的容错能力和网络管理功能。例如，若网络中某个站点的网卡出现了故障而不停地发送帧，集线器可以检测到这个问题，在内部断开与出故障网卡的连线，使整个以太网能正常工作。\n\n\n交换式以太网（交换机）\n\nwww.bilibili.com/video/BV1NT411g7n6\n\n1990 年面世的交换式集线器(Switching Hub)，实质上是具有多个接口的网桥，常称为以太网交换机(Switch)或二层交换机（二层是指以太网交换机工作在数据链路层）。\n局域网交换机是数据链路层设备，能实现数据链路层和物理层的功能。\n仅使用交换机（而不使用集线器）的以太网就是交换式以太网。\n\n\n对于传统使用集线器的共享式 10Mb/s 以太网，若共有 N 个用户，则每个用户的平均带宽为总带宽（10Mb/s）的 1/N。\n使用以太网交换机（全双工方式）连接这些主机时，虽然从每个接口到主机的带宽还是 10Mb/s，但是因为一个用户通信时是独占带宽的（而不是和其他网络用户共享传输介质带宽的），所以拥有 N 个接口的交换机的总容量为 Nx10Mb/s。这正是交换机的最大优点。\n\n\n                  \n                  半双工方式时交换机总容量 \n                  \n                \n\n一般情况下，题中没有特别说明交换机的工作方式，则默认为全双工工作方式。\n但是在半双工交换机中，拥有 N 个 10Mb/s 接口的半双工交换机的总容量为\\frac{N}{2}\\times 10Mb/s。\n\n\n\n\n                  \n                  交换机使用例子 \n                  \n                \n\n交换机能将网络分成较小的冲突域，而集线器连接的设备属于同一个冲突域。\n假设一个局域网中大部分的通信量在本局域网内进行时，若使用集线器，则会增加冲突和延迟，降低整个网络的效率，而使用交换机将不同网段的通信隔开，则可以提高网络性能。\n\n\n以太网交换机特点：\n\n当交换机的接口直接与主机或其他交换机连接时，可工作在全双工方式，并能同时连通多对接口，使每对相互通信的主机都能像独占通信介质那样，无冲突地传输数据，这样就不需要使用 CSMA/CD 协议。\n当交换机的接口连接集线器时，只能使用 CSMA/CD 协议且只能工作在半双工方式。\n以太网交换机实质上是一个多接口的网桥，它能将网络分成小的冲突域，为每个用户提供更大的带宽。\n交换机是一种即插即用设备，其内部的帧转发表是通过自学习算法，基于网络中各主机间的通信，自动地逐渐建立的。\n交换机因为使用专用交换结构芯片，交换速率较高。\n交换机独占传输介质的带宽。\n\n\n决定一个帧是转发到某个接口还是丢弃它称为过滤。决定一个帧应被移至哪个接口称为转发。\n交换机的过滤和转发借助交换表完成。交换表中的一个表项至少包含：一个 MAC 地址和一个连通该 MAC 地址的接口。\n\nA 先向 B 发送一帧，从接口 1 进入交换机。交换机收到帧后，先查找交换表，找不到 MAC 地址为 B 的表项。然后，交换机将该帧的源地址 A 和接口 1 写入交换表，并向除接口 1 外的所有接口广播这个帧。交换表中写入（A，1）后，从任何接口收到目的地址为 A 的帧都应从接口 1 转发出去。\n因为交换机所连的主机会随时变化，所以需要更新交换表中的表项。为此，交换表中的每个表项都设有一定的有效时间，过期表项将被自动删除。这就保证了交换表中的数据符合当前网络的实际状况。这种自学习算法使得交换机能即插即用，而不必手工配置，因此非常方便。\n\n\n                  \n                  同一局域网中具有相同的静态 MAC 地址通信 \n                  \n                \n\n在同一个局域网中，两个设备具有相同的 MAC 地址，若这两个设备通过交换机相互发送帧，则根据交换机的原理，目的 MAC 地址等于本机 MAC 地址的帧将被交换机丢弃。当其他设备向这两个设备中的一个发送帧时，另一个设备也收到帧，而网卡在与本机 MAC 地址比较后，都认为是属于自己的帧。因此，导致这两个设备无法正常通信。\n\n\n以太网交换机主要采用两种交换模式：\n\n\n直通交换方式\n只检查帧的目的 MAC 地址，以决定该帧的转发接口。\n这种方式的交换时延非常小，缺点是它不检查差错就直接转发，因此可能将一些无效帧转发给其他站。\n不适用于需要速率匹配、协议转换或差错检测的线路。\n\n\n存储转发交换方式\n先将接收到的帧缓存到高速缓存器中，并检查数据是否正确，确认无误后通过查找表转换为输出接口，以便将该帧发送出去。若发现帧有错，则将其丢弃。\n优点是可靠性高，且能支持不同速率接口间的转换，缺点是时延较大。\n\n\n\n交换机一般都具有多种速率的接口。\n共享式交换式以太网的对比\n\n\n主机发送普通帧\n\n对于共享式以太网，集线器将帧转发到其他所有接口，其他各主机中的网卡根据帧的目的 MAC 地址决定接收或丢弃该帧。\n对于交换式以太网，交换机收到帧后，根据帧的目的 MAC 地址和自身的交换表将帧明确地转发给目的主机。\n\n\n\n\n主机发送广播帧\n\n对于共享式以太网，集线器将帧转发到其他所有接口，其他各主机中的网卡检测到帧的目的 MAC 地址是广播地址时，就接收该帧。（集线器不检测直接转发）\n对于交换式以太网，交换机检测到帧的目的 MAC 地址是广播地址，于是从其他所有接口转发该帧，其他各主机收到该广播帧后，就接收该帧。（交换机检测后再转发）\n\n两种情况从效果上看是相同的，但它们的原理并不相同。\n\n\n\n多对主机同时通信\n\n对于共享式以太网，当多对主机同时通信时，必然产生冲突。\n\n\n\n\n对于交换式以太网，交换机能实现多对接口的高速并行交换，因此不会产生冲突。\n\n\n可见，集线器既不隔离广播域，又不隔离冲突域，而交换机不隔离广播域，但隔离冲突域。\n\n\n\n交换式以太网的网络性能远高于共享式以太网，集线器早已被交换机取代。\nQ&amp;A\n\n无线局域网(802.11)\nIEEE 802.11\n分类\n无线局域网可分为两大类：有固定基础设施的无线局域网和无固定基础设施的移动自组织网络。\n所谓“固定基础设施”，是指预先建立的、能覆盖一定地理范围的固定基站。\n\n\n有固定基础设施\n802.11 标准使用星形拓扑，其中心称为接入点(AccessPoint, AP)，在 MAC 层使用 CSMA/CA 协议。使用 802.11 系列协议的局域网又称 Wi-Fi。\n\n\n\n\n\n无固定基础设施移动自组织网络\n另一种无线局域网是无固定基础设施的无线局域网，又称自组网络。自组网络没有上述基本服务集中的 AP，而有由一些平等状态的移动站相互通信组成的临时网络。各结点之间地位平等，中间结点都为转发结点，因此都具有路由器的功能。\n\n\n\nMAC 帧\n\n\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n在 A-(1)–AP-(2)–B 这种三段的数据链路中可以看作\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n地址 1地址 2地址 3去的地址来的地址三个地址中最后一个地址链路 1APAB链路 2BAPA\n\n\n\n\n\n虚拟局域网(VLAN)\n一个以太网是一个广播域，当一个以太网中包含的计算机太多时，往往会导致以太网中出现大量的广播帧。\n广播信息的目的地是该网络中的所有计算机，所以网络中的每台计算机都必须花时间来处理这些广播信息，若网络中存在大量的广播信息，则所有计算机的运行效率都会受到影响，导致网络性能降低。\n\n通过虚拟局域网(VirtualLAN, VLAN)，可将一个较大的局域网分割成一些较小的与地理位置无关的逻辑上的 VLAN，而每个 VLAN 是一个较小的广播域。\nVLAN 建立在交换技术的基础上，以软件方式实现逻辑分组与管理，VLAN 中的计算机不受物理位置的限制。当计算机从一个 VLAN 转移到另一个 VLAN 时，只需简单地通过软件设定，而无须改交它在网络中的物理位置。同一个 VLAN 的计算机不一定连接到相同的物理网段，它们可连接到相同的交换机，也可连接到不同的局域网交换机，只要这些交换机互连即可。\n从数据链路层的角度看，不同 VLAN 中的主机之间不能直接通信。\n虚拟局域网VLAN 并不是一种新型网络，它只是局域网能够提供给用户的一种服务。\nVLAN 优点：有效共享资源、简化了网络管理，提高了信息的保密性、网络的安全性\n\n\n有以下三种划分 VLAN 的方式：\n\n\n基于接口\n将交换机的若干接口划为一个逻辑组，这种方法最简单、最有效，若主机离开了原来的接口，则可能进入一个新的子网。\n\n\n基于MAC 地址\n按 MAC 地址将一些主机划分为一个逻辑子网，当主机的物理位置从一个交换机移动到另一个交换机时，它仍属于原来的子网。\n\n\n基于IP 地址\n根据网络层地址或协议划分 VLAN，这样的 VLAN 可以跨越路由器进行扩展，将多个局域网的主机连接在一起。\n\n\n\n虚拟局域网 VLAN 有多种实现技术，最常见的就是基于以太网交换机的接口来实现 VLAN。这就需要以太网交换机能够实现以下两个功能：\n\n能够处理带有 VLAN 标记的帧，也就是 IEEE 802.1Q 帧。\n交换机的各接口可以支持不同的接口类型，不同接口类型的接口对帧的处理方式有所不同。\n\n\n802.3ac 标准定义了支持 VLAN 的以太网帧格式的扩展。它在以太网帧中插入一个 4 字节的标识符（插在源地址字段和类型字段之间），称为 VLAN 标签，用来指明发送该帧的计算机属于哪个虚拟局域网。\n插入 VLAN 标签的帧称为 802.1Q 帧。因为 VLAN 帧的首部增加了 4 字节，所以以太网的最大帧长从原来的 1518 字节变为 1522 字节。\n\n\n\n\n\n\n\n\n广域网\n广域网的基本概念\n广域网(WideAreaNetwork, WAN)通常是指覆盖范围很广（远超一个城市的范围）的长距离网络，任务是长距离运送主机所发送的数据。连接广域网各结点交换机的链路都是高速链路，广域网首要考虑的问题是通信容量必须足够大，以便支持日益增长的通信量。\n广域网的通信子网主要使用分组交换技术，将分布在不同地区的局域网或计算机系统互连起来，达到资源共享的目的。\n广域网覆盖范围较广、结点较多，为了保证可靠性和可扩展性，通常需采用网状结构。\n广域网不等于互联网。互联网可以连接不同类型的网络，通常使用路由器来连接。因此，局域网可以通过广域网与另一个相隔很远的局域网通信。\n广域网由一些结点交换机（不是路由器）及连接这些交换机的链路组成。结点交换机的功能是存储并转发分组。结点之间都是点到点连接，但为了提高网络的可靠性，通常一个结点交换机往往与多个结点交换机相连。\n\n\n                  \n                  Tip\n                  \n                \n\n结点交换机和路由器都用来转发分组，它们的工作原理也类似。结点交换机在单个网络中转发分组，而路由器在多个网络构成的互联网中转发分组。\n\n\n目前局域网接入广域网主要是通过路由器实现。\n从层次上考虑，广域网和局域网的区别很大，因为局域网使用的协议主要在数据链路层（还有少量在物理层），而广域网使用的协议主要在网络层。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n广域网局域网覆盖范围很广，通常跨区域较小，通常在一个区域内连接方式通常采用点对点连接普遍使用广播信道OSI 参考模型层次物理层，数据链路层，网络层物理层，数据链路层着重点强调资源共享强调数据传输\n联系与相似点\n\n广域网和局域网都是互联网的重要构件，从互联网的角度看，二者平等（不是包含关系）\n当连接到一个广域网或一个局域网上的主机在该网内进行通信时，只需要使用其网络的物理地址\n\nPPP 协议\n点对点协议(Point-to-PointProtocol，PPP)是现在最流行的点对点链路控制协议。\n主要有两种应用：\n\n\n用户通常都要连接到某个 ISP 才能接入互联网，PPP 协议就是用户计算机与 ISP 通信时所用的数据链路层协议；\n\n\n\n广泛用于广域网路由器之间的专用线路。\n\n\n\nPPP 协议有三个组成部分：\n\n一个链路控制协议(LCP)\n\n用来建立、配置、测试数据链路连接，以及协商一些选项。\n\n\n一套网络控制协议(NCP)\nPPP 协议允许采用多种网络层协议，每个不同的网络层协议要用一个相应的 NCP 来配置，为网络层协议建立和配置逻辑连接。\n\n\n一种组帧的方法（将 IP 数据报封装到串行链路）\nIP 数据报在 PPP 帧中就是其信息部分，这个信息部分的长度受最大传送单元(MTU)限制。\n\n\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n因为 PPP 是点对点的，并不是总线形，所以无须使用 CSMA/CD 协议，自然就不会有最短帧长的限制，所以信息段占 0 ～ 1500 字节，而不是 46~1500 字节。\n\n\n\n\n当处于链路静止状态时，通信双方不存在物理层的连接。\n当链路一方检测到载波信号并建立物理连接时，进入链路建立状态。\n在链路建立状态下，链路控制协议(LCP)开始协商一些配置选项（包括最大帧长、鉴别协议等）。\n\n若协商成功，则进入鉴别状态。\n若协商失败，则退回到链路静止状态。\n\n\n协商成功后，双方就建立了 LCP 链路，接着进入“鉴别”状态。\n\n若双方无须鉴别或鉴别身份成功，则进入网络层协议状态。\n若鉴别失败，则进入链路终止状态。\n\n\n处于网络层协议状态后，双方采用 NCP 配置网络层，配置协商成功后，进入链路打开状态。\n只要链路处于打开状态，双方就可进行数据通信。\n数据传输结束后，链路一方发出终止请求且在收到对方发来的终止确认后，或者链路出现故障时，进入链路终止状态。载波停止后，回到链路静止状态。\n\n\nPPP 协议的特点如下：\n\nPPP不使用序号和确认机制，只保证无差错接收（CRC 检验），即提供差错检测功能，但不提供纠错功能。因此是不可靠服务。\nPPP只支持全双工的点对点链路，不支持多点线路。\nPPP 的两端可以运行不同的网络层协议，但仍可使用同一个 PPP 进行通信。\nPPP 是面向字节的，所有 PPP 帧的长度都是整数个字节。\nPPP 可用于拨号连接，因此支持动态分配 IP 地址。\n"},"计算机基础/计算机网络/4_网络层":{"title":"网络层","links":[],"tags":["计算机网络"],"content":"网络层概述\n网络层的主要目的在任意结点间进行数据报不可靠传输。\n网络层的主要任务就是将分组从源主机经过多个网络和多段链路传输到目的主机，可以将该任务划分为分组转发和路由选择两种重要的功能。\n冲突域\n冲突域是指能产生冲突的所有设备的集合，这些结点之间存在介质争用的现象。\n在 OSI 参考模型中，冲突域被视为第 1 层的概念，像集线器、中继器等简单无脑复制转发信号的第 1 层设备所连接的结点都属于同一个冲突域，也就是说它们不能划分冲突域。而第 2 层（网桥、交换机）、第 3 层（路由器）设备都可以划分冲突域。\n\n\n                  \n                  Tip\n                  \n                \n\n“域”表示冲突或广播在其中发生并传播的区域。\n\n\n广播域\n广播域是指接收同样广播消息的结点集合。也就是说，在该集合中的任何一个结点发送一个广播帧，其他能收到这个帧的结点都被认为是该广播域的一部分。\n在 OSI 参考模型中，广播域被视为第 2 层的概念，像第 1 层（集线器等）、第 2 层（交换机等）设备所连接的结点都属于同一个广播域。而路由器，作为第 3 层设备，则可以划分广播域，即可以连接不同的广播域。\n通常所说的局域网(LAN)特指使用路由器分割的网络，也就是广播域。\n路由与转发\n路由器主要完成两个功能：\n\n\n路由选择（确定哪一条路径）\n根据路由协议构造路由表，同时经常或定期地与相邻路由器交换信息，获取网络最新拓扑，动态更新维护路由表，以决定分组到达目的地结点的最优路径。\n虽然一些路由协议也将延迟等作为参数进行路由选择，但路由协议使用得最多的参数是传输距离，此外还有一些其他参数。\n\n\n分组转发（当一个分组到达时所采取的动作）\n指路由器根据转发表将分组从合适的端口转发出去，关键操作是转发表查询、转发及相关的队列管理和任务调度等。\n路由器只能根据 IP 进行转发。\n\n\n路由表是根据路由选择算法得出的，而转发表是从路由表得出的。转发表的结构应当使查找过程最优化，路由表则需要最优化网络拓扑变化的计算。\n路由表通常包含目的网络和到达该目的网络路径上的下一个路由器的 IP 地址。\n路由器转发一个分组的过程如下：先接收整个分组，然后对分组进行错误检查，若出错，则丢弃错误的分组；否则存储该正确的分组。最后根据路由选择协议，将正确的分组转发到合适的端口，这种机制称为存储转发机制。\n\n在讨论路由选择的原理时，往往不区分转发表和路由表，而笼统地使用路由表一词。\n路由器\n路由器主要实现物理层、数据链路层、网络层的功能。\n路由器是一种具有多个输入/输出端口的专用计算机，其任务是连接不同的网络（连接异构网络）并完成分组转发。在多个逻辑网络（即多个广播域）互连时必须使用路由器。\n路由器是第三层设备，向传输层及以上层次隐藏下层的具体实现，所以在路由器互连的多个局域网的结构中，每个局域网的物理层、数据链路层、网络层协议可以不同。而网络层之上的协议数据是路由器所不能处理的，因此网络层以上的高层协议必须相同。\n路由器是第三层设备，要处理的内容比第二层设备交换机更多，因而转发速度比交换机慢。\n通常的路由器可以支持多种网络层协议，并提供不同协议之间的分组转发。例如使用特定的路由器连接 IPv4 与 IPv6 网络，就是典型的网络层协议不同而实现互连的例子。\n路由器工作在网络层，不转发广播包（目的地址为 255.255.255.255 的 IP 包），因此能够分隔广播域，抑制网络风暴。\n\n当源主机向目标主机发送数据报时，路由器先检查源主机与目标主机是否连接在同一个网络上。\n\n若源主机和目标主机在同一个网络上，则直接交付而无须通过路由器。\n若源主机和目标主机不在同一个网络上，则路由器按照转发表（由路由表得出）指出的路由将分组转发给下一个路由器，这称为间接交付。\n\n可见，在同一个网络中传递数据无须路由器的参与，而跨网络通信必须通过路由器进行转发。\n\n从结构上看，路由器由路由选择和分组转发两部分构成。\n从模型的角度看，路由器是网络层设备，它实现了网络模型的下三层，即物理层、数据链路层和网络层。\n\n\n\n                  \n                  Tip\n                  \n                \n\n若一个存储转发设备实现了某个层次的功能，则它可以互连两个在该层次上使用不同协议的网段（网络）。若网桥实现了物理层和数据链路层，则网桥可以互连两个物理层和数据链路层不同的网段；但中继器实现了物理层后，却不能互连两个物理层不同的网段，这是因为中继器不是存储转发设备，它属于直通式设备。\n\n\n\n转发表是从路由表得出的，其表项和路由表项有直接的对应关系。但转发表的格式和路由表的格式不同，其结构应使查找过程最优化，而路由表则需对网络拓扑变化的计算最优化。\n转发表中含有一个分组将要发往的目的地址，以及分组的下一跳（即下一步接收者的目的地址，实际为 MAC 地址）。为了减少转发表的重复项目，可以使用一个默认路由代替所有具有相同“下一跳”的项目，并将默认路由设置得比其他项目的优先级低。\n路由表总是用软件来实现的；转发表可以用软件和特殊的硬件来实现。\n注意转发和路由选择的区别：\n\n“转发”是路由器根据转发表把收到的 IP 数据报从合适的端口转发出去，它仅涉及一个路由器。\n“路由选择”则涉及很多路由器，路由表是许多路由器协同工作的结果。这些路由器按照复杂的路由算法，根据从各相邻路由器得到的关于网络拓扑的变化情况，动态地改变所选择的路由，并由此构造出整个路由表。\n\n路由表不等于转发表，分组的实际转发是靠直接查找转发表，而不是查找路由表。\n\n网络层的服务\n分组交换网根据其通信子网向端点系统提供的服务，还可进一步分为面向连接的虚电路服务和无连接的数据报服务。这两种服务方式都是由网络层提供的。\n\n\nOSI 参考模型曾主张在网络层使用面向连接的虚电路服务，认为应由网络自身来保证通信的可靠性。\n虚电路是面向连接的，它提供的是可靠的服务，能保证数据的可靠性和有序性，但是一旦虚电路中的某个结点出现故障，就必须重新建立一条虚电路。\n对于出错率高的传输系统，易出现结点故障，因此采用数据报方式更合适。\n\n\nTCP/IP 体系的网络层提供的是无连接的数据报服务，其核心思想是应由用户主机来保证通信的可靠性。\n数据报是无连接的，它提供的是不可靠的服务，分组有可能丢失、失序，也不保证到达的时间，传输既不保证可靠性，又不保证分组的按序到达。\n\n\n分组交换-虚电路\n在虚电路方式中，当两台计算机进行通信时，应当先建立网络层的连接，也就是建立一条逻辑上的虚电路(Virtual Circuit, VC)，连接一旦建立，就固定了虚电路对应的物理路径。\n\n\n                  \n                  Tip\n                  \n                \n\n虚电路提供的服务包括：\n\n永久性虚电路（PVC）：提前定义好的、基本上不需要任何建立时间的端点之间的连接。\n交换型虚电路（SVC）：端点之间的一种临时性连接，这些连接只持续所需的时间，且在会话结束时就取消这种连接。\n\n\n\n\n每次建立虚电路时，将一个未用过的虚电路号(VCID)分配给该虚电路，以区别于本系统中的其他虚电路，然后双方就沿着已建立的虚电路传送分组。\n分组的首部仅在连接建立时使用完整的目的地址，之后每个分组的首部只需携带这条虚电路的编号即可。\n在虚电路网络中的每个结点上都维持一张虚电路表，表中每项记录一个打开的虚电路的信息，包括在接收链路和发送链路上的虚电路号、前一结点和下一结点的标识，它是在虚电路建立过程中确定的。\n与电路交换类似，整个通信过程分为三个阶段：\n\n\n虚电路建立\n数据传输前，主机 A 与主机 B 先建立连接，主机 A 发出“呼叫请求”分组，该分组通过中间结点送往主机 B，若主机 B 同意连接，则发送“呼叫应答”分组予以确认。\n\n\n数据传输\n虚电路建立后，主机 A 和主机 B 就可相互传送数据分组。\n\n\n虚电路释放\n传送结束后，主机 A 通过发送“释放请求”分组来拆除虚电路，逐段断开整个连接。\n\n\n\n虚电路服务具有如下特点：\n\n虚电路通信链路的建立和拆除需要时间开销，对交互式应用和少量的短分组情况显得很浪费，但对长时间、频繁的数据交换效率较高。\n虚电路的路由选择体现在连接建立阶段，连接建立后，就确定了传输路径。\n虚电路提供了可靠的通信功能，本身就可实现差错控制，不需要依赖其他协议实现差错控制;能保证每个分组正确且有序到达。此外，还可对两个端点的流量进行控制，当接收方来不及接收数据时，可以通知发送方暂缓发送。\n虚电路有一个致命的弱点，即当网络中的某个结点或某条链路出现故障而彻底失效时，所有经过该结点或该链路的虚电路将遭到破坏。\n分组首部包含的是虚电路号，不包含目的地址,相对于数据报方式，其开销小。\n\n虚电路之所以是虚，是因为这条电路不是专用的，每个结点到其他结点之间的链路可能同时有若干条虚电路通过，也可能同时在多个结点之间建立虚电路。\n网络中的传输是否有确认与网络层提供的两种服务没有任何关系。\n分组交换-数据报\n在互联网采用的 TCP/IP 体系结构中，网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。也就是说，所传送的分组可能出错、丢失、重复、失序或超时，这就使得网络中的路由器可以做得比较简单，而且价格低廉（与电话网络相比）。\n网络在发送分组前不需要先建立连接。\n源主机的高层协议将报文拆成若干较小的数据段，并加上地址等控制信息后构成分组。中间结点存储分组很短一段时间，找到最佳的路由后，尽快转发每个分组。\n\n当分组正在某一链路上传送时，分组并不占用网络其他部分的资源。因为采用存储转发技术，资源是共享的，所以主机 A 在发送分组时，主机 B 也可同时向其他主机发送分组。\n数据报服务具有如下特点：\n\n发送分组前不需要建立连接。发送方可随时发送分组，网络中的结点可随时接收分组。\n网络尽最大努力交付，传输不保证可靠性，所以分组可能出错或丢失；网络为每个分组独立地选择路由，转发的路径可能不同，因此分组不一定按序到达目的结点。\n发送的分组中要包括发送方和接收方的完整地址，以便可以独立传输。\n当分组在交换结点存储转发时，需要排队等候处理，这会带来一定的时延。当网络发生拥塞时，这种时延会大大增加，交换结点还可根据情况丢弃部分分组。\n网络具有余路径，当某个交换结点或一条链路出现故障时，可相应地更新转发表，寻找另一条路径转发分组，对故障的适应能力强。\n收发双方不独占某条链路，资源利用率较高。\n\n采用这种设计思想的好处是：网络的造价大大降低、运行方式灵活、能够适应多种应用。\n比较\n\n异构网络互连\n互联网是由全球范围内数以百万计的异构网络互连起来的。这些网络的拓扑结构、寻址方案、差错处理方法、路由选择机制等都不尽相同，即数据链路层和物理层均不同。网络层所要完成的任务之一就是使这些异构的网络实现互连。\n网络互连是指将两个以上的计算机网络，通过一定的方法，用一些中继系统相互连接起来，以构成更大的网络系统。\n根据所在的层次，中继系统分为以下 4 种：\n\n物理层中继系统：转发器，集线器。\n数据链路层中继系统：网桥或交换机。\n网络层中继系统：路由器。\n网络层以上的中继系统：网关。\n\n当使用物理层或数据链路层的中继系统时，只是把一个网络扩大了，而从网络层的角度看，它仍然是同一个网络，一般并不称为网络互连。因此，网络互连通常是指用路由器进行网络连接和路由选择。\n\n\n                  \n                  Tip\n                  \n                \n\n路由器是一台专用计算机，用于在互联网中进行路由选择。\n许多有关 TCP/IP 的文献也将网络层的路由器称为网关。\n\n\nTCP/IP 在网络互连上采用的做法是在网络层采用标准化协议，但相互连接的网络可以是异构的。\n虚拟互连网络也就是逻辑互连网络，意思是互连起来的各种物理网络的异构性本来是客观存在的，但是通过 IP 协议就可使这些性能各异的网络在网络层上看起来像是一个统一的网络。这种使用 IP 协议的虚拟互连网络可简称为 IP 网络。\n\n使用 IP 网络的好处是：当 IP 网上的主机进行通信时，就好像在单个网络上通信一样，而看不见互连的各个网络的具体异构细节（如具体的编址方案、路由选择协议等）。\n软件定义网络(SDN)\n网络层的主要任务是转发和路由选择。可以将网络层抽象地划分为数据平面（也称转发层面）和控制平面，转发是数据平面实现的功能，而路由选择是控制平面实现的功能。\n\n软件定义网络(SoftwareDefinedNetwork, SDN)是近年流行的一种创新网络架构，它采用集中式的控制平面和分布式的数据平面，两个平面相互分离，控制平面利用控制-数据接口对数据平面上的路由器进行集中式控制，方便软件来控制网络。\n传统网络中的路由器既有转发表又有路由选择软件，即既有数据平面又有控制平面。但是在 SDN 结构中，路由器都变得简单了，它的路由选择软件都不需要了，因此路由器之间不再相互交换路由信息。\n在网络的控制平面有一个逻辑上的远程控制器（可由多个服务器组成）。远程控制器掌握各主机和整个网络的状态，为每个分组计算出最佳路由，通过 Openflow 协议（或其他途径）将转发表（在 SDN 中称为流表）下发给路由器。路由器的工作很单纯，即收到分组、查找转发表、转发分组。\n\n这样，网络又变成集中控制的，而本来互联网是分布式的。SDN 并非要把整个互联网都改造成集中控制模式，这是不现实的。然而，在某些具体条件下，特别是像一些大型的数据中心之间的广域网，使用 SDN 模式来建造，就可使网络的运行效率更高。\nSDN 的可编程性通过为开发者提供强大的编程接口，使得网络具有很好的编程性。\n\n\n对上层应用的开发者，SDN 提供的编程接口称为北向接口，北向接口提供了一系列丰富的 API，开发者可以在此基础上设计自已的应用，而不必关心底层的硬件细节。\n\n\nSDN 控制器和转发设备建立双向会话的接口称为南向接口，通过不同的南向接口协议（如 Openflow），SDN 控制器就可兼容不同的硬件设备，同时可在设备中实现上层应用的逻辑。\n\n\nSDN 控制器集群内部控制器之间的通信接口称为东西向接口，用于增强整个控制平面的可靠性和可拓展性。\n\n\n\nSDN 的优点：\n\n全局集中式控制和分布式高速转发，既利于控制平面的全局优化，又利于高性能的网络转发。\n灵活可编程与性能的平衡，控制和转发功能分离后，使得网络可以由专有的自动化工具以编程方式配置。\n降低成本，控制和数据平面分离后，尤其是在使用开放的接口协议后，就实现了网络设备的制造与功能软件的开发相分离，从而有效降低了成本。\n\nSDN 的问题：\n\n安全风险，集中管理容易受攻击，若崩溃，则整个网络会受到影响。\n瓶颈问题，原本分布式的控制平面集中化后，随着网络规模扩大，控制器可能成为网络性能的瓶颈。\n\nIPV4\nIPv4 即现在普遍使用的网际协议(IntemetProtocol, IP)。\nIPv4 地址是给因特网(Internet)上的每一个主机（或路由器）的每一个接口分配的一个在全世界范围内唯一的32 比特的标识符。IP 地址由互联网名字和数字分配机构 ICANN 进行分配。\nIP 定义数据传送的基本单元一一 IP 分组及其确切的数据格式。IP 也包括一套规则，指明分组如何处理、错误怎样控制。\nIPv4 地址\n\n表示方法\n由于 IPv4 地址由 32 比特构成，不方便阅读、记录以及输入等，因此 IPv4 地址采用点分十进制表示方法以方便用户使用。\n\n\n分类编址\n\n\n无论哪类 IP 地址，都由网络号和主机号两部分组成。即\n\\text{IP地址}::=\\{&lt;\\text{网络号}&gt;,&lt;\\text{主机号}&gt;\\}\n\n网络号标志主机（或路由器）所连接到的网络，一个网络号在整个互联网范围内必须是唯一的。\n主机号标志该主机（或路由器），一台主机号在它前面的网络号所指明的网络范围内必须是唯一的。\n\n由此可见，一个 IP 地址在整个互联网范围内是唯一的。\n特殊 IP 地址\n在各类 IP 地址中，有些 IP 地址具有特殊用途，不用作主机的 IP 地址：\n\n主机号全为 0 表示本网络本身，不能分配给主机（或路由器）的各接口。\n主机号全为 1 表示本网络的广播地址，又称直接广播地址，不能分配给主机（或路由器）的各接口。\n127.x.x.x 保留为环回自检地址，此地址表示任意主机本身，目的地址为环回地址的 IP 数据报永远不会出现在任何网络上。\n32 位全为 0，即 0.0.0.0 表示本网络上的本主机。\n32 位全为 1，即 255.255.255.255 表示整个 TCP/IP 网络的广播地址，又称受限广播地址。实际使用时，因为路由器对广播域的隔离，255.255.255.255 等效为本网络的广播地址。\n\n\n\n\n\n\n\nIP 地址特点\n\n\n每个 IP 地址都由网络号和主机号两部分组成，因此 IP 地址是一种分等级的地址结构。\n分等级的好处是：\n\nIP 地址管理机构在分配 IP 地址时只分配网络号，而主机号则由得到该网络的单位自行分配，方便了 IP 地址的管理；\n路由器仅根据目的主机所连接的网络号来转发分组（而不考虑目标主机号），从而减小了路由表所占的存储空间。\n\n\n\nIP 地址是标志一台主机（或路由器）和一条链路的接口。当一台主机同时连接到两个网络时，该主机就必须同时具有两个相应的 IP 地址，其网络号必须是不同的。因此路由器至少应具有两个或两个以上的 IP 地址，每个端口都有一个不同网络号的 IP 地址。\n\n\n用转发器或桥接器（网桥等）连接的若干 LAN 仍然是同一个网络（同一个广播域），因此该 LAN 中所有主机的 IP 地址的网络号必须相同，主机号必须不同。\n\n\n在 IP 地址中，所有分配到网络号的网络都是平等的。\n\n\n在同一个局域网上的主机或路由器接口的 IP 地址中的网络号必须是相同的。\n\n\n划分子网编址\n把 IP 网络划分成子网，这样做的好处减少广播域的大小。增加子网的数量是子网划分的结果，并不是目的。\n划分子网\n两级 IP 地址的缺点：IP 地址空间的利用率有时很低；给每个物理网络分配一个网络号会使路由表变得太大，进而使网络性能变坏；两级 IP 地址不够灵活。\n\n\n从 1985 年起，在 IP 地址中又增加了一个“子网号字段”，使两级 IP 地址变成了三级 IP 地址。这种做法称为划分子网。\n划分子网已成为互联网的正式标准协议。\n划分子网的基本思路如下：\n\n\n划分子网纯属一个单位内部的事情。单位对外仍然表现为没有划分子网的一个网络。\n\n\n划分子网的方法是从网络的主机号借用若干位作为子网号，当然主机号也相应减少了相同的位数。三级 IP 地址的结构：\n\\text{IP地址}::=\\{&lt;\\text{网络号}&gt;,&lt;\\text{子网号}&gt;,&lt;\\text{主机号}&gt;\\}\n\n\n\n路由器转发分组根据的仍然是 IP 数据报的目的网络号，本单位的路由器收到 IP 数据报后，再按目的网络号和子网号找到目的子网。最后把 IP 数据报交付给目的主机。\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n\n划分子网只是把 IP 地址的主机号部分进行再划分，而不改变 IP 地址原来的网络号。因此，从一个 IP 地址本身无法判断该主机所连接的网络是否进行了子网划分。\n子网中的主机号全 0 或全 1 的地址不能被指派，其中主机号全 0 的地址为子网的网络地址，主机号全 1 的地址为子网的广播地址。\n划分子网增加了灵活性，但减少了能够连接在网络上的主机总数。\n\n\n\n子网掩码\n子网掩码可用来指明分类 IP 地址的主机号部分被借用了多少位作为子网号。\n子网掩码是一个长 32 位的二进制串，由一串 1 和跟随的一串 0 组成。其中，1 对应于 IP 地址中的网络号及子网号，而 0 对应于主机号。\n\n主机或路由器只需将 IP 地址和其对应的子网掩码逐位“与”（AND 运算），就可得出相应子网的网络地址。\n\n\n\n\n默认子网掩码是指在未划分子网的情况下使用的子网掩码。\n\n默认网关\n默认网关是子网与外部网络连接的设备，也就是连接本机或子网的路由器接口的 IP 地址。\n当主机发送数据时，根据所发送数据的目的 IP 地址，通过子网掩码来判定目的主机是否在子网中，若目的主机在子网中，则直接发送。若目的主机不在子网中，则将该数据发送到默认网关，由网关（路由器）将其转发到其他网络，进一步寻找目的主机。\n现在的互联网标准规定：所有网络都必须使用子网掩码。若一个网络未划分子网，则该网络的子网掩码就使用默认子网掩码。\n子网掩码是一个网络的重要属性，路由器相互之间交换路由信息时，必须将自己所在网络的子网掩码告诉对方。分组转发时，路由器将分组的目标地址和某网络的子网掩码按位相与，若结果与该网络地址一致，则路由匹配成功，路由器将分组转发至该网络。\n在使用子网掩码的情况下：\n\n一台主机在设置 IP 地址信息的同时，必须设置子网掩码。\n同属于一个子网的所有主机及路由器的相应端口，必须设置相同的子网掩码。\n路由器的路由表中所包含的信息主要内容有目的网络地址、子网掩码、下一跳地址。\n\n无分类编址 CIDR\n无分类编址\n无分类域间路由选择(ClasslessInter-DomainRouting, CIDR)是在变长子网掩码的基础上，提出的一种消除传统 A、B、C 类地址及划分子网的概念。\n无分类编址方法使用的地址掩码与划分子网使用的子网掩码类似，由32 比特构成。用左起多个连续的比特 1 对应 IPv4 地址中的网络前缀；之后的多个连续的比特 0 对应 IPv4 地址中的主机号。\nCIDR 使用网络前缀的概念代替网络的概念，与传统分类 IP 地址最大的区别就是，网络前缀的位数不是固定的，可以任意选取。\n\\text{IP地址}::=\\{&lt;\\text{网络前缀}&gt;,&lt;\\text{主机号}&gt;\\}\n\n\nCIDR 还使用斜线记法（或称 CIDR 记法），即记为“IP 地址/网络前缀所占的位数”。\n\nCIDR 将网络前缀都相同的连续 IP 地址组成一个CIDR 地址块。只要知道 CIDR 地址块中的任何一个地址，就能知道这个地址块的最小地址和最大地址，以及地址块中的地址数。\nCIDR 虽然不使用子网，但仍然使用“掩码”一词。“CIDR 不使用子网”是指 CIDR 并没有在 32 位地址中指明若干位作为子网字段。但分配到一个 CIDR 地址块的单位，仍可在本单位内根据需要划分出一些子网。例如，某单位分配到地址块/20，就可继续划分为 8 个子网（从主机号中借用 3 位来划分子网），这时每个子网的网络前缀就变成了 23 位。\nCIDR 地址块中的地址数一定是 2 的整数次幂，实际可指派的地址数通常为2^N-2，N 表示主机号的位数，主机号全 0 代表网络号，主机号全 1 为广播地址。网络前缀越短，其地址块包含的地址数就越多。\n\n\n                  \n                  Tip\n                  \n                \n\n注意地址数和实际可指派的地址数的区别\n\n\n\n\n\n路由聚合\n因为一个 CIDR 地址块中有很多地址，所以在路由表中就可利用 CIDR 地址块来查找目的网络。\n这种地址的聚合称为路由聚合，也称构成超网，它使得路由表中的一个项目可以表示多个原来传统分类地址的路由，有利于减少路由器之间的信息交换，进而提高网络性能。\n\n网络前缀越长，地址块越小，路由越具体；因此若路由器查表转发分组时发现有多条路由条目匹配，则选择网络前缀最长的那条路由条目，这称为最长前缀匹配，因为这样的路由更具体。\n\n\n\n\n\n子网划分应用举例\n通常有两类划分子网的方法：采用定长的子网掩码，采用变长的子网掩码。\n定长子网掩码\n\n\n\n\n\n变长子网掩码\n\n\n\n\n\n\n                  \n                  每个子块的位置不能随便选取的原因 \n                  \n                \n\n每个子网的最小地址只能选取主机号全 0 的地址，最大地址只能选取主机号全 1 的地址。\n在上图中，如果 218.75.230.0000 0100(218.75.230.4)作为某个网络的起点，那么该网络只有 4 个地址。但此时 1，2，3，4 网络所需地址都大于 4，即 218.75.230.4 无法作为 1，2，3，4 网络的起点。\n\n\n\n\nIPv4 数据报\nIPv4 数据报的首部格式及其内容是实现 IPv4 协议各种功能的基础。在 TCP/IP 标准中，各种数据格式常常以 32 比特（即 4 字节）为单位来描述。\n格式\n一个 IP 分组（或称 IP 数据报）由首部和数据部分组成。首部前一部分的长度固定，共 20B，是所有 IP 分组必须具有的。在首部固定部分的后面是一些可选字段，其长度可变，用来提供错误检测及安全等机制。\n\n\n\n版本\n占 4 位。指 IP 的版本，IPv4 数据报中该字段值是 4。\n\n\n首部长度\n占 4 位。以 4B 为单位，最大可表示的首部长度为 60B（15x4B）。最常用的首部长度是 20B（5x4B），该字段值是 5，此时不使用任何可选字段。\n\n\n总长度\n占 16 位。指首部和数据之和的长度，单位为字节，因此数据报的最大长度为 2^16^-1=65535B（但很少传输这么长的 IPv4 数据报）。\n以太网帧的最大传送单元（MTU）为 1500B（包含首部和数据），因此当一个 IP 数据报封装成帧时，数据报的总长度（首部加数据）一定不能超过下面的数据链路层的 MTU 值。\n\n\n\n标识\n占 16 位。属于同一个 IPv4 数据报的各分片数据报应该具有相同的标识。\nIP 软件会维持一个计数器，每产生一个 IPv4 数据报，计数器值就加 1，并将此值赋给标识字段。但它并不是“序号”（因为 IP 是无连接服务）。\n当一个数据报的长度超过网络的 MTU 时，必须分片，此时每个数据报片都复制一次标识号，以便能正确地重装成原来的数据报。\n\n\n标志(Flag)\n占 3 位。\n\n标志字段的最低位为(More Fragment)MF，MF=1 表示本分片后面还有分片，MF=0 表示本分片后面没有分片。\n标志字段的中间位为(Don’t Fragment)DF，DF=1 表示不允许分片，DF=0 表示允许分片。\n最高位为保留位，必须设置为 0。\n\n\n\n片偏移\n占 13 位。它指出较长的数据报在分片后，某片在原数据报中的相对位置，片偏移以 8B 为偏移单位，且值必须为整数。\n除最后一个分片外，每个分片的长度一定是 8B 的整数倍，否则，会造成其相邻后续分片数据报的片偏移不是整数。\n\n\n生存时间(TTL, Time To Live)\n占 8 位。数据报在网络中可通过的路由器数的最大值，标识数据报在网络中的寿命，以确保数据报不会永远在网络中循环。\n路由器在转发数据报前，先将 TTL 减 1。若 TTL 被减为 0，则该数据报必须丢弃。\n\n\n\n协议\n占 8 位。指出此数据报携带的数据使用何种协议，即数据报的数据部分应上交给哪个协议进行处理，如 TCP、UDP 等。\n\n\n首部检验和\n占 16 位。它只检验数据报的首部，但不包括数据部分。这是因为数据报每经过一个路由器，都要重新计算首部检验和（有些字段，如生存时间、总长度、标志、片偏移、源/目的地址都可能发生变化），不检验数据部分可减少计算的工作量。\n计算检验和的方法是先把数据报的首部划分为许多 16 比特的序列，用反码算术运算把所有 16 比特相加后，将得到的和的反码写入检验和字段。\n接收方的网络层发现检验和出错后，就丢弃收到的数据报，但不会发送差错报文。\n\n\n源地址字段\n占 4B，标识发送方的 IP 地址。\n\n\n目的地址字段\n占 4B，标识接收方的 IP 地址。\n\n\n可选字段\n长度从 1 字节到 40 字节不等，用来支持排错、测量以及安全措施等功能。实际上，可选字段很少被使用。\n\n\n填充\n用来确保 IPv4 数据报的首部长度是 4 字节的整数倍，使用全 0 进行填充。\n当首部长度（20 字节固定部分+可变部分）的长度不是 4 字节整数倍时，填充相应数量的全 0 字节，以确保 IPv4 数据报的首部长度是 4 字节的整数倍。\n\n\n分片\n\n一个链路层数据帧能承载的最大数据量称为最大传送单元(MTU)。\n因为 IP 数据报被封装在链路层的帧中，因此链路层的 MTU 严格地限制   上的各段链路可能使用不同的链路层协议，有不同的 MTU。\n当 IP 数据报的总长度大于链路 MTU 时，就需要将 IP 数据报中的数据分装在多个较小的 IP 数据报中，这些较小的数据报称为片。\n\n\n\n发送\nIP 数据报的发送和转发过程包含以下两个过程：主机发送 IP 数据报，路由器转发 IP 数据报。\n\n\n若目的主机不在子网中，则将该数据发送到默认网关，由网关（路由器）将其转发到其他网络，进一步寻找目的主机。\n转发\n当分组到达路由器后，路由器根据目的 IP 地址的网络前缀来查找转发表，确定下一跳应当到哪个路由器。\n因此，在转发表中，每条路由必须有：目的网络地址，下一跳地址。\n这样，IP 数据报最终一定可以找到目的主机所在目的网络上的路由器（可能要通过多次间接交付），当到达最后一个路由器时，才试图向目的主机进行直接交付。\n采用 CIDR 编址时，若一个分组在转发表中可以找到多个匹配的前缀，则应当使用最长前级匹配。\n为了更快地查找转发表，可以按照前缀的长短，将前缀最长的排在第 1 行，按前缀长度的降序排列。这样，从第 1 行最长的开始查找，只要检索到匹配的，就不必再继续查找。\n综上所述，归纳出路由器执行的分组转发算法如下：\n\n从收到的 IP 分组的首部提取目的主机的 IP 地址。\n若查找到特定主机路由，则按照这条路由的下一跳转发分组；否则从转发表中的下一条开始检查，执行步骤 3）。\n将这一行的子网掩码与目的地址逐位“与”。若运算结果与本行的前缀匹配，则查找结束，按照“下一跳”指出的进行处理（或者直接交付本网络上的目的主机，或通过指定接口发送到下一跳路由器）。否则，若转发表还有下一行，则对下一行进行检查，直到转发表没有下一行。\n若转发表中有一个默认路由，则把分组传送给默认路由；否则，报告转发分组出错。\n\n\n\n\n\n值得注意的是，转发表（或路由表）并没有给分组指明到某个网络的完整路径（即先经过哪个路由器，然后经过哪个路由器等）。转发表指出，到某个网络应当先到某个路由器（即下一跳路由器），到达下一跳路由器后，再继续查找其转发表，知道再下一步应当到哪个路由器。这样一步一步地查找下去，直到最后到达目的网络。\n得到下一跳路由器的 IP 地址后，并不是直接将该地址填入待发送的数据报，而是将该 IP 地址转换成 MAC 地址（通过 ARP），将此 MAC 地址填入 MAC 帧首部，然后根据这个 MAC 地址找到下一跳路由器。在不同网络中传送时，MAC 帧的源地址和目的地址要发生变化。\n网络地址转换(NAT)\n网络地址转换(NetworkAddressTranslation, NAT)是指通过将专用网络地址如（如 Intranet）转换为公用地址（如 Interme），从而对外隐藏内部管理的 IP 地址。\n它使得整个专用网只需要一个全球 IP 地址就可与互联网连通，因为专用网本地 IP 地址是可重用的，所以 NAT 大大节省了 IP 地址的消耗。同时，它隐藏了内部网络结构，从而降低了内部网络受到攻击的风险。\n此外，为了网络安全，划出了部分 IP 地址为私有 IP 地址。私有 IP 地址只用于 LAN，不用于 WAN 连接（因此私有 IP 地址不能直接用于 Internet，必须通过网关利用 NAT 把私有 IP 地址转换为 Intermet 中合法的全球 IP 地址后才能出现在 Internet 上），并且允许私有 IP 地址被 LAN 重复使用。这有效地解决了 IP 地址不足的问题。\n在互联网中的所有路由器，对目的地址是私有地址的数据报一律不进行转发。这种采用私有 IP 地址的互联网络称为专用互联网或本地互联网。私有 IP 地址也称可重用地址。\n私有 IP 地址网段：\n\n10.X.X.X\n172.16.XX ~ 172.31.X.X\n192.168.X.X ~ 192.168.X.X\n\n基本的 NAT 方法\n使用 NAT 时需要在专用网连接到互联网的路由器上安装 NAT 软件，NAT 路由器至少有一个有效的外部全球 IP 地址。当使用本地地址的主机和外界通信时，NAT 路由器使用 NAT 转换表进行本地 IP 地址和全球 IP 地址的转换。\n\n\n网络地址与端口号转换方法(NAPT)\n将 NAT 和运输层端口号结合使用，称为网络地址与端口号转换(Network Address and Port Translation，NAPT)\n由于目前绝大多数基于 TCP/IP 协议栈的网络应用，都使用运输层的传输控制协议 TCP 或用户数据报协议 UDP，为了更加有效地利用 NAT 路由器中的全球 IP 地址，现在常将 NAT 转换和运输层端口号结合使用。\n这样，只需要一个全球 IP 地址，就可让多台主机同时访问互联网。\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n普通路由器在转发 IP 分组时，其源 IP 地址和目的 IP 地址都不会改变。而 NAT 路由器在转发 IP 分组时，一定要更换其 IP 地址（转换源 IP 地址或目的 IP 地址）。\n普通路由器仅工作在网络层，而 NAT 路由器转发数据报时需要查看和转换传输层的端口号。\n\n\n特点\nNAT（和 NAPT）的一个重要特点就是通信必须由专用网内部发起，因此拥有内部专用地址的主机不能直接充当因特网中的服务器。\n\n地址解析协议(ARP)\nIP 地址与 MAC 地址\nIP 地址是网络层及网络层之上使用的地址，它是分层式的。\n\n因为路由器的隔离，IP 网络中无法通过广播 MAC 地址来完成跨网络的寻址，所以在网络层只使用 IP 地址来完成寻址。\n\n\n虽然在 IP 数据报首部中有源 IP 地址，但路由器只根据目的 IP 地址进行转发。\n在局域网的链路层，只能看见 MAC 帧。IP 数据报被封装在 MAC 帧中。通过路由器转发时，IP 数据报在每个网络中都被路由器解封装和重新封装，其MAC 帧首部中的源地址和目的地址会不断改变。这也决定了无法使用 MAC 地址跨网络通信。\n\n\n\n                  \n                  Tip\n                  \n                \n\n路由器因为互连多个网络，所以它不仅有多个 IP 地址，而且有多个硬件地址。\n\n\n寻址时，每个路由器依据其路由表（依靠路由协议生成）选择到目标网络（即主机号全为 0 的网络地址）需要转发到的下一跳（路由器的物理端口号或下一网络地址），而 IP 数据报通过多次路由转发到达目标网络后；改为在目标局域网中通过数据链路层的 MAC 地址以广播方式寻址。这样可以提高路由选择的效率。\n地址解析协议\n无论网络层使用什么协议，在实际网络的链路上传送数据帧时，最终必须使用硬件地址。所以需要一种方法来完成 IP 地址到 MAC 地址的映射，这就是地址解析协议(Address Resolution Protocol, ARP)。\n每台主机都设有一个ARP 高速缓存，用来存放本局域网上各主机和路由器的IP 地址到 MAC 地址的映射表，称 ARP 表。使用 ARP 来动态维护 ARP 表。\n\nARP 工作在网络层，其工作原理如下：\n\n\n主机 A 欲向本局域网上的某台主机 B 发送 IP 数据报时，先在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。\n\n若有，则可以查出其对应的硬件地址，再将此硬件地址写入 MAC 帧，然后通过局域网将该 MAC 帧发往此硬件地址。\n若没有，则通过使用目的 MAC 地址为 FF-FF-FF-FF-FF-FF 的帧来封装并广播 ARP 请求分组（广播发送），使同一个局域网里的所有主机都收到此 ARP 请求。\n\n\n\n\n主机 B 收到该 ARP 请求后，向主机 A 发出 ARP 响应分组（单播发送），分组中包含主机 B 的 IP 地址与 MAC 地址的映射关系。\n\n\n\n主机 A 收到 ARP 响应分组后就将此映射写入 ARP 缓存，然后按查询到的硬件地址发送 MAC 帧。\n\n\nARP 因为“看到了”IP 地址，所以它工作在网络层，而 NAT 路由器因为“看到了”端口，所以它工作在传输层。\n\nARP 用于解决同一局域网上的主机或路由器的 IP 地址和硬件地址的映射问题。\n若目的主机和源主机不在同一个局域网上，则要通过 ARP 找到本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络，剩下的工作就由下一个网络来做。\n\n使用 ARP 的 4 种典型情况：\n\n\n发送方是主机（H1），要把 IP 分组发送到本网络上的另一台主机（H2）。这时 H1 在网 1 用 ARP 找到目的主机 H2 的硬件地址。\n\n\n发送方是主机（H1），要把 IP 分组发送到其他网络上的一台主机（H4）。这时 H1 用 ARP 找到与网 1 连接的路由器 R1 的硬件地址（默认网关），剩下的工作由 R1 来完成。\n开始在 H1 和 R1 之间传送时，MAC 帧首部中的源地址是 H1 的 MAC 地址，目的地址是 L1 的硬件地址，路由器 R1 收到此 MAC 帧后，在数据链路层，要丢弃原 MAC 的首部和尾部。这时首部中的源地址和目的地址分别为 L2 和 L3 的 MAC 地址。路由器 R2 收到此帧后，再次更换 MAC 帧的首部和尾部，首部中的源地址和目的地址分别变为 L4 和 H4 的 MAC 地址。MAC 帧首部的这种变化，在上面的 IP 层中是看不见的。\n\n\n发送方是路由器（R1），要把 IP 分组转发到与 R1 连接的网络（网 2）上的一台主机（H3）。这时 R1 在网 2 用 ARP 找到目的主机 H3 的硬件地址。\n\n\n发送方是路由器（R1），要把 IP 分组转发到网 3 上的一台主机（H4）。这时 R1 在网 2 用 ARP 找到与网 2 连接的路由器 R2 的硬件地址，剩下的工作由 R2 来完成。\n\n\n\n从 IP 地址到硬件地址的解析是自动进行的，主机的用户并不知道这种地址解析过程。只要主机或路由器和本网络上的另一个已知 IP 地址的主机或路由器进行通信，ARP 就自动地将这个 IP 地址解析为数据链路层所需要的硬件地址。\n网际控制报文协议(ICMP)\n为了有效地转发 IP 数据报和提高交付成功的机会，在网络层使用了网际控制报文协议(IntermetControl MessageProtocol, ICMP)，让主机或路由器报告差错和异常情况。\nICMP 报文被封装在 IP 数据报中发送，但 ICMP 不是高层协议，而是网络层的协议。\nICMP 报文有两种，即ICMP 差错报告报文和ICMP 询问报文。\n\n差错报告报文\nICMP 差错报告报文用于目标主机或到目标主机路径上的路由器，向源主机报告差错和异常情况。共有以下5 种常用的类型：\n\n\n终点不可达\n当路由器或主机不能交付数据报时，就向源点发送终点不可达报文。\n\n\n\n源点抑制\n当路由器或主机因为拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢。\n\n\n\n\n时间超过\n当路由器收到生存时间(TTL)为零的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。\n\n当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文。\n\n\n参数问题\n当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文。\n\n\n\n改变路由（重定向）\n路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由）。\n\n\n\n\n对于以下几种情况，不应发送 ICMP 差错报告报文：\n\n对 ICMP 差错报告报文，不再发送 ICMP 差错报告报文。\n对第一个分片的数据报片的所有后续数据报片，都不发送 ICMP 差错报告报文。\n对具有多播地址的数据报，都不发送 ICMP 差错报告报文。\n对具有特殊地址（如 127.0.0.0 或 0.0.0.0）的数据报，不发送 ICMP 差错报告报文。\n\n询问报文\nICMP 询问报文常用的 2 种类型：\n\n回送请求和回答报文：用来测试目的站是否可达以及了解其有关状态。\n时间戳请求和回答报文：用来进行时钟同步和测量时间。\n\nICMP 应用\n\nICMP 的两个常见应用是分组网间探测PING（用来测试两台主机之间的连通性）和跟踪路由Traceroute（UNIX 中的名字，在 Windows 中是 Tracert，可以用来跟踪分组经过的路由）。\n\n\nPING 工作在应用层，使用了 ICMP回送请求和回答报文。\n\n\nTraceroute 工作在网络层，使用了 ICMP时间超过报文。\n\n\n\n\n\n路由算法\n路由选择协议的核心是路由算法，即需要何种算法来获得路由表中的各个项目。\n路由算法的目的很简单：给定一组路由器及连接路由器的链路，路由算法要找到一条从源路由器到目的路由器的“最佳”路径。\n通常，“最佳”路径是指具有最低费用的路径。\n静态路由与动态路由\n路由器转发分组是通过路由表转发的，而路由表是通过各种算法得到的。\n从能否随网络的通信量或拓扑自适应地进行调整变化来划分，路由算法可以分为如下两大类。\n\n\n静态路由算法\n指由网络管理员手工配置每一条路由。\n静态路由算法的特点是简单和开销较小，但不能及时适应网络状态的变化，适用于简单的小型网络。\n\n\n动态路由算法\n根据网络流量负载和拓扑结构的变化来动态调整自身的路由表。\n动态路由算法能较好地适应网络状态的变化，但实现复杂，开销也大，适用于较复杂的大网络。\n常用的动态路由算法可分为两类：距离-向量路由算法和链路状态路由算法。\n\n\n\n静态路由配置\n静态路由配置是指用户或网络运维人员使用路由器的相关命令给路由器人工配置路由表。\n\n特殊路由\n路由表存在两种特殊的路由：\n\n\n特定主机路由\n对特定目的主机的 IP 地址专门指明一个路由，以方便网络管理员控制和测试网络。\n若特定主机的 IP 地址是 a.b.c.d，则转发表中对应项的目的网络是 a.b.c.d/32。/32 表示的子网掩码没有意义，但这个特殊的前缀可以用在转发表中。\n\n\n\n默认路由\n用特殊前缀0.0.0.0/0表示默认路由，全 0 掩码和任何目的地址进行按位与运算，结果必然为全 0，即必然和前缀 0.0.0.0/0 相匹配。只要目的网络是其他网络（不在转发表中），就一律选择默认路由。\n默认路由通常用于路由器到互联网的路由，互联网包括无数的网络集合，不可能在路由表项中一一列出，因此只能采用默认路由的方式。\n\n\n\n动态路由算法\n距离-向量路由算法\n\n链路状态路由算法\n链路状态是指本路由器都和哪些路由器相邻，以及相应链路的代价。“代价”用来表示费用、距离、时延和带宽等，这些都由网络管理人员来决定。\n\n链路状态算法要求每个结点都具有全网拓扑结构图（这个拓扑结构图在全网范围内是一致的），它们执行下列两项任务：\n\n主动测试所有相邻结点的状态；\n定期地将链路状态传播给所有其他结点。\n\n因此每个结点都知道全网共有多少个结点、哪些结点是相连的、其代价是多少等，于是每个结点都可使用Dijkstra 最短路径算法计算出到达其他结点的最短路径。\n在链路状态算法中，结点每收到一个链路状态报文，便用其更新自已的网络状态“视野图”，一旦链路状态发生变化，就使用 Dijkstra 算法重新计算到达所有其他结点的最短路径。\n因为一个结点的链路状态只涉及相邻结点的连通状态，而与整个互联网的规模并无直接关系，所以链路状态算法适用于大型的或路由信息变化聚敛的互联网环境。\n链路状态算法的主要优点是\n\n每个结点都使用同样的链路状态数据独立地计算路径，而不依赖中间结点的计算；\n链路状态报文不加改变地传播，因此采用该算法易于查找故障。\n当一个结点从所有其他结点接收到报文时，它就在本地立即计算出正确的路径，保证一步汇聚。\n因为链路状态报文仅运载来自单个结点关于直接链路的信息，其大小与网络中的结点数目无关，所以链路状态算法比距离-向量算法有更好的规模可伸展性。\n链路状态算法具有快速收敛的优点，它能在网络拓扑发生变化时，立即进行路由的重新计算，并及时向其他路由器发送最新的链路状态信息，使得各路由器的链路状态表能够尽量保持一致。\n\n\n两种路由算法的比较：\n\n在距离-向量算法中，每个结点仅与它的直接邻居交谈，向它的邻居发送自己的路由表，其大小取决于网络中的结点数目，代价较大。\n在链路状态算法中，每个结点通过广播的方式与所有其他结点交谈，但它只告诉它们与它直接相连的链路的费用。\n\n路由选择协议\n互联网采用的是自适应的、分布式路由选择协议。\n因为互联网的规模非常大，许多联网单位不愿让外界了解自己单位网络的布局细节，所以互联网采用分层次的路由选择协议。\n为此，可以把整个互联网划分为许多较小的自治系统。自治系统是在单一技术管理下的一组路由器，这些路由器使用一种 AS 内部的路由选择协议和共同的度量。一个 AS 对其他 AS 表现出的是一个单一的和一致的路由选择策略。\n\n这样，互联网就把路由选择协议划分为两大类。\n\n\n内部网关协议(Interior Gateway Protocol, IGP)\n内部网关协议即在一个自治系统内部使用的路由选择协议，它与在互联网中的其他自治系统选用什么路由选择协议无关。\n目前这类路由选择协议使用得最多，如 RIP 和 OSPF。\n\n\n外部网关协议(External Gateway Protocol, EGP)\n若源主机和目的主机处在不同的自治系统中，则当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议。\n目前使用最多的外部网关协议是 BGP-4。\n\n\n自治系统之间的路由选择也称域间路由选择，自治系统内部的路由选择也称域内路由选择。\n每个自治系统自己决定在本自治系统内部运行哪个内部网关协议。但每个自治系统都有一个或多个路由器除运行本系统的内部网关协议外，还要运行外部网关协议。\n\n\n\n                  \n                  Tip\n                  \n                \n\n\n外部网关协议 EGP 和内部网关协议 IGP 只是路由选择协议的分类名称，而不是具体的路由选择协议。\n外部网关协议和内部网关协议名称中使用的是“网关”这个名词，是因为在因特网早期的 RFC 文档中，没有使用“路由器”而使用的是“网关”这一名词。\n\n\n\n内部网关协议\n路由信息协议(RIP)\n路由信息协议(Routing Information Protocol, RIP)是内部网关协议 IGP 中最先得到广泛应用的协议。RIP 是一种分布式的基于距离向量的路由选择协议。\n规定\n\n\n网络中的每个路由器都要维护从它自身到其他每个目的网络的距离记录，即距离向量。\n\n\nRIP 使用跳数(Hop Count)来衡量到达目的网络的距离。\n规定从一路由器到直接连接的网络的距离定义为 1；而每经过一个路由器，距离就加 1。\nRIP 允许一条路径最多只能包含 15 个路由器。因此距离等于 16 时表示网络不可达。可见 RIP 只适用于小型互联网。\n\n距离向量路由可能会出现环路的情况，规定路径上的最高跳数的目的是为了防止分组不断在环路上循环，减少网络拥塞的可能性。\n\n\nRIP 认为好的路由就是它通过的路由器数目少，即距离短或跳数少。\n\n\n\n每个路由表项都有三个关键字段：目的网络，距离，下一跳路由器地址。\n\n\n特点\nRIP 的每个路由器都要不断与其他路由器交换信息，下面三个特点非常重要。\n\n\n和谁交换信息\n仅和直接相邻的路由器交换信息。\n\n\n\n交换什么信息\n交换的信息是本路由器所知道的全部信息，即自己的路由表。\n\n\n何时交换信息\n按固定的时间间隔（如 30 秒）交换路由信息。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息。\n\n\n基本工作过程\n路由器刚开始工作时，只知道自己到直接相连的几个网络的距离为 1。\n每个路由器仅和相邻路由器周期性地交换并更新路由信息。\n所谓收敛，是指当路由环境发生变化后，各路由器调整自己的路由表以适应网络拓扑结构的变化，最终达到稳定状态（路由表与网络拓扑状态保持一致）。收敛越快，路由器就能越快适应网络拓扑结构的变化。\n\n\n距离向量算法\n\n\n\n\n\n\n\n若 180 秒（RIP 默认超时时间）还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达的路由器，即把距离设置为 16（距离为 16 表示不可达）。\n优缺点\n\n\n优点：\n\n实现简单、开销小、收敛过程较快。\n若一个路由器发现了更短的路由，则这种更新信息就传播得很快，在较短时间内便可被传至所有路由器，俗称“好消息传播得快”。\n\n缺点：\n\n\nRIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。因此若是某个自治系统内任意两台主机通信时经过的路由器数量可能超过15个，那就不能使用 RIP 协议，该考虑使用 OSPF 协议。\n\n\n路由器之间交换的是路由器中的完整路由表，因此网络规模越大，开销也越大。\n\n\n当网络出现故障时，路由器之间需反复多次交换信息才能完成收敛，要经过较长时间才能将故障消息传送到所有路由器（即慢收敛现象），俗称“坏消息传播得慢”。\n\n\n\n开放最短路径优先协议(OSPF)\n开放最短路径优先(Open Shortest Path First, OSPF)协议是使用分布式链路状态路由算法的典型代表，也是内部网关协议(IGP)的一种。\n特点\n\n\nOSPF 向本自治系统中所有路由器发送信息。\n而 RIP 仅仅向自己相邻的几个路由器发送信息。\n\n\n发送的信息是与本路由器相邻的所有路由器的链路状态，但这只是路由表的一部分。\n而在 RIP 中，发送的信息是本路由器所知道的全部信息，即整个路由表。\n\n\n只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息，并且更新过程收敛得快，不会出现 RIP“坏消息传得慢”的问题。\n而在 RIP 中，不管网络拓扑是否发生变化，路由器之间都要定期交换路由表的信息。\n\n\nOSPF 是网络层协议，它不用 UDP 或 TCP，而直接用 IP 数据报传送（其 IP 数据报首部的协议字段为 89）。\n而RIP 是应用层协议（但其核心功能是路由选择，属于网际层），它在传输层使用 UDP。\n用 UDP 传送是指将该信息作为 UDP 报文的数据部分，而直接使用 IP 数据报传送是指将该信息直接作为 IP 数据报的数据部分。RIP 报文是作为 UDP 数据报的数据部分。\n\n\nOSPF 允许对每条路由设置成不同的代价，对于不同类型的业务可计算出不同的路由。\n\n\n若到同一个目的网络有多条相同代价的路径，则可将通信量分配给这几条路径。\n\n\nOSPF 分组具有鉴别功能，从而保证仅在可信赖的路由器之间交换链路状态信息。\n\n\nOSPF 支持可变长度的子网划分和无分类编址 CIDR。\n\n\n每个链路状态都带上一个 32 位的序号，序号越大，状态就越新。\n\n\n工作原理\n因为各路由器之间频繁地交换链路状态信息，所以所有路由器最终都能建立一个链路状态数据库，即全网的拓扑结构图。然后，每个路由器利用链路状态数据库中的数据，使用 Dijkstra 算法计算自己到达各目的网络的最优路径，构造出自已的路由表。此后，当链路状态发生变化时，每个路由器重新计算到达各目的网络的最优路径，构造出新的路由表。\n\n\n                  \n                  Tip\n                  \n                \n\n虽然使用 Dijkstra 算法能计算出完整的最优路径，但路由表中不会存储完整路径，而只存储“下一跳”（只有到了下一跳路由器，才能知道再下一跳应当怎样走）。\n\n\n为了使 OSPF能够用于规模很大的网络，OSPF将一个自治系统再划分为若干更小的范围，称为区域。域之间通过区域边界路由器互连。\n划分区域的好处是，将利用洪泛法交换链路状态信息的范围局限在每个区域而非整个自治系统，从而减少了整个网络上的通信量。\n\nOSPF 协议将一个自治域划分成若干域，有一种特殊的域称为主干区域。主干区域中，用于连接主干区域和其他下层区域的路由器称为区域边界路由器。只要是在主干区域中的路由器，就都称为主干路由器，因此主干路由器可以兼作区域边界路由器。\n工作过程\nOSPF 共有以下五种分组类型：\n\n问候分组：用来发现和维持邻站的可达性。\n数据库描述分组：向邻站给出自已的链路状态数据库中的所有链路状态项目的摘要信息。\n链路状态请求分组：向对方请求发送某些链路状态项目的详细信息。\n链路状态更新分组：用洪泛法对全网更新链路状态，它是 OSPF 最核心的部分。\n链路状态确认分组：对链路更新分组的确认。\n\n\n在网络中通常传送的 OSPF 分组大多是问候分组。两个相邻路由器通常每隔 10 秒要交换一次问候分组，以便知道哪些站可达。若有 40 秒没有收到某个相邻路由器发来的问候分组，则认为该相邻路由器不可达，应立即修改链路状态数据库，并重新计算路由表。\n\n在路由器刚开始工作时，OSPF 让每个路由器使用数据库描述分组和相邻路由器交换本数据库中已有的链路状态摘要信息。然后，路由器使用链路状态请求分组，向对方请求发送自已所缺少的某些链路状态项目的详细信息。经过一系列的这种分组交换，就建立了全网同步的链路数据库。\n在网络运行的过程中，只要一个路由器的链路状态发生变化，该路由器就要使用链路状态更新分组，用洪泛法向全网更新链路状态。其他路由器在收到更新分组后要发送确认。\n为了确保链路状态数据库与全网的状态保持一致，OSPF 还规定每隔一段时间（如 30 分钟）要刷新一次数据库中的链路状态。因为一个路由器的链路状态只涉及与相邻路由器的连通状态，与整个网络的规模并无直接关系，所以当互联网规模很大时，OSPF 要比 RIP 好得多。\n外部网关协议\n边界网关协议(BGP)\n概念\n边界网关协议(BorderGatewayProtocol, BGP)是不同自治系统 AS 的路由器之间交换路由信息的协议，是一种外部网关协议。边界网关协议 BGP 常用于互联网的网关之间。\n内部网关协议主要是设法使数据报在一个 AS 中尽可能有效地从源站传送到目的站。在一个 AS 内部也不需要考虑其他方面的策略。然而 BGP 使用的环境却不同，主要原因如下：\n\n\n互联网的规模太大，使得 AS 之间路由选择非常困难，每个主干网路由器表中的项目数都非常庞大。对于 AS 之间的路由选择，要寻找最佳路由是很不现实的。\n\n\n\nAS 之间的路由选择必须考虑政治、安全或经济等有关因素。\n\n\n\n自治系统之间的路由选择协议应当允许使用多种路由选择策略。这些策略包括政治、经济、安全等，它们都是由网络管理人员对每一个路由器进行设置的。但这些策略并不是自治系统之间的路由选择协议本身。\nBGP 只能是力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并非要寻找一条最佳路由。\nBGP 采用的是路径向量路由选择协议，它与距离向量协议（如 RIP）和链路状态协议（如 OSPF）都有很大的区别。\nBGP 是应用层协议，它是基于 TCP 的。\n工作原理\n\n\n配置 BGP 时，每个 AS 的管理员要选择至少一个路由器，作为该 AS 的“BGP 发言人”，BGP 发言人往往就是 BGP 边界路由器。\n\n\n\n一个 BGP 发言人与其他 AS 中的 BGP 发言人要交换路由信息，就要先建立 TCP 连接，然后在此连接上交换 BGP 报文以建立 BGP 会话，再利用 BGP 会话交换路由信息。\n使用 TCP 连接交换路由信息的两个 BGP 发言人，彼此成为对方的邻站或对等站。\n每个 BGP 发言人除了必须运行 BGP 外，还必须运行该 AS 所用的内部网关协议，如 OSPF 或 RIP。\n\n\n\nBGP 所交换的网络可达性信息，就是要到达某个网络所要经过的一系列自治系统，即到达某个网络所经过的路径。当 BGP 发言人互相交换网络可达性信息后，各 BGP 发言人就根据所用的策略，从收到的路由信息中找出到达各自治系统的较好路由。\n\n\n\n\n特点\n\nBGP 交换路由信息的结点数量级是 AS 个数的数量级，这要比这些 AS 中的网络数少很多。\n寻找一条较好的路径，取决于找准正确的 BGP 发言人，而每个 AS 中 BGP 发言人（或边界路由器）的数目是很少的。这样就使得 AS 之间的路由选择不致过分复杂。\nBGP 支持 CIDR，因此 BGP 的路由表也就应当包括目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的各个自治系统序列。\n当 BGP 刚运行时，BGP 的邻站交换整个 BGP 路由表。但以后只需要在发生变化时更新有变化的部分。这样做对节省网络带宽和减少路由器的处理开销方面都有好处。\n\n报文\n\n打开报文：用来与相邻的另一个 BGP 发言人建立关系，使通信初始化。\n更新报文：用来通知某一路由的信息，以及列出要撤销的多条路由。\n保活报文：用来周期性地证实邻站的连通性。\n通知报文：用来发送检测到的差错。\n\n\n若一个 BGP 发言人想与另一个 AS 的 BGP 发言人建立邻站关系，则要向对方发送 Open 报文，若对方接受这种邻站关系，则用 Keepalive 报文响应。\n邻站关系一旦建立，就要继续维持这种关系。为此，这两个 BGP 发言人彼此要周期性地交换 Keepalive 报文（一般每隔 30 秒）。Keepalive 报文只有 19B，因此不会造成网络上太大的开销。\nUpdate 报文是 BGP 的核心内容，BGP 发言人可以用 Update 报文撤销它曾经通知过的路由，也可以宣布增加新的路由。\n三种路由协议比较\n从实现功能（路由选择）的角度看，这三个路由选择协议都属于网络层。\n从数据包按网络体系结构逐层封装的角度看，RIP 和 BGP 属于应用层，OSPF 属于网络层。\n\n\nIP 多播\n概念\n多播是让源主机一次发送的单个分组可以抵达用一个组地址标识的若干目的主机，即一对多的通信。在互联网上进行的多播，称为 IP 多播。\n与单播相比，在一对多的通信中，多播可大大节约网络资源。\n多播需要路由器的支持才能实现，能够运行多播协议的路由器称为多播路由器。\n\n多播地址\n多播数据报的源地址是源主机的 IP 地址，目的地址是IP 多播地址。IP 多播地址就是 IPv4 中的 D 类地址。每个 D 类 IP 地址标志一个多播组，一台主机可以随时加入或离开一个多播组。\n\n多播数据报和一般的 IP 数据报的区别是，前者使用 D 类 IP 地址作为目的地址，并且首部中的协议字段值是 2，表明使用 IGMP 协议。\n需要注意的是：\n\n多播数据报也是“尽最大努力交付”，不提供可靠交付。\n多播地址只能用于目的地址，而不能用于源地址。\n对多播数据报不产生 ICMP 差错报文。\n\nIP 多播可以分为两种：\n\n只在本局域网上进行硬件多播；\n在互联网的范围内进行多播。\n\n目前大部分主机都是通过局域网接入互联网的。因此，在互联网上进行多播的最后阶段，还是要把多播数据报在局域网上用硬件多播交付给多播组的所有成员。\n多播机制仅应用于 UDP，它能将报文同时发送给多个接收者。而 TCP 是一个面向连接的协议，它意味着分别运行在两台主机的进程之间存在一条连接，因此会一对一地发送。\n硬件多播\n由于 MAC 地址（也称为硬件地址）有多播 MAC 地址这种类型，因此只要把IP 多播地址映射成多播 MAC 地址，即可将 IP 多播数据报封装在局域网的 MAC 帧中，而 MAC 帧首部中的目的 MAC 地址字段的值，就设置为由 IPv4 多播地址映射成的多播 MAC 地址。这样，可以很方便地利用硬件多播来实现局域网内的 IP 多播。\n\n因特网号码指派管理局 IANA，将 01-00-5E-00-00-00 到 01-00-5E-7F-FF-FF 的多播 MAC 地址，用于映射 IPv4 多播地址。\n\n\n\n\n\n网际组管理协议(IGMP)\n路由器要获得多播组的成员信息，需要利用网际组管理协议(InternetGroupManagementProtocol，IGMP)。\nIGMP 是让连接到本地局域网上的多播路由器，知道本局域网上是否有主机参加或退出了某个多播组。IGMP 并不是在互联网范围内对所有多播组成员进行管理的协议。IGMP 不知道 IP 多播组包含的成员数，也不知道这些成员分布在哪些网络上。\nIGMP 报文被封装在 IP 数据报中传送，但它也向 IP 提供服务。因此不把 IGMP 视为一个单独的协议，而视为整个网际协议 IP 的一个组成部分。IGMP 的工作可分为两个阶段。\n第一阶段：当某台主机加入新的多播组时，该主机应向多播组的多播地址发送一个 IGMP 报文，声明自己要成为该组的成员。本地的多播路由器收到 IGMP 报文后，还要利用多播路由选择协议，把这种组成员关系转发给互联网上的其他多播路由器。第二阶段：组成员关系是动态的。本地多播路由器要周期性地探询本地局域网上的主机，以便知道这些主机是否仍继续是组的成员。只要对某个组有一台主机响应，多播路由器就认为这个组是活跃的。但一个组在经过几次探询后仍然没有一台主机响应，多播路由器就认为本网络上的主机都已离开了这个组，因此就不再把这个组的成员关系转发给其他的多播路由器。\n多播路由选择协议\n仅使用 IGMP 并不能在因特网上进行 IP 多播。连接在局域网上的多播路由器还必须和因特网上的其他多播路由器协同工作，以便把 IP 多播数据报用最小的代价传送给所有的多播组成员，这就需要使用多播路由选择协议。\n多播路由选择实际上就是要找出以源主机为根结点的多播转发树，其中每个分组在每条链路上只传送一次（即在多播转发树上的路由器不会收到重复的多播数据报）。\n\n不同的多播组对应于不同的多播转发树；同一个多播组，对不同的源点也会有不同的多播转发树。\n移动 IP\n移动 IP 技术是指移动站以固定的 IP 地址实现跨越不同网络的漫游功能，并保证基于 IP 的网络权限在漫游过程中不发生任何改变。\n移动 IP 的目标是把分组自动地投递给移动站。一个移动站是把其连接点从一个网络或子网改变到另一个网络或子网的主机。\n移动 IP 定义了三种功能实体：\n\n移动结点：具有永久 IP 地址的移动主机。\n本地代理：也称归属代理，通常就是连接在归属网络（原始连接到的网络）上的路由器。\n外地代理：通常就是连接在被访网络（移动到另一地点所接入的网络）上的路由器。\n\n值得注意的是，某用户将笔记本关机后从家里带到办公室重新上网，在办公室能很方便地通过 DHCP 自动获取新的 IP 地址。虽然笔记本移动了，更换了地点及所接入的网络，但这并不是移动 IP。\n但是，若我们需要在移动中进行 TCP 传输，则在移动站漫游时，应一直保持这个 TCP 连接，否则移动站的 TCP 连接就会断断续续。可见，若要使移动站在移动中的 TCP 连接不中断，就必须使笔记本的 IP 地址在移动中保持不变。这就是移动 IP 要研究的问题。\n\n在移动 IP 中，每个移动站都有一个原始地址，即永久地址（或归属地址），移动站原始连接的网络称为归属网络。永久地址和归属网络的关联是不变的。\n归属代理通常是连接到归属网络上的路由器，然而它实现的代理功能是在应用层完成的。当移动站移动到另一地点，所接入的外地网络也称被访网络。被访网络中使用的代理称为外地代理，它通常是连接在被访网络上的路由器。\n外地代理有两个重要功能：\n\n要为移动站创建一个临时地址，称为转交地址。转交地址的网络号显然和被访网络一致。\n及时把移动站的转交地址告诉其归属代理。\n\n\n移动 IP 的基本通信流程如下：\n\n\n移动站 A 在归属网络时，按传统的 TCP/IP 方式进行通信。\n\n\n移动站 A 漫游到被访网络时，向外地代理进行登记，以获得一个临时的转交地址。外地代理要向 A 的归属代理登记 A 的转交地址。\n\n\n\n\n归属代理知道移动站 A 的转交地址后，会构建一条通向转交地址的隧道，将截获的发送给 A 的 IP 分组进行再封装，并通过隧道发送给被访网络的外地代理。\n\n\n\n外地代理把收到的封装的 IP 分组进行拆封，恢复成原始的 IP 分组，然后发送给移动站 A，这样 A 在被访网络就能收到这些发送给它的 IP 分组。\n\n\n\n移动站 A 在被访网络对外发送 IP 分组时，仍然使用自己的永久地址作为 IP 分组的源地址，此时显然无须通过 A 的归属代理来转发，而是直接通过被访网络的外部代理。\n\n\n\n移动站 A 移动到另一被访网络时，在新外地代理登记后，然后新外地代理将 A 的新转交地址告诉其归属代理。无论如何移动，A 收到的 IP 分组都是由归属代理转发的。\n\n\n移动站 A 回到归属网络时，A 向归属代理注销转交地址。\n\n\n\n为了支持移动性，在网络层中还应增加一些新功能：\n\n移动站到外地代理的登记协议；\n外地代理到归属代理的登记协议；\n归属代理数据报封装协议；\n外地代理拆封协议。\n\n所有使用同一外地代理的移动主机都可以共享同一个转交地址。\nIPV6\n为了解决“IP 地址耗尽”问题，有以下三种措施：\n\n采用无类别编址 CIDR，使 IP 地址的分配更加合理。\n采用网络地址转换（NAT）方法以节省全球 IP 地址。\n采用具有更大地址空间的新版本的 IPv6。\n\n前两种方法只是延长了 IPv4 使用寿命，只有第三种方法能从根本上解决 IP 地址耗尽问题。\n特点\n\n\n更大的地址空间。IPv6 将地址从 IPv4 的 32 位增大到 128 位，IPv6 的地址空间是 IPv4 的 2^96^ 倍。\n\n\n扩展的地址层次结构。IPv6 因为地址空间很大，所以可以划分为更多的层次。\n\n\n灵活的首部格式。IPv6 定义了许多可选的扩展首部，不仅可提供比 IPv4 更多的功能，而且能提高路由器的处理效率，这是因为路由器对扩展首部不进行处理。\n\n\n改进的选项。IPv6 首部长度是固定的，其选项放在有效载荷中，选项是灵活可变的。而 IPv4 所规定的选项是固定不变的，其选项放在首部的可变部分。\n\n\n允许协议继续扩充。IPv6 允许不断扩充功能，而 IPv4 的功能是固定不变的。\n\n\n支持即插即用（即自动配置）。因此 IPv6 不需要使用 DHCP。\n\n\n支持资源的预分配。\n\n\nIPv6 中不充许分片。IPv6 只有源主机才能分片，是端到端的，不允许类似 IPv4 传输路径中的路由分片。因此，若一个路由器收到的 IPv6 数据报因太大而不能转发到链路上，则丢弃该数据报，并向发送方发送一个指示分组太大的 ICMP 报文。\n\n\nIPv6 首部长度是固定的 40B，而 IPv4 首部长度是可变的（必须是 4B 的整数倍）。\n\n\n增大了安全性\n\n\n\n虽然 IPv6 与 IPv4 不兼容，但总体而言它与所有其他的互联网协议兼容，包括 TCP、UDP、ICMP、IGMP 和 DNS 等，只是在少数地方做了必要的修改（大部分是为了处理长地址）。\nIPV6 数据报\n\nIPv6 将 IPv4 数据报首部中不必要的功能取消了，这使得 IPv6 数据报基本首部中的字段数量减少到只有 8 个。但由于 IPv6 地址的长度扩展到了 128 比特，因此使得 IPv6 数据报基本首部的长度反而增大到了 40 字节，比 IPv4 数据报首部固定部分的长度（20 字节）增大了 20 字节。\n\n\n\n版本：占4 位，指明协议的版本，对于 IPv6 该字段的值是 6。\n\n\n通信量类：占8 位，用来区分不同的 IPv6 数据报的类别或优先级。\n\n\n流标号：占 20 位，IPv6 提出流的抽象概念。流是指互联网上从特定源点到特定终点（单播或多播）的一系列数据报（如实时音/视频传输），而在这个“流”所经过的路径上的路由器都保证指明的服务质量。所有属于同一个流的数据报都具有相同的流标号。\n\n\n有效载荷长度：占 16 位，指明 IPv6 数据报除基本首部以外的字节数（所有扩展首部都算在有效载荷之内）。这个字段的最大值是 65535 字节。\n\n\n下一个首部：占 8 位，该字段相当于 IPv4 首部中的协议字段或可选字段。\n当 IPv6 没有扩展首部时，其作用与 IPv4 的协议字段一样，它指明 IPv6 数据报所运载的数据是何种协议数据单元；\n\n当 IPv6 带有扩展首部时，它就标识后面第一个扩展首部的类型。\n\n\n\n跳数限制(Hop Limit)：占 8 位，类似于 IPv4 首部的 TTL 字段。源点在每个数据报发出时即设定某个限制值（最大为 255）。路由器每次转发时将其值减 1，减为零时就将该数据报丢弃。\n\n该字段的作用与 IPv4 数据报首部中的生存时间 TTL 字段完全一样。\n\n\n\n源地址和目的地址：占 128 位，是数据报的发送端/接收端的 IP 地址。\n\n\nIPV6 地址\n表示方法\nIPv4 地址通常使用点分十进制表示法。若 IPv6 也使用这种表示法，则地址书写起来将相当长。IPv6 标准使用冒号十六进制记法，即把地址中的每 4 位用一个十六进制数表示，并用冒号分隔每 16 位。\n\n在 IPv6 地址的冒号十六进制记法的基础上，再使用“左侧零”省略和“连续零”压缩，可使 IPv6 地址的表示更加简洁。\n\n“左侧零”省略是指两个冒号间的十六进制数中最前面的一串 0 可以省略不写。\n“连续零”压缩是指一连串连续的 0 可以用一对冒号取代。\n\n\n在一个 IPv6 地址中只能使用一次“连续零”压缩，否则会导致歧义。\n\n冒号十六进制记法还可结合点分十进制的后缀。这在 IPv4 向 IPv6 过渡阶段非常有用。\n\nCIDR 的斜线表示法在 IPv6 中仍然可用。\n\n分类\nIPv6 数据报的目的地址有以下三种基本类型：\n\n单播：就是传统的点对点通信。\n多播：一点对多点的通信，数据报发送到一组计算机中的每一台。\n任播：这是 IPv6 增加的一种类型。任播的终点是一组计算机，但数据报只交付其中的一台计算机，通常是距离最近的一台计算机。\n\n\n\n\n\n未指明地址：该地址不能用作目的地址，只能用于还未配置 IPv6 地址的主机作为源地址。\n\n\n环回地址：该地址的作用与 IPv4 的环回地址相同，但 IPv6 的环回地址仅此一个。\n\n\n多播地址：该地址的作用和 IPv4 的一样。这类地址占 IPv6 地址空间的 1/256。\n\n\n本地链路单播地址：该地址的作用类似于 IPv4 的私有 IP 地址。\n\n\n全球单播地址：用得最多的地址。IPv6 全球单播地址采用三级结构：\n\n第一级为全球路由选择前缀，占 48 位，用于互联网中的路由选择，相当于 IPv4 分类地址中的网络号；\n第二级为子网标识符，占 16 位，用于各机构构建自己的子网：\n第三级为接口标识符，用于指明主机或路由器的单个网络接口，相当于 IPv4 分类地址中的主机号。\n\n\n\n\nIPv4 向 IPv6 过渡\n从 IPv4 向 IPv6 过渡只能采用逐步演进的办法，同时还必须使新安装的 IPv6 系统能够向后兼容。IPv6 系统必须能够接收和转发 IPv4 分组，并且能够为 IPv4 分组选择路由。\n从 IPv4 向 IPv6 过渡可以采用下列两种策略：\n\n\n双协议栈\n指在一台设备上同时装有 IPv4 和 IPv6 两个协议栈，分别配置了一个 IPv4 地址和一个 IPv6 地址，因此这台设备既能和 IPv4 网络通信，又能和 IPv6 网络通信。\n双协议栈主机在与 IPv6 主机通信时采用 IPv6 地址，而在与 IPv4 主机通信时采用 IPv4 地址，双协议栈主机使用应用层的域名系统（DNS）获知目的主机采用的是哪种地址。\n若 DNS 返回的是 IPv4 地址，则双协议的源主机就使用 IPv4 地址。若 DNS 返回的是 IPv6 地址，则双协议栈的源主机就使用 IPv6 地址。\n\n\n\n隧道技术\n指在 IPv6 数据报要进入 IPv4 网络时，把整个 IPv6 数据报封装成 IPv4 数据报的数据部分，使原来的 IPv6 数据报就好像在 IPv4 网络的隧道中传输。当 IPv4 数据报离开 IPv4 网络时，再将其数据部分交给主机的 IPv6 协议。\n\n\n"},"计算机基础/计算机网络/5_传输层":{"title":"传输层","links":[],"tags":["计算机网络"],"content":"基本概念\n传输层的功能\n物理层、数据链路层和网络层，它们共同解决了将主机通过异构网络互联起来所面临的问题，实现了主机到主机的通信。然而在计算机网络中实际进行通信的真正实体，是位于通信两端主机中的进程。\n传输层位于网络层之上、应用层之下，它为运行在不同主机上的进程之间提供逻辑通信。\n传输层属于面向通信部分的最高层，同时也是用户功能中的最低层。显然，即使网络层协议不可靠（网络层协议使分组丢失、混乱或重复），传输层同样能为应用程序提供可靠的服务。\n\n网络的边缘部分的两台主机使用网络的核心部分的功能进行端到端的通信时，只有主机的协议栈才有传输层，而路由器在转发分组时都只用到下三层的功能（即在通信子网中没有传输层，传输层只存在于通信子网以外的主机中）。\n\n从网络层来说，通信的双方是两台主机，IP 数据报的首部给出了这两台主机的 IP 地址。但“两台主机之间的通信”实际上是两台主机中的应用进程之间的通信。应用进程之间的通信又称端到端的逻辑通信。\nIP 协议虽然能把分组送到目的主机，但这个分组还停留在主机的网络层，而没有交付给主机中的进程。从传输层来看，通信的真正端点不是主机而是主机中的进程。\n两个主要协议\n\nTCP/IP 协议族在 IP 层之上使用了两个传输协议：\n\n\n面向连接的传输控制协议(TCP)，采用 TCP 时，传输层向上提供的是一条全双工的可靠逻辑信道；\nTCP 提供面向连接的可靠服务，通信双方在传送数据之前必须先建立连接，然后基于此连接进行可靠数据传输，数据传输结束后要释放连接。\nTCP 不提供广播或多播服务。\nTCP 为了实现可靠数据传输，就必须增加许多措施，如确认、流量控制、计时器及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多的处理机资源。因此 TCP 主要适用于可靠性更重要的场合，如文件传输协议、超文本传输协议、远程登录等。\n\n\n无连接的用户数据报协议(UDP)，采用 UDP 时，传输层向上提供的是一条不可靠的逻辑信道。\nUDP 提供无连接的不可靠服务，通信双方在传送数据之前不需要建立连接，接收方的传输层在收到 UDP 用户数据报后，无须给发送方发回任何确认。\nUDP 在 IP 层之上仅提供两个附加服务：多路复用和对数据的错误检查。\nIP 层知道怎样把分组投递给一台主机，但不知道怎样把它们投递给主机上的具体应用。\n因为 UDP 比较简单，所以执行速度比较快、实时性好。使用 UDP 的应用主要包括小文件传送协议、DNS、SNMP 和实时传输协议。\n\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n网络层无法同时实现两种协议（即在网络层要么只提供面向连接的服务，如虚电路：要么只提供无连接服务，如数据报，而不可能在网络层同时存在这两种方式）。\n\n\n\n端口\n端口能让应用层的各种进程将其数据通过端口向下交付给传输层，以及让传输层知道应当将其报文段中的数据向上通过端口交付给应用层相应的进程。\n端口在传输层的作用类似于 IP 地址在网络层的作用，只不过 IP 地址标识的是主机，而端口标识的是主机中的应用进程。\n在协议栈层间的抽象的协议端口是软件端口，它与路由器或交换机上的硬件端口是完全不同的概念。硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层的各种协议进程与传输实体进行层间交互的一种地址。传输层使用的是软件端口。\n\n应用进程通过端口号进行标识，端口号长度为 16 比特，取值范围是 0 ~ 65535。\n端口号只具有本地意义，即端口号只标识本计算机应用层中的各进程，在因特网中不同计算机的相同端口号是没有联系的。\n根据端口号范围可将端口分为两类：\n\n\n服务器端使用的端口号\n\n熟知端口号，数值为 0 ～ 1023，这些端口号指派给了 TCP/IP 最重要的一些应用程序，让所有的用户都知道。\n登记端口号，数值为 1024 ～ 49151，供没有熟知端口号的应用程序使用的，使用这类端口号必须在 IANA 登记，以防止重复。\n\n\n\n客户端使用的端口号\n数值为 49152 ～ 65535。因为这类端口号仅在客户进程运行时才动态地选择，所以又称短暂端口号。\n当服务器进程收到客户进程的报文时，就知道了客户进程所使用的端口号，因而可以把数据发送给客户进程。通信结束后，刚用过的客户端口号就不复存在，这个端口号就可以供其他客户进程使用。\n\n\n\n\n在网络中通过 IP 地址来标识和区别不同的主机，通过端口号来标识和区分一台主机中的不同应用进程，端口号拼接到 IP 地址即构成套接字(Socket)。\n在网络中采用发送方和接收方的套接字来识别端点。套接字，实际上是一个通信端点，即\n \\text{套接字}(Socket)=( \\text{IP地址:端口号})\n\n它唯一地标识网络中的一台主机上的一个应用进程。\n在网络通信中，主机 A 发给主机 B 的报文包含目的端口号和源端口号，源端口号是“返回地址”的一部分，即当主机 B 需要发回一个报文给主机 A 时，主机 B 到主机 A 的报文中的目的端口号便是主机 A 到主机 B 的报文中的源端口号（完全的返回地址是主机 A 的 IP 地址和源端口号）。\n复用和分用\n\n复用是指发送方不同的应用进程都可以使用同一个传输层协议传送数据。\n分用是指接收方的传输层在剥去报文的首部后能够把这些数据正确交付到目的应用进程。\n\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n网络层也有复用和分用的功能，但网络层的复用是指发送方不同协议的数据都可被封装成 IP 数据报发送出去，分用是指接收方的网络层在剥去首部后把数据交付给相应的协议。\n\n\n检错检测\n传输层要对收到的报文（首部和数据部分）进行差错检测。\n\n对于TCP协议，若接收方发现报文段出错，则要求发送方重发该报文段。\n对于UDP协议，若接收方发现数据报出错，则直接丢弃。\n\n在网络层，IP 数据报首部中的检验和字段只检验首部是否出错，而不检查数据部分。\nUDP\nUDP 概述\nUDP 仅在 IP 层的数据报服务之上增加了两个最基本的功能：复用和分用，以及差错检测。\nUDP 优点：\n\nUDP 无须建立连接，因此 UDP 不会引入建立连接的时延。\n无连接状态。当某些专用服务器使用 UDP 时，一般都能支持更多的活动客户机。\nUDP 的首部开销小。TCP 有 20B 的首部开销，而 UDP 仅有 8B 的开销。\nUDP 没有拥塞控制，因此网络中的拥塞不会影响源主机的发送速率。\nUDP 支持一对一、一对多、多对一和多对多的交互通信。\n\nUDP 应用场景：\n\nUDP 常用于一次性传输较少数据的网络应用，如 DNS、SNMP 等，因为对于这些应用，若采用 TCP，则将为连接创建、维护和拆除带来不小的开销。\nUDP 也常用于多媒体应用（如 IP 电话、实时视频会议、流媒体等），显然，可靠数据传输对这些应用来说并不是最重要的，但 TCP 的拥塞控制会导致数据出现较大的延迟，这是它们不可容忍的。\n\nUDP 不保证可靠交付，但这并不意味着应用对数据的要求是不可靠的，所有维护可靠性的工作可由用户在应用层来完成。应用开发者可根据应用的需求来灵活设计自己的可靠性机制。\nUDP 是面向报文的。\n\n发送方 UDP 对应用层交下来的报文，在添加首部后就向下交付给 IP 层，一次发送一个报文，既不合并，也不拆分，而是保留这些报文的边界；\n接收方 UDP 对 IP 层交上来 UDP 数据报，在去除首部后就原封不动地交付给上层应用进程，一次交付一个完整的报文。\n\n因此报文不可分割，是 UDP 数据报处理的最小单位。因此，应用程序必须选择合适大小的报文，若报文太长，UDP 把它交给 IP 层后，可能会导致分片；若报文太短，UDP 把它交给 IP 层后，会使 IP 数据报的首部的相对长度太大，两者都会降低 IP 层的效率。\nUDP 数据报\nUDP 数据报包含两部分：首部字段和用户数据字段。UDP 首部有 8B，由 4 个字段组成，每个字段的长度都是 2B。\n各字段意义如下：\n\n源端口：源端口号。在需要对方回信时选用，不需要时可用全 0。\n目的端口：目的端口号。这在终点交付报文时必须使用到。\n长度：UDP 数据报的长度（包括首部和数据），其最小值是 8（仅有首部）。\n检验和：检测 UDP 数据报在传输中是否有错。该字段是可选的，当源主机不想计算检验和时，则直接令该字段为全 0（若检验和计算结果恰好是 0，则该字段为全 1）。\n\n\n若接收方 UDP 发现收到的报文中的目的端口号不正确（即不存在对应于端口号的应用进程）则就丢弃该报文，并由 ICMP 发送“端口不可达”差错报文给发送方。\nUDP 检验\n在计算检验和时，要在 UDP 数据报之前增加 12B 的伪首部，伪首部并不是 UDP 的真正首部。只是在计算检验和时，临时添加在 UDP 数据报的前面，得到一个临时的 UDP 数据报。\n检验和就是按照这个临时的 UDP 数据报来计算的。\n伪首部既不向下传送又不向上递交，而只是为了计算检验和。\n\nUDP 计算检验和的方法和计算 IP 数据报首部检验和的方法相似。不同的是 IP 数据报的检验和只检验 IP 数据报的首部，但 UDP 的检验和要将首部和数据部分一起检验。\nUDP 计算检验和的方法：\n\n\n发送方首先把全 O 放入检验和字段并添加伪首部，然后把 UDP 数据报视为许多 16 位的字串接起来。\n若 UDP 数据报的数据部分不是偶数个字节，则要在末尾填入一个全 0 字节，但此字节不发送。\n\n\n然后按二进制反码计算出这些 16 位字的和，将此和的二进制反码写入检验和字段，并发送。\n\n\n接收方把收到的 UDP 数据报加上伪首部（若不为偶数个字节，则还需要补上全 0 字节）后，按二进制反码求这些 16 位字的和。\n当无差错时其结果应为全 1，否则就表明有差错出现，接收方就应该丢弃这个 UDP 数据报。\n\n\nUDP 检验和检验出 UDP 数据报是错误的，则可以丢弃，也可以交付给上层，但是需要附上错误报告，即告诉上层这是错误的数据报。\n通过伪首部，不仅可以检查源端口号、目的端口号和 UDP 用户数据报的数据部分，还可以检查 IP 数据报的源 IP 地址和目的地址。\n这种简单的差错检验方法的校错能力不强，但它的好处是简单、处理速度快。\nTCP\n特点\nTCP 是在不可靠的 IP 层之上实现的可靠的数据传输协议，它主要解决传输的可靠、有序、无丢失和不重复问题。\nTCP 是 TCP/IP 体系中非常复杂的一个协议，主要特点如下：\n\nTCP 是面向连接的传输层协议，TCP 连接是一条逻辑连接。\n每一条 TCP 连接只能有两个端点，每一条TCP 连接只能是一对一的。\nTCP 提供可靠交付的服务，保证传送的数据无差错、不丢失、不重复且有序。\nTCP 提供全双工通信，允许通信双方的应用进程在任何时候都能发送数据，为此 TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据。\n\n发送缓存用来暂时存放：发送应用程序传送给发送方 TCP 准备发送的数据；TCP 已发送但尚未收到确认的数据。\n接收缓存用来暂时存放：按序到达但尚未被接收应用程序读取的数据；不按序到达的数据。\n\n\nTCP 是面向字节流的，虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅视为一连串的无结构的字节流。\n\nTCP 和 UDP 在发送报文时所采用的方式完全不同。UDP 报文的长度由发送应用进程决定，而 TCP 报文的长度则根据接收方给出的窗口值和当前网络拥塞程度来决定。若应用进程传送到 TCP 缓存的数据块太长，则 TCP 就把它划分得短一些再传送；若太短，则 TCP 也可等到积累足够多的字节后再构成报文段发送出去。关于 TCP 报文的长度问题，后面会详细讨论。\n\n\n                  \n                  Tip\n                  \n                \n\n在以下的情况下，TCP 的“可靠交付”功能是必不可少的：\n\n每个 IP 数据报独立地选择路由，因此在到达目的主机时有可能出现失序。\n由于路由选择的计算出现错误，导致 IP 数据报在互联网中转圈。最后数据报首部中的生存时间的数值下降到零。这个数据报在中途就被丢失。\n某个路由器突然出现很大的通信量，以致路由器来不及处理到达的数据报。因此有的数据报被丢弃。\n\n所以即使假定在一个互联网中所有链路的传输都不出现差错，所有结点也都不会发生故障。在这种情况下 TCP 的“可靠交付”功能仍然不是多余的。\n\n\n报文段\nTCP传送的数据单元称为报文段。\nTCP 报文段既可以用来运载数据，又可以用来建立连接、释放连接和应答。\n一个 TCP 报文段分为首部和数据两部分，整个 TCP 报文段作为 IP 数据报的数据部分封装在 IP 数据报中。其首部的前 20B 是固定的。TCP 首部最短为 20B，后面有 4N 字节是根据需要而增加的选项，长度为 4B 的整数倍。\n\n\n\n源端口和目的端口\n各占 2B。分别表示发送方和接收方使用的端口号。\n\n\n序号\n占 4B，范围为 0 ～ 2^32^-1，共 2^32^个序号。\nTCP 连接中传送的字节流中的每个字节都要按顺序编号，序号字段值指的是本报文段所发送的数据的第一个字节的序号。\n例如，一报文段的序号字段值是 301，而携带的数据共有 100B，表明本报文段的数据的最后一个字节的序号是 400，因此下一个报文段的数据序号应从 401 开始。\n\n\n确认号\n占 4B，是期望收到对方下一个报文段的第一个数据字节的序号。\n若确认号为 N，则表明到序号 N-1 为止的所有数据都已正确收到。\n例如，B 正确收到了 A 发送过来的一个报文段，其序号字段是 501，而数据长度是 200B（序号 501 ～ 700），这表明 B 正确收到了 A 发送的到序号 700 为止的数据。因此 B 期望收到 A 的下一个数据序号是 701，于是 B 在发送给 A 的确认报文段中把确认号置为 701。\n\n\n\n数据偏移（即首部长度）\n占 4 位，这里不是 IP 数据报分片的那个数据偏移，而是表示首部长度（首部中还有长度不确定的选项字段），它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。\n“数据偏移”的单位是 32 位（以 4B 为计算单位）。因为 4 位二进制数能表示的最大值为 15，所以 TCP 首部的最大长度为 60B。\n\n\n\n保留\n占 6 位，保留为今后使用，但目前应置为 0。\n\n\n紧急位 URG\n当 URG=1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送（相当于高优先级的数据）。紧急数据被插入到报文段数据的最前面，而在紧急数据后面的数据仍是普通数据，因此要与首部中的紧急指针字段配合使用。\n\n\n确认位 ACK\n仅当 ACK=1 时确认号字段才有效。当 ACK=0 时，确认号无效。\nTCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。\n\n\n推送位 PSH（Push）\n两个应用进程进行交互式通信时，都希望在键入一个命令后立即就能收到对方的响应，此时发送方 TCP 把 PSH 置 1，接收方 TCP 收到 PSH=1 的报文段后，就尽快交付给接收应用进程，而不再等到整个缓存都填满了后再向上交付。\n\n\n复位位 RST(Reset)\n当RST=1 时，表示 TCP 连接中出现严重差错（如主机崩溃等），必须释放连接，然后重新建立传输连接。此外，它还可用于拒绝一个非法的报文段。\n\n\n同步位 SYN\n\n\n当 SYN=1 时表示这是一个连接请求或连接接受报文。\n当 SYN=1，ACK=0 时，表明这是一个连接请求报文，若对方同意建立连接，则应在响应报文中使用 SYN=1，ACK=1。\n\n\n终止位 FIN(Finish)\n用来释放一个连接。当 FIN=1 时，表明此报文段的发送方的数据已发送完毕，并要求释放传输连接。\n\n\n窗口\n占 2B，范围为 0 ～ 2^16^-1。\n窗口值告诉对方，从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。\n接收方的数据缓存空间是有限的，因此窗口值作为接收方让发送方设置其发送窗口的依据。\n例如，设确认号是 701，窗口字段是 1000。这表明，从 701 号算起，发送此报文段的一方还有接收 1000 字节数据（字节序号为 701 ～ 1700）的接收缓存空间。\n\n\n检验和\n占 2B。检验和字段检验的范围包括首部和数据两部分。\n在计算检验和时，和 UDP 一样，要在 TCP 报文段的前面加上 12B 的伪首部（只需将 UDP 伪首部的协议字段的 17 改成 6，UDP 长度字段改成 TCP 长度，其他的和 UDP 一样）。\n\n\n\n紧急指针\n占 2B。紧急指针仅在 URG=1 时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据在报文段数据的最前面）。也就是说，使窗口为零也可以发送紧急数据。\n\n\n选项\n长度可变，最长可达 40B。\n当不使用选项时，TCP 首部长度是 20B。TCP 最初只规定了一种选项，即最大报文段长度（MaximumSegmentSize，MSS）。MSS 是 TCP 报文段中的数据字段的最大长度（注意仅仅是数据字段）。\n\n\n填充\n这是为了使整个首部长度是 4B 的整数倍。\n\n\n连接管理\nTCP 是面向连接的协议，因此每个 TCP 连接都有三个阶段：连接建立、数据传送和连接释放。\nTCP 连接的管理就是使运输连接的建立和释放都能正常进行。\nTCP 把连接作为最基本的抽象，每条 TCP 连接有两个端点，TCP 连接的端点不是主机，不是主机的 IP 地址，不是应用进程，也不是传输层的协议端口。TCP 连接的端口即为套接字，每一条 TCP 连接唯一地被通信的两个端点（即两个套接字）所确定。\n\n同一个 IP 地址可以有多个不同的 TCP 连接，而同一个端口号也可以出现在多个不同的 TCP 连接中。\n\nTCP 连接的建立采用客户/服务器模式。主动发起连接建立的应用进程称为客户(Client)，而被动等待连接建立的应用进程称为服务器(Server)。\n连接的建立(三次握手)\n连接的建立经历以下 3 个步骤，通常称为“三次握手”。\n“三报文握手”建立 TCP 连接的目的在于解决以下三个主要问题：\n\n使 TCP 双方能够确知对方的存在。\n使 TCP 双方能够协商一些参数。\n使 TCP 双方能够对运输实体资源进行分配和初始化。\n\n连接建立前，服务器处于 LISTEN（收听）状态，等待客户的连接请求。\n\n\n\n客户机的 TCP 首先向服务器的 TCP 发送连接请求报文段。这个报文段的首部中的同步位 SYN=1，同时选择一个初始序号 seq=x。\nTCP 规定，SYN 报文段不能携带数据，但要消耗掉一个序号。这时，客户机进入 SYN-SENT（同步已发送）状态。\n\n\n服务器的 TCP 收到连接请求报文段后，如同意建立连接，则向客户机发回确认，并为该 TCP 连接分配缓存和变量。\n在确认报文段中，把 SYN 位和 ACK 位都置 1，确认号是 ack=x+1，同时也为自已选择一个初始序号 seq=y。\n确认报文段不能携带数据，但也要消耗掉一个序号。这时，服务器进入 SYN-RCVD（同步收到）状态。\n\n\n当客户机收到确认报文段后，还要向服务器给出确认，并为该 TCP 连接分配缓存和变量。\n确认报文段的 ACK 位置 1，确认号 ack=y+1，序号 seq=x+1。该报文段可以携带数据，若不携带数据则不消耗序号。\n这时，客户机进入 ESTABLISHED（已建立连接）状态。当服务器收到来自客户机的确认后，也进入 ESTABLISHED 状态。\n\n\n成功进行以上三步后，就建立了 TCP 连接，接下来就可以传送应用层数据。TCP 提供的是全双工通信，因此通信双方的应用进程在任何时候都能发送数据。\n\n\n\n                  \n                  为什么不采用“两次握手”建立连接 \n                  \n                \n\n不采用“两次握手”建立连接主要是为了防止两次握手情况下已失效的连接请求报文段突然又传送到服务器而产生错误。\n客户 A 向服务器 B 发出 TCP  连接请求，第一个连接请求报文在网络的某个结点长时间滞留，A 超时后认为报文丢失，于是再重传一次连接请求，B 收到后建立连接。数据传输完毕后双方断开连接。而此时，前一个滞留在网络中的连接请求到达服务器 B，而 B 认为 A 又发来连接请求。此时，\n\n若使用“三次握手”，则 B 向 A 返回确认报文段，因为是一个失效的请求，所以 A 不予理睬，建立连接失败。\n若采用的是“两次握手”，则这种情况下 B 认为传输连接已经建立，并一直等待 A 传输数据，而 A 此时并无连接请求，因此不予理睬，这样就造成了 B 的资源白白浪费。\n\n\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n\n\n\n连接的释放(四次挥手)\n与 TCP 连接的两个进程中的任何一个都能终止该连接。TCP 连接释放的过程通常称为“四次挥手”。\n\n\n\n客户机打算关闭连接时，向其 TCP 发送连接释放报文段，并停止发送数据，主动关闭 TCP 连接，该报文段的终止位 FIN=1，序号 seq=u，它等于前面已传送过的数据的最后一个字节的序号加 1，FIN 报文段即使不携带数据，也要消耗掉一个序号。\n这时，客户机进入 FIN-WAIT-1（终止等待 1）状态。\nTCP 是全双工的，即可以想象为一条 TCP 连接上有两条数据通路，发送 FIN 的一端不能再发送数据，即关闭了其中一条数据通路，但对方还可以发送数据。\n\n\n服务器收到连接释放报文段后即发出确认，确认号 ack=u+1，序号 seq=v，等于它前面已传送过的数据的最后一个字节的序号加 1。然后服务器进入 CLOSE-WAIT（关闭等待）状态。\n此时，从客户机到服务器这个方向的连接就释放了，TCP 连接处于半关闭状态。但服务器若发送数据，客户机仍要接收，即从服务器到客户机这个方向的连接并未关闭。\n客户机收到来自服务器的确认后，进入 FIN-WAIT-2（终止等待 2）状态，等待服务器发出的连接释放报文段。\n\n\n若服务器已经没有要向客户机发送的数据，就通知 TCP 释放连接，此时，其发出 FIN=1 的连接释放报文段。\n设该报文段的序号为 w（处于半关闭状态的服务器可能又发送了一些数据），还必须重复发送上次已发送的确认号 ack=u+1。这时服务器进入 LAST-ACK（最后确认）状态。\n\n\n客户机收到连接释放报文段后，必须发出确认，之后进入 TIME-WAIT（时间等待）状态。该报文段的确认位 ACK 置 1，确认号 ack=w+1，序号 seq=u+1。\n服务器收到该确认报文段后就进入 CLOSED（连接关闭）状态。客户机进入 TIME-WAIT 状态后，还要经过时间等待计时器设置的时间 2MSL（Maximum Segment Lifetime，最长报文段寿命）后，才进入 CLOSED 状态。\n\n\n若服务器收到连接释放请求后不再发送数据，则从客户机发出 FIN 报文段时刻算起，客户机释放连接的最短时间为 1 RTT + 2 MSL，服务器释放连接的最短时间为 1.5 RTT。\n\n\n\n                  \n                  Note\n                  \n                \n\n除时间等待计时器外，TCP 还设有一个保活计时器。设想 TCP 双方已建立连接，但后来客户主机突然出现故障。显然，服务器以后就不能再收到客户发来的数据。因此，应当有措施使服务器不要再白白等待下去，这个问题就可以使用保活计时器来解决。\n\n\n\n流量控制\n流量控制的功能就是让发送方的发送速率不要太快，以便让接收方来得及接收，因此可以说流量控制是一个速度匹配服务（匹配发送方的发送速率与接收方的读取速率）。\n\nTCP 利用滑动窗口机制来实现流量控制。TCP 要求发送方维持一个接收窗口(rwnd)，接收方根据当前接收缓存的大小，动态地调整接收窗口的大小，其大小反映了接收方的容量。接收方将其放在 TCP 报文段首部中的“窗口”字段，以通知发送方。\n发送方的发送窗口不能超过接收方给出的接收窗口值，以限制发送方向网络注入报文的速率。\n假设数据只从 A 发往 B，而 B 仅向 A 发送确认报文段，则 B 可通过设置确认报文段首部中的窗口字段来将 rwnd 通知给 A。接收方允许连续接收的能力，单位是字节。\n\n发送方 A 总是根据最新收到的 rwnd 值来限制自已发送窗口的大小，从而将未确认的数据量控制在 rwnd 大小之内，保证 A 不会使 B 的接收缓存溢出。\n设 A 向 B 发送数据，在连接建立时，B 告诉 A：“我的接收窗口 rwnd=400”。接收方 B 进行了三次流量控制，这三个报文段都设置了 ACK=1，只有在 ACK=1 时确认号字段才有意义。第一次把窗口减到 rwnd=300，第二次又减到 rwnd=100，最后减到 rwnd=0，即不充许发送方再发送数据。这使得发送方暂停发送的状态将持续到 B 重新发出一个新的窗口值为止。\n\nTCP 为每个连接设有一个持续计时器，只要发送方收到对方的零窗口通知，就启动持续计时器。若计时器超时，就发送一个零窗口探测报文段，而对方就在确认这个探测报文段时给出现在的窗口值。若窗口仍然为零，则发送方收到确认报文段后就重新设置持续计时器。\n\n传输层和数据链路层的流量控制的区别是：\n\n传输层实现的是端到端，即两个进程之间的流量控制。传输层的滑动窗口协议的窗口大小则可以动态变化。\n数据链路层实现的是两个中间的相邻结点之间的流量控制。此外，数据链路层的滑动窗口协议的窗口大小不能动态变化。\n\n拥塞控制\n拥塞\n在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏，这种情况就叫作拥塞。\n\n\n                  \n                  Note\n                  \n                \n\n拥塞现象是指到达通信子网中某一部分的分组数量过多，使得该部分网络来不及处理，以致这部分乃至整个网络性能下降的现象，严重时甚至导致网络通信业务陷入停顿，即出现死锁现象。\n\n\n判断网络是否进入拥塞状态的方法是，观察网络的吞吐量与网络负载的关系：\n\n若随着网络负载的增加，网络的吞吐量明显小于正常的吞吐量，则网络就可能已进入轻度拥塞状态；\n若网络的吞吐量随着网络负载的增大而下降，则网络就可能已进入拥塞状态。\n\n\n拥塞控制\n拥塞控制是指防止过多的数据注入网络，保证网络中的路由器或链路不致过载。出现拥塞时，端点并不了解拥塞发生的细节，对通信的端点来说，拥塞往往表现为通信时延的增加。\n拥塞控制主要解决的问题是如何获取网络中发生拥塞的信息，从而利用这些信息进行控制，以避免因拥塞而出现分组的丢失。\n\n\n                  \n                  拥塞控制与流量控制的区别 \n                  \n                \n\n\n\n拥塞控制是让网络能够承受现有的网络负荷，是一个全局性的过程，涉及所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。\n\n\n\n流量控制往往是指点对点的通信量的控制，是个端到端的问题（接收端控制发送端），它所要做的是抑制发送端发送数据的速率，以便使接收端来得及接收。\n\n\n\n\n拥塞控制和流量控制也有相似的地方，即它们都通过控制发送方发送数据的速率来达到控制效果。\n\n\n拥塞控制的方法有两种：\n\n\n开环控制\n在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。\n这是一种静态的预防方法。一旦整个系统启动并运行，中途就不再需要修改。\n当网络的流量特征可以准确规定且性能要求可以事先获得时，适合使用开环控制。\n\n\n闭环控制\n事先不考虑有关发生拥塞的各种因素，采用监测网络系统去监视，及时检测哪里发生了拥塞，然后将拥塞信息传到合适的地方，以便调整网络系统的运行，并解决出现的问题。\n闭环控制是基于反馈环路的概念，是一种动态的方法。\n当网络的流量特征不能准确描述或者当网络不提供资源预留时，适合使用闭环控制。因特网采用的就是闭环控制方法。\n\n\n\n\n                  \n                  Note\n                  \n                \n\n\n王道书上没有\n\n\n\n\nTCP 拥塞控制方法\n可靠传输 TCP 进行拥塞控制的算法有四种：慢开始、拥塞避免、快重传和快恢复。\n发送方在确定发送报文段的速率时，既要考虑接收方的接收能力，又要从全局考虑不要使网络发生拥塞。因此，除了接收窗口，TCP 还要求发送方维持一个拥塞窗口(cwnd)，其大小取决于网络的拥塞程度，并且动态地变化。\n发送方控制拥塞窗口的原则：只要网络未出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去，以提高网络的利用率。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络的分组数，以缓解网络出现的拥塞。\n\n\n                  \n                  判断网络出现拥塞的依据 \n                  \n                \n\n没有按时收到应当到达的 TCP 确认报文段而产生了超时重传。\n\n\n发送窗口的上限值应取接收窗口 rwnd 和拥塞窗口 cwnd 中较小的一个，即\n\\text{发送窗口的上限值}=min[rwnd,cwnd]\n\n\n假设：\n\n数据为单方向传送，对方只传送确认报文。\n接收方总是有足够大的缓存空间，因而发送窗口的大小由网络的拥塞程度决定，也就是不考虑接收方对发送方的流量控制。\n以 TCP 最大报文段长度 MSS（即TCP 报文段的数据载荷部分）的个数作为讨论问题的单位，而不是以字节为单位（尽管 TCP 是面向字节流的）。\n\n\n慢开始-拥塞避免\n\n\n                  \n                  ssthresh 阈值 \n                  \n                \n\n为了防止 cwnd 增长过大而引起网络拥塞，还需要设置一个慢开始门限 ssthresh（闽值）。这样，当慢开始一直把 cwnd 增大到一个规定的 ssthresh 时，然后改用拥塞避免算法。\n\n\n\n慢开始算法的思路是当发送方刚开始发送数据时，因为并不清楚网络的负荷情况，若立即把大量数据注入网络，则有可能引发网络拥塞。因此先发送少量数据探测一下，若没有发生拥塞，则适当增大拥塞窗口，即由小到大逐渐增大拥塞窗口（即发送窗口）。\n使用慢开始算法后，每经过一个传输轮次（即往返时延 RTT），cwnd 就会加倍，即 cwnd 的值随传输轮次指数增长。\n\n慢开始的“慢”并不是指拥塞窗口 cwnd 的增长速率慢，而是指在 TCP 开始发送报文段时先设置 cwnd=1，使得发送方一开始向网络注入的报文段少（目的是试探一下网络的拥塞情况），然后逐渐增大 cwnd，这对防止网络出现拥塞是一个非常有力的措施。\n\n\n                  \n                  Tip\n                  \n                \n\n在不超过阈值的时候，每经过一个 RTT 后拥塞窗口 cwnd 就会加倍，这里的加倍本质上原拥塞窗口 cwnd 加上收到的 ACK。\n\n接受缓存的大小/最大段长 MSS = 接受窗口大小\n\n假设 MSS=1KB，接收缓存 60KB，接收缓存满了才向应用层交付。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n阈值(ssthresh)拥塞窗口(cwnd)接收窗口(rwnd)发送窗口(swnd)发送数据量/接受ACK量RTT1\\infty32292929RTT2\\infty61606060\n\n\n\n拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，县体做法是：每经过一个往返时延 RTT 就把发送方的拥塞窗口 cwnd 加 1，而不是加倍，使拥塞窗口 cwnd 按线性规律缓慢增长，这比慢开始算法的拥塞窗口增长速率要缓慢得多。\n“拥塞避免”也并非指完全能够避免拥塞，而是指在拥塞避免阶段将 cwnd 值控制为按线性规律增长，使网络比较不容易出现拥塞。\n\n无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（未按时收到确认）\n\n首先把慢开始门限 ssthresh 设置为出现拥塞时的发送方的 cwnd 值的一半（但不能小于 2）\n然后把拥塞窗口 cwnd 重新设置为 1，执行慢开始算法。这样做的目的是迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完。\n\n\n\n\n快重传-快恢复\n有时个别报文段会在网络中丢失，但实际上网络并未发生拥塞。若发送方迟迟收不到确认，就会产生超时，并误认为网络发生了拥塞，这就导致发送方错误地启动慢开始算法，从而降低传输效率。\n采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失。\n\n快重传算法是使发送方尽快（尽早）进行重传，而不等超时计时器超时再重传。这就要求：\n\n接收方不要等待自已发送数据时才进行销带确认，而要立即发送确认，即使收到了失序的报文段也要立即发出对已收到报文段的重复确认。\n发送方一旦连续收到 3 个余 ACK（即重复确认），就立即重传相应的报文段，而不等该报文段的超时计时器超时再重传。\n\n\n\n\n                  \n                  Tip\n                  \n                \n\nTCP 规定每当比期望序号大的失序报文段到达时，就发送一个冗余 ACK，指明下一个期待字节的序号。\n\n\n快恢复算法的原理如下：当发送方连续收到 3 个冗余 ACK（重复确认）时，把慢开始门限 ssthresh 调整为当前 cwnd 的一半（为了预防网络发生拥塞）。但此时发送方知道现在只是丢失了个别的报文段，于是不启动慢开始算法，而是执行快恢复算法。\n\n\n                  \n                  Tip\n                  \n                \n\n因为跳过了拥塞窗口 cwnd 从 1 起始的慢开始过程，所以被称为快恢复。\n\n\n\n总流程\n\n接收方的缓存空间总是有限的。因此，发送方发送窗口的大小由流量控制和拥塞控制共同决定。\n\n\n                  \n                  Tip\n                  \n                \n\n当题目中同时出现接收窗口(rwnd)和拥塞窗口(cwnd)时，发送方发送窗口的实际大小是由 rwnd 和 cwnd 中较小的那一个确定的。\n\n\n\n\n\n\n\n\n\nTCP 拥塞控制与网际层拥塞控制的关系*\n\n\n可靠传输\nTCP 在不可靠的 IP 层之上建立一种可靠数据传输服务。\nTCP 提供的可靠数据传输服务保证接收方从缓存区读出的字节流与发送方发出的字节流完全一样。TCP 使用了检验、序号、确认和重传等机制来达到这一目的。其中，TCP 的检验机制与 UDP 一样。\n序号和确认\n\n\n\n\n\n\n\n\n\n                  \n                  Tip\n                  \n                \n\nTCP 使用累积确认，这看起来像是 GBN 的风格。但是，正确收到但失序的报文并不会丢弃，而是缓存起来，并且发送余 ACK 指明期望收到的下一个报文段，这是 TCP 方式和 GBN 的显著区别。\n例如，A 发送了 N 个报文段，其中第 k 个报文段丢失，其余 N-1 个报文段正确地按序到达接收方 B。\n\n使用 GBN 时，A 需要重传分组 k，以及所有后继分组 k+1,k+2,,N。相反，TCP 却至多重传一个报文段，即报文段 k。\n另外，TCP 中提供一个 SACK(Selective ACK)选项，即选择确认选项。使用选择确认选项时，TCP 看起来就和 SR 非常相似。因此，TCP 的差错恢复机制可视为 GBN 和 SR 协议的混合体。\n\n\n\n重传\n有两种事件会导致 TCP 对报文段进行重传：超时和冗余 ACK。\nTCP 每发送一个报文段，就对这个报文段设置一个超时计时器。计时器设置的重传时间到期但还未收到确认时，就要重传这一报文段。\n因为 TCP 的下层是互联网环境，IP 数据报所选择的路由变化很大，所以传输层的往返时延的方差也很大。为了计算超时计时器的重传时间，TCP 采用一种自适应算法，它记录一个报文段发出的时间，以及收到相应确认的时间，这两个时间之差称为报文段的往返时间(Round-TripTime, RTT)。TCP 维护了 RTT 的一个加权平均往返时间 RTTS，它会随新测量 RTT 样本值的变化而变化。\n显然，超时计时器设置的**超时重传时间(RetransmissionTime-Out，RTO)**应略大于 RTTS，但也不能大太多，否则当报文段丢失时，TCP 不能很快重传，导致数据传输时延大。\n\n\n超时触发重传存在的一个问题是超时周期往往太长。所幸的是，发送方通常可在超时事件发生之前通过注意所谓的冗余 ACK 来较好地检测丢包情况。\n冗余 ACK 就是再次确认某个报文段的 ACK，而发送方先前已经收到过该报文段的确认。TCP 规定当发送方收到对同一个报文段的 3 个余 ACK 时，就可以认为跟在这个被确认报文段之后的报文段已经丢失。\n例如，发送方 A 发送了序号为 1、2、3、4、5 的 TCP 报文段，其中 2 号报文段在链路中丢失，它无法到达接收方 B。因此 3、4、5 号报文段对于 B 来说就成了失序报文段，但它们不是 B 所期望收到的下一个报文段，于是 B 就发送 3 个对 1 号报文段的冗余 ACK，表示自己期望接收 2 号报文段。当 A 收到对于 1 号报文段的 3 个见余 ACK 时，认为 2 号报文段已经丢失，这时发送方 A 可以立即对 2 号报文段执行重传，这种技术通常称为快速重传。\n当然，冗余 ACK 还被用在拥塞控制中。\nUDP 和 TCP 对比\n\n\n\n\n"},"计算机基础/计算机网络/6_应用层":{"title":"应用层","links":[],"tags":["计算机网络"],"content":"网络应用模型\n客户/服务器(C/S)\n在客户/服务器(Client/Server，C/S)模型中，有一个总是打开的主机称为服务器，它服务于许多来自其他称为客户机的主机请求。\n其工作流程如下：\n\n服务器处于接收请求的状态。\n客户机发出服务请求，并等待接收结果。\n服务器收到请求后，分析请求，进行必要的处理，得到结果并发送给客户机。\n\n\n服务器上运行着专门用来提供某种服务的程序，可同时处理多个远程或本地客户的请求。客户程序必须知道服务器程序的地址。服务器启动后就一直不断地运行着，被动等待并接收来自各地客户的请求。因此，服务器程序不需要知道客户程序的地址。\n客户/服务器模型最主要的特征是：客户是服务请求方，服务器是服务提供方。使用客户/服务器模型的常见应用包括 Web、文件传输协议(FTP)、远程登录和电子邮件等。\n客户/服务器模型的主要特点还有：\n\n网络中各计算机的地位不平等，服务器可通过对用户权限的限制来达到管理客户机的目的。整个网络的管理工作由少数服务器担当，因此网络的管理非常集中和方便。\n客户机相互之间不直接通信。例如，在 Web 应用中两个浏览器并不直接通信。\n可扩展性不佳。受服务器硬件和网络带宽的限制，服务器支持的客户机数有限。\n\nP2P 模型\n在 C/S 模型中，服务器性能的好坏决定了整个系统的性能，当大量用户请求服务时，服务器就必然成为系统的瓶颈。P2P 模型的思想是整个网络中的传输内容不再被保存在中心服务器上，每个结点都同时具有下载、上传的功能，其权利和义务都是大体对等的。\n在 P2P 模型中，各计算机没有固定的客户和服务器划分。相反，任意一对计算机称为对等方，直接相互通信。\n实际上，P2P 模型从本质上来看仍然使用客户/服务器模型，每个结点既作为客户访问其他结点的资源，又作为服务器提供资源给其他结点访问。\n\n与 C/S 模型相比，P2P 模型的优点主要体现如下：\n\n减轻了服务器的计算压力，消除了对某个服务器的完全依赖，可以将任务分配到各个结点上，因此大大提高了系统效率和资源利用率。\n多个客户机之间可以直接共享文档。\n可扩展性好，传统服务器有响应和带宽的限制，因此只能接受一定数量的请求。\n网络健壮性强，单个结点的失效不会影响其他部分的结点。\n\n缺点：在获取服务的同时，还要给其他结点提供服务，因此会占用较多的内存，影响整机速度。\n动态主机配置协议(DHCP)\n\n动态主机配置协议(Dynamic Host Configuration Protocol, DHCP)常用于给主机动态地分配 IP 地址，它提供了即插即用的连网机制，这种机制允许一台计算机加入新的网络和自动获取 IP 地址而不用手工参与。\nDHCP 是应用层协议，它是基于 UDP 的。\n\nDHCP 的工作原理：使用客户/服务器模型。\n\n\n需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送发现报文，这时该主机就成为 DHCP 客户。本地网络上的所有主机都能收到这个广播报文，但只有 DHCP 服务器才能回答此广播报文。\n\n\nDHCP 服务器先在其数据库中查找该计算机的配置信息。\n\n若找到，则返回找到的信息；\n若找不到，则从服务器的 IP 地址池中取一个地址分配给该计算机。\n\nDHCP 服务器的回答报文称为提供报文。\n\n\n\nDHCP 服务器和 DHCP 客户的交换过程如下：\n\n\nDHCP 客户广播“DHCP 发现”消息，试图找到网络中的 DHCP 服务器，以便从 DHCP 服务器获得一个 IP 地址。\n源地址为 0.0.0.0，目的地址为 255.255.255.255。\n\n\nDHCP 服务器收到“DHCP 发现”消息后，广播“DHCP 提供”消息，其中包括提供给 DHCP 客户机的 IP 地址。\n源地址为 DHCP 服务器地址，目的地址为 255.255.255.255。\n\n\nDHCP 客户收到“DHCP 提供”消息，若接受该 IP 地址，则广播“DHCP 请求”消息向 DHCP 服务器请求提供 IP 地址。\n源地址为 0.0.0.0，目的地址为 255.255.255.255。\n\n\nDHCP 服务器广播“DHCP 确认”消息，将 IP 地址分配给 DHCP 客户。\n源地址为 DHCP 服务器地址，目的地址为 255.255.255.255。\n\n\nDHCP 允许网络上配置多台 DHCP 服务器，当 DHCP 客户发出“DHCP 发现”消息时，有可能收到多个应答消息。这时，DHCP 客户只会挑选其中的一个，通常挑选最先到达的。\nDHCP 服务器分配给 DHCP 客户的 IP 地址是临时的，因此 DHCP 客户只能在一段有限的时间内使用这个分配到的 IP 地址。DHCP 称这段时间为租用期。租用期的数值应由 DHCP 服务器自己决定，DHCP 客户也可在自己发送的报文中提出对租用期的要求。\nDHCP 客户和服务器端需要通过广播方式进行交互，原因是在 DHCP 执行初期，客户机不知道服务器端的 IP 地址，而在执行中间，客户机并未被分配 IP 地址，从而导致两者之间的通信必须采用广播的方式。采用 UDP 而不采用 TCP 的原因也很明显：TCP 需要建立连接，若连对方的 IP 地址都不知道，则更不可能通过双方的套接字建立连接。\nDHCP 是应用层协议，因为它是通过客户/服务器模式工作的，DHCP 客户向 DHCP 服务器请求服务，而其他层次的协议是没有这两种工作方式的。\n\n域名系统(DNS)\n域名系统(Domain Name System, DNS)是因特网使用的命名系统，用来把便于人们记忆的具有特定含义的主机名转换为便于机器处理的 IP 地址。相对于 IP 地址，人们更喜欢使用具有特定含义的字符串来标识因特网上的计算机。\nDNS 系统采用客户/服务器模型，其协议运行在UDP之上，使用 53 号端口。\n从概念上可将 DNS 分为三部分：层次域名空间、域名服务器和解析器。\n层次域名空间\n因特网采用层次树状结构的命名方法。\n采用这种命名方法，任何一个连接到因特网的主机或路由器，都有一个唯一的层次结构名称，即域名(Domain Name)。\n域(Domain)是名字空间中一个可被管理的划分。域可以划分为子域，而子域还可以继续划分为子域的子域，这样就形成了顶级域、二级域、三级域等。每个域名都由标号序列组成，而各标号之间用点（“.”）隔开。\n\n域名中的标号有以下几点需要注意：\n\n标号中的英文不区分大小写。\n标号中除连字符（-）外不能使用其他的标点符号。\n每个标号不超过 63 个字符，多标号组成的完整域名最长不超过 255 个字符。\n级别最低的域名写在最左边，级别最高的顶级域名写在最右边。\n\n顶级域名分为如下三大类：\n\n国家（地区）顶级域名。例如“.cn”。\n通用顶级域名。例如“.com”。\n基础结构域名。用于反向域名解析，即 IP 地址反向解析为域名。\n\n\n\n\n                  \n                  IP 地址与域名不具有一一对应的关系 \n                  \n                \n\n若一台主机通过两块网卡连接到两个网络（如服务器双线接入），则就具有两个 IP 地址，每个网卡对应一个 MAC 地址，显然这两个 IP 地址可以映射到同一个域名上\n\n\n域名服务器\n域名到 IP 地址的解析是由运行在域名服务器上的程序完成的，一个服务器所负责管辖的（或有权限的）范围称为区（小于或等于“域”），一个区中的所有结点必须是能够连通的，每个区设置相应的权限域名服务器，用来保存该区中的所有主机的域名到 IP 地址的映射。\n每个域名服务器不但能够进行一些域名到 IP 地址的解析，而且还必须具有连向其他域名服务器的信息。当自己不能进行域名到 IP 地址的转换时，能够知道到什么地方去找其他域名服务器。\nDNS 使用了大量的域名服务器，它们以层次方式组织。没有一台域名服务器具有因特网上所有主机的映射，相反，该映射分布在所有的域名服务器上。有 4 种类型的域名服务器。\n\n\n根域名服务器\n根域名服务器是最高层次的域名服务器，所有的根域名服务器都知道所有的顶级域名服务器的域名和 IP 地址。\n根域名服务器是最重要的域名服务器，不管是哪个本地域名服务器，要对因特网上任何一个域名进行解析，只要自已无法解析，就首先要求助于根域名服务器。\n根域名服务器用来管辖顶级域（如.com），通常它并不直接把待查询的域名直接转换成 IP 地址，而是告诉本地域名服务器下一步应当找哪个顶级域名服务器进行查询。\n\n\n顶级域名服务器\n这些域名服务器负责管理在该顶级域名服务器注册的所有二级域名。收到 DINS 查询请求时，就给出相应的回答（可能是最后的结果，也可能是下一步应当查找的域名服务器的 IP 地址）。\n\n\n权限域名服务器（授权域名服务器）\n每台主机都必须在权限域名服务器处登记。为了更加可靠地工作，一台主机最好至少有两个权限域名服务器。实际上，许多域名服务器都同时充当本地域名服务器和权限域名服务器。权限域名服务器总能将其管辖的主机名转换为该主机的 IP 地址。\n\n\n本地域名服务器\n本地域名服务器对域名系统非常重要。每个因特网服务提供者（ISP），或一所大学，甚至一所大学中的各个系，都可以拥有一个本地域名服务器。当一台主机发出 DNS 查询请求时，这个查询请求报文就发送给该主机的本地域名服务器。\n\n\n域名解析过程\n域名解析是指把域名转化为 IP 地址的过程。\n当客户端需要域名解析时，通过本机的 DNS 客户端构造一个 DNS 请求报文，以 UDP 数据报方式发往本地域名服务器。\n域名解析有两种方式：递归查询、迭代查询。\n\n主机向本地域名服务器的查询都采用递归查询。\n本地域名服务器向其他域名服务器采用递归查询或选代查询\n\n\n因为该方法给根域名服务器造成的负载过大，所以实际中几乎不使用。\n\n本地域名服务器向根域名服务器的查询通常是采用选代查询。\n当根域名服务器收到本地域名服务器发出的选代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地域名服务器：“你下一步应当向哪个顶级域名服务器进行查询”。然后让本地域名服务器进行后续的查询（而不替本地域名服务器进行后续的查询）。\n同样，顶级域名服务器收到查询报文后，要么给出所要查询的 IP 地址，要么告诉本地域名服务器下一步应当向哪个权限域名服务器查询。最后，知道了所要解析的域名的 IP 地址后，把这个结果返回给发起查询的主机。\n为了提高 DNS 的查询效率，并减少因特网上的 DNS 查询报文数量，在域名服务器中广泛地使用了高速缓存，用来缓存最近查询过的域名的相关映射信息。这样，当另一个相同的域名查询到达该 DINS 服务器时，该服务器就能直接提供所要求的 IP 地址。\n\n因为主机名和 IP 地址之间的映射不是永久的，所以 DNS 服务器将在一段时间后丢弃高速缓存中的信息。在主机中同样也很需要高速缓存，许多主机在启动时从本地域名服务器下载域名和地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且只在从缓存中找不到域名时才使用域名服务器。\n\n文件传输协议(FTP)\n工作原理\n文件传输协议(File Transfer Protocol，FTP)是因特网上使用得最广泛的文件传输协议。\nFTP 提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限。它屏蔽了各计算机系统的细节，因而适合于在异构网络中的任意计算机之间传送文件。\nFTP 提供以下功能：\n\n提供不同种类主机系统（硬、软件体系等都可以不同）之间的文件传输能力。\n以用户权限管理的方式提供用户对远程 FTP 服务器上的文件管理能力。\n以匿名 FTP 的方式提供公用文件共享的能力。\n\nFTP 采用客户/服务器的工作方式，使用 TCP 可靠的传输服务。一个 FTP 服务器进程可同时为多个客户进程提供服务。\nFTP 的服务器进程由两大部分组成：一个主进程，负责接收新的请求；另外有若干从属进程，负责处理单个请求。其工作步骤如下：\n\n打开熟知端口 21（控制端口)，使客户进程能够连接上。\n等待客户进程发连接请求。\n启动从属进程处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后即终止。\n回到等待状态，继续接收其他客户进程的请求。主进程与从属进程是并发执行的。\n\nFTP 服务器必须在整个会话期间保留用户的状态信息。特别是服务器必须把指定的用户账户与控制连接联系起来，服务器必须追踪用户在远程目录树上的当前位置。\n控制连接与数据连接\nFTP 在工作时使用两个并行的 TCP 连接：\n\n一个是控制连接（服务器端口号 21）\n一个是数据连接（服务器端口号 20）。\n\n使用两个不同的端口号可以使协议更容易实现。\n\n\n控制连接\n服务器监听 21 号端口，等待客户连接，建立在这个端口上的连接称为控制连接，用来传输控制信息。\nFTP 客户发出的传送请求，通过控制连接发送给服务器端的控制进程，但控制连接并不用来传送文件。\n在传输文件时还可以使用控制连接（如客户在传输中途发一个中止传输的命令），因此控制连接在整个会话期间一直保持打开状态。\n\n\n数据连接\n服务器端的控制进程在接收到 FTP 客户发送来的文件传输请求后，就创建“数据传送进程”和“数据连接”。\n\n\n数据传送进程实际完成文件的传送。\n\n\n数据连接用来连接客户端和服务器端的数据传送进程，在传送完毕后关闭“数据传送连接”并结束运行。数据连接在每次文件传输时才建立，传输结束就关闭。\n数据连接有两种传输模式：\n\n\n主动模式PORT\n客户端连接到服务器的 21 端口，登录成功后要读取数据时，客户端随机开放一个端口，并发送命令告知服务器，服务器收到 PORT 命令和端口号后，通过 20 端口和客户端开放的端口连接，发送数据。\n\n\n\n被动模式PASV\nPASV 模式的不同点是，客户端要读取数据时，发送 PASV 命令到服务器，服务器在本地随机开放一个端口，并告知客户端，客户端再连接到服务器开放的端口进行数据传输。\n\n\n\n是用 PORT 模式还是 PASV 模式，选择权在客户端。简单概括为，主动模式传送数据是“服务器”连接到“客户端”的端口；被动模式传送数据是“客户端”连接到“服务器”的端口。\n\n\n\n\n电子邮件\n电子邮件系统组成结构\n电子邮件是一种异步通信方式，通信时不需要双方同时在场。电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可以随时上网到自己使用的邮件服务器进行读取。\n一个电子邮件系统应具有三个最主要的组成构件，即\n\n\n用户代理(User Agent, UA)\n用户与电子邮件系统的接口。用户代理向用户提供一个很友好的接口来发送和接收邮件，用户代理至少应当具有撰写、显示和邮件处理的功能。通常情况下，用户代理就是一个运行在 PC 上的程序（电子邮件客户端软件），常见的有 Outlook 和 Foxmail 等。\n\n\n邮件服务器\n它的功能是发送和接收邮件，同时还要向发件人报告邮件传送的情况（已交付、被拒绝、丢失等）。邮件服务器以客户/服务器模式工作，但它必须能够同时充当客户和服务器。例如，当邮件服务器 A 向邮件服务器 B 发送邮件时，A 就作为 SMTP 客户，而 B 是 SMTP 服务器；反之，当 B 向 A 发送邮件时，B 就是 SMTP 客户，而 A 就是 SMTP 服务器。\n\n\n邮件发送协议和读取协议\n\n\n邮件发送协议用于用户代理向邮件服务器发送邮件或在邮件服务器之间发送邮件，如 SMTP;\nSMTP 用的是“推”（Push）的通信方式，即用户代理向邮件服务器发送邮件及在邮件服务器之间发送邮件时，SMTP 客户将邮件“推”送到 SMTP 服务器。\n\n\n邮件读取协议用于用户代理从邮件服务器读取邮件，如 POP3。\nPOP3 用的是“拉”（Pull）的通信方式，即用户读取邮件时，用户代理向邮件服务器发出请求，“拉”取用户邮箱中的邮件。\n\n\n\n\n\n\n下面简单介绍电子邮件的收发过程。\n\n发件人调用用户代理来撰写和编辑要发送的邮件。\n邮件撰写完后，发件人点击“发送邮件”按钮，把发送邮件的工作全都交给用户代理来完成，就什么都不用管了。用户代理用 SMTP 把邮件传送给发送端邮件服务器。\n发送端邮件服务器将邮件放入邮件缓存队列中，等待发送。\n发送端邮件服务器的 SMTP 客户与接收端邮件服务器的 SMTP 服务器建立 TCP 连接，然后就把邮件缓存队列中的邮件依次发送出去。注意，邮件是直接传送给接收端邮件服务器的，而不会在互联网的某个中间邮件服务器落地。\n运行在接收端邮件服务器中的 SMTP 服务器进程收到邮件后，将邮件放入收件人的用户邮箱，等待收件人在方便时进行读取。\n\n电子邮件格式\n一个电子邮件分为信封和内容两大部分，邮件内容又分为首部和主体两部分。\nRFC822 规定了邮件的首部格式，而邮件的主体部分则让用户自由撰写。用户写好首部后，邮件系统自动地将信封所需的信息提取出来并写在信封上，用户不需要亲自填写信封上的信息。\n\n邮件内容的首部包含一些首部行，每个首部行由一个关键字后跟冒号再后跟值组成。有些关键字是必需的，有些则是可选的。最重要的关键字是 To 和 Subject。\n\n\nTo 是必填的关键字，后面填入一个或多个收件人的电子邮件地址。\n电子邮件地址的格式为：收件人邮箱名@邮箱所在主机的域名，如abc@cskaoyan.com，其中邮箱名 abc 在 cskaoyan.com 这个邮件服务器上必须是唯一的。这也就保证了该邮件地址在整个因特网上是唯一的。\n\n\nSubject 是可选关键字，是邮件的主题，反映了邮件的主要内容。\n\n\n\nSMTP 协议只能传送 ASCII 码文本数据，不能传送可执行文件或其他的二进制对象。SMTP 不能满足传送多媒体邮件（例如带有图片、音频或视频数据）的需要。并且许多其他非英语国家的文字（例如中文、俄文、甚至带有重音符号的法文或德文）也无法用 SMTP 传送。\n为解决 SMTP 传送非 ASCII 码文本的问题，提出了多用途因特网邮件扩展(Multipurpose Internet Mail Extensions，MIME)。\nMIME 并未改动 SMTP 或取代它。当发送端发送的邮件中包含有非 ASCII 码数据时，不能直接使用 SMTP 进行传送，而要通过 MIME 进行转换，将非 ASCII 码数据转换为 ASCII 码数据。之后，就可以使用 SMTP 进行传送。接收端也要使用 MIME 对接收到的 ASCII 码数据进行逆转换，以便可以得到包含有非 ASCII 码数据的邮件。\n\nMIME 主要包括以下三部分内容：\n\n5 个新的邮件首部字段，包括 MIME 版本、内容描述、内容标识、传送编码和内容类型。\n定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化。\n定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变。\n\nSMTP 和 POP3\nSMTP\n简单邮件传输协议(Simple Mail Transfer Protocol, SMTP)是一种提供可靠且有效的电子邮件传输的协议，它控制两个相互通信的 SMTP 进程交换信息。\n因为 SMTP 采用客户/服务器模式工作，所以负责发送邮件的 SMTP 进程就是 SMTP 客户，而负责接收邮件的 SMTP 进程就是 SMTP 服务器。SMTP 用的是 TCP 连接，端口号为 25。\nSMTP 通信有以下三个阶段。\n\n\n连接建立\n发件人的邮件发送到发送方邮件服务器的邮件缓存中后，SMTP 客户就每隔一定时间对邮件缓存扫描一次。如发现有邮件，就与接收方邮件服务器的 SMTP 服务器建立 TCP 连接，SMTP 服务器使用的熟知端口号为 25。\n连接建立后，接收方 SMTP 服务器发出 220 Serviceready（服务就绪）。然后 SMTP 客户向 SMTP 服务器发送 HELO 命令，附上发送方的主机名。\nSMTP 不使用中间的邮件服务器。TCP 连接总是在发送方和接收方这两个邮件服务器之间直接建立，而不管它们相隔多远，不管在传送过程中要经过多少个路由器。当接收方邮件服务器因故障暂时不能建立连接时，发送方的邮件服务器只能等待一段时间后再次尝试连接。\n\n\n邮件传送\n连接建立后，就可开始传送邮件。\n邮件的传送从 MAIL 命令开始，MAIL 命令后面有发件人的地址。如MAIL FROM：&lt;fh@hit.edu.cn&gt;。若 SMTP 服务器已准备好接收邮件，则回答 250OK。下面跟着一个或多个 RCPT 命令，每发送一个 RCPT 命令，都应有相应的信息从 SMTP 服务器返回，如 250 OK 或 550 No such user here（无此用户）。\nRCPT 命令的作用是，先弄清接收方系统是否已做好接收邮件的准备，然后才发送邮件，以便不至于发送了很长的邮件后才知道地址错误，进而避免浪费通信资源。获得 OK 的回答后，客户端就使用 DATA 命令，表示要开始传送邮件的内容。\n正常情况下，SMTP 服务器返回的信息是 354 Start mail input；此时 SMTP 客户就可开始传送邮件内容。\n\n\n连接释放邮件发送完毕后，SMTP 客户应发送 QUIT 命令。SMTP 服务器返回的信息是 221（服务关闭)，表示 SMTP 同意释放 TCP 连接。\n\n\n\nPOP3 和 IMAP\n邮局协议(Post Ofice Protocol, POP)是一个非常简单但功能有限的邮件读取协议，现在使用的版本是 POP3。\nPOP 也采用客户/服务器模式，在传输层使用 TCP，端口号为 110。接收方的用户代理必须运行 POP 客户程序，而接收方的邮件服务器中则运行 POP 服务器程序。\nPOP 有两种工作方式：“下载并保留”和“下载并删除”。在“下载并保留”方式下，用户从邮件服务器上读取邮件后，邮件依然会保存在邮件服务器上，用户可再次从服务器上读取该邮件；而使用“下载并删除”方式时，邮件一旦被读取，就被从邮件服务器上删除。\n另一个邮件读取协议是因特网报文存取协议(IMAP)，它比 POP 复杂得多，IMAP 为用户提供了创建文件夹、在不同文件夹之间移动邮件及在远程文件夹中查询邮件等联机命令，为此 IMAP 服务器维护了会话用户的状态信息。IMAP 的另一特性是允许用户代理只获取报文的某些部分，例如可以只读取一个报文的首部，或多部分 MIME 报文的一部分。这非常适用于低带宽的情况，用户可能并不想取回邮箱中的所有邮件，尤其是包含很多音频或视频的大邮件。\n此外，随着万维网的流行，目前出现了很多基于万维网的电子邮件，如 Hotmail、Gmail 等。这种电子邮件的特点是，用户浏览器与 Hotmail 或 Gmail 的邮件服务器之间的邮件发送或接收使用的是 HTTP，而仅在不同邮件服务器之间传送邮件时才使用 SMTP。\n\n万维网(WWW)\n万维网(World Wide Web, WWW)是一个分布式、联机式的信息存储空间，在这个空间中：一样有用的事物称为一样“资源”，并由一个全域“统一资源定位符”（URL）标识。这些资源通过超文本传输协议（HTTP）传送给使用者，而后者通过单击链接来获取资源。\n万维网的内核部分是由三个标准构成的：\n\n统一资源定位符(URL)：负责标识万维网上的各种文档，并使每个文档在整个万维网的范围内具有唯一的标识符 URL。\n超文本传输协议(HTTP)：一个应用层协议，它使用 TCP 连接进行可靠的传输，HTTP 是万维网客户程序和服务器程序之间交互所必须严格遵守的协议。\n超文本标记语言(HTML)：一种文档结构的标记语言，它使用一些约定的标记对页面上的各种信息（包括文字、声音、图像、视频等）、格式进行描述。\n\n万维网以客户/服务器模式工作。浏览器是在用户主机上的万维网客户程序，而万维网文档所驻留的主机则运行服务器程序，这台主机称为万维网服务器。客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档。\n工作流程如下：\n\nWeb 用户使用浏览器（指定 URL）与 Web 服务器建立连接，并发送浏览请求。\nWeb 服务器把 URL 转换为文件路径，并返回信息给 Web 浏览器。\n通信完成，关闭连接。\n\nHTTP\n操作过程\nHTTP 定义了浏览器怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器。\n\n从层次的角度看，HTTP 是面向事务的应用层协议，它规定了在浏览器和服务器之间的请求和响应的格式与规则，是万维网上能够可靠地交换文件的重要基础。\n从协议执行过程来说，浏览器要访问 WWW 服务器时，首先要完成对 WWW 服务器的域名解析。一旦获得了服务器的 IP 地址，浏览器就通过 TCP 向服务器发送连接建立请求。\n\n每个万维网站点都有一个服务器进程，它不断地监听 TCP 的端口 80，当监听到连接请求后便与浏览器建立 TCP 连接。然后，浏览器就向服务器发送请求获取某个 Web 页面的 HTTP 请求。服务器收到请求后，将构建所请求 Web 页的必需信息，并通过 HTTP 响应返回给浏览器。浏览器再将信息进行解释，然后将 Web 页显示给用户。最后，TCP 连接释放。\n用户单击鼠标后所发生的事件按顺序如下：\n\n浏览器分析链接指向页面的 URL。\n浏览器向 DNS 请求解析。\n域名系统 DNS 解析出服务器的 IP 地址。\n浏览器与该服务器建立 TCP 连接（默认端口号为 80）。\n浏览器发出 HTTP 请求。\n服务器通过 HTTP 响应把文件发送给浏览器。\n释放 TCP 连接。\n浏览器解释文件，并将 Web 页显示给用户。\n\n实际过程涉及 TCP/IP 体系结构中应用层的 DHCP、DNS 和 HTTP，传输层的 UDP 和 TCP，网际层的 IP 和 ARP，数据链路层的 CSMA/CD 或 PPP（若涉及 ISP 接入或广域网传输）。\n特点\nHTTP 使用 TCP 作为传输层协议，保证了数据的可靠传输。HTTP 不必考虑数据在传输过程中被丢弃后又怎样被重传。但是，HTTP 本身是无连接的。也就是说，虽然 HTTP 使用了 TCP 连接，但通信的双方在交换 HTTP 报文之前不需要先建立 HTTP 连接。\nHTTP 是无状态的。也就是说，同一个客户第二次访问同一个服务器上的页面时，服务器的响应与第一次被访问时的相同，因为服务器并不记得曾经服务过的这个客户。HTTP 的无状态特性简化了服务器的设计，使之更易支持大量并发的请求。\nHTTP 既可以使用非持续连接（HTTP/1.0），也可以使用持续连接（HTTP/1.1 支持）。\n\n\n对于非持续连接，每个网页元素对象的传输都需要单独建立一个 TCP 连接（第三次握手的报文段中梢带了客户对万维网文档的请求）。\n请求一个万维网文档所需的时间是该文档的传输时间（与文档大小成正比）加上两倍往返时间 RTT（一个 RTT 用于 TCP 连接，另一个 RTT 用于请求和接收文档）。每请求一个对象都导致 2xRTT 的开销，此外每次建立新的 TCP 连接都要分配缓存和变量，使万维网服务器的负担很重。\n\n\n\n所谓持续连接，是指万维网服务器在发送响应后仍然保持这条连接，使同一个客户和该服务器可以继续在这条 TCP 连接上传送后续的 HTTP 请求报文和响应报文。\n\n\nHTTP/1.1 默认使用持续连接。持续连接又分为非流水线和流水线两种工作方式。\n\n对于非流水线方式，客户在收到前一个响应后才能发出下一个请求，服务器在发送完一个对象后，其 TCP 连接就处于空闲状态，浪费了服务器资源。\n对于流水线方式，客户可以连续发出对各个对象的请求，服务器就可连续响应这些请求。若所有的请求和响应都是连续发送的，则引用所有对象共计经历 1 个 RTT 延迟，而不是像非流水线方式那样，每个对象都必须有 1 个 RTT 延迟。这种方式减少了 TCP 连接中的空闲时间，提高了效率。当然，在流水线方式中，服务器在每个 RTT 连续发送的数据量还受到 TCP 发送窗口的限制。\n\n报文结构\nHTTP 是面向文本的，因此报文中的每个字段都是一些 ASCⅡ 码串，并且每个字段的长度都是不确定的。\n有两类 HTTP 报文：\n\n请求报文：从客户向服务器发送的请求报文。\n响应报文：从服务器到客户的回答。\n\n\n两种报文都由三个部分组成，两者格式的区别就是开始行不同。\n\n开始行：在请求报文中的开始行称为请求行，而在响应报文中的开始行称为状态行。开始行的三个字段之间都以空格分隔，最后的“CR”和“LF”分别代表“回车”和“换行”。\n首部行：用来说明浏览器、服务器或报文主体的一些信息。首部可以有几行，但也可以不使用。在每个首部行中都有首部字段名和它的值，每一行的结束都要有“回车”和“换行”。整个首部行结束时，还有一空行将首部行和后面的实体主体分开。\n实体主体：在请求报文中一般不用这个字段，而在响应报文中也可能没有这个字段。请求报文的“请求行”有三个内容：方法、请求资源的 URL 及 HTTP 的版本。其中，“方法”是对所请求对象进行的操作，这些方法实际上也就是一些命令。\n"},"计算机基础/软件测试/1_软件测试技术复习":{"title":"软件测试技术复习","links":[],"tags":[],"content":"软件测试基础\nIEEE将软件可靠性定义为：系统在特定环境下，在给定的时间内无故障运行的概率。\n影响软件可靠性的因素：需求错误，设计错误，编码错误，测试错误，文档错误。\n软件缺陷的特征：\n\n缺陷不易看到。\n发现了缺陷，但不易找到问题发生的原因所在。\n\n定义\n软件测试的定义：\n\n软件测试是为了发现错误而执行程序的过程。\n软件测试是根据软件开发各阶段的规格说明和程序的内部结构而精心设计的一批测试用例，并利用这些测试用例运行程序以及发现错误的过程，即执行测试步骤。\n\n测试：一项活动，在这项活动中某个系统或组成的部分将在特定的条件下运行，结果将被观察和记录，并对系统或组成部分进行评价。测试活动有两种结果：找出缺陷和故障，或显示软件执行正确。\n测试用例：所谓测试用例是为特定的目的而设计的一组测试输入、执行条件和预期的结果；测试用例是执行测试的最小实体。\n测试步骤：测试步骤详细规定了如何设置、执行、评估特定的测试用例。\n测试是一个或多个测试用例的集合。测试无法说明错误不存在，只能说明软件错误已出现。一个好的测试用例在于发现了还未曾发现的错误；一次成功的测试则是发现了错误的测试。\n设计测试用例的基本准则：代表性、可判定性、可再现性\n测试用例特征：\n\n最有可能抓住错误的；\n不是重复的、多余的；\n一组相似测试用例中最有效的；\n既不是太简单，也不是太复杂。\n\n软件测试不等于程序测试。软件测试贯串于软件定义和开发的整个过程。\n软件测试的目标：发现错误，检查系统是否满足需求。\n软件测试的对象：软件开发过程中所产生的需求规格说明、概要设计规格说明、详细设计规格说明以及源程序。\n软件测试涉及的关键问题包括四个方面：测试由谁来执行、测试什么、什么时候进行测试、怎样进行测试。\n软件测试八原则：\n\n尽早地和及时地测试\n测试用例应当由测试数据和与之对应的预期结果组成；\n在程序提交测试后，应当由专门的测试人员进行测试；\n测试用例应包括合理的输入条件和不合理的输入条件；\n严格执行测试计划，排除测试的随意性；\n充分注意测试当中的群体现象；\n应对每一个测试结果做全面的检查；\n保存测试计划、测试用例、出错统计和最终分析报告，为维护工作提供充分的资料。\n\n分类\n\n周期性\n测试→改错→再测试→再改错\n\n代价\n随着整个开发过程的时间推移，更正缺陷或修复问题的费用呈几何级数增长。\n\n软件开发过程\n软件产品的组成\n客户需求、产品说明、设计文档、测试文档、进度计划、上一版本信息反馈、商业竞争对手的同类软件产品情况、易用性数据、观察与感受说明书。\n设计文档：\n\n构架：即产生描述软件整体设计的文档，包括软件所有主要部分的描述以及相互间的交互方式。\n数据流示意图：表示数据在程序中如何流动的正规示意图。通常由圆圈和线条组成，所以也称为泡泡图。\n状态变化示意图：将软件分解为基本状态或者条件的另一种正规示意图，表示不同状态之间的变化的方式。\n流程图：用图形描述程序逻辑的最常用方式之一。根据详细的流程图编写程序代码简单方便。\n注释代码：代码注释是便于维护代码的程序员掌握代码的内容和执行方式。\n\n测试文档：\n\n测试计划：描述用于验证软件是否符合产品说明书和客户需求的整体方案。\n测试用例：依据测试的项目，并描述验证软件的详细步骤。\n软件测试报告：描述依据测试用例找出的问题，通常提交测试报告。\n归纳、统计和总结：采用图表、表格和报告等形式来描述整个测试过程。\n\n软件开发模式\n\n\n大棒开发法\n\n\n边写边改法\n\n\n瀑布法\n瀑布模式是将软件生命周期的各项活动，规定为按照固定顺序相连的若干个阶段性工作，形如瀑布流水，最终得到软件产品。\n优点：易于理解；调研开发的阶段性；强调早期计划及需求调查；确定何时能够交付产品及何时进行评审与测试。\n缺点：需求调查分析只进行一次，不能适应需求变化；顺序的开发流程，使得开发中的经验教训不能反馈到该项目的开发中去；不能反映出软件开发过程的反复与迭代性；没有包含任何类型的风险评估；开发中出现的问题直到开发后期才能够显露，因此失去及早纠正的机会。\n\n\n\n快速原型法\n根据客户需求在较短的时间内解决用户最迫切解决的问题，完成可演示的产品。这个产品只实现最重要功能，在得到用户的更加明确的需求之后，原型将丢弃。\n\n\n\n螺旋模式法\n螺旋模式是瀑布模式与边写边改演化模式相结合，并加入风险评估所建立的软件开发模式。\n主要思想是在开始时不必详细定义所有细节，而是从小开始，定义重要功能，尽量实现，接受客户反馈，进入下一阶段，并重复上述过程，直到获得最终产品。\n优点：严格的全过程风险管理；强调各开发阶段的质量；提供机会评估项目是否有价值继续下去。\n\n\n敏捷开发\n轻量和简单。\n敏捷方法论包含最少的流程和文档，减少正式性。目的是做眼前能做的事情，而不去预测太远的未来，首先完成紧迫的事情。\n开发方法要称之为敏捷，需要具备4个基本特征：增量的、协作的、直接的、适应性强的。\n\n\n开发与测试的关系\n测试与开发各阶段的关系\n\n测试与开发的并行性\n\n完整的软件开发流程\n\n软件测试模型\n\n\nV模型\n\n\n\nX模型\n\n\n\nH模型\n\n\n\nW模型\n\n\n\n软件测试过程\n制定测试计划\n\n制定计划\n测试大纲\n软件测试报告\n\n测试执行过程\n\n初测期：测试主要功能和关键的执行路径，排除主要障碍。\n细测期：依据测试计划和测试大纲、测试用例，逐一测试大大小小的功能、方方面面的特性、性能、用户界面、兼容性、可用性等等；\n回归测试期：系统已达到稳定，在一轮测试中发现的错误已十分有限；复查已知错误的纠正情况，确认未引发任何新的错误时，终结回归测试。\n\n\n软件测试策略与过程\n软件测试的复杂性分析\n\n无法对程序进行完全测试\n测试无法显示潜在的软件缺陷和故障\n存在的故障现象与发现的故障数量成正比\n不能修复所有的软件故障\n软件测试的代价\n\n\n软件测试方法与策略\n软件测试策略：是为软件工程过程定义的一个软件测试的模板，也就是把特定的测试用例方法放置进去的一系列步骤。\n软件测试充分性五原则：\n\n单调性\n非复合性\n非分解性\n复杂性\n回报递减率\n\n静态测试\n静态测试不实际运行软件，主要是对软件的编程格式、结构等方面进行评估。\n静态测试包括代码检查、静态结构分析、代码质量度量等。它可以由人工进行，也可以借助软件工具自动进行。\n静态方法常常称为“分析”，静态测试是对被测程序进行特性分析方法的总称。\n静态测试可以完成以下工作：\n\n\n发现下列程序的错误\n错用局部变量和全局变量；未定义的变量、不匹配的参数；不适当的循环嵌套或分支嵌套、死循环、不允许的递归；调用不存 在的子程序，遗漏标号或代码。\n\n\n找出以下问题的根源\n从未使用过的变量；不会执行到的代码、从未使用过的标号；潜在的死循环。\n\n\n提供程序缺陷的间接信息\n所用变量和常量的交叉应用表；是否违背编码规则；标识符的使用方法和过程的调用层次。\n\n\n为进一步查找做好准备\n\n\n选择测试用例\n\n\n进行符号测试\n\n\n代码检查\n代码检查包括代码走查、桌面检查、代码审查等，主要检查代码和设计的一致性，代码对标准的遵循、可读性，代码的逻辑表达的正确性，代码结构的合理性等方面。\n静态结构分析\n静态结构分析主要是以图形的方式表现程序的内部结构。\n代码质量度量\n软件质量包括六个方面：功能性、可靠性、易用性、效率、可维护性、可移植性\n针对软件的可维护性，目前主要存在三种度量参数：\n\nLine复杂度：以代码的行数作为计算的基准。\nHalstead复杂度：以程序中使用到的运算符与运算元数量作为计数目标，然后可以据以计算出程序容量、工作量等。\nMcCabe复杂度：一般称为圈复杂度，它将软件的流程图转化为有向图，然后以图论来衡量软件的质量。\n\n\n动态测试\n主要特征：计算机必须真正运行被测试的程序，通过输入测试用例，对其运行情况即输入与输出的对应关系进行分析，以达到检测的目的。\n动态测试包括：功能确认与接口测试、覆盖率分析、性能分析、内存分析\n黑盒测试\n黑盒测试又称为功能测试、数据驱动测试和基于规格说明的测试。它是一种从用户观点出发的测试，一般被用来确认软件功能的正确性和可操作性。\n黑盒测试是在程序接口进行测试，它只是检查程序功能是否按照规格说明书的规定正常使用，也被称为用户测试。\n特点：\n\n与软件的具体实现过程无关，在软件实现的过程发生变化时，测试用例仍然可以使用。\n用例的设计可以和软件实现同时进行，这样能够压缩总的开发时间。\n\n黑盒测试的具体技术方法：\n\n边界值分析法\n等价类划分法\n因果图法\n决策表法\n\n白盒测试\n白盒测试又称为结构测试、逻辑驱动测试或基于程序的测试，一般用来分析程序的内部结构。\n白盒测试需要完全了解程序结构和处理过程，它按照程序内部逻辑测试程序，检验程序中每条通路是否按预定要求正确工作，也被称为程序员测试。\n单元测试\n单元测试的辅助模块：\n\n\n驱动模块(Drive)\n用来模拟被测试模块的上一级模块，相当于被测模块的主程序。它接收数据，将相关数据传送给被测模块，启动被测模块，并打印出相应的结果。\n\n\n桩模块(Stub)\n用来模拟被测模块工作过程中所调用的模块。它们一般只进行很少的数据处理。\n\n\n被测模块、驱动模块和桩模块共同构成了一个如下图所示的单元测试的测试环境\n\n集成测试\n集成测试的整个过程由4个步骤完成：\n\n主控模块作为测试驱动器。\n根据集成的方式（深度或广度），下层的桩模块一次一次地被替换为真正的模块。\n在每个模块被集成时，都必须进行单元测试。\n重复第2步，直到整个系统被测试完成。\n\n\n\n非增量式测试\n采用一步到位的方法来构造测试，对所有模块进行个别的单元测试后，按照程序结构图将各模块连接起来，把连接后的程序当作一个整体进行测试。\n缺点：当一次集成的模块较多时，非增量式测试容易出现混乱，因为测试时可能发现了许多故障，在修正一个故障的同时，可能又引入了新的故障，很难判定出错的具体原因和位置。\n\n\n增量式测试\n增量式测试的集成是逐步实现的。逐次将未曾集成测试的模块和已经集成测试的模块结合成程序包，再将这些模块集成为较大系统，在集成的过程中边连接边测试，以发现连接过程中产生的问题。\n按照不同的实施次序可以分为三种不同的方法：\n\n\n自顶向下增量式测试\n模块集成的顺序是首先集成主程序，然后依照控制层次结构向下进行集成。从属于主程序的按深度优先方式或者广度优先方式集成到结构中去。\n深度优先方式的集成：首先集成在结构中的一个主控路径下的所有模块，主控路径的选择是任意的。\n广度优先方式的集成：首先沿着水平方向，把每一层中所有直接隶属于上一层的模块集成起来，直到底层。\n优点：可以自然的做到逐步求精，一开始就能让测试者看到系统的框架。\n缺点：需要提供桩模块。\n\n\n自底向上增量式测试\n程序模块结构的最底层模块开始集成和测试。\n优点：生成测试数据简单。\n缺点：直到最后一个模块被加进去之后才能看到整个程序的框架。\n\n\n混合增量式测试\n把自顶向下测试和自底向上测试这两种方式结合起来进行集成和测试。这样可以兼具两者的优点，而摒弃其缺点。\n\n\n\n\n回归测试\n用来保证（由于测试或其他原因的）改动不会带来不可预料的行为或另外的错误。\n\n\n增量式测试要比非增量式测试具有一定的优越性。\n确认测试\n确认测试也称为合格性测试，是检验所开发的软件是否能按用户提出的要求进行。软件确认要通过一系列证明软件功能和要求一致的黑盒测试来完成。\n系统测试\n由于软件只是计算机系统中的一个组成部分，软件开发完成之后，最终还要和系统中的硬件系统、某些支持软件、数据信息等其他部分配套运行。因此，在投入运行前要完成系统测试，以保证各组成部分不仅能单独的得到检验，而且在系统各部分协调工作的环境下也能正常工作。\n恢复测试\n恢复测试是通过各种手段，强制性地使软件出错，使其不能正常工作，进而检验系统的恢复能力。\n安全测试\n安全测试的目的在于验证安装在系统内的保护机制能否在实际中保护系统且不受非法入侵，不受各种非法干扰。\n强度测试\n强度测试（压力测试）的目的是要检测非正常的情形，测试是想要破坏程序。\n性能测试\n性能测试用来测试软件在系统集成中的运行性能，特别是针对实时系统和嵌入式系统，仅提供符合功能需求但不符合性能需求的软件是不能被接受的。\n正确性测试\n正确性测试检查软件的功能是否符合规格说明。\n可靠性测试\n可靠性测试是从验证的角度出发 ，检验系统的可靠性是否达到预期的目标，同时给出当前系统可能的可靠性增长情况。\n兼容性测试\n软件兼容性测试是检测各软件之间能否正确地交互和共享信息，其目标是保证软件按照用户期望的方式进行交互，使用其它软件检查软件操作的过程。\n黑盒测试\n黑盒测试被称为功能测试或数据驱动测试。在测试时，把被测程序视为一个不能打开的黑盒子，在完全不考虑程序内部结构和内部特性的情况下进行。\n黑盒测试的目的主要是在已知软件产品所应具有的功能的基础上，进行：\n\n检查程序功能能否按需求规格说明书的规定正常使用，测试各个功能是否有遗漏，检测性能等特性要求是否满足。\n检测人机交互是否错误，检测数据结构或外部数据库访问是否错误，程序是否能适当地接收输入数据而产生正确的输出结果，并保持外部信息（如数据库或文件）的完整性。\n检测程序初始化和终止方面的错误。\n\n等价类划分法\n等价类划分法是一种重要的、常用的黑盒测试方法，它将不能穷举的测试过程进行合理分类，从而保证设计出来的测试用例具有完整性和代表性。\n等价类划分法是把所有可能的输入数据，即程序的输入域划分为若干部分（子集），然后从每一个子集中选取少数具有代表性的数据作为测试用例。\n等价类是指某个输入域的子集合。在该子集合中，各个输入数据对于揭露程序中的错误都是等效的，它们具有等价特性，即每一类的代表性数据在测试中的作用都等价于这一类中的其它数据。\n采用等价类划分法设计测试用例通常分两步进行：\n\n确定等价类，列出等价类表。\n确定测试用例。\n\n划分等价类可分为两种情况：\n\n有效等价类：指对软件规格说明而言，是有意义的、合理的输入数据所组成的集合。\n无效等价类：指对软件规格说明而言，是无意义的、不合理的输入数据所构成的集合。\n\n等价类划分的依据：\n\n按照区间划分\n按照数值划分\n按照数值集合划分\n按照限制条件或规则划分\n细分等价类\n\n在设计测试用例时，应同时考虑有效等价类和无效等价类测试用例的设计。\n针对是否对无效数据进行测试，可以将等价类测试分为\n\n标准等价类测试：不考虑无效数据值，测试用例使用每个等价类中的一个值。\n健壮等价类测试：主要的出发点是考虑了无效等价类。对有效输入，测试用例从每个有效等价类中取一个值；对无效输入，一个测试用例有一个无效值，其他值均取有效值。\n\n边界值分析法\n边界值分析法是对输入或输出的边界值进行测试的一种黑盒测试方法。\n通常边界值分析法是作为对等价类划分法的补充，这种情况下，其测试用例来自于等价类的边界。\n边界值分析法设计测试用例步骤：\n\n首先确定边界情况。\n选取正好等于、刚刚大于或刚刚小于边界的值作为测试数据。\n\n在测试用例设计过程中，某些边界值条件是不需要呈现给用户的，或者说用户是很难注意到的，但同时确实属于检验范畴内的边界条件，称为内部边界值条件或子边界值条件。\n在实际的测试用例设计中，需要将基本的软件设计要求和程序定义的要求结合起来，即结合基本边界值条件和内部边界值条件来设计有效的测试用例。\n采用边界值分析测试的基本思想是：故障往往出现在输入变量的边界值附近。\n边界值分析法是基于可靠性理论中称为“单故障”的假设，即有两个或两个以上故障同时出现而导致软件失效的情况很少，也就是说，软件失效基本上是由单故障引起的。\n\n有二元函数f(x,y)，其中x∈[1,12]，y∈[1,31]。\n则采用边界值分析法设计的测试用例是：{ &lt;1,15&gt;, &lt;2,15&gt;, &lt;11,15&gt;, &lt;12,15&gt;, &lt;6,15&gt;, &lt;6,1&gt;, &lt;6,2&gt;, &lt;6,30&gt;, &lt;6,31&gt; }\n\n对于一个含有n个变量的程序，采用边界值分析法测试程序会产生4n+1个测试用例。\n\n健壮性测试是作为边界值分析的一个简单的扩充，它除了对变量的5个边界值分析取值外，还需要增加一个略大于最大值以及略小于最小值的取值，检查超过极限值时系统的情况。因此，对于有n个变量的函数采用健壮性测试需要6n+1个测试用例。\n\n因果图法\n等价类划分法和边界值分析方法都是着重考虑输入条件，但没有考虑输入条件的各种组合、输入条件之间的相互制约关系。这样虽然各种输入条件可能出错的情况已经测试到了，但多个输入条件组合起来可能出错的情况却被忽视了。\n因此必须采用一种适合于描述多种条件的组合、相应产生多个动作的形式来进行测试用例的设计，这就需要利用因果图（逻辑模型）。\n因果图法：一种利用图解法分析输入的各种组合情况，从而设计测试用例的方法。\n因果图法设计测试用例的步骤：\n\n画出因果图\n因果图转换为判定表\n为判定表中每一列的情况设计一个测试用例。\n\n因果图法的优点：\n\n考虑到了输入情况的各种组合以及各个输入情况之间的相互制约关系。\n能够帮助测试人员按照一定的步骤，高效率的开发测试用例。\n因果图法是将自然语言规格说明转化成形式语言规格说明的一种严格的方法，避免不完整性和二义性。\n\n\n图中的左结点ci表示输入状态（或称原因），右结点ei表示输出状态（或称结果）。\nci与ei取值0或1，0表示某状态不出现，1则表示某状态出现。\n因果图中的约束：在实际问题中输入状态相互之间、输出状态相互之间可能存在某些依赖关系，称为“约束”。\n对于输入条件的约束有E、I、O、R四种约束，对于输出条件的约束只有M约束。\n\nE约束(异)：a和b中最多有一个可能为1，即a和b不能同时为1。\nI约束(或)：a、b、c中至少有一个必须为1，即a、b、c不能同时为0。\nO约束(唯一)：a和b必须有一个且仅有一个为1。\nR约束(要求)：a是1时，b必须是1，即a为1时，b不能为0。\nM约束(强制)：若结果a为1，则结果b强制为0。\n\n\n因果图生成测试用例的基本步骤如下：\n\n分析软件规格说明中哪些是原因（即输入条件或输入条件的等价类），哪些是结果（即输出条件），并给每个原因和结果赋予一个标识符。\n分析软件规格说明中的语义，找出原因与结果之间、原因与原因之间对应的关系，根据这些关系画出因果图。\n在因果图上用一些记号表明约束或限制条件。\n把因果图转换为决策表。\n根据决策表中的每一列设计测试用例。\n\n决策表法\n条件桩：列出了问题的所有条件。\n动作桩：列出了问题规定可能采取的操作。\n条件项：列出针对它所列条件的取值，在所有可能情况下的真假值。\n动作项：列出在条件项的各种取值情况下应该采取的动作。\n规则：由动作项和条件项组成。\n决策表的建立步骤：\n\n列出所有的条件桩和动作桩；\n填入条件项；\n填入动作项，制定初始判定表；\n简化；合并相似规则或者相同动作。\n\n决策表测试仅适合对输入域展开分析，不适合对输出域展开测试。\n\n错误推测法\n错误推测法凭借的是测试人员的直觉和经验来推测系统中可能出现的各种缺陷。\n常常是列举出系统中所有可能的缺陷和容易发生缺陷的特殊情况，以此来设计测试用例。\n优点：充分发挥个人的经验和潜能，命中率高。\n缺点：覆盖率难以保证；过多的依赖于个人的经验。\n白盒测试\n白盒测试也称结构测试或逻辑驱动测试，是针对被测单元内部是如何进行工作的测试。\n根据程序的控制结构设计测试用例，主要用于软件或程序验证。\n白盒测试法检查程序内部逻辑结构，对所有逻辑路径进行测试，是一种穷举路径的测试方法。\n即使每条路径都测试过了，仍然可能存在错误。因为：\n\n穷举路径测试无法检查出程序本身是否违反了设计规范，即程序是否是一个错误的程序。\n穷举路径测试不可能查出程序因遗漏路径而出错。\n穷举路径测试发现不了一些与数据相关的错误。\n\n白盒测试方法原则：\n\n保证一个模块中的所有独立路径至少被测试一次。\n所有逻辑值均需测试真和假两种情况。\n检查程序的内部数据结构，保证其结构的有效性。\n在上下边界及可操作范围内运行所有循环。\n\n白盒测试常用测试用例设计方法有：逻辑覆盖法（逻辑驱动测试）、基本路径测试方法\n基本概念\n控制流图\n控制流图（简称流图）是对程序流程图进行简化后得到的，它可以更加突出的表示程序控制流的结构。\n控制流图中包括两种图形符号：\n\n\n节点\n由带标号的圆圈表示，可代表一个或多个语句、一个处理框序列和一个条件判定框。\n表示一个或多个无分支的语句或源程序语句。\n\n\n控制流线\n由带箭头的弧或线表示，可称为边。它代表程序中的控制流。\n\n\n\n\n环形复杂度\n环形复杂度也称为圈复杂度，它是一种为程序逻辑复杂度提供定量尺度的软件度量。\n给定控制流图G的环形复杂度V(G)，计算方法有：\n\n\nV(G) = E-N+2​\nE是控制流图中边的数量，N是控制流图中的节点数量\n\n\nV(G) =P+1​\nP是控制流图G中判定节点的数量\n\n\n覆盖测试\n测试覆盖率\n用于确定测试所执行到的覆盖项的百分比。其中的覆盖项是指作为测试基础的一个入口或属性，比如语句、分支、条件等。\n测试覆盖率包括\n\n功能点覆盖率：用于表示软件已经实现的功能与软件需要实现的功能之间的比例关系。\n结构覆盖率：包括语句覆盖率、分支覆盖率、循环覆盖率、路径覆盖率等。\n\n逻辑覆盖法\n根据覆盖目标的不同，逻辑覆盖可分为：\n\n语句覆盖：使程序中的每个可执行语句至少执行一次。\n判定覆盖：使程序中的每个判定至少都获得一次“真”值和“假”值。\n条件覆盖：使程序中每个判定包含的每个条件的可能取值（真/假）都至少满足一次。\n判定/条件覆盖：使程序中每个判定包含的每个条件的所有情况（真/假）至少出现一次，并且每个判定本身的判定结果（真/假）也至少出现一次。\n组合覆盖：使程序中每个判定的所有可能的条件取值组合都至少出现一次。\n路径覆盖：覆盖程序中所有可能的路径。\n\n\n路径测试\n路径测试就是从一个程序的入口开始，执行所经历的各个语句的完整过程。\n独立路径是指从程序的入口到出口的多次执行中，每次至少有一个语句是新的，未被重复的，也即每次至少要经历一条从未走过的弧。\n为 了满足路径覆盖，必须首先确定具体的路径以及路径的个数。通常采用控制流图的边序列和节点序列表示某一条具体路径。\n表示方法：\n\nab，表明路径是先经历弧a，接着再经历弧b，弧a和弧b是先后相接的。\na+b，表明两条弧是“或”的关系，是并行的路段。\n\n路径数的计算：将所有弧均以数值1来代替，再进行表达式的相乘和相加运算，最后得到的数值即为该程序的路径数。\n基本路径测试方法\n在不能做到所有路径覆盖的前提下，如果某一程序的每一个独立路径都被测试过，那么可以认为程序中的每个语句都已经检验过了，即达到了语句覆盖。\n基本路径测试方法步骤：\n\n画出程序的控制流图\n计算程序的环形复杂度\n导出独立路径\n设计测试用例\n\n最少测试用例数计算\n"},"阅读/中国是部金融史":{"title":"中国是部金融史","links":[],"tags":[],"content":"\n\n                  \n                  中国是部金融史 \n                  \n                \n\n\n\n《中国是部金融史》-  陈雨露 杨忠恕\n出版时间： 2013-03-01 00:00:00\nISBN： 9787550212527\nPC地址：weread.qq.com/web/reader/5a0329a05593f05a0dce61c\n\n\n\n管仲的刀\n\n反动势力之所以被称为反动势力，不是因为反动，而是因为有势力。既然有势力，又怎么可能被你革掉？打倒旧势力，想兵不血刃，那是不可能的。改革的真谛就在于对立双方的妥协，妥协不是投降，而是在损失最小的情况下寻找前进的路径。\n⏱ 2023-12-10 02:53:55\n\n\n封建统治者给予人们利益的时候，一定要显示出来；夺取人民利益的时候，千万不能暴露，所谓“见予之形，不见夺之理”。\n⏱ 2023-12-10 02:58:33\n\n\n“衡山之谋”说穿了其实很简单，以高价诱使敌方放弃本业，追求某种产业的畸形利润，最终造成敌人经济瘫痪。在任何时代，一种商品价格暴涨都会带来巨额利润。这种利润高得让人炫目，除非这种利润来自垄断性技术，否则是一定会出事的。高利润会吸引相当一批人冲进去，这批人往往还是能率先看到商机的精英。等到一个国家几乎全民干一件事情的时候，暴利就要终结了。道理很简单，不可能让所有的人都赚钱。\n⏱ 2023-12-10 03:01:28\n\n大秦无货币\n\n权力只对来源负责，这是一个亘古不变的真理。\n⏱ 2023-12-11 00:22:34\n\n通货紧缩是好事吗\n\n封建皇权的灭亡，不可能从最坏开始，更不可能在最坏的时候发生。恰恰相反，一个王朝的覆灭，往往是从试图逐渐变好开始。\n⏱ 2023-12-11 01:53:27\n\n小结：财富的循环\n\n在某一个时点上社会财富的总量必然是有限的，必须留出让全社会人继续生存的财富，也就是马克思所谓的“必要劳动时间”：社会最底层必须能维持自身和家庭的生存。\n⏱ 2023-12-12 00:39:32\n\n\n整个循环的逻辑是：帝国抢占富人产业→富人把小农从土地上挤走→封建官商又从土地上挤出了富人→富人中的强者成为黑势力→小农成为流民……最终结果：国弱、民贫，唯独官富。皇权一旦使所有社会资源都匍匐在自己脚下，封建官僚就会在瞬间吸干帝国的经济血液，无论皇帝、黑势力还是黎民百姓，都没有力量遏制这头怪兽。\n⏱ 2023-12-12 00:40:07\n\n无官的世界\n\n汉光武帝、汉明帝、汉章帝三代，前后六十四年，物价稳定，每石粮食的价格只有二十钱，已经低于西汉“文景之治”的水平。然而，货币最好的投向却不再是土地，这是一个崭新的时代，人们有了更为赚钱的陶瓷业、造船业、畜牧业……\n⏱ 2023-12-12 16:38:24\n\n小结：盛衰小农一钱间\n\n小农家庭衡量剥削残酷与否的标准根本不是被拿走多少，而是还剩余多少。\n⏱ 2023-12-13 15:18:49\n\n炫富的下场\n\n其实，财富从来都没有罪恶。这个世界上若没有富人，又怎么会有创造财富的动力？西晋社会最恶劣的逻辑是：在晋代士族高门的把持下，绝大部分人不但没有财富，甚至无论如何辛勤劳动都不能获得财富，所以，炫富才会显得如此刺目。\n⏱ 2023-12-15 01:24:01\n\n全民高利贷\n\n货币只是财富的一种符号，并不是真正的财富，高利贷所有的作用只是转移财富，而不是创造财富。\n⏱ 2023-12-17 02:01:21\n\n壮哉盛隋\n\n天下人生产财富的动力是获得财富，一个成功的财富生产分配制度，必须平衡所有集团利益，必须遏制掠夺之手，不能让一个人、一小撮人独占天下之利，更不能让人们劳而无获。\n⏱ 2023-12-20 00:07:29\n\n金简除罪\n\n乱世之中，所有财富、所有规则、所有人才都毁于一旦，而社会进步最终必须以财富积累为基础，“乱世—盛世”循环只能在大乱之后满足人类最基本的生存需要。所以，千万不要以为乱世是盛世之源。\n⏱ 2024-01-04 01:27:37\n\n官无事，民自富\n\n公共选择理论认为，如果一个企业可以获得财政的无偿拨款，那么这个企业就不会关心生产，从堂官到胥吏，大家只关心自己如何捞钱。久而久之，这样的企业必将损害社会利益。公共选择理论还认为，如果一个企业依靠政府的强制力排除任何人染指自己的行业，那么，这个企业就会把掠夺的触角伸向社会每一个角落——这个企业不但会损害社会财富增量，还会侵蚀社会财富存量。如果一个企业存在的基础是强制性公权力，那么这个企业就是公权力伸向社会财富的触角。\n⏱ 2024-01-04 01:32:35\n\n钱味甘，大热有毒\n\n不是所有的竞争都一定提高生产效率，不是所有的竞争都一定会提高社会公众福利，更不是所有市场选择的结果都一定是好的！在这个世界上，除了“竞争”(compete)还有“竞次”(race to the bottom)，“竞争”是比谁更优秀，“竞次”是比谁更下贱、谁脸皮更厚、谁心更黑！“竞争”和“竞次”也是有相同点的，那就是，两者都把市场作为工具，都通过市场实现利益分配和再分配。所有社会都存在市场，市场也都有“竞次”特征，只不过封建社会时的表现更为突出。马克思在描述资本主义社会的时候提出，资本家对劳动力的剥削是有底线的：维持劳动力再生产，工人工资要足以维持自身和家庭生存。封建社会不存在这条底线，失去土地的流民只能压低自身劳动力的价格，甚至被迫损害生命，结果还是不能获得维持自身和家庭生存的资源。人们竞相出卖自己，微薄的收入最后一定会突破马克思所谓的“剥削底线”，不要说购买土地，就连自己和家人的生存都难以为继。最后，人们只能卖身为奴，让自己从封建社会直接倒退回奴隶社会。所以，我们才在史籍中一次次见到“父子携手，共入江湖”的描写。故曰“竞次”！\n⏱ 2024-01-04 01:56:44\n\n增发货币的两种方法\n\n现代财政学有个名词叫作“转移支付”，就是国家把征收上来的税款重新分配给社会各个阶层，是现代国家调节贫富差距的重要手段。增发货币也是一种调节贫富差距的方法，力度远比“转移支付”狠：“转移支付”还得先收税，然后才能转移，增发货币却可以直接改变一个阶层的贫富状态。现代增发货币的方法很多，有“央行再贷款”、“发行央行专项票据”、“降低存款准备金”、“放松信贷”、“降息”……跟封建社会比，这些名称虽然令人眼花缭乱，其实本质从来没有变——增加流通中的货币。\n⏱ 2024-01-04 02:42:14\n\n《李娃传》中的金融故事\n\n《李娃传》之所以重要，是因为它揭示了一个盛世必备的重要特征：贫贱者可因奋斗而富贵，富贵者亦可因浪荡而贫贱，整个社会阶层上下之间是可以自由流动的。\n⏱ 2024-01-04 02:51:06\n\n小结：魔道相争胜者谁\n\n人们往往认为，“小农经济”是一种自给自足的生产状态，老死不相往来，“你耕田来我织布，你挑水来我浇园”的生产生活，能缔造一个鲁滨逊式的世外桃源吗？答：绝无可能。衡量一个经济体能否自给自足最关键的标志，是经济体内生产和消费的产品数量是否一致。只要经济体内有货币存在，就绝无可能出现真正自我封闭的经济循环，真正的小农经济体根本无法孕育如此丰富的货币制度，更不要说西汉的“子钱家”、唐朝的高利贷。中原大地自古就是一块市场经济最发达的土地，甚至远比中世纪的西欧要发达。\n⏱ 2024-01-04 03:00:22\n"},"阅读/人民公开课：中国共产党与国家治理体系和治理能力现代化":{"title":"人民公开课：中国共产党与国家治理体系和治理能力现代化","links":[],"tags":[],"content":"\n\n                  \n                  人民公开课：中国共产党与国家治理体系和治理能力现代化 \n                  \n                \n\n\n\n《人民公开课：中国共产党与国家治理体系和治理能力现代化》-  “名家领读经典”课题组\n出版时间： 2017-07-01 00:00:00\nISBN： 9787213081194\nPC地址：weread.qq.com/web/reader/dd1320307170dcf7dd1adf3\n\n\n\n我劝天公重抖擞\n国家演进，一般都是从小到大，从分到合，从孤立分散到多元一体，大一统代表复杂社会，高层次管理，以及世界主义。\n\n⏱ 2024-12-15 01:09:31\n\n\n西方传统，政府不太灵光，君主不太灵光。他们革命，先借君权反教权，后借民主反君权，主要是为市民社会（商业社会）开道。结果，君权也没反彻底，教权也没反彻底。\n\n⏱ 2024-12-15 01:10:16\n\n\n他们最服两样管，一是上帝，二是金钱。现在，上帝就是金钱，金钱就是上帝。除了这两样，谁都管不着，这就叫自由。\n\n⏱ 2024-12-15 01:10:31\n\n\n欧洲的自治传统也影响到马克思。马克思，早期主要是同无政府主义作战，施蒂纳讲“唯一者”，有点像存在主义，也被他批判。但就连他也有欧洲文化的烙印。比如他说，共产主义是自由人的联合体。\n\n⏱ 2024-12-15 01:12:05\n\n\n我认为，中国传统，最大特点是国家大一统，宗教多元化，世俗性强。中国文化的最大优点是不立教，不传教，人文精神强。\n\n⏱ 2024-12-15 02:19:25\n\n\n历代治理之得失\n要批判地总结中国历史上治理体系和治理能力的经验与教训，而不是“以儒代马”，更不是把中国传统文化国学化、宗教化、商品化、庸俗化、“心灵鸡汤化”。\n\n⏱ 2024-12-16 00:58:49\n\n\n马克思主义是西方哲学社会科学的高峰，讲马克思主义，不能脱离西方文明的背景。西方文明是历史发展着的。我认为它有四个鲜明的特征：第一，重军事实力，这是受希腊和罗马文化的影响。第二，重法律，这是受中世纪教会统治的影响。第三，重劳动，这是文艺复兴以来科学文化发展带来的影响。第四，重资本，对资本这个概念，马克思的研究最为深刻。\n\n⏱ 2024-12-16 00:59:16\n\n\n希腊城邦制大体是个什么制度呢？与其说是雅典的制度，还不如说是斯巴达体制更妥当些，说白了，它实质上就是个军事制度。而罗马帝国继承的，主要是这个制度。\n\n⏱ 2024-12-16 01:00:58\n\n\n关于宗教，马克思有两句话，第一句很著名，即宗教是麻醉人民的鸦片；另一句不著名，但更深刻，即宗教的根源是形而上学。\n\n⏱ 2024-12-16 01:02:06\n\n\n古希腊和传统中国都有科学思想，但这种科学思想的基础不是劳动技术。这种科学思想不是以劳动者为主体的思想，不是一种实践学说，没有有效地推动生产力的发展。科学思想不是必然就能够转化为生产力的，仅凭发表科学论文，并不意味着你是科技强国。\n\n⏱ 2024-12-16 01:03:34\n\n\n文艺复兴之所以是个转变，就是因为它使“劳动”成为西方文化的核心。劳动是知识的来源，劳动创造世界，劳动创造产权，这是洛克在《政府论》里的论述。私有产权是人类不平等的起源，这是卢梭在《论人类不平等的起源和基础》里说的。\n\n⏱ 2024-12-16 01:05:36\n\n\n马克思没有简单地反对资本。他主张资本为劳动服务，他反对的是资本主义，即少数人垄断社会信用机制的那样一种形式。\n\n⏱ 2024-12-16 01:06:03\n\n\n西方推崇宗教，有漫长的教会统治，导致的一个最特殊的结果是：教会代表法律，法律是上帝制定的，所以，西方就有“法律超越政治”、“法比国大”的说法。\n\n⏱ 2024-12-16 02:31:03\n\n\n文艺复兴以来，西方的现代文化是由劳动者创造的，意大利的工匠、法国的小农、英国的小业主、荷兰的买卖人，创造了现代西欧文化，而他们共同的敌人是资本家，也就是那些靠放债剥削他们劳动的人，那些垄断了社会信用机制的人。所以，劳动与资本的矛盾是现代矛盾的根源。这一套说法产生在欧洲是很自然的。而劳动者当家作主的思想，如果不是由马克思提出来，在欧洲也会有别人提出来，尽管论述得不一定像马克思那样深刻犀利、博大精深。社会主义思想，在西欧根深蒂固，现在的欧盟，即使不打社会主义和劳动者当家作主的旗号，他们也不会歧视农民、工人和做小买卖的人。但工会、农会、商会势力强大，这些都是马克思主义诞生之后才有的。\n\n⏱ 2024-12-16 02:32:05\n\n\n士大夫和读书人是官僚的后备军，腐败的根源就是官僚主义，因此，反腐一旦触及官僚主义及其后备军——读书人的精英意识，那就等于得罪了天下的“清流”。\n\n⏱ 2024-12-16 02:34:45\n\n\n我们自信我们走在正确的道路上，既是说我们能够分清历史中好的东西与坏的东西，也是说我们能够不断改掉自己传统中坏的东西，不断发扬好的东西。\n\n⏱ 2024-12-16 02:35:36\n\n\n每个时代有每个时代的问题，每一代的学问，都是为了回应时代的问题。\n\n⏱ 2024-12-16 02:35:44\n\n\n纪律检查、中央巡视、权力监督，秦始皇时代就有了。\n\n⏱ 2024-12-16 02:36:57\n\n\n法家所说的法，不是上帝之法，不是柏拉图和黑格尔的法哲学。法家说的法，就是国法。法的基础，就是国家政治，没有抽象的、脱离国家政治的法律。\n\n⏱ 2024-12-16 02:37:01\n\n\n孔子的学说，固然有很多的道理，但孔子的思想，维护的是以血缘伦理为基础的氏族政治。他以为处理好了亲戚朋友关系，就是处理好了国家政治关系。\n\n⏱ 2024-12-16 02:38:08\n\n\n先秦之儒，不过是家族学说。而两汉之儒，则为国家政治、经济、司法学说。两者不可同日而语。\n\n⏱ 2024-12-16 02:42:47\n\n\n发展企业与商业，这不是不对，但关键在于发展成果落在谁的手上\n\n⏱ 2024-12-16 02:43:41\n\n\n唐初的执政者，实际上是两大贵族集团：一个是关陇军事贵族集团，靠的是军功；一个是郡望大姓，靠的是门第。如果在此两者之间再加一个，那就是沙门贵族集团，即佛教势力。\n\n⏱ 2024-12-16 10:43:13\n\n\n唐代继承了隋朝科举选人的制度。但是，我们必须记住，科举制并不是唐朝唯一的选官制度。唐朝主要有三种选官制度，科举制度最不重要，重要的乃是门荫入仕和杂色入流。所谓门荫入仕，是指一定品级的亲贵高官的子孙，可根据父、祖辈官爵的高低（但需经过考试后）被授予不同官阶的官职。而杂色入流，则指各级官府的胥吏（由汉代的文吏演化而来）升到一定级别并考试合格后，可到吏部参加铨选，考试合格后可获得“官”的资格。\n\n⏱ 2024-12-16 10:45:41\n\n\n毛主席喜欢柳宗元，喜欢他的《封建论》。他认为：一是中央不能出“修正主义”，地方不能搞分裂。二是经济要发展，但经济发展的成果不能落到既得利益集团手中。这是两大历史经验教训。\n\n⏱ 2024-12-16 10:48:01\n\n\n宋代彻底消灭了唐的贵族官制，官员依靠国家俸禄，没有造反的物质基础。科举所考，均是课试文章，与治国理政没有关系，选拔出来的规矩人，根本没有造反的能力。\n\n⏱ 2024-12-16 10:49:49\n\n\n科举考出的官员，大多数是书呆子，这些官员在一个地方待一阵，不犯错误就调走了，而胥吏则久居地方，掌握地方事务。所以，表面上看是无人负责、无人治理，实际上，地方上是胥吏包办、胥吏治理。\n\n⏱ 2024-12-16 10:50:48\n\n\n宋代的一种制度悖论，便是叶适所谓的“官无封建而吏有封建”。\n\n⏱ 2024-12-16 10:50:57\n\n\n“国学”这个东西，便是宋代搞出来的，它起初的名字叫“道学”。宋学终结了汉学，宋儒终结了汉儒，其实所终结的，是汉儒治国理政的思想，即以“华夏不治夷狄”，反对“大一统”，以道学的空谈，以所谓“君子不器”，排斥治国理政的学说。自从道学产生之后，中国的儒家思想就逐渐丧失了战斗力，变成了像老庄学说那样的玄谈与空想。道学更提出了一套自然法。这个自然法，就是三纲五常。所谓“心即理”，就是养成一颗尊君、崇父、从夫的心，说白了，便是一颗当奴才的心，而至于“民心”何在，他们从来就不去关心，更懒得过问。\n\n⏱ 2024-12-16 10:52:17\n\n\n明代的一切治理政策中，最为错误，对后世影响最大的就是一条鞭法的实行。\n\n⏱ 2024-12-16 10:54:32\n\n\n但是，到了东汉时代，汉人一般不愿当兵，也不能当兵，兵源多依赖外族，所谓“五胡乱华”之根源，因此早就种下。\n\n⏱ 2024-12-16 10:57:00\n\n\n没有人民的军队，就没有人民的一切。枪杆子里面出政权，这是一切道理中最基本的硬道理。\n\n⏱ 2024-12-16 10:57:31\n\n\n中国数千年来，何以不能解决国家组织能力问题？这里的要害就在于，无论是儒家的士大夫精英政治，还是法家的官僚政治，均不能面对中国治理体系之根本缺陷，即如何从根本上调动人民的积极性。从皇帝到基层，层层复杂的治理结构，不过是以官治官，乃至以胥吏为官，而如果不靠人民积极地有所作为，也就不能充分发挥组织能力。几千年来，人民逃避剥削压迫，其实质就是逃避政治、逃避组织、逃避国家。其消极方式表现为逃避赋税、消极怠工，而积极方式便表现为造反起义、落草为寇。\n\n⏱ 2024-12-16 10:57:54\n\n\n统一与分裂\n概括而言，历代都面临着一个如何处理既得利益阶层的问题，这个问题处理不好，就会造成封建。\n\n⏱ 2024-12-16 11:37:15\n\n\n盛唐时期，府兵制逐渐瓦解，朝廷开始实行募兵制。募兵制发展的一个恶性结果是形成了藩镇割据的局面。\n\n⏱ 2024-12-16 17:40:05\n\n\n改革是要付出血的代价的，一旦既得利益集团形成，打破它很难。\n\n⏱ 2024-12-16 17:45:36\n\n\n柳宗元《封建论》中的历史观，与传统上占主流的历史循环论，或者历史倒退论完全不同。他认为历史是一个不断前进的发展过程，而且这一过程是客观的，是不以任何人尤其是圣人的意志为转移的。因为中国古代的士大夫，包括很多思想家、哲学家，都会把古代的一些制度看作是圣人的想法，是圣人的意志，即“圣人意”的体现。而柳宗元则不同意这种看法，他认为社会的发展、制度的变迁，是一个客观发展的历史过程，不受任何人，尤其是圣人的主观意志所主宰。柳宗元的这种历史观，又是建立在他带有唯物论色彩的自然观的基础之上。\n\n⏱ 2024-12-16 17:46:58\n\n\n政权的合法性在于维护人民的安全。\n\n⏱ 2024-12-16 17:47:45\n\n\n其次，柳宗元在论述国家之乱与封建、郡县之关系时，是将“政”与“制”，也即政治与制度这两个截然不同的范畴划分开来了。制度的优越性，本来就是要靠人来贯彻实现的。如果制度不行，即便贯彻实现它的人再贤能，也不会有好的效果；如果制度很好，实现它的人不好，当然也不会体现出它的优越性来。\n\n⏱ 2024-12-16 17:49:06\n\n\n因循与创新\n当我们说到历史的长时段的时候，我们其实经常会碰到两个关键词：一个关键词是“延续”，另一个关键词就是“变迁”。也就是说，历史一步一步地走来，都是由延续和变迁这两者相互作用的，一方面是相辅相成，另一方面也相互冲突、相互摩擦。\n\n⏱ 2024-12-18 02:37:24\n\n\n我们通常有一种很单纯的观念，觉得制度都是好的，制度是客观的、中立的，但人事可能有不同的利益选择。人事影响到制度的时候，这个制度就会发生扭曲。我们从历史上来看，应该说，没有任何一个制度是能摆脱人事的。所有的制度在它建立、设计的时候，一定就是保护一些人的利益，而限制一些人的利益的。所以，制度在它产生的时候，必定就是跟人事相关的。在它的执行过程中，实际上也是跟人事分不开的。\n\n⏱ 2024-12-18 02:44:39\n\n\n就是我们在看一个制度运作时，不仅要看书面的规定，也要看到这个制度在现实中究竟是怎么运作的。\n\n⏱ 2024-12-18 02:57:28\n\n\n从制度文化的层面来看，制度所产生的实际效应，不光是和制定者、施行者有关的，也是和这个制度的扭曲者、漠视者、抗拒者有关系的，是所有这些人互动而形成的这样一种实际状况。\n\n⏱ 2024-12-18 02:57:39\n\n\n从“东亚病夫”到民族复兴\n中国共产党从1921年建党到1935年遵义会议选择毛泽东，历经14年，其间党的领导人有陈独秀、瞿秋白、向忠发、李立三、王明、博古。他们按照苏俄革命道路的基本经验来指导中国革命，结果中国共产党撞得鼻青脸肿，磕得头破血流。1935年遵义会议选择毛泽东，不是利益集团妥协的结果，这是中国共产党对胜利的选择，因为14年实践证明了，只有毛泽东的道路才是中国革命胜利的唯一道路。不是唯二的，都试过了，没有其他一条小路或捷径可行，就只有这一条了。毛泽东是中国共产党所有领导人中第一个、也是唯一一个解决了中国革命最为根本问题的人。\n\n⏱ 2024-12-19 02:53:56\n\n\n正如美国建构主义者的鼻祖亚历山大·温特所讲的一样，一个国家，在生存、独立和经济财富三种利益之上，还必须加上第四种国家利益，那就是集体自尊。什么叫集体自尊？中华民族1840年以来最缺的就是集体自尊。我们有个人自尊，但有集体自尊吗？作为一个民族来看，有集体自尊吗？什么叫集体自尊？就如毛泽东讲的，中国必须独立，中国必须解放，中国的事情必须由中国人民自己做主张，自己来处理，不容许任何帝国主义国家再有一丝一毫的干涉。\n\n⏱ 2024-12-18 04:03:43\n\n\n新中国一路走来，光荣和梦想需要代代相传。我们不要拿前三十年否定后三十年，也不要用后三十年否定前三十年，新中国的历程是一个完整的整体，前三十年奠定了完整的工业基础，养成了良好的工作作风。这是我们的光荣，我们一定要秉承我们的光荣。或许我们对前辈有不满之处，可能他们也有失误的地方，也会出现问题，但是他们给我们建立了坚强的脊梁。当我们在指责他们的时候，我们一定要注意，我们是不是在摧毁自己的脊梁，我们能不能像他们的脊梁那么硬，能让我们的后人踏着我们的肩膀前行。\n\n⏱ 2024-12-18 04:05:55\n\n\n毛泽东思想与当代世界体系治理\n长征路上毛泽东与王明、张国焘的路线斗争，以及在短短的一年时间里，毛泽东的正确路线将党从溃败绝境带向与国民党联手进入全国抗日的生死经验，使全党很快认识到毛泽东同志的思想是可以依赖的、引领全党走向全国胜利的思想，这个思想在党的七大上便被全党公认并命名为“毛泽东思想”。\n\n⏱ 2024-12-18 17:57:02\n\n\n实事，是具体事物，这是唯物论；求是，是具体事物中的真理，这就是辩证法。真理总是具体的。王明和张国焘与毛泽东争的不是真理是什么，而是哪里的真理。毛泽东说的是中国的真理，王明说的是苏联的真理，而张国焘说的则是个人的真理。这就是差别。\n\n⏱ 2024-12-18 17:57:41\n\n\n见识了王明的弱智，特别是后来看到赫鲁晓夫治国理政的乱象，毛泽东要求在全党进行历史唯物主义教育，用实践的方法培养中国未来的接班人。现在我理解了毛泽东当时让我们广大知识青年上山下乡的意义\n\n⏱ 2024-12-18 17:58:28\n\n\n现在一些文人热捧“民国范儿”，岂不知，民国时国破家亡，南京大屠杀的时候，举个奥地利旗都能保命，举个中华民国的旗就保不了命。这时的“著名学者”还有意义吗？亡国了，你个人声誉，什么“著名学者”、“大师”，有什么用呀。所以，不要把个人看得太重，要看重国家。\n\n⏱ 2024-12-18 17:59:55\n\n\n世界上国家之间的斗争，都是为了资源而产生的斗争，这是唯物论解释；陷入唯心论，用普世的爱来解释国际关系，则一定要吃大亏。不斗争就不能进步，但不善于斗争，也不能进步\n\n⏱ 2024-12-18 18:04:07\n\n\n革命不能代替，只有通过本国人民的体验产生的革命，才能使那里的人民掌握革命的本领。你代替人家革命，结果你走后，人家还是成长不起来。\n\n⏱ 2024-12-18 18:05:12\n\n\n国家对外政策的节制力主要体现为国家对军队的约束力\n\n⏱ 2024-12-18 18:06:42\n\n\n世界大势浩浩荡荡，其特点是什么呢？就是实体经济＋社会主义。实体经济既是工业资本主义的经济基础，也是社会主义的经济基础，它们共同的敌人是金融垄断资本主义。\n\n⏱ 2024-12-18 18:17:10\n\n\n危机治理的中国经验\n因此，两个常识必须记住：其一，一般工业化是一个不断追加投资的经济过程，而军事工业的投资量更大，如果不对外作战，并没有回报。其二，大多数后发国家都没有起码的工业化基础，要进入工业化就必须先有资本，所以首先面临的挑战叫作“资本极度稀缺”。为什么特别强调“极度”两字？因为西方主流经济学的分析逻辑之成立，恰在于认为生产力诸要素都具有“相对”稀缺性，西方经济学所讨论的一般经济过程，都没有要素极度稀缺的情况，比如说劳动力要素极度稀缺是零，没有劳动力如何讨论要素的优化配置？资本主义时期的西方经济学说发展到亚当·斯密，认为可以在要素相对稀缺条件下，使用市场看不见的手优化组合资源配置达到最优。但是没有分析在资本要素极度稀缺，甚至稀缺至零的条件下怎样依靠市场达到最优配置。因此，大多数发展中国家都很难按照一般西方经济学理论逻辑来构建或调整本国的经济发展过程，因为，他们首先面对的都是资本极度稀缺。\n\n⏱ 2024-12-19 17:41:55\n\n\n外资从来都是有代价的，任何外资在资本稀缺程度为零的发展中国家，都会在引进的瞬间变成外债负担；\n\n⏱ 2024-12-19 17:43:26\n\n\n我们不能把今天的问题写成过去的问题，我们也不能为了处理我们今天的问题而否定前人。因为我不是主流经济学家，所以我的表达更为直白：中国现在面临的主要是三大过剩——因产业过剩而必致金融过剩，因产业和金融过剩而必致商业过剩。由此，可以归纳为三大资本过剩。\n\n⏱ 2024-12-19 17:45:58\n\n\n产业、金融和商业过剩的逻辑关系是，当产业过剩的时候，银行家不会向过剩的产业投资，政府却不断地制造货币，货币总量在不断地增加，但又不能再将货币直接投向过剩的产业领域，只能由中央人民银行给各个商业银行，于是出现金融资本的流动性过剩。\n\n⏱ 2024-12-19 17:46:13\n\n\n世界上任何国家只要金融过剩，资金通常都会和房地产结合。金融资本跟地产资本之间的结合机会几乎是天衣无缝、互相依赖的。大量的过剩金融资本有意无意地推高地产价格，这在世界范围内具有普遍性，并非本国独创。产业只要过剩，金融向产业投就意味着砸钱收不回来，金融就不会投，不投又导致不断增发货币，于是产生金融过剩，当然会接着出现商业过剩。\n\n⏱ 2024-12-19 17:47:47\n\n\n资本积累到了一定程度，利润率就下降了。所以，试图在产业、金融、商业这三大资本完全过剩条件下构建信用社会，形成稳定信用关系的努力，不是不值得肯定，而是大环境不好。因此，这种主观愿望和努力往往带来较高的制度成本，以及因这种努力不奏效而带来的较高的治理成本。总体来看，在资本过剩条件下，无论主观如何，制度成本过高是必然的规律。\n\n⏱ 2024-12-19 17:48:36\n\n\n与过剩时代不同，资本稀缺派生出来的问题是：无论何种体制、何种意识形态、何种政府、谁当领袖，都有一个共同的规律——当资本极度稀缺时，政府的第一个任务肯定是资本积累，因此就必然是亲资本（pro-capital）的政策体系。国内思想界简单地搬用某个欧洲国家在特定的时空条件下，偶发性地形成的左派和右派的这种观点，不太明智。有人一言以蔽之地认为过去都是极左的错误，更是有点荒唐愚昧。在资本极度短缺的年代，客观上不会有形成所谓左的错误的条件，即使有错误，也只可能是极右的错误。因为，这时无论以任何名义建立的政府，其政策体系都一定是亲资本导向的。只有当资本不再短缺，当资本进入过剩，这时候的政策体系也必然是不论何党何派、何种政治体制、何种意识形态、谁为政府领袖，都会相应地调整到或多或少的民生导向，或者说，亲贫困（pro-poor）政策基本上具备执行条件了。\n\n⏱ 2024-12-19 17:55:50\n\n\n亲贫困和亲资本这两大本质对立的政策体系，都是在客观外部环境发生根本性条件改变的时候才有可能内生性地发生改变。亦即，条件不具备的时候，政治家说与做就不可能是一回事。\n\n⏱ 2024-12-24 12:49:16\n\n\n我们是在什么意义上说清王朝是反动政权呢？不是简单地说它反对现代化，而是说清王朝的现代化道路是走不通的。这绝对不是说构建革命的意识形态的历史是错误的，这个工作非常非常重要，也曾经是高度有效的，尤其是在推动中国这个一穷二白的国家走向现代化时，是唯一有效的。它的有效性就在于，国家在资本为零的条件下，想要动员劳动力，成规模地、而不是个体地，投入于大型基本建设来替代资本的时候，它需要依靠精神的力量。经典理论讲的是K和L的关系，K是资本，L是劳动。我们那个年代所做的无外乎就是成功地以L替代了K，在资本稀缺为零的条件下，用劳动力的成规模投入来替代资本，完成了资本原始积累，进入了工业化，这就是中国发展的所谓秘密。而在这种情况下，如果要动员劳动力，不可能告诉大众说我是资本你是劳动力，你的剩余被我占有，你给我干活去……因而，恰恰是革命意识形态，有效地动员了普通大众，成规模地近乎无偿地投入劳动，替代稀缺资本。\n\n⏱ 2024-12-25 21:27:26\n\n\n其实自从帝国主义开始瓜分中国以来，即1840年以后，中国就不再有完整意义上的中央政府。到1900年八国联军打进北京，李鸿章在东南坐镇，那次叫“通电八省，拒不勤王”，表明中央早就已经与地方分裂了。因为，帝国主义列强当时已经把中国瓜分了，那时候，包括大家所熟知的北洋水师、淮军、湘军，都属于以中央政权为名的地方军事势力。而湘淮两大派系的互相斗争，演化为后来淮系李鸿章的海防论和湘系左宗棠的陆防论之争。据此，洋务运动的实质，也是各地督府在搞本地的军事工业，以壮大本地的军事实力。\n\n⏱ 2024-12-27 00:36:05\n\n\n其实地方实力派的军事工业，客观上恰恰是压垮清朝这个病入膏肓的骆驼的最后一根稻草。\n\n⏱ 2024-12-27 00:38:10\n\n\n蒋介石想靠英美日得到稳定的国际环境，但帝国主义不买账。这就是民国没有能够稳住这个国家的重要原因之一。\n\n⏱ 2024-12-27 00:41:29\n\n\n民国先亡于财政金融、亡于经济崩溃，后亡于军事失败。蒋介石也想解决“半封建”问题，但是，他无力解决帝国主义的问题，这是因为中国的官僚资本，是通着帝国主义的。\n\n⏱ 2024-12-27 00:41:55\n\n\n1949—1950年新中国成立之初遭遇的严重的通货膨胀经济危机，乃是1936年民国放弃银本位开始发行纸币以来延续了20年的通胀危机，而并非新中国政权因为“左右”问题造成的。\n\n⏱ 2024-12-27 00:44:06\n\n\n1998年银行与财政才正式分家，中国才算开始进入相对比较独立的货币体系建立过程；到2001年、2002年才完成了中国现代纸币体系的建设。\n\n⏱ 2024-12-27 00:45:43\n\n\n这与20世纪50年代的道理是一样的，所以，1950年以后中国构建的上层建筑和意识形态叫作“全盘苏化”。这可能不是中国人完全自主开展的国家政治建设。当时游击队员出身的中共进城干部，还不知道如何有效组织管理苏式重工业，于是在政府的经济部门都派驻了苏联专家，帮着搞国家政治建设。所以，中国政府经济部门完全按照投资国的要求构建了八大工业部、五大经济委等，全套苏化政府部门的管理业务也搬过来；高级干部得去学习，后来继任的领导人都是那个年代培训学习过来的。大学里所有现代学科院系也都派驻了苏联专家，帮着搞教材，搞管理，搞学科体系建设。无须太多解释，总之经济基础一定要求有与之相适应的上层建筑，这既是经典理论，也是极其简单的常识。\n\n⏱ 2024-12-27 00:50:38\n\n\n直到1957年其应该交回的中国领土，才还给中国；带来的直接影响就是苏联不再向中国投资了。当不断需要追加投资的中国城市工业化过程突然出现投资中断，请问这个经济还能维持吗？没有任何人可以维持，于是中国苏式的工业化停了。因此，中国的上层建筑，为了管理苏联投资的工业化经济而构建的科层化政府部门，也就不能再继续正常运作了，无论如何，只能另辟蹊径。由此，就有1958年郑州会议要调动地方积极性，因为中央政府无苏联投资，经济就得停下来，不如让地方来继续搞工业化。但地方却毫无工业化的经验，于是“大跃进”成为发动地方工业化的社会运动。毛泽东当时为什么进退两难？因为是中央让地方搞工业化，地方同志犯了错误，又不能打击他们，还得要保护两个积极性，不能轻易出面纠正“大跃进”中过于激进的错误。大家都以为他太荒唐，其实他是种稻子的农民出身，难道不知道小孩是不能站到田里的稻穗上的？这主要还是因为那个时候苏联的投资突然停了，中央政府随即完全没有投资能力了，国家经济增长陡然下降，于是1958—1960年大危机就爆发了。苏联靠不住，只能靠自己了，靠“穷棒子”互助组，毛泽东说“打破常规”就是“大跃进”，而打破常规是被逼出来的。\n\n⏱ 2024-12-27 00:58:36\n\n\n中国当时也没有条件推进苏式工业这个经济基础了，可全盘苏化的上层建筑要改谈何容易？因此，以路线斗争为名发动工农兵改造上层建筑，这个也是中国创造。至于成还是不成，经验多还是教训多，留待后人评说吧。若是按今天仍然坚持的经典理论来看，经济基础决定上层建筑，没有苏联投资的经济基础了，这个苏式上层建筑是难以维持的。所以，即使再谈论今天所说的种种“极左”，在当时历史条件下，也许算是为了民族经济复兴的危机治理做法当时的经济基础，只不过是苏联留下的官僚主义上层建筑，已经无法再适应当时的经济基础，只能动员劳动力维持国家建设的经济基础了。按苏联形式主义运作的官僚们难以动员劳动力，如果不跟老百姓一起下乡干活，一块上工地，就难以被劳动者信服。但如果要用革命意识形态重新动员老百姓，就需要驱使已经学会穿中山装喝苏式咖啡的官员们下乡了。所以，20世纪60年代就有“四清运动”等等一系列大量干部下乡活动，革命意识形态再次成为抑制政府过分官僚化的武器。\n\n⏱ 2024-12-27 01:04:25\n\n\n如果说20世纪60年代的上山下乡是1958年经济危机的结果，1968年上山下乡则是1966年经济危机的结果，那么1974—1976年的上山下乡，是70年代引进外资变成外债带来的经济危机所导致的结果。在毛泽东时代，每一次经济危机都靠上山下乡向农村转嫁了城市劳动力过剩的代价，因此城市的国家工业化原始积累阶段发生的内生性危机，都安全地软着陆了。能软着陆，根本上就是因为农民支持毛泽东，因为他使耕者有其田。\n\n⏱ 2024-12-27 02:12:20\n\n\n当外资突然停止时，只能用劳动力集中投入来替代稀缺程度为零的资本；当发生经济危机时，因为中国幅员辽阔，还因为是典型的城乡二元结构，得以让农村作为载体来承接代价，否则，积聚于城市的产业资本就难以度过危机。\n\n⏱ 2024-12-27 02:14:28\n\n\n总之，如果没有当年的农村集体化，就不可能有向农村转嫁危机的载体，没有这个载体，中国就难以度过这几次经济危机。国家在没有形成产业资本的工业化早期资本的原始积累阶段是最弱的，在没有形成完整的社会化大生产，在没有产业资本门类齐全的经济结构的时候，就像刚生下的娃娃，哪怕是发烧感冒都能要命这个道理是一样的。我们的新中国，也是从娃娃长大的。\n\n⏱ 2024-12-27 02:17:30\n\n\n发达国家最大的问题是：其构建的民主法治的上层建筑，原来是以产业资本作为经济基础来支撑的。从20世纪70年代开始发达国家渐次向外移出产业，到90年代末期基本完成了产业转移，意味着原来支撑这种上层建筑的产业基础大多转移出去了，这时候发达国家的上层建筑愈发依赖政府增加债务来维持，因此发达国家的政府债务就越来越大。90年代以前，世界政府债务主要是发展中国家的，因为发展中国家要搞工业化，要接受发达国家的投资，投资需由政府偿还，遂成为国家债务。这类债务是生产性负债。90年代以后，主要是发达国家政府因经济增长缓慢，社会开支占比过高而增加负债。这类债务则主要是福利性负债。\n\n⏱ 2024-12-27 02:24:06\n\n\n政府就是每年每月通过增发货币来制造通货膨胀基础，只要国家不出现消费过热拉动的恶性膨胀，政府就能够通过不断增大货币分母来缩小债务分子。\n\n⏱ 2024-12-27 02:28:16\n\n\n只要产业和金融作为国家经济两条腿的支撑能力不足，都避免不了产生像这些国家一样多米诺骨牌的命运。只有仍然保留了设备制造业的欧洲中心国家——德国、法国能支撑得住。\n\n⏱ 2024-12-27 02:28:23\n\n\n中国道路与中国共产党的“四个三十年”\n为什么我国社会管理成本越来越高，花费了大量人力财力，社会秩序却依然未见好转，甚至每况愈下？科层体系不可能单独治国。在治理体系里，居民自治恒定比政府治理分量更重。这个道理适用于无论大小贫富的所有国家。科层体系能办“大事”办不了“小事”，居民自治能办“小事”办不了“大事”。但民心系于“小事”，所以“小事”恒定重于“大事”。\n\n⏱ 2024-12-30 00:48:44\n\n\n以人民为中心的改革观\n凡是在追求资源配置效率即经济增长的框架下，几乎无法解决公正问题!\n\n⏱ 2024-12-30 00:58:14\n\n\n人们对社会不公正反映越来越强烈，主要是因为以下原因：一是社会公平改善的速度，跟不上社会大众心理预期的速度。特别是，社会大众公平意识、民主意识、权利意识不断增强，客观上降低了对于不公平的容忍程度。而任何政策效果都有一定的时滞，加之财政约束及其他条件限制，决定了执政者不可能出台更具激进的解决方案。这恰好与人们的强烈期盼形成一定时差，进而导致公平性客观状况与大众主观感受存在反差。二是舆论的放大效应，助长了对社会不公平的主观感受。尤其是在自媒体时代，类似“富二代炫富”以及暴露出的官员严重腐败行为等偶发事件被有选择性拱出水面，与之对比，诸如少数生活困难，或者因政府部门失职导致求助无门的弱势群体的生存状态和遭遇，通过网络媒体披露，也在刺痛普通百姓的心灵，在主观上放大了社会不公平。三是少数政府官员“公知化”。随着“媒体政治”意味的不断强化，一些官员特别是一些高官，竞相把自己的位置当成“亲民”秀台，在自身无法解决问题甚至根本就不作为的同时，却高谈阔论社会不公平现状及解决的迫切性，并把问题推给所谓“体制”。其结果不仅不能缓解社会不公平感，反而强化了社会公众的负面情绪。\n\n⏱ 2024-12-31 02:08:02\n\n\n学好用好马克思主义政治经济学\n在古汉语中，“经济”一词是“经邦济世”、“经国济民”，即治理国家、拯救庶民的意思。在古代希腊、罗马语言中的“经济”一词指的是“家政管理”。\n\n⏱ 2024-12-31 02:10:39\n\n\n按照西方主流经济学的认识，市场经济的核心是稀缺资源的配置问题，而供求和价格的相互作用又是市场机制的核心。只要让价格起作用，市场就会自动达到均衡，实现资源的优化配置。经济体制改革的主要任务，就是要创造出使价格能够自动调节资源配置的制度条件来，简单地说，就是管住货币，放开价格，全面推动私有化、自由化和开放化。而且，所有的这些改革举措应当在短期内全面推开，这就是所谓的“休克疗法”和“大爆炸”。他们还断言，人们不可能两步跨越一道鸿沟，渐进式改革是难以成功的。\n\n⏱ 2024-12-31 02:16:07\n\n"},"阅读/以利为利：财政关系与地方政府行为":{"title":"以利为利：财政关系与地方政府行为","links":[],"tags":[],"content":"\n\n                  \n                  以利为利：财政关系与地方政府行为 \n                  \n                \n\n\n\n《以利为利：财政关系与地方政府行为》-  周飞舟\n出版时间： 2012-12-01 00:00:00\nISBN： 9787542636492\nPC地址：weread.qq.com/web/reader/1e7326a0813ab7b45g014524\n\n\n\n第一章 绪论：政府行为与中央—地方关系\n\n在财政支出方面，地方政府负担了大部分地方支出，中国的分权格局主要表现在财政支出即“事权”的分权上面。由于中央政府掌握着对收入即“财权”的控制权，所以这种分权在本质上是“事权”的下放和“财权”的部分下放。与其叫作分权，不如叫作“放权”更为合适。\n⏱ 2024-04-30 11:29:10\n\n\n到底是以市场化改革促发展，还是以政府调节实现社会平等和经济增长，在意识形态方面就表现为所谓“右派”和“左派”的激烈争论。\n⏱ 2024-05-01 01:46:56\n\n\n虽然市场的作用不断扩大，“体制外”的力量不断成长，但是国家和政府的控制并没有明显的弱化，许多重要的市场要素如资本、土地乃至劳动力的配置权力仍然掌握在政府手中[插图]。与改革前不同的只是其控制的手段和方式出现了明显的变化。\n⏱ 2024-05-01 01:50:13\n\n\n精英替代理论假设在过去的计划经济体制中掌握资源分配权力的政治精英将逐渐被市场转型过程中兴起的经济精英和社会精英所替代，或者说社会的精英集团将呈现出分化的趋势，没有一种精英团体会像过去一样全面垄断社会资源的分配权。精英再生产理论则认为旧有的政治精英会在转型过程中利用其已经掌握的权力去维持在经济和社会中的地位，成长为新的经济精英和社会精英。\n⏱ 2024-05-01 01:51:08\n\n\n总结以上的研究，我们可以看出社会学在分析政府和社会关系时的特点。这主要表现在两个方面。第一，政府在与非政府力量互动时，自觉不自觉地采取了某些权力技术或变通策略。第二，政府在很大程度上是以一种与社会相对立的姿态出现的，无论政府对乡镇企业的“扶持之手”，还是对农民的“掠夺之手”，政府的动机似乎是“外生”的。\n⏱ 2024-05-01 01:53:47\n\n\n近半个世纪以来，西方现代政治经济学发展出了两个研究政府行为的基本范式，即公共财政学派和公共选择学派。公共财政学派将政府定义为公共物品和公共服务的提供者，其提供公共服务的效率是辖区居民对政府认同和评价的基础，这也构成了制约政府行为最重要的力量。居民可以通过“用脚投票”的方式来和政府行为进行互动，而政府在此基础上努力为辖区提供高水平的公共服务。公共选择学派则认为政府官员也有自己的利益，没有理由认为政府会将辖区居民的利益最大化而忽视自身的利益。\n⏱ 2024-05-01 01:56:08\n\n\n首先，省、市、县各级政府不但是各自独立的利益主体，而且有着极为明确的主体意识。\n⏱ 2024-05-04 01:08:24\n\n\n市对县的利他性财政政策正、是以市级政府能够与省级政府讨价还价的局面为前提的。也就是说，如果省与市的讨价还价变成纯粹的上对下的命令式或者压力性体制，则市对县利他性政策的空间也不会存在了。\n⏱ 2024-05-04 01:10:48\n\n\n就财政的中央—地方关系而言，改革开放以来经历了两个大的阶段，以1994年的分税制为分界点。分税制以前，政府间普遍采用的是财政包干制，上下级政府间每年或者每几年都要就包干的形式、基数、超收分成比例进行讨价还价。这为各级政府对上“利己”、对下“利他”的“放水养鱼”行为提供了一个基本的制度背景，也是典型的财政分权效应。而1994年的分税制将中央与地方的税收分配比例固定化了，一劳永逸地消除了上下级讨价还价的局面，而且通过这种比例将大部分财政收入集中到中央，所以我们说分税制既是一种制度化、规范化的改革，又是一种集权化的改革。\n⏱ 2024-05-04 01:13:30\n\n\n所以说，改革前后中央—地方关系发生了实质性的变化，即从改革前讨价还价的关系变成了改革后地方主要依靠中央拨付转移支付补助的关系。地方对中央的财政依赖大大加强了。\n⏱ 2024-05-04 01:15:44\n\n\n在这种局面下，基层政府的财力大小主要看上级拨付的转移支付量的大小，所以造成了中部地区的县乡困难、东部地区和西部地区的县乡财政相对宽裕的局面[插图]。这种局面构成了我们理解政府和企业、政府和农民关系的基础。\n⏱ 2024-05-04 01:15:57\n\n\n由于制造业企业上缴的主要税收是增值税，而分税制规定增值税75%归中央，25%归地方，所以在分税制以后，地方政府能够从企业上收取的地方税收大幅度下降。在这种局面下，我们在1990年代中期看到了地方乡镇企业大规模倒闭、转制的高潮。\n⏱ 2024-05-04 01:19:18\n\n\n事实上，我们普遍可以看到，分税制以后增值税已经完全不构成地方财政收入的主体税收。地方的主体税收迅速转变为被100%划为地方税种的营业税。营业税主要来自于建筑业和第三产业，这有助于我们理解90年代后期以至到今天仍然过热的地方基础建设投资热潮以及各种以“大兴土木”为主的政绩工程。地方政府的这种反应是预期之中的结果，预料之外的结果则是东部地区的地方政府开始开辟税收之外的财政收入来源，即“圈地”和“以地生财”。由于政府垄断了土地的一级市场，所以可以低成本地从农民手中获得土地，以高价格在土地二级市场卖出去，从中获得了巨额的土地转让收入。\n⏱ 2024-05-04 01:20:07\n\n\n政府的财政之所以被叫作“公共财政”，是因为政府配置、提供的资源、物品和服务具有公共性质，我们一般将这些物品和服务称为公共品和公共服务，这无疑是相对于“私人物品和服务”而言的。\n⏱ 2024-05-04 01:25:06\n\n\n在财政领域，我们将政府提供公共品的职责范围称为政府的事权，而将政府的财政收入叫作政府的财权。就政府和社会的关系而言，我们笼统地讨论政府的事权和财权，就政府内部的政府间关系而言，我们则要讨论事权和财权在各级政府之间的分配情况。\n⏱ 2024-05-04 01:25:50\n\n\n中国有五级政府，在财政关系上，每一级政府采取的是“下管一级”的制度，也就是说每级政府只负责制定它与其下一级政府的财政体制。\n⏱ 2024-05-04 01:26:58\n\n\n首先，我们评价和衡量政府间财政体制的一个重要标准就是要看一级政府的财权和事权是否相称或者对称。很明显，如果某级政府的事权远远超出其财权，则这级政府的财政就会出现赤字，并且没有能力为公共品和公共服务提供所需的资金；反过来，如果财权远远超出其事权，则政府提供公共品和公共服务的效率就会出现问题，因为财政收入基本上来源于税收，财权超出事权说明这个地区的居民上缴了过多的税收却没有充分享受到这些税收所能提供的公共服务。\n⏱ 2024-05-04 01:28:29\n\n\n一般而言，财政补助分为两种，一种被称为“一般性补助”(General Purpose)，没有指定补助的用途；另一种被称为“专项补助”(Earmarked or Specific Purpose)，是指资金都附带有明确的用途，下级政府不得将资金挪作他用。\n⏱ 2024-05-04 01:30:10\n\n\n财政分权的极端例子在古代是春秋战国时代的分封制；在当代，美国的“财政联邦主义”(Fiscal Federalism)是比较典型的代表。\n⏱ 2024-05-04 01:32:15\n\n\n对于财政集权而言，极端的例子就是新中国成立后1949年到1952年实行的严格财政“统收统支”体制。在统收统支的制度下，地方政府不但没有独立的财权，其财政收入完全归中央政府进行安排，而且其事权即支出权也由中央政府严格控制。\n⏱ 2024-05-04 01:32:44\n\n\n地方权力过大，容易造成中央的政令不通，在极端的情况下造成“诸侯政治”甚至地方割据和国家分裂；而中央实行过度的集权又容易使得整个政治和经济体制陷于僵化，难以对地方出现的问题进行灵活和适当的反应和处理，地方的小问题往往容易蔓延和发展成为全国性的大问题，从而也威胁到政权和国家的稳定。所谓“一放就乱、一收就死”就是指的这种状况。\n⏱ 2024-05-04 01:33:58\n\n\n软预算约束是一个被普遍使用的概念[插图]，在财政领域，软预算约束主要指下级政府的支出超过预算，而自己并不为其缺口负责，通常由上级政府的事后追加补助(Bailout)或者借债来填补。对于借债而言，下级政府相信自己没有或只有部分偿还责任，包袱最终还是由上级政府来背。\n⏱ 2024-05-04 01:35:49\n\n\n分权虽然会促进地方政府间的竞争，但是这些竞争并不一定会消除软预算约束。这些竞争可以表现为招商引资，也可以表现为大搞“形象工程”，因为效率从来都不是衡量地方政府表现的首要指标。\n⏱ 2024-05-04 01:36:41\n\n第二章 改革前的中央地方关系\n\n[插图]随着“一五”计划和社会主义改造的完成，我国中央—地方间的基本经济和财政关系的构架已经建立起来。根据上面的分析，这种框架的基本特点是：中央控制了全国大部分的人力、财力和物力的管理和分配，这种控制是通过计划指标管理的形式，并通过建立在各个工业经济部门的“条条”系统来进行直接的、自上而下的控制实现的。具体而言，重要的企业几乎全部纳入“条条”系统直接管理，其他企业则通过“块块”系统间接管理，但是其税收和利润大部分归中央财政进行分配。\n⏱ 2024-05-04 01:48:04\n\n\n这种全面放权一方面迅速刺激了经济增长，另一方面却带来了严重的问题。问题主要表现为严重的“浮夸风”以及经济结构的严重失调，其根源却是伴随着全面放权出现的地方政府指标竞赛行为。\n⏱ 2024-05-04 17:41:43\n\n\n从“大跃进”的实践中可以看出，锦标赛体制本身并不会内生出地方政府狂热追求高指标的约束力量，而是相反，竞赛在压力之下愈演愈烈。只有造成了严重的经济和社会后果之后，中央政府才开始力图终止竞赛。\n⏱ 2024-05-05 00:44:06\n\n\n政府对社会经济资源的全面控制是锦标赛发动的另一个重要基础。如果我们按照资源配置的手段将社会经济资源分为“体制内资源”（政府计划控制）和“体制外资源”（市场控制），那么，通过对主要农产品的统购统销和三大社会主义改造，市场基本不再是配置社会经济资源的手段，几乎全部资源都通过政府控制的计划经济体制来进行配置和再分配。在这种形势下的分权只能是政府内部中央向地方政府的分权而非向市场和社会的分权。由于资源的再分配取决于中央政府的指标和计划体系，所以地方政府无法成为独立的利益主体和行动者，只能是在中央政府的指挥棒下进行比赛的参赛者。在这种竞赛中，竞赛的胜利者得到的奖励是完成或超额完成指标任务后的荣誉，并不能通过比赛得到不受比赛的发起者控制的额外利益。\n⏱ 2024-05-04 17:49:14\n\n\n在高度的政治控制之下，地方政府竞相通过制定高指标、全面动员社会经济资源来实现高指标来表现政治上的忠诚，“公司化”和“层层加码”就是实现这些指标的必然手段，而且为中央政府所允许和鼓励。中央对资源的高度控制使得地方政府并不关心投资和建设的长期经济效益，而只是以扩大投资规模为目标；\n⏱ 2024-05-04 17:58:12\n\n\n“一放就乱、一乱就收、一收就死”指的就是这种由“集权—放权”逻辑导致的经济波动和周期\n⏱ 2024-05-04 17:50:27\n\n\n第一，无论是收权还是放权，都有一个绝对的前提，就是国家经济资源的全面控制。在社会主义计划体制之下，市场和商品经济不存在，几乎所有的社会经济资源都归政府来管理和进行配置，因此“收放”实践可以被理解为国家通过行政手段来刺激、调整经济结构和经济发展速度的尝试。这种尝试的基本模式就是经济停滞时放权，过热和混乱时则集权。[插图]图2-1　固定资产投资规模变化情况（单位：亿元）第二，放权的核心手段是下放地方的投资权和企业的管理权。当然，鉴于计划经济的特点，伴随着投资权和企业管理权的下放，农业、商业乃至财权和事权也一般都出现下放的趋势。在放权过程中，关系国计民生的主要产品的产量成为推动、衡量地方竞赛的主要指标，而投资权的下放则是地方能够实现展开竞赛、追求目标的基本条件。第三，无论是集权和放权都是在中央其他方面的高度集权下展开的，越是放权，则越要求在其他方面集权。放权和集权又是在小心翼翼的控制下进行的，这种控制全面表现在人事上，或是在意识形态、政治和军事上。地方政府也形成独立的利益主体意识，但是并不能理解成为类似于西方分权体系下的独立利益主体，充其量只能叫作中央对地方的放权。地方政府展开的竞赛表面上是围绕经济，实质上也是在高度集权下展开的政治竞赛，地方经济并不能从竞赛中得益。\n⏱ 2024-05-05 00:47:39\n\n第三章 财政包干的效应和后果\n\n承包制是在不改变所有权性质的情况下，将使用权和收益权让渡给经营者个人的一种所有权与使用权分离的产权结构。这种结构既维持了产权的公有或集体所有的性质，又能够有效地调动生产经营者的积极性，是一种典型的渐进式的改革策略。\n⏱ 2024-05-05 23:10:58\n\n\n财政承包，其基本思路是中央对各省级财政单位的财政收入和支出进行包干，地方增收的部分可以按一定比例留下自用，对收入下降导致的收不抵支则减少或者不予补助。\n⏱ 2024-05-05 00:49:47\n\n\n包干制总的精神就是“包”，“包”的前提就是将中央—地方各自的收支权限划分清楚，中央“包”给地方的是收支总数，而不对地方的增收、减支的权利多加干预。\n⏱ 2024-05-05 00:52:48\n\n\n虽然财政包干制的体制显得非常复杂，但是基本上可以概括为这样的四类：(1)总额分成，但是分成比例每年都变化；(2)固定比例分成，这种分成比例一定几年不变；(3)比例上解或者比例补助。在包干的基础上，超收或补助的部分按一定比例上解或者补助，这个比例可能是固定的，也可能按一定的比例递增；(4)定额上解或定额补助。这是俗称所谓的“大包干”的办法，只要地方政府的收入超出了定额，就可以全部留归己用。\n⏱ 2024-05-05 01:03:51\n\n\n财政分权(Fiscal Decen tralization)的理论是研究的一个基本起点。这个理论认为，在地方资源和生产要素可以自由流动和居民可以“用脚投票”的前提下，中央对地方的财政分权可以引发地方政府间展开良性的区域竞争，从而有效推动经济增长[插图]。\n⏱ 2024-05-05 23:21:42\n\n\n乡镇企业是最具中国特色的企业形式，主要有两个特点：一个是这些企业不是坐落于有规模经济效益的城市，而是散布在农村地区，其劳动力以家有土地的农民为主；另一个特点是其产权是乡镇或者村集体所有，是一种“共有”性质的产权结构。这种独特的企业在80年代兴盛一时，成为中国经济增长的核心推动力量。\n⏱ 2024-05-05 23:16:24\n\n\n在80年代的税收体制下，增加财政收入最为直接和有效的手段就是创办地方企业，而企业上缴的产品税和增值税就是财政收入增长的主干力量。自1985年到1991年，全国的税收总额年均增速7.7%，产品税和增值税的增长速度年均8%，而全国企业所得税的年均增速只有1.8%。前两个税种与企业的规模相关，而后一税种与企业的盈利相关。由此可见，地方工业尤其是乡镇企业的迅速发展是国家财政收入增长的一个重要动力，但是这种增长却与企业的效益关联甚小。\n⏱ 2024-05-05 23:20:00\n\n\n与乡镇企业蓬勃发展的态势不同，国有企业改革走的是一条典型的“渐进式”和“摸着石头过河”的道路，经历了复杂的制度变迁的过程，先后实行过“企业基金制”、“利润留成制”、“利改税”、“承包制”、“股份制”等等。总的来说，是从企业的利润分配改革扩展到经营体制的改革，再扩展到产权制度改革。产权制度的改革发生在改革开放的第二阶段，而利润分配、经营体制的改革大部分按先后顺序发生在第一阶段。\n⏱ 2024-05-06 10:02:27\n\n\n改革前，正如上一章所分析的，企业主要是通过上缴利润而非税收的形式增加国家的财政收入。\n⏱ 2024-05-05 23:24:38\n\n\n从上面的分析可以看出，企业固定资产规模的扩大与流转税的增长是同步的，而与所得税增长没有关系，和企业利润呈现出相反的关系。流转税大多以企业的产值或者增加值为税基，与企业规模有直接的关系。在“一揽子包干”的财政包干制下，主管部门或者地方政府要实现财政收入和GDP的增长，企业增收的作用并不明显，而企业规模的扩大才是其主要途径。\n⏱ 2024-05-06 10:06:30\n\n\n由此，我们看到了财政包干制下地方政府与国有企业的关系与其与乡镇企业发展的关系基本是类似的：企业规模的扩大是地方政府的主要关注点，而企业的效益则对于地方GDP和财政收入增长来说作用相对次要一些。而国有企业承包制的运行也促进了这种格局的形成，这主要与承包制的两个关键的制度设计有关。一个设计叫作“含税承包”。承包制在1987年推广，一直到1993年实行的都是所谓的“含税承包”，即承包基数包括了企业应该上缴的企业所得税和收入调节税。如果利润超过了承包基数，则实际上是以低于基数内55%的所得税率缴纳所得税[插图]，如果所缴纳的所得税和调节税超过了承包基数，则国家会将多出的税金返还给企业。这样一来，只要企业超额完成了承包基数，实际上就可以少交企业所得税和收入调节税。而且超额越多，就相当于减税越多。“含税承包”在实践中实际变成了“减税承包”。由于所得税和调节税归地方政府，所以地方政府要增加财政收入，根本不能依靠所得税。另一个设计叫作“税前还贷”，即企业可以在计算所得税前将所需还贷的部分扣除。这种设计在实践中有两个效应。一个效应与“含税承包”相似，即实际缴纳的所得税减少了，而且新增贷款部分越大，所得税减少的幅度就越大。另一个效应是客观上鼓励企业扩大贷款规模，因为新增贷款投资所产生的新增利润实际上无须缴纳所得税。对于地方政府而言，由于新增贷款投资可以直接带来以企业产值为税基计算的产品税、增值税和营业税等流转税，所以地方政府也对帮助企业获得新增贷款极有热情。这在实践中造成了企业规模在新增贷款下迅速扩大。\n⏱ 2024-05-06 10:08:49\n\n\n财政包干制是和乡镇企业的兴起以及国有企业的改革紧密结合在一起的。\n⏱ 2024-05-08 17:41:56\n\n\n地方与中央、地方各级政府之间几乎每年都会就此与中央政府进行讨价还价。各方的利益边界在讨价还价中逐渐明确，有研究发现，下级政府在谈判中的筹码就是地方的经济发展，形成了“放水养鱼”的财政包干与地方经济发展的基本逻辑，地方政府的利益主体意识逐渐明确起来[插图]。\n⏱ 2024-05-08 17:43:47\n\n\n但是，在财政包干制的增收压力下，地方政府和地方企业在利益上紧密联系在一起，形成了一定程度上的利益共同体。虽然没有直接干预企业，但是地方政府主动帮助企业获得银行贷款，企业的固定资产规模、生产规模得以迅速扩大，由规模扩大而带来的流转税收的增加成为地方政府完成财政包干任务的主要依靠。对于企业而言，规模的扩大实际上使自己成为地方政府财政的王牌，成为地方政府“自己的企业”，即使亏损，地方政府也要设法保全。\n⏱ 2024-05-08 17:44:42\n\n\n所谓的“放水养鱼”，是指地方政府通过各种途径向企业“注”水，以行政或者半行政手段动员地方资源来扩大企业生产规模，而不是建立真正的市场机制，使企业真正增强在市场竞争中的活力。实际上，在计划和市场的价格“双轨制”环境下，企业更易通过“寻租”来扩大规模，地方政府则更易通过“设租”来增加收入，虽然在这种局面下地方GDP和财政收入都能够达到快速增长，地方政府和企业的行为却是与建立市场经济的路径背道而驰的。在这种发展模式下，地方政府虽然退出了企业的经营管理，实际上却是更深地介入了企业的利益链条，与企业的命运紧密相连。对于国有企业而言，企业的贷款、流动资金和利润仍然基本掌握在地方政府手中，形成了“银行放款、企业用款、财政还款”的局面，而乡镇企业与地方政府的关系则更为密切，基本相当于地方政府自己开办的公司。\n⏱ 2024-05-08 17:46:46\n\n\n地方政府和企业的密切关系形成了地方政府的独立利益，加强了对新增加的经济资源的控制能力，这直接导致中央政府的再分配能力的下降与中央—地方关系的紧张状态。\n⏱ 2024-05-08 17:47:24\n\n\n在改革以前，中央政府的财政收入比重虽然很低，但是支出比重很高，这两个比重之间有着巨大的差额。这说明大量的地方政府组织的财政收入上解到中央来由中央政府负责支出。\n⏱ 2024-05-09 11:24:29\n\n\n简而言之，财政包干制将中央—地方关系由以前的“集中地方财力由中央支出”的局面改变到“就地收入、就地支出”的局面，由以前的收入支出不平衡改变到中央和地方各自维持收支均衡的局面。\n⏱ 2024-05-09 11:24:52\n\n第四章 分税制改革及其影响\n\n中央政府于1994开始推行的分税制改革可以看作是对财政包干制的全面否定。\n⏱ 2024-05-09 11:26:50\n\n\n例如王绍光先生认为，财政包干制使地方积累了大量的财力，而中央的财政收入比重过小，“诸侯经济”的态势已经初步形成，这不但降低了中央政府调控经济运行的能力，而且中央政府的权威也受到影响。在这种背景下，分税制是中央集权的必然要求[插图]。\n⏱ 2024-05-09 11:28:16\n\n\n所以说，构成分税制基本背景的主线有两条，一条是中央与地方关系中中央财政的被动局面，另一条则是政府与企业的关系。财政包干制不但无法实现“政企分开”的目标，反而在一定程度上加剧了地方政府与企业的结合，这又反过来造成了中央财政能力的下降。这两条主线决定了分税制改革的集权性质以及对政府和企业关系的深远影响。\n⏱ 2024-05-09 11:35:14\n\n\n广义的分税制改革[插图]主要包括两个方面的内容，一个是税制改革，即税种的重新划分和调整，另一个是财政体制的改革，即中央和地方重新划分和调整各自的财权和事权。\n⏱ 2024-05-09 15:05:50\n\n\n首先，通过“财税分家”的改革，将征税的权力直接集中于中央。改革以前，税务是作为财政系统下的一个部门而发挥作用的，而财政部门是地方政府的“钱袋子”，是控制和管理最为严密的部门。为了地方利益，地方政府可以通过操纵税收部门而方便地“藏富于企业”。\n⏱ 2024-05-09 15:10:48\n\n\n分税制无疑是促成乡镇企业大规模转制以及国有企业股份化的主要动力之一。\n⏱ 2024-05-09 17:37:11\n\n\n与私有化浪潮相伴随的重要现象是地方政府的财政收入增长方式发生了明显的转变，即由过去的依靠企业税收变成了依靠其他税收尤其是营业税\n⏱ 2024-05-09 17:37:26\n\n\n与增值税不同，营业税主要是对建筑业和第三产业征收的税收，其中建筑业又是营业税的第一大户。所以，地方政府将组织税收收入的主要精力放在发展建筑业上是顺理成章的事情。\n⏱ 2024-05-09 17:39:07\n\n\n分税制作为一种集权化的财政改革，使得地方政府开始寻求将预算外和非预算资金作为自己财政增长的重点。预算外资金的主体是行政事业单位的收费，而非预算资金的主体是农业上的提留统筹与土地开发相关的土地出让收入。与预算内资金不同，这些预算外和非预算的资金管理高度分权化。对于预算外资金，虽然需要层层上报，但是上级政府一般不对这部分资金的分配和使用多加限制。而对于非预算资金，上级政府则常常连具体的数量也不清楚。分税制改革以后，为了制止部门的乱摊派、乱收费现象，中央出台了一系列预算外资金的改革办法，其中包括收支两条线、国库统一支付制度改革等等，力图将行政事业性收费有计划、有步骤地纳入预算内进行更加规范的管理，但是对于非预算资金，却一直没有妥善的管理办法，因此非预算资金也开始成为地方政府所主要倚重的财政增长方式。\n⏱ 2024-05-09 17:40:23\n\n\n这都促使企业、居民对城市建设用地的需求快速增长。由于大部分外向型经济位于东部沿海地区，所以在这些地区城市化发展得最为迅速，政府“经营城市”的发展模式也最为突出。要经营城市，就要大兴土木；要大兴土木，则需要大量新增的建设用地。在这个宏观背景下，土地征用和出让成为地方政府预算以及非预算收入最主要的来源。\n⏱ 2024-05-10 08:02:42\n\n\n按照《土地管理法》的规定，只有地方政府有权将农业用地征收、开发和出让，供应日益紧缺的城市建设用地，并且征收农业用地的补偿费用等成本远低于城市建设用地出让价格。地方政府低价征收农业用地，进行平整、开发后，可以招拍挂等形式在土地二级市场上出让。在东部沿海地区，地方政府通过这个过程迅速积累了规模巨大的土地出让收入。利用大规模的土地出让收入和已征收的大量城市建设用地，地方政府可以通过财政担保和土地抵押的方式取得更大规模的金融贷款来投入城市建设。这样以来，土地收入——银行贷款——城市建设——征地之间形成了一个不断滚动增长的循环过程。这个过程不但塑造了东部地区繁荣的工业化和城市景象，也为地方政府带来了滚滚财源。这些财源除了包括通过土地征收、开发和出让过程中直接得到的土地收入之外，还包括城市建设过程中迅速增长的以建筑业、房地产业等营业税为主的预算财政收入，这些收入全部属于地方收入，无需与中央政府共享。所以说，随着城市化的迅速发展，地方政府的预算收入和非预算资金（土地收入）呈现出双双平行的增长态势。因此，新世纪激烈的城市化过程是与地方政府“经营城市”、“经营土地”的行为取向密不可分的。在此过程中，地方政府形成了推动地方经济和财政收入双双增长的新发展模式。\n⏱ 2024-05-09 17:43:20\n\n第五章 转移支付体系的建立\n\n自上而下的规模巨大的财政转移支付，是分税制后中央和地方财政关系中一个最为重要的特点。\n⏱ 2024-05-09 17:44:13\n\n\n中央对地方的转移支付包括三大类：税收返还、专项转移支付和财力性转移支付。\n⏱ 2024-05-09 17:44:26\n\n\n[插图]\n⏱ 2024-05-09 17:44:58\n\n\n分税制将收入集中于中央而引起的地方财政缺口被认为是导致基层财政困难的主要原因，也就是学界所形成一定共识的“财权层层上收、事权层层下移”的效应。分税制虽然只是对中央和省级财政的收入划分做了规定，但是由于省以下的收入划分则由省政府决定，所以分税制造成的收入上收的效应就会在各级政府间层层传递，造成所谓的财权“层层上收”的效应[插图]。分税制后全国普遍流行一种这样的说法：“中央财政喜气洋洋，省市财政勉勉强强、县级财政拆东墙补西墙、乡镇财政哭爹叫娘”，可以在一定程度上反映出中央和地方的状况。其背后隐含的意思是明显的，就是中央“拿走了”本来应该属于地方的财力，而使地方财政尤其是县乡财政陷入窘迫的境地。县乡财政困难也被认为是90年代中期以后中西部地区农民负担问题日益严重的重要原因[插图]。但是，由我们介绍的转移支付体系来看，这种说法实际上是将问题过分简化了。中央“拿走”的部分实际上并没有被中央花掉，而是以转移支付的形式返还给了地方。我们如果只从总量来进行分析的话，将地方基层财政的困难归咎于分税制改革陷入有失公平。如果这些困难真与分税制有关系的话，问题应该出在转移支付上面。\n⏱ 2024-05-10 22:23:07\n\n\n分税制所划定的中央与省之间的关系几乎被完整地传递到县乡基层财政。\n⏱ 2024-05-12 11:56:16\n\n\n虽然分税制改革集中了县乡财力，扩大了收支缺口，但是通过转移支付几乎完全弥补了因改革带来的县乡财力减少部分，维持了与改革前相同的相对收支水平。\n⏱ 2024-05-12 11:57:39\n\n\n虽然分税制集中县乡收入的作用非常明显，但是其所造成的不断扩大的收支缺口已经被向下的转移支付弥补。从这个角度上来说，分税制本身不应该为县乡财政的困难状况负责。但这只是总量分析，如果转移支付的分配在地区间没有实现均等化，则亦会造成某些地区县乡财政的困难。\n⏱ 2024-05-12 12:01:14\n\n\n转移支付的作用有两个，一个是通过转移支付，实现地区间财政支出的均等化，使得各个地区的居民能够享有类似水平的公共服务；另外一个通过转移支付实现中央政府对地方政府的行为约制。\n⏱ 2024-05-12 12:02:01\n\n\n转移支付的均等化效应远弱于由于地区发展不平衡带来的不平等效应。\n⏱ 2024-05-12 12:03:49\n\n\n分税制在集中了地方财政的收入、提高了中央财政占财政总收入的比重之后，通过税收返还和转移支付补助的形式来弥补地方财政的支出缺口。从全国总的形势来看，基本是成功的。但是分地区来看，则存在着比较严重的地区不均衡现象。这无疑与分税制制度设计的初衷是有差距的。所以我们可以说，分税制实行十年以来，提高“两个比重”和“国家能力”的目的基本达到了，但是弱化地区间因发展速度带来的财力不均、公共服务水平不均的问题却不但没有能够解决，反而在一定程度上更加严重了。这主要是指中部地区严重落后于东部和西部地区而言。\n⏱ 2024-05-12 12:11:26\n\n\n单纯的讨论财政的收入、支出和转移支付的分配，只是财政的一个方面即“财”的方面，要真正全面理解这些收入分配背后的影响因素，还应深入到政府行为的层面即“政”的方面。分税制作为一次意义深远的制度变革，在集中财政收入、加强转移支付的同时，还对政府和企业的关系以及地方政府的预算外收入产生了巨大的影响，这在很大程度上重新塑造了过去十年来地方政府的行为模式。\n⏱ 2024-05-12 12:12:21\n\n\n与此同时，分税制改革对中央和地方关系、区域间关系以及政府和企业的关系也产生了重大而深远的影响，这些影响在分税制实行十年以来逐步呈现出来。首先，在中央和地方的关系上，中央财政的实力以及所谓的“国家能力”不断加强。中央财政不但独立于地方财政，而且地方财力的近三分之一需要中央财政拨付转移支付进行补助。通过这种先集中财力、再进行补助的方式，中央实际上掌握了对财政收入的再分配权力，加强了中央权威，比较彻底地消除了财政上“诸侯割据”的潜在危险。另一方面，通过设立独立于财政、垂直管理的税收征管系统，在一定程度上解决了改革前“利税”不分、地方政府“藏富于企业”的老问题，能够有效地保证经济增长带来的收益被国家财政分享。与此同时，地方政府尤其是中西部地区的地方政府在财政上对中央的依赖性也大大增强。\n⏱ 2024-05-12 12:13:56\n\n\n认为分税制是造成中西部地区基层财政困难的原因的说法有一定的片面性。分税制虽然通过税收共享从地方政府集中了收入，但是转移支付制度又将大部分集中的收入拨付到地方政府进行支出，所以说地方政府由于税收分享造成的财政缺口大部分得到了弥补。但是，由于转移支付的分配存在区域间的不平衡，使得地区间的财力差距不但没有越来越小，反而呈现出逐渐拉大的趋势。从全国趋势上来看，在过去的十年里，东部地区靠工业化、西部地区靠中央补助使得人均财力都有明显而迅速的增长，唯有中部地区基层政府、尤其是县乡政府的人均财力增长缓慢，也与东部与西部的差距越来越大，这说明转移支付制度还有待于进一步完善。\n⏱ 2024-05-12 12:18:57\n\n\n分税制之前，企业按隶属关系上缴税收，使得地方工业化带来的收益大部分保留在地方政府手中，这使我们看到自80年代到90年代中期全国兴盛一时的乡镇企业。众所周知，乡镇企业作为一种集体产权的企业组织，其竞争能力在很大程度上来自于地方政府的大力扶持。分税制改革之后，所有企业的税收都要与中央分享，而且税收系统独立于地方政府，这导致地方政府能够从企业中得到的财政收入大为减少，办集体企业的热情迅速下降，我们看到了90年代中期以后乡镇企业大规模转制的现象。\n⏱ 2024-05-13 01:07:57\n\n\n我们看到，过去描述的所谓中央与地方“一放就乱、一收就死”的关系在最近几年里已经不再适用，中央尽可以加强规范、集中收入，但是地方政府和地方经济并不会因此被“管死”，而是不断挖掘出新的生财之道。所以，分税制带来的集权效应并非全面而有效的，除了集中了部分地方的预算内收入之外，最多只能算作“表面集权化”。所以如果只讨论分权和集权的优劣之处而不讨论预算约束，对于中国这样一个大国来说意义是非常有限的。\n⏱ 2024-05-13 01:11:45\n\n第六章 县乡财政危机\n\n中国的财政体制是所谓“下管一级”的体制，即中央与省、省与地市、地市与县、县与乡镇分别制定两级政府间的财权和事权的划分办法。这意味着中央不会对省以下的政府间财政体制进行过多干预，而最基层的县与乡镇间的财政体制也甚少受到来自中央、省、地市的直接干预，有着相当大的自由度。\n⏱ 2024-05-13 01:12:50\n\n\n中央和省之间的财政体制对于下辖各级政府间的体制起着示范的作用，下级政府间的体制通常会与中央与省之间的体制大致相似。\n⏱ 2024-05-13 01:13:09\n\n\n在分税制之前，各级政府间普遍采用的是中央与省之间的“财政包干制”，县乡之间也是如此。县与各乡镇之间一般实行指标任务式的“一揽子包干法”，在包干的基础上对于超额完成任务的和不能完成任务的乡镇分别采取奖励和惩罚的措施。这种体制每隔三到五年要进行一次调整，主要变化的就是包干任务和超收、欠收的奖惩办法，另外对于支出责任也可能会根据实际情况的变化进行一些相应的调整。\n⏱ 2024-05-13 01:14:53\n\n\n一般而言，财政的支出责任可以总结为“三保”，即“保工资、保运转、保建设”。保工资就是要保证行政和事业两大类部门工作人员的工资发放；保运转则是要为各行政和事业部门配备日常办公经费，这些经费包括办公用品、会议、差旅、招待费用等等，一般是按照财政供养人员数来配备；保建设则是指一些常规性的公共维修和建设项目。\n⏱ 2024-05-13 01:18:46\n\n\n财政包干体制在县乡间的表现形态。激励作用是非常明显的，对于超收乡镇而言，增大超收部分所得的收入全部是可以自由支配的“活钱”，而对于欠收乡镇而言，完成收入基数就意味着不必东拼西凑地去填补支出基数。这个体制对于我们理解乡镇政府的行为有很大的帮助。\n⏱ 2024-05-13 01:21:52\n\n\n在地方的实践中，乡镇政府要实现自己可支配收入的最大化，并非一味地以收入最大化为目标。因为在这种包干制下，在一个体制周期内收入的快速增长会提高下一周期内的收入基数和收入任务数，这会造成下一体制周期内完成任务的难度，并造成自身收入的减少。因此，乡镇政府的行为策略是应该与乡镇政府官员的任期制结合在一起理解的。如果一个官员为了博取很快的晋升，他可能会尽全力增加其任期内的财政收入；如果一个官员预期到自己会在相当长的一段时间内留在本乡镇，则他可能会对收入增长的速度进行“控制”。\n⏱ 2024-05-13 01:22:00\n\n\n分税制与包干制最大的不同在于“分税”，即对不同的税种采用了不同的税收分配办法，而且彻底改变了过去按照企业隶属关系划分税收的办法。例如就增值税而言，全国所有工业企业，无论其所有权性质如何，无论其归哪一级政府部分所有，无论其所在地在何处，都是按照中央和地方75∶25的比例进行分配。这种“一竿子捅到底”的办法实际上在一定程度上突破了原有的“下管一级”的财政体制，使得从省到县和乡镇都要对中央共享税收的分配办法作出反应。\n⏱ 2024-05-13 01:24:11\n\n\n所谓“分税包干”，就是分税种进行包干。对于省级政府而言，其本级所属的大型工业企业的增值税和消费税被中央按照分税制方案划走绝大部分之后，本级的财政收入锐减，不能够满足其支出需要。在这种局面下，中西部地区的许多省份仿照分税制的设计，与省以下的财政单位也开始实行分税种的收入分享制度。这种分享我们可以称之为“省内分税制”。\n⏱ 2024-05-13 11:17:19\n\n\n这种“省内分税制”非常可能导致各地区和市级财政单位亦步亦趋地实行“地市分税制”，即地市与县及以下单位也会划分一些共享税收。我们可以将这种层层共享税收的体制称之为“层层分税制”。\n⏱ 2024-05-13 11:17:59\n\n\n“层层分税制”鲜明地展示出分税制对于省以下政府间财政关系的影响。中央政府虽然只是规范了与省级之间的税收分配关系，但是却如“一石激起千层浪”般地使得省以下各级政府纷纷进行分税种的税收分享改革。\n⏱ 2024-05-13 11:19:11\n\n\n虽然从全国的总量上来看，中央集中的税收收入大部分都作为税收返还和转移支付下拨到了地方乃至县级财政，但是从结构上来看，转移支付既存在着地区上的不平衡，也存在着拨付方式上的缺陷。从地区上来看，中部地区的县乡财政得到的人均转移支付是相对最少的；从拨付方式上看，虽然西部地区得到的转移支付并不少，但是大部分是以专项转移支付的形式下拨的。专项转移支付不是财力性的补助，不能担负起“保工资、保运转”的支出责任，而且这些资金的分配、使用都不能由基层财政做主。从时间上来看，财力性的转移支付直到2000年也只占到转移支付总量的10%稍多一点，完全不能够对分税制后县乡财政的缺口起到真正的弥补作用。\n⏱ 2024-05-13 11:24:56\n\n\n“层层分税制”迅速向上集中了财力，“基数包干法”又对下级财政的增收施加了巨大的压力，而转移支付又没有迅速到位。这就是分税制推行之后中西部地区的县乡财政面临的基本局面。基层财政的困难最直接地表现为90年代中期以后迅速变得异常突出的农民负担问题。\n⏱ 2024-05-13 11:26:03\n\n\n在这种情况下，乡镇政府不得不“各出奇谋”，想尽办法来调用、转借其他的资金以填补财政收入的“亏空”，因为如果财政收入达不到基数，县财政的工资补助收入也不会全额下拨。一种比较常见的办法是，是将一笔非预算资金“调入”预算内作为财政收入上缴县国库，县财政再把这笔资金当作预算内的财政支出（例如工资）拨付给乡财政，这样一笔非财政收入实际上是被当作财政收入在县乡之间“转”了一圈，所以有些地方财政干部将这种办法称为“空转”[插图]。\n⏱ 2024-05-13 11:32:29\n\n\n至此为止，我们对工资拖欠问题有了一个明确的答案，即乡镇政府通过筹借资金“完成”了财政收入的包干基数，在上缴县级财政、又得到县财政拨付的工资款之后，必须先拿出一部分去偿还调用、转借和借贷来充作财政收入的资金，这样才导致了工资的拖欠和乡镇财政运转的困难。如果不能及时偿还，便形成了基层政府的负债。这样，乡镇政府就陷入了一个两难的境地：如果要及时全额发放工资，就会形成负债，而且由于借款多来自于企业和民间，不偿还就丧失了“信用”，以后就会告贷无门；如果要及时全额还清贷款，工资就发不了，而“保工资”是乡镇领导的第一要务。实际的运行策略是，工资发一些，旧债还一点。结果工资拖欠避免不了，债务也越积越多。\n⏱ 2024-05-13 11:33:38\n\n\n[插图]\n⏱ 2024-05-13 11:43:43\n\n第七章 基层政权的“悬浮”状态\n\n农民负担问题之所以非常重要，因为它直接关系到乡村社会的稳定。在中国的传统政治中，这也是一个中心的问题。历代的王朝兴衰更替，除了外族入侵是一个直接的外部因素之外，沉重的农民负担导致民不聊生是重要的内部因素。历代统治者都极为重视农民负担问题，被看作是“国之大本”[插图]。\n⏱ 2024-05-13 20:54:36\n\n\n从表面上看，税费改革的主角是两个，即中央政府和农民。中央政府付出了巨大的财政资金来补偿因为改革带来的财政缺口，农民则直接从中受益。但从改革的执行和后果来看，真正的主角是地方政府。虽然按照改革的设计，地方政府能够维持改革前的财政收支状况，但在实际过程中，农村地方政府，尤其是县乡村三级政府和组织却受到了前所未有的巨大冲击，其中尤以乡镇政府为甚。首先是乡镇政府的职能和角色开始受到普遍的质疑。作为五级政府中最低的一级，乡镇政府在改革前的实际职能被概括为“三要政府”，即“要钱、要粮、要命”，分别是收取税费、定购粮和开展计划生育。定购粮自90年代后期已经基本名存实亡，而计划生育工作也随着社会发展和人口素质的提高变得不那么困难，最困难的“要钱”任务则被税费改革一举取消。在这种形势下，有学者和政策研究人员提出应该取消乡镇一级政府，或者将其作为县级政府的派出机构。其次，中央和地方基层政府的关系、尤其是县乡村的关系正在发生深刻的变化。税费改革以前，基层政府的财政主要依靠地方税收（包括地方的工商税收和农业税收）、各种摊派和收费。对于大部分中西部地区的农村而言，收入结构的特点是费大于税、农业税大于工商税；而改革取消了农村收费和农业税之后，这些地区的基层政府收入开始越来越依靠上级政府尤其是中央政府的转移支付补助。这些补助不但包括税费改革转移支付和农业税降低转移支付，还包括越来越多的名目繁复、数量巨大的专项补助。改革伴随着巨大的财政资金由中央向中西部的地方流动的开始。用政策语言来说，税费改革是“公共财政反哺农村”的开始。\n⏱ 2024-05-13 22:14:36\n\n\n从改革的设计和初衷来看，两个目的是非常明显的。一个是减轻和彻底取消农民负担，另一个是逐步在农村建立公共服务和公共事业体系，即不是靠向农民收钱、而是由政府的公共财政体系来负担地方的公共建设。但是执行的任务非常艰巨：一是要保证农民负担不再反弹，避免所谓的“黄宗羲定律”[插图]；二是要建立有效、公平的公共服务体系。这两个任务的成败却主要取决于位于中央和农民中间的地方政府。更直接而言，取决于地方政府财政收支的状况和财政体系的运行效率。也就是说，税费改革表面看来是国家与农民关系的调整，而实质上改革的关键却在于中央和地方关系的调整。因此，理解新型的国家—农民关系的关键在于我们对地方政府行为的理解。\n⏱ 2024-05-13 22:11:33\n\n\n农村基层政府的财力主要有三个大的部分计算而来：本级收入（预算内收入）、补助收入或上解支出、预算外收入。其中本级收入是指经过财政体制划分之后属于本级政府的收入；而补助收入则是指上级政府为了弥补本级政府的支出，而拨付的各种补助或者转移支付。通常财政上计算一级政府的“可支配财力”时，采用“本级收入+补助收入-上解”的办法，这也等于本级政府的预算内支出的总量。预算外的收入和支出通常单独计算，所以“可支配财力”的概念并不包括预算外的部分，但是实际上，预算外收入无疑是构成政府财力的一个重要部分。\n⏱ 2024-05-13 22:15:06\n\n\n造成乡镇财力下降的直接原因是转移支付和农业税增加额不足以弥补原来的“三提五统”收费。\n⏱ 2024-05-14 12:44:36\n\n\n按照财政部《农村税费改革中央对地方转移支付暂行办法》（财预【2002】468号文件），我们得到：某地区转移支付额=乡镇转移支付+村级转移支付+教育集资转移支付其中：该地区乡镇转移支付=（该地区乡村两级办学经费+该地区计划生育经费+该地区优抚经费+该地区乡村道路修建经费+该地区民兵训练费+其他统筹支出+该地区屠宰税减收+该地区农业特产税政策性减收-该地区农业税增收）×该地区转移支付系数[插图]我们可以看到，乡镇转移支付的计算依据实际上就是原来“五项统筹”的内容。而乡镇转移支付是税费改革转移支付中最大的一个部分。这说明中央对地方计算的时候，实际上是根据地方改革前的乡统筹为基础来计算的。有意思的是，在税费改革前，财政部要求各地上报“三提五统”等农民负担的实际数量，而各地政府因为并不知道这个上报数是为了计算转移支付，反而以为是对农民减负工作的检查，所以大部分上报的要少于实际数。而中央对地方转移支付的测算则是以这些上报数为主要依据。\n⏱ 2024-05-14 12:46:20\n\n\n县级政府在向下进行税费改革转移支付时，对事权进行了一些实质性的调整。正是这些调整使得税费改革转移支付有相当大的一部分并没有发放到乡镇政府中去。这些调整中主要的方面包括农村义务教育与乡镇人员工资的发放形式。\n⏱ 2024-05-14 12:46:32\n\n\n在改革以前，小学和初中公办教师的工资是由乡镇的预算内财力进行支付的，而改革以后，则由县财政的预算内财力直接支付，即县财政直接将工资发放到全县每个公办教师的个人银行账户上去，不再和乡镇财政发生任何关系。从表面上看，县财政的负担增加而乡财政的负担减轻，实际上并非如此。如我们在上一节所述，县乡之间的预算内财力分配是由县乡财政体制决定的。改革以前，县级政府会在体制中为各乡镇安排发放教师工资的财力，而改革以后，则不再安排这一部分财力。一个简单的做法是，各乡镇将原来用于发放教师工资的财力上解到县财政，由县财政直接发到教师个人账户里去。实际上，这些财力本来就放在县级国库里，所谓“上解”，其实就是县财政不再下拨到乡镇而已。从财政上说，发放教师工资不再是乡镇财政的事权，而变成县级财政的事权，所以叫作“以县为主”。改革的主要意义在于解决乡镇财政因为自身困难而拖欠、挪用教师工资的问题。\n⏱ 2024-05-14 12:51:35\n\n\n“以县为主”的主要内容是教师工资由县财政统发，而办学的其他费用，如学校运转的公用经费，县财政很少负担，主要由学校直接向学生收取的杂费负担。\n⏱ 2024-05-14 12:51:51\n\n\n那么，县政府为什么就能够“名正言顺”地将转移支付中的“乡村办学经费”留在县里呢？这是因为“以县为主”以后，虽然名义上乡镇政府仍负责民办教师工资和学校日常运作费用，但这些支出责任实际上已经有名无实。民办教师大部分分布在小学，初中的民办教师非常之少，而小学民办教师的补助按照历来的“三级办学”体制（村负责小学、乡镇负责初中、县政府负责高中），是村级的责任。教师工资统发一般伴随着对民办教师的清退、转正工作，而且是以“清”为主、以“转”为辅。所以在实现“以县为主”后，民办教师的工资支出已经是很小的一部分了。而学校的日常运作则主要依靠向学生收取的杂费，只是在运转十分困难的时候，校长才会去找乡镇政府要求补助。如果是小学，则要先找村长，村里办不成，再和村长去找乡长。能否得到、得到多少，都很难说。而在这种形势下，县政府将转移支付的办学经费留在县里，乡镇政府也难有异词。\n⏱ 2024-05-14 12:53:27\n\n\n对于财政和金融机构而言，资金的流动和时间上的延迟是生财和用财的关键因素。\n⏱ 2024-05-23 10:50:53\n\n\n工资支出，看上去虽然像是刚性的、专门的支出款项，但是由于这是财力的主要部分，乡镇政府经常用来应急。工资如果能晚发一个月，资金的运用余地就大大增加，这相当于增加了其政府财力。在税费改革以前，乡镇政府有“统筹费”来调度使用，这相当于基层政府运转的“润滑剂”。税费改革以后，这笔“润滑剂”缩水，乡镇政府必然会挤占、挪用其工资支出来维持乡镇的运转和日常工作。\n⏱ 2024-05-23 10:51:58\n\n\n事权上收、工资统发作为税费改革的后果或者配套措施，使得乡镇财政变得越来越“空壳化”。\n⏱ 2024-05-23 10:53:30\n\n\n工资的统发制度则实际上将乡镇财政完全“挖空”。全额财政供养人员的工资统发以后，乡镇的财力便只剩下了公用经费和税费改革转移支付，而这两部分的资金分配也逐年减少。\n⏱ 2024-05-23 10:55:11\n\n\n与事权上收、工资统发相伴随的另外的变化就是县乡关系全面的重新调整。首先，在对税费改革转移支付的向下分配中，县级政府并不是简单计算财政缺口，而是重新规定支出标准。也就是推翻改革前对乡镇财力缺口的测算，重新制定一套乡镇的事权分配方案。其次，在县乡财政体制对财权的分配中，农业税的征收不再是重点，工商税收变成了原来那些农业乡镇的主要工作任务。\n⏱ 2024-05-23 10:57:27\n\n\n乡镇预算外收入的减少和转移支付的分配方案实际上的效果是“硬化”了乡镇的预算约束。一方面，将一些有收费项目的支出责任直接上收到县级执行，另一方面，分配到乡镇的转移支付资金都附加了各种条件。在这两个过程中，县财政集中了越来越多的乡镇财力，而乡镇财政的预算权力则被减到了最小化。对于乡镇财政来说，这当然是巨大的代价。而改革之所以能够顺利进行，没有遇到大的阻力，是因为在执行过程中，县级政府采取了一些补偿性的措施。\n⏱ 2024-05-23 10:59:17\n\n\n从表面上看，县级政府截取了大部分的税费改革转移支付，但实际上这些转移支付资金中许多被用来提高乡镇的支出基数，即乡镇政府人员的工资和公用经费。\n⏱ 2024-05-23 11:00:03\n\n\n总结税费改革以后政府间关系的变化，我们发现主要在两个方面。一个是通过对事权和支出责任的再划分，乡镇财政基本上变成了空壳财政，大部分财政资金都是用于发放乡镇人员的工资，处于“有财无政”的状态；另一方面，乡镇人员的工资比改革前变得更有保障，旨在“养廉”以防聚敛。这对于乡镇政府的行为模式产生了巨大的影响。\n⏱ 2024-05-23 11:00:54\n\n\n总结起来，借债有两个主要的来源。每年年底，许多乡镇政府都会向县财政打报告，以各种名义要求补助。这些补助，在县政府看来都是“暂借款”，而在乡镇看来都是“赞助款”或“困难补助”，是不打算还的。另一个办法是乡政府干部用个人名义，向民间借款。这些借款一般具有小额、多笔、高利、短期的特点，主要用于维持政府运转，有时也用来充当税款，完成收入基数。这些借款多发生在年底，是为了还旧债和借新债。\n⏱ 2024-05-23 11:14:41\n\n\n总而言之，税费改革以后，乡镇政府的行为由向农民收取税费一变而为借钱和“跑”钱。借钱和跑钱，一要靠上级政府，二要靠民间的有钱人。税费改革，在使得基层政府更加依赖于上级政府的意义上是一种集权化式的改革，它产生的另一个也许是更加深远的影响在于，基层政权运作的基础正在发生悄悄的改变，民间的富人和富裕阶层正越来越成为乡村两级政府组织所依赖的对象。\n⏱ 2024-05-24 17:19:35\n\n\n从本章的分析可知，税费改革在减轻和取消农民负担的同时，开始对中央和地方政府、地方政府和地方政府之间的关系产生巨大的影响，收入和支出的分权框架逐渐消失，对于以农业收入为主的县乡政府而言，其财政收入的主要部分开始由农业税费变成来自中央及上级政府的转移支付。而农村公共事业的支出责任也在调整和改革中逐渐上移。\n⏱ 2024-05-24 17:22:13\n\n\n税费改革通过取消税费和加强政府间转移支付来实现基层政府财政的公共管理和公共服务职能，力图将国家—农民的“汲取型”关系转变为一种“服务型”的关系。在这个过程中，中央政府通过加强预算和预算外管理、转移支付制度和对资金的监管来控制地方政府的行为，而地方政府内部的关系也发生了很大的调整和改变，其中县乡体制的调整、转移支付制度的设计和具体化以及“以县为主”、“工资统发”的改革都是为了配合税费改革的实行而做出的积极调整。改革取得了明显的成效，即农民负担大为减轻，地区间均等化的转移支付框架初步建立了起来，由上而下、用东到西的转移支付资金替代农民税费成为中西部地区基层政府财政收入的主要来源。但是，税费改革的更深层次的目标，即转变基层政府职能、实现国家和农民的“服务型”关系并没有完成，而且出现了一些意外的后果，其中最为重要的就是以乡镇政府为中心的基层政府行为的“迷失”。我们看到，乡镇财政在变得越来越“空壳化”，乡镇政府的行为则以四处借贷、向上“跑钱”为主，不但没有转变为政府服务农村的行动主体，而且正在和农民脱离其旧有的联系，变成了表面上看上去无关紧要、可有可无的一级政府组织。\n⏱ 2024-05-24 17:29:29\n\n\n即使乡镇政府不被取消，“悬浮型”政权的特征也已经越来越凸显出来。\n⏱ 2024-05-24 17:34:08\n\n第十章 专项资金在基层：农村义务教育\n\n从国家政策的角度来讲，我国农村义务教育的管理体制叫作“在国务院领导下，由地方政府负责、分级管理、以县为主”。从这个体制上看，各级政府对义务教育均有不同程度的投入，而以县级政府的投入力度最大。\n⏱ 2024-05-27 17:35:11\n\n\n首先，税费改革促进了民办教师和代课教师的清退工作。由于这些非公办教师的工资来自于乡统筹中的农村教育费附加，税费改革取消了这笔收费之后，非公办教师的工资来源便没有着落。新拨付的税费改革转移支付资金属于预算内资金，只能用来补发公办教师的工资，不能用于这些非财政供养人员的工资支出。在我们调查的两个县，民办教师和代课教师都是在税费改革的前一年(2001)就已经清退干净。其次，税费改革并没有使教师工资拖欠的问题得到解决。从我们上一节的分析得知，工资拖欠的主要原因是入不敷出和虚假收入，而税费改革并没有解决乡镇财政的收入问题，反而通过杜绝收费，使得乡镇财政的日子更加难过。在这种情况下，教师工资的拖欠问题必然是更加严重了。再次，税费改革使得公用经费和校舍建设资金成为乡镇财政无法解决的问题。在税改以前，公用经费就非常不足，这是由于乡镇财政预算内收入本身不足的缘故。而校舍建设和危房改造的部分资金则来自乡镇财政的收费、集资、借款和欠款。税改之后，这些非规范收费的路被堵死，学校的经费自然就更加没有着落。\n⏱ 2024-05-28 00:55:05\n\n\n“以县为主”之所以能够保证教师工资的足额发放，主要由于两个方面的原因。一个是部分“挤占”了乡镇财政的“水分收入”，这部分“收入”如果是由乡财政来发，只能用于“空转”或者“还债”，是无法用来发工资的，另一个原因在于利用了税费改革导致的县级财政收入中农业税的增加。而农业税之所以能够增加，是由于“并费入税”，实际上是将原来乡镇政府的一部分收费算在其中。所以说，解决教师工资拖欠问题，并不是县财政拿出了另外的财力，也并非由于上级增加的转移支付，而是属于“羊毛出在羊身上”，实际上是将一部分乡镇财政的“虚假收入”和一部分改革前的乡镇收费集中上来，统一发放了教师工资，直接由县财政将工资付到教师个人的银行账户之上，一举解决了教师工资拖欠问题。从财政资金运行的意义上说，这实际上就是将一部分财政资金通过由县财政设立了一笔统一、直接发放的“工资专项资金”，绕过了乡财政，但是有意思的是，这笔资金的真正来源还是乡财政。这种根据支出用途、利用上级财政直接以类似于专项资金的支配方式使用财政资金的方式，正是此后各类财政资金“专项化”的滥觞。\n⏱ 2024-05-28 00:58:40\n\n\n税费改革不但促进了“以县为主”体制的实行，而且也能够保证县级财政有比较足够的财力来发放教师工资。换句话说，“以县为主”紧跟在税费改革之后实行，实际上是把税费改革带来的县级财政增收给了教育。\n⏱ 2024-05-28 00:59:46\n\n\n“以县为主”解决了义务教育教师工资的问题，但是并没有解决好公用经费和学校建设的资金问题。\n⏱ 2024-05-28 01:01:26\n\n\n对于中小学而言，日常的办公费用、学校运转所需的费用有两个基本的来源，一个是从学生手中收取的杂费，收费标准比较严格且总额较少，勉强可以满足书本、体检、水电等开支，而学校的教学设备，从粉笔到课桌板凳、从开运动会到体育器械，都需要从财政的公用经费中列支，这是学校运转的另一个经费来源。\n⏱ 2024-05-28 01:02:40\n\n\n这种基层财政的运作方式虽然不够规范和透明，但是由于政府与基层社会接触密切，信息沟通充分，能够解决很多实际出现的问题。实际上，这也正是乡镇一级财政存在并能发挥作用的意义所在。而随着“以县为主”和“税费改革”的展开，这种局面也彻底改变了。“以县为主”的教育体制几乎完全取消了乡政府对教育的投入责任，当然包括公用经费。\n⏱ 2024-05-28 01:09:08\n\n\n乡政府在“以县为主”的体制中地位尴尬。按照“以县为主”的规定，乡镇政府的领导们都异常轻松，在我们的访谈中，他们在谈到以后教育问题时，都表现出一副“事不关己、高高挂起”的姿态，但是在实际的执行过程中，他们又无法作壁上观。造成这种尴尬局面的根本原因，还是在于县级财力的紧张状况。\n⏱ 2024-05-28 11:20:37\n\n\n可以预见的是，在县乡财力没有迅速增加、县乡财力持续紧张的情况下，“以县为主”的体制很可能又回到以前“以乡为主”的“东拼西凑”的老路上去。\n⏱ 2024-05-28 11:21:15\n\n\n随着专项资金数量和种类的迅速增加，层层上报、审批成了地方政府最为主要的工作之一，也成为地方政府获得上级资金的主要管道之一。有的地方官员说，地方干部最主要的考核目标是“招商引资”，这四个字实际上是两件事，“招商”是指从发达地区招揽企业和投资，而“引资”就是去上级部门跑资金、跑项目。而跑资金、跑项目最重要的是靠“门路”和“关系”。\n⏱ 2024-05-28 11:24:25\n\n\n一个村的项目和财政资金多少主要不是和这个村的需求有关，而是和村领导的跑项目的“能力”有关。\n⏱ 2024-05-28 11:24:43\n\n\n只要项目的分配不尽合理，一般都会带来严重的使用效率问题。效率问题主要表现在这样几个方面。一是违规使用。我们在调查中发现，除了扶贫款、救灾款等少数几项被称为“高压线”的专项资金之外，拖延、截留、挪用、挤占专项资金的现象非常普遍；二是“一女多嫁”。搞一个农田水利项目可以以多个项目的名义从财政、水利、扶贫等部门套取多笔专项资金；三是“假配套”。由于专项资金一般要求地方政府各级配套下达，而地方政府又无能力进行配套，所以在专项之间腾挪借用搞“假配套”的现象屡见不鲜。\n⏱ 2024-05-28 11:26:17\n\n第十一章 发达地区的基层财政\n\n因为与以往的财政包干制度相比，分税制更注重效率而非地区间的绝对平均，所需要引起关注的只是如何加强和完善配套的转移支付制度而已。\n⏱ 2024-05-29 01:32:25\n\n\n如果说预算内的财政是受到市财政部门核定支出、严格控制的“吃饭财政”，那么预算外的财政收支才是真正体现乡镇政府的公共财政功能、提供服务和搞建设的乡镇财政，我们可以将其称为“办事财政”，这也是发达地区区别于不发达地区的一个最重要的方面之一。\n⏱ 2024-05-29 01:37:23\n\n\n我们可以看出南海的乡镇财政与不发达地区的“吃饭财政”和“要饭财政”相比，具有这样几个鲜明的特点：首先，其预算内财政也是“吃饭财政”。虽然与不发达地区相比，南海乡镇预算内财政的总量很大，但是大部分都上缴到上级财政单位尤其是市级财政使用，所以留在乡镇一级的财政收入仍然主要用于工资和日常运转支出。其次，“吃饭”的开支和“办事”的开支在财政体制上是分开的。在不发达地区，我们看到非常严重的预算资金的互相“挤占”的情况，通常是“吃饭”的钱挤掉了“办事”的钱，而某些不得不办的“大事”如校舍修建、道路建设又反过来挤占“吃饭”的钱或者是干脆举债或从农民手里收钱，加重农民负担。但是在南海这种“挤占”现象不存在，因为办事（各种公共财政开支）的钱都是从预算外财政里出，这也是我们将这部分财政称为“办事财政”的原因。这种做法可以消除挤占现象，保证公共建设的开支，当然也有潜在的问题。正如我们前面的分析所言，在市和镇的财政关系中，乡镇财政通过把大部分地税收入的财政权限交给市级财政而得到了对预算外也就是“办事财政”的财政权限，市级财政对“办事财政”的支出并无控制和干预，所以在某种程度上，乡镇财政的“办事财政”实际上也是一个“独立财政”，缺乏上级部门的控制和监管。随着工业化的深入和经济的发展，我们有理由相信这一块独立财政会迅速膨胀，而乡镇政府也有这样的动力。再次，用于“办事”的钱主要来自土地的非农化。国家作为一个利益主体，虽然没有得到由土地非农化带来的直接收益，但是通过征收企业的增值税等国税税种也参与这种“以土地为中心”的工业化收益的分配。只不过向其纳税的这些企业都是一些没有办理国家征地手续的“空中工厂”而已。市级政府不是土地的所有者，不能分享地租这种工业化的土地直接收益，但是通过汲取大量乡镇一级的地方税收，而最大化地参与了工业化间接收益的分配。但是这种分配是以与乡镇政府的妥协为代价的，妥协的结果就是乡镇政府可以建立起一块以土地的直接和间接收益为中心的“土地财政”，并且对其具有完全的财政权限。在这部分财政里，既有土地带来的直接收益（地租或土地有偿使用费），也有土地非农化带来的间接收益（治安、教育、文化的各种收费）。随着这部分财政独立性的增强，必然迅速膨胀开来，其经济和社会的影响有待进一步的考察和分析。\n⏱ 2024-05-29 01:41:33\n\n第十二章 土地征用和政府的土地收入\n\n目前我国土地的所有权有两种形式：全民所有制和集体所有制。全民所有制即国有土地，我国所有的城市土地均为国有，按照1982年的宪法修正案规定，“城市的土地属于国家所有”（第10条）；集体土地所有权则属于农村集体。\n⏱ 2024-06-03 00:39:27\n\n\n土地收入是指政府通过征税、收费或者经营形式获得的、与土地征用和出让有关的收入。其中既包括了通过土地出让得到的土地出让金，也包括了各种与土地有关的税费收入。严格来说，土地出让金并非政府的财政收入，而是通过土地开发和出让得到的“准经营”式的收入，是土地使用方“一揽子”向政府缴纳的整个使用权期限内的租金。\n⏱ 2024-06-02 23:50:22\n\n\n国家征收土地增值税，主要目的是为调节房地产开发市场的秩序，抑制房地产开发、转让的暴利行为。因此，这一税种的征收，最主要受到影响的还是房地产开发企业，特别是开发别墅、公寓、写字楼等高档项目的开发商，以及炒卖楼花的个人买卖行为。因为《条例》规定：纳税人建造普通标准住宅出售，增值额未超过扣除项目金额（开发成本及税费）20%的，国家免征土地增值税。因此从这点来说，个人购买房屋如果购买的是普通标准住宅，而且是用于自己居住的，一般不会受土地增值税影响。而如果购买的是高档次规格的房产，由于开发商的利润率（增值额）许多都超过了土地增值税开征的最低限额，这部分开发商必然要缴纳一定比例的土地增值税，这样开发商的开发收益就会相对减少。\n⏱ 2024-06-02 23:53:40\n\n\n土地出让金不是税费，而是政府出让土地得到的租金。这笔租金实际上是一笔支付的多年租金，从资金性质上来看，是用地企业的预付资金。\n⏱ 2024-06-02 23:58:29\n\n第十三章 土地财政\n\n地方政府流行的说法“第一财政靠工业、第二财政靠土地”说明了二元财政的收入来源，“吃饭靠第一财政、建设靠第二财政”，则说明了二元财政的支出。\n⏱ 2024-06-03 00:05:55\n\n\n综合长安区和绍兴县的情况来看，土地收入无疑是地方财政的支柱。在绍兴，无论是预算内还是预算外土地收入都是最为重要的部分。为什么在这些地区会形成这种以土地收入为主的二元财政结构？对于地方政府而言，这种结构的形成有赖于外生和内生因素的共同作用。外生的因素就是当前的土地、财政和税收体制，而内生的因素是地方政府在当前体制下的谋利行为。分税制改革以来，中央将一般预算内的主体税种划分为中央收入，而将非主体税种划分为地方收入。同时，由于在1994—2002年间被划分为地方收入的企业所得税和个人所得税增长迅速，2002年中央又把这两个所得税划为中央地方共享收入。这种集中财力的努力给地方政府的收入行为带来了一种“挤压”效应，即迫使地方政府不断把增加地方财政收入的重心移向那些零散、量小、不重要的税种。在所得税变成中央共享税之后，我们看到自2002年以来，营业税的增长异常迅速，成为带动地方财政收入增长的最主要力量，这明显就是“挤压”效应的结果。\n⏱ 2024-06-03 00:08:49\n\n\n中央伴随分税制改革的另一个努力在于预算制度改革。预算制度改革主要内容是将预算外的资金纳入预算内进行管理，同时推行国库集中支付制度和预算外资金的“收支两条线”的管理办法，力图使得地方政府的资金收支透明化、管理规范化。由于预算内资金的管理是相对集权化、透明化的，而预算外资金对于地方政府来说相对自由度较大，如果将预算外资金纳入预算内管理的话无疑限制了地方政府的支出权限。这就造成了第二个“挤压”效应：地方政府力图做大那部分没有纳入预算内管理的预算外收入，而其中最主要的就是以土地出让金为主的土地收入。\n⏱ 2024-06-03 00:09:39\n\n\n在双重“挤压”效应之下，对于地方政府的财政来说，预算内财政增收的重点变成了营业税和土地税收，而预算外财政增收的重点就是土地出让金。\n⏱ 2024-06-03 00:10:15\n\n\n预算外的土地出让金部分的主要使用途径有三个：首先是用于土地开发和转让成本，这包括对农民的补偿和“三通一平”“五通一平”的成本，正如我们在分析土地出让金的时候所指出的，这部分不包括在土地出让金的净收益中。土地出让金的净收益，主要用于两个方面。一个是用于补充财政支出和土地征用的其他成本。土地出让金是政府手中的“活钱”，缺少预算约束，这些资金虽然许多都是通过财政部门支出的，但与正规的财政资金支出制度完全不同。政府征用和出让的土地分成三大类，公益性、工业化和经营性，分别采取划拨出让、协议出让和招拍挂的出让方式。对于公益性土地出让（公路、水利、教育、卫生等等），政府的土地开发收入并不足以弥补土地开发的成本，所以这里政府一般要“倒贴”，但是具体倒贴多少，倒贴的部分到底是从土地出让金中支出还是靠银行贷款，各地的情况并不相同，我们也缺少具体的数据。另外，对于工业性用地的开发，地方政府也一般无钱可赚，这是因为各地政府为了“招商引资”，一般会限制地价。如下表所示，工业用地的价格并不像商住用地那样连年增长，而是保持在一个维持在开发成本的水平，在有些情况下，政府还要倒贴一部分。政府要通过土地征用和转让挣钱，主要靠商住用途的经营性用地。\n⏱ 2024-06-03 00:11:20\n\n\n另一个是比较重要的和大头的支出，这就是土地出让金的大部分会作为基本资产来成立一些政府下属的开发和建设公司。一般的县级政府下面都会有几个这样的大的公司：城市投资开发有限公司、城市交通投资有限公司、城市水务集团、城中村改造有限公司等等，一般将这些公司称为“政府性公司”。这些公司性质属于国有投资公司，一般在2000年以后成立，都是由政府部门的领导出任董事长或总经理，除了交通公司之外大都属于非营利性质，其主要的功能是进行城市公益性基础设施的投资和建设。\n⏱ 2024-06-03 00:11:41\n\n\n政府注入公司的土地出让金并非直接用来进行开发建设，而是用来作为资本金，获取银行贷款。这些公司政府性公司就是我们通常所说的“地方政府融资平台”。这是连接土地财政和土地金融的关键机构。\n⏱ 2024-06-03 00:11:59\n\n第十四章 土地金融和城市化：“三位一体”的发展模式\n\n土地征用、开发和出让的目的和结果都指向大规模的城市建设，这正是新世纪以来高速发展的城市化的根本动力。\n⏱ 2024-06-03 00:12:30\n\n\n一般说来，作为融资平台主体的政府性公司获得银行贷款的途径有三种：公司互保、财政担保和土地抵押。所谓公司互保就是几个大的政府性公司用资本金互相担保进行贷款，由于这些公司的资本金大部分来自于政府的财政投入，所以这些贷款基本属于政府用财政资金作保的贷款；财政担保则更为简单，实际上就是政府财政部门直接出面做担保主体，由财政局直接出具一份“承诺函”，其中写明贷款主体、担保主体以及各种细节。前两种其实没有太大区别，其担保资金都是政府的财政资金，第三种则是土地抵押贷款，这也是融资的主要方式。\n⏱ 2024-06-03 00:40:28\n\n\n要获得土地抵押贷款，则必须拥有土地使用权证。\n⏱ 2024-06-03 00:40:32\n\n\n政府一般将这些公司所要建设、开发项目用地的使用权划拨给公司。这些建设用地既包括公益性的建设用地，也包括部分非公益性的、用于经营性开发的商住用地。对于后者，政府性公司无权将其用招拍挂的形式出让，而是将其抵押给银行来获得土地抵押贷款。\n⏱ 2024-06-03 00:41:02\n\n\n在土地开发和城市建设中，所谓的“以地养地”之法是常见的。其基本思路就是将一部分地理位置好的公益性用地作为经营性用地按招拍挂的形式出让，获得高额出让金之后用于补贴公益性建设的支出。\n⏱ 2024-06-03 00:43:59\n\n\n这些储备土地的用途则更彰显出政府储备土地的动机。公益性质的建设用地和工业用地，由于无利可图，不在土地储备中心的供地之列。政府储备的土地几乎全部用于住宅和商业经营目的，以实现土地收益的最大化。\n⏱ 2024-06-03 00:45:26\n\n\n结合我们上面分析的土地抵押贷款，我们在此可以看到另外一种土地金融和地方财政的关系：银行不断地向土地储备中心发放土地抵押贷款，土地储备中心则不断进行征地——开发——出让以赚取土地出让收入，基本思路是用旧储土地的抵押贷款进行新一轮土地征收，然后用出让土地的收入还清抵押贷款，再用新征用的土地进行新一轮的土地抵押贷款。\n⏱ 2024-06-03 00:45:56\n\n\n在这个循环往复的过程之中，政府和银行的思路都非常明确：银行的土地抵押贷款以土地作为抵押，贷款一般在1—2年之内就可以收回；财政担保贷款虽然贷款期比较长，但是有不会破产的政府财政做担保，所以也可以放心放贷；政府的收入则来自两个方面，一个是土地出让收入，只要土地可以不断征用、出让，或者只要土地出让价格足够高，政府就可以取得巨额的土地出让收入；另一方面，只要财政和金融资金不断地投入城市建设、扩大基础设施建设的规模，尽管融资规模会不断扩大，但是根据我们在上一部分的分析，政府的地方税收尤其作为预算收入支柱的建筑业、房地产业的税收收入也会不断增长、财政实力会不断增强。进一步而言，政府收入的增长又会进一步扩大融资规模和征地规模，这无疑是一个“双赢”的局面。所以，我们可以看到，土地收入——银行贷款——城市建设——征地之间形成了一个不断滚动增长的循环过程。这个过程不但为地方政府带来了滚滚财源，也塑造了新世纪繁荣的工业化和城市景象，我将其叫作土地、财政和金融“三位一体”的发展模式。\n⏱ 2024-06-03 00:47:16\n\n\n在这种模式下发展出来的轰轰烈烈的城市化实际上是以土地而非以产业和人口为中心的城市化，我将其称为“土地城市化”。这种“土地城市化”的发展模式有以下几个主要特点：第一，土地城市化不以工业化为必然前提。当然这并不意味着工业化过程不重要，而是说工业化并非城市化的中心内容。\n⏱ 2024-06-03 00:47:56\n\n\n但是各地发展的实践表明，城市化的关键在于房地产业，只要有大量的财政和金融支持，房地产业可以不依托于工业化而独立发展。各种房地产泡沫的形成正是财政和金融推动的一个结果。\n⏱ 2024-06-03 00:48:10\n\n\n在这个模式中，工业对于城市化的基础地位已经逐渐城市房地产业所替代了。\n⏱ 2024-06-03 00:48:48\n\n\n第二，土地城市化不以人口城市化为必要条件。在常规城市化的路径下，工业化为城市带来了资本积累，而工业化所需的劳动力及其家庭成员是城市发展的人口基础。这些人口基础的生产和消费构成城市运转的主体。但是在我国，城市化的路径有所不同，大量的劳动力及其家庭成员并没有成为城市居民。\n⏱ 2024-06-03 00:49:38\n\n\n税收收入、土地出让收益、非税收入、转移支付是财政收入的四大组成部分。\n⏱ 2024-06-03 00:53:38\n"},"阅读/伊豆的舞女":{"title":"伊豆的舞女","links":[],"tags":[],"content":"\n\n                  \n                  伊豆的舞女 \n                  \n                \n\n\n\n《伊豆的舞女》-  川端康成\n出版时间： 2023-01-16 00:00:00\nISBN：\nPC地址：weread.qq.com/web/reader/e8732d70813ab78bcg013ecf\n\n\n\n第一章\n山路变得曲曲折折，眼看就要到天城山的山顶了。这时，大雨把茂密的杉树林笼罩成白花花的一片，从山脚快速地向我逼近。\n\n⏱ 2024-12-05 17:50:53\n\n\n一路上虽然重叠的群山、原始的森林及深邃幽谷的秋色都令我入迷不已，但我心里却紧张地悸动着，有一个期望催我匆忙赶路。\n\n⏱ 2024-12-05 17:50:47\n\n\n第二章\n舞女从楼下端茶上来。她跪坐在我面前，脸颊绯红，手不停地颤抖，茶碗差点从茶托上掉下来。为了不让茶碗掉下来，正当她顺势要把它放到榻榻米上时，茶已经洒了出来。\n\n⏱ 2024-12-06 01:45:43\n\n\n黄昏时分，下起了滂沱大雨。群山被染成了白花花的一片，已分不出远近。前面的小河转眼间变成了浑黄的泥水滚滚奔腾。\n\n⏱ 2024-12-06 01:48:10\n\n\n第四章\n房间里只我们两个人，起初她离得远远的，伸长了手落子，可渐渐地进入忘我的境地，全神贯注地俯身到棋盘上。就在她那头美得有些不自然的黑发马上要碰到我胸口的时候，她的脸倏地通红。“对不起，要挨骂啦。”说着扔下棋子，飞奔出去。\n\n⏱ 2024-12-06 01:56:15\n\n\n我一开始读，她就把脸凑过来，几乎贴到我的肩膀，表情十分认真，眼睛闪烁着光芒，专注地凝视着我的额头，一眨也不眨。\n\n⏱ 2024-12-06 01:59:39\n\n\n她那双又黑又亮的大眼睛，是她全身最美的地方。双眼皮的线条美得无法形容。而且她笑起来像朵花似的。用笑起来像朵花似的来形容她，是最恰当不过的了。\n\n⏱ 2024-12-06 01:59:51\n\n\n第五章\n或许是因为这秋日的天空太过晴朗，海天相接处，雾霭朦胧，恍如一派春色。\n\n⏱ 2024-12-06 02:01:09\n\n\n山间小路遍地落叶，一步一滑，陡峭难行。我走得上气不接下气，索性有些豁出去了，用手掌抵着膝盖，加快了步伐。\n\n⏱ 2024-12-06 02:01:23\n\n\n舞女一人高高地提着下摆，急匆匆地跟在我的身后，一直与我保持着不到两米的距离。我回头与她攀谈，她吃惊似的莞尔一笑，停下脚步回应我。舞女说话间，我停下等她赶上来，她却顿足不前，直到我继续走起来，她才迈步。道路蜿蜒曲折，到了更加险峻的地段，我越发加快了脚步，舞女依然在后面和我保持两米左右的距离，埋头爬着。\n\n⏱ 2024-12-06 02:03:11\n\n\n第七章\n快接近码头时，舞女蹲在海边的身影撞入了我的心头。直到走到近旁她依然一动不动，默默地耷拉着头。还是昨晚的妆容，这更加牵动了我的心。眼梢的红晕为略带愠色的脸庞增添了一抹稚嫩的凛然之色。\n\n⏱ 2024-12-06 02:14:14\n\n\n我寻了很多话题与她攀谈，可是舞女只是俯首，一味盯着运河入海处，一言不发。有几次我话还没说完，她就一个劲儿点头。\n\n⏱ 2024-12-06 02:14:23\n\n"},"阅读/叫魂：1768年中国妖术大恐慌":{"title":"叫魂：1768年中国妖术大恐慌","links":[],"tags":[],"content":"\n\n                  \n                  叫魂：1768年中国妖术大恐慌 \n                  \n                \n\n\n\n《叫魂：1768年中国妖术大恐慌》-  孔飞力\n出版时间： 2014-06-01 00:00:00\nISBN： 9787542643216\nPC地址：weread.qq.com/web/reader/675326e0813ab6ffcg019c10\n\n\n\n中译本序言\n每个社会都以自己的方式对政治权力的限度作出界定。没有哪个社会愿意长期容忍不受限制的专权。\n\n⏱ 2024-12-08 04:23:16\n\n\n第一章 中国窃贼传奇\n1768年，中国悲剧性近代的前夜。某种带有预示性质的惊颤蔓延于中国社会：一个幽灵——一种名为“叫魂”的妖术——在华夏大地上盘桓。[插图]据称，术士们通过作法于受害者的名字、毛发或衣物，便可使他发病，甚至死去，并偷取他的灵魂精气，使之为己服务。\n\n⏱ 2024-12-08 04:24:30\n\n\n据他们说，石匠们需要将活人的姓名写在纸片上，贴在木桩的顶部，这样会给大锤的撞击添加某种精神的力量，人们称之为“叫魂”。那些因此而被窃去精气的人，不是生病，便是死去。\n\n⏱ 2024-12-08 04:26:48\n\n\n巨成是一个已被预先设定有罪的疑犯，他的招供当然不会令人满意。于是，法庭上惯常使用的刑讯便开始了。\n\n⏱ 2024-12-08 04:37:40\n\n\n主刑者渐渐地将一根楔子插入两者之间，交替地变换方位。通过对棍子上部不断扩张施压，使得棍子下部不断向中间那根固定在厚木凳上的笔直棍子靠去，于是，受刑者的踝骨便极痛苦地受到压迫，甚至被完全压碎。如果不幸的受害者坚信自己是无辜的，或者顽固地不肯认罪，因而使这一可怕的过程得以完成的话，到头来，他的骨头就会变成一摊稀浆。\n\n⏱ 2024-12-08 04:38:18\n\n\n最后，大概实在是熬痛不过，巨成招供道，所有对他指控之事均属真实。然而，知县并未因此而感到满足，因为这痛苦不堪的和尚所讲的故事前后并不完全一致。夹棍又两次被收紧，但并未带来更令人满意的结果。\n\n⏱ 2024-12-08 04:38:20\n\n\n公众的歇斯底里与卑劣的腐败现象结合在一起，几乎酿成了司法上的一桩大错。公堂上的用刑虽能逼人招供，却往往会因为受到指控的被告在上一级官府翻供而使供词难以作数。当某件案子到达省一级时，官员们因为远离肮脏的县府大堂上的种种压力与诱惑，对于被告的偏见也就小得多。谁说这是一件涉及妖术的案件？更有可能的是，这是由容易轻信的民众，受到贪婪的地方捕役中的恶棍以及无能的县府官员们的挑动，而造成的又一桩早已司空见惯的丑事。现在，省里的官员们很乐意于销掉这个案子。\n\n⏱ 2024-12-08 04:43:07\n\n\n第二章 盛世\n在妖术恐慌波及的省份，居住的人口比当时整个欧洲的总和还多，不少人被搞得丧失生命或身败名裂。可是，从总体上来看，它给人们生活带来的危害又远不及十六、十七世纪席卷欧洲的巫术大恐慌。为什么妖术恐慌在中国带来的危害如此有限？正如同这场恐慌究竟因何发生一样，这是一个颇值得深究的问题。\n\n⏱ 2024-12-08 04:54:04\n\n\n农民、官僚和皇帝的生活方式不同，他们需要考虑的主要问题也不同，妖术恐慌对他们形成的冲击也就不尽相同。\n\n⏱ 2024-12-08 04:54:20\n\n\n“除贱为良”的目的在于通过废除平民中的“贱人”身份，使得“臣民”这一群体不因其中特殊下层社会集团的存在而显得杂乱无章。\n\n⏱ 2024-12-08 04:58:08\n\n\n这样做既是对汉人长期以来划分社会等级的做法的一种嘲弄，也表达了征服者的某种“仁慈”，从而使得清朝政权能够更好地高居于相对来说已无显著差异的芸芸众生之上。\n\n⏱ 2024-12-08 04:58:39\n\n\n一位历史学家指出，用金钱赎身的条款其实并没有什么意义，因为它大大超出了佃农们的能力，况且，不管在什么情况下，他们一旦赎身也就失去了生计。\n\n⏱ 2024-12-08 05:00:08\n\n\n从一个十八世纪中国普通老百姓的角度来看，商业的发展大概并不意味着他可以致富或他的生活会变得更加安全，反而意味着在一个充满竞争并十分拥挤的社会中，他的生存空间更小了。商业与制造业的发展使得处于巨大压力下的农村家庭能够生存下去，但要做到这一点，就必须最大限度地投入每个人的劳力。从历史的眼光来看，当时经济的生气勃勃给我们以深刻印象；但对生活于那个时代的大多数人来说，活生生的现实则是这种在难以预料的环境中为生存所作的挣扎奋斗。\n\n⏱ 2024-12-08 05:01:50\n\n\n有关叫魂的怀疑都集中在流浪者身上，包括陌生人，没有根基的人，来历不明与目的不明的人，没有社会关系的人，以及不受控制的人。\n\n⏱ 2024-12-08 17:51:58\n\n\n我们应该把乾隆年间的商业看作是汲取不断增长的劳动力的蓄水池。它使得只有小块土地的家庭能通过出售家中妇女与孩童的手工作品而得以生存。但是，有足够的证据表明，无论是商业的扩展还是向外部的移民都不能使每个人都得到关照，总有一部分人会被完全排除在生产性经济之外。他们的出路，并不在于向外迁徙，而是向社会的下层移动，沦为乞丐之类的社会下层阶级。\n\n⏱ 2024-12-08 17:53:41\n\n\n在官僚们的心目中，不管是什么人，凡四处流浪的乞丐都是对于公共安全的一种威胁。那些居无定所、没有家室的人也是无法纳入控制的人。\n\n⏱ 2024-12-08 17:58:15\n\n\n大多数被通缉的人犯都换上了僧道服装，销声匿迹，远遁外地。这就是为什么“至如妖言妖书等重大案件，每案必有外来奸僧邪道主持，煽惑良由”。因为这些人居无定所，要追寻他们的踪迹也就极为困难。\n\n⏱ 2024-12-08 17:59:12\n\n\n弘历从来就对佛教僧人有着根深蒂固的怀疑（这同他对于佛教大事声张的赞助是很不一致的）。这并不仅仅是因为和尚及他们的行动使得当局难以对之加以管束。正如弘历本人在另一场合所表露的那样，他的这种态度还反映了儒教对于那些“甘心剃发为僧，并不顾父母妻子，则行踪可疑”的人们所持有的更一般性的鄙视。[插图]在这方面，僧人的情况与受人歧视的太监相似——太监为了饭碗的缘故，而摒弃了生养后代这一最重要的尽孝的义务。\n\n⏱ 2024-12-08 18:05:28\n\n\n第三章 或现或隐的威胁\n弘历的风格，是尚武的满人种族特性与普世主义文化的一种不太和谐的混合物。他希望将满族特性变为帝国机制的一个有机组成部分。君权既要成为满人文化完整性的保护者，又要成为多种族霸权的一种象征，其正当性则应通过普遍性的儒家言辞得到证明。[插图]作为满族德行的捍卫者，弘历采用的方法有二：第一，他要在种族问题的真正细节或只具有象征意义的小处均让汉族文人感到惊恐不安；第二，他要通过向自己的满族同胞宣讲本族尚武的传统和优越的品质，来激励起他们的种族意识。\n\n⏱ 2024-12-09 02:32:16\n\n\n对于普通旗人来说，他们既缺乏一种建立在坚实经济基础之上的自我尊严，又没有由军事威胁而带来的促人清醒的挑战，几乎再没有什么东西可以让他们用来支撑自己作为征服民族的骄傲了。\n\n⏱ 2024-12-09 02:54:17\n\n\n如果满人在中国文化面前失去自我的话，那么，正是江南文化对他们造成了最大的损害。\n\n⏱ 2024-12-10 17:29:03\n\n\n第四章 罪的界定\n信息是一种权力与力量，但也与安全有关。\n\n⏱ 2024-12-10 17:36:50\n\n\n国家与妖术对抗时目标模糊不清的情形，反映了它在对待超自然力量的问题上的立场暧昧不明。一方面，国家本身通过许多途径建立了与神灵世界的种种联系。它有着自己的天地崇拜，并在为自然神灵归类的同时，也为那些已被融入自身宗教体系的民间神灵归类。国家一直通过宫廷星相家从事着解读天象的活动。因此，国家很难全盘否认人与神灵之间存在着联系的现实。另一方面，国家若公开加入同那些与之处于竞争地位的不同天地崇拜的争斗，那就只能意味着它承认了它们同神灵世界存在着有效联系，从而会大大提高它们的地位。\n\n⏱ 2024-12-10 17:50:41\n\n\n如果有人问起：妖术实践是否“真的”会削弱国家对于社会的控制？这实在是不得要领。真正作数的应是百姓对于妖术的反应。\n\n⏱ 2024-12-10 17:53:39\n\n\n第五章 妖术大恐慌的由来\n这些关于法术正反作用的看法，暴露了时时刻刻均困扰着大多数普通百姓的种种焦虑：早夭，草草下葬，失去子女，死后得不到恰当祭扫，等等。\n\n⏱ 2024-12-11 17:13:52\n\n\n国家既然以包揽一切的态度宣称只有它才有资格掌管人与神灵世界之间的交往关系，它便精心设计出一系列规则条例，以便对有组织的僧人道士进行管理。自然，在国家为他们所制定的规则中也就不无荒唐之处。从形式上来说，即便从事礼仪活动的大多数僧道人员其实并不“从属于”任何僧道机构，官方却仍可能要这些机构对他们的活动负责。至于民间宗教的职事人员，以我们在西方背景下所养成的眼光来看甚至算不上专职宗教人员，但他们却主宰并支撑着那个无所不包并深深植根于民间社区的宗教活动体系。国家若想制止这种暧昧不清的状态，是否可以坚持要所有僧人道士都明确表明自己的师徒关系？或要求所有从事宗教活动者都登记注册？从中国宗教的实际情况来看，这些想法是荒谬可笑的。大多数宗教职事人员注定是没有什么社会地位可言的（根据国家对社会地位的边际性质的界定）。如果国家一定要将那些规则（对此，我将予以概要说明）强加于他们身上，也就等于把民间宗教本身也给取消了。在那个时代，这对于国家来说当然是一件不可能办到的事情。这个简单的事实为学界关于“国家对宗教的控制”的讨论带来了一个不甚真实却极为有趣的侧面。\n\n⏱ 2024-12-11 17:18:05\n\n\n不管怎么说，国家还是做了知其不可而为之的尝试。我们必须将这种尝试视为国家在表明自己的态度，而不是国家的“体制”正在按照自己本来的思路行事。\n\n⏱ 2024-12-11 17:18:37\n\n\n和尚是1768年大恐慌的主要嫌疑对象。但多少有点让人惊奇的是，十八世纪有关谈神说鬼的两本主要的集子（著者为蒲松龄和袁枚）对和尚的描述却相对来说十分友善。大量的妖术行径都被归到了像本章开头所叙及的谋财害命的道士头上。相形之下，和尚遭到批判的主要原因在于他们的虚伪或不道德的行为，尤其是他们在性生活上的放纵（在欧洲，这也是人们对僧侣发起攻击时通常会涉及的一个主题）。此中奥妙，为“妖道淫僧”一词所道尽。\n\n⏱ 2024-12-12 17:37:05\n\n\n普通百姓对于和尚的态度也许受到了下述两种情况的制约。一是见习修行和尚身份本身的模糊性（他们既是佛门一员又不在佛门之中）；二是一般人对于乞讨者的暧昧态度（这被认为是一种无根无底的懒人的职业，但它又因为僧人实在太贫穷而在某种程度上得到了人们的认可）。对于道士，普通百姓的态度也许就是一种更为直截了当的恐惧了。人们习惯上常常将道士的活动同各种各样的法术联系在一起（如炼丹术，以符咒驱邪，以及寻求长生不老，等等）。因此，当“邪术”成为问题时，道士也就顺理成章地成了怀疑对象。尽管道士在社区里通常从事的是诸如以符咒为人治病之类的有益的活动，但他们在人们想象中的妖魔形象却表明，在人们看来，法术是很容易转化而成为邪术的。[插图]由于和尚在社区中所从事的主要活动是协助死者的魂顺利通过阴间，他们便不是与道士同一意义上的术士。这大概也解释了为什么在百姓的故事传说中和尚相对来说温厚善良的原因。\n\n⏱ 2024-12-13 11:17:24\n\n\n对于其他文化所做的研究表明，人们常常会将妖术同外来者连在一起\n\n⏱ 2024-12-13 11:19:10\n\n\n可是，人们对于乞丐的恐惧同他们是否掌握礼仪“技巧”并没有任何关系。恰恰相反，他们的危险性正是在于无人能在礼仪上非议他们。\n\n⏱ 2024-12-13 11:21:03\n\n\n。皇家的恐惧则不仅同个体也同群体有关。君权神授的完整性与持久性需要通过皇家不断从事的礼仪活动而反复得到验证；同时，君权神授本身也可以因为自然的机制（如只有在发生自然灾害和出现其他征兆时才可以看到的宇宙力量），或由于巴望让国家遭难的煽风点火者的行动而发生断裂。国家不仅需要坚决否认这些妖人同神灵世界存在着任何交流关系，也要对他们的行为无情地予以禁止。皇家的祭祀官员们对于除了自己以外其他任何同神灵世界的联系都采取嘲弄态度，这种做法其实证明了他们对于自己的“神授”地位能否持久有着一种根深蒂固的焦虑。对普通百姓来说，术师的妖术威胁到的是灵魂与躯体之间的脆弱联接；而对皇朝的上层人士来说，这种行为危害到的则是皇朝同上天力量之间的脆弱联系。\n\n⏱ 2024-12-13 11:23:30\n\n\n第六章 各省的清剿\n官僚责任制度的运作是围绕着对信息的控制而展开的。一项罪行如果未经官方确认已经发生，那么，一个官员就不会因为对此罪行失察而受到惩罚。\n\n⏱ 2024-12-13 11:24:39\n\n\n我怀疑其余的多数人在司法上并不具备足够坚定的自我意识来抗衡与其职位相随的政治压力。取悦皇帝是贯彻司法的中心环节。\n\n⏱ 2024-12-13 11:28:53\n\n\n一个政府的有效运作取决于对信息流动的仔细掌控。对十八世纪的清王朝来说这牵涉到两个问题：第一，明确区分紧急情况和日常事务，从而使各种问题能在适当的层次上根据合理的次序得到解决；第二，确保地方官能及时而准确地提出报告。这两个问题的解决从未使弘历感到满意。\n\n⏱ 2024-12-13 11:29:06\n\n\n追查妖术案碰到了一个在清代制度中普遍存在的问题，事实上，这也是任何一个以地方官员为地方情况主要信息来源的制度都会遇到的问题。虽然朱批奏折制度具有广泛监督的潜在功能（即一个官员会为了个人利益而举告别人），但实际上却并非如此。皇帝的假设是，地方官出于自身利益总是对手边的问题轻描淡写以减轻他失职的过失。在这种情况下，常规的监察系统（例如对税收报告的监察）变得毫无作用，因为并没有什么常规的制度可以用来审核妖术案犯的人数。对于罪犯的这种紧急而非常规的清剿立刻使皇帝与官僚处于掌控信息的竞争之中，使他们之间的关系更形尖锐紧张。\n\n⏱ 2024-12-13 11:35:48\n\n\n苏州织造的位置向来是由内务府的可靠官员来充任的。织造府位于政治敏感的长江下游地区的中心，织造的职责不仅在于向皇上供应奢侈的丝织品，而且也在于及时提供地方上的有关情报。\n\n⏱ 2024-12-14 00:47:30\n\n\n第九章 政治罪与官僚君主制\n一个讲的是流传于普通百姓中的妖术恐惧，一个说到了皇帝如何逐渐确信妖术其实是谋反的烟幕，还有一个述及对妖术不置可否的官僚们所面临的困境——他们力图应付来自上下两方面的压力，却无法使任何一方满意。\n\n⏱ 2024-12-14 00:58:44\n\n\n在这些故事背后，还有着另外一个最难解读的故事，那就是：包括妖术恐慌在内的种种地方性事件是如何变成推动整个政治制度运作的燃料的。\n\n⏱ 2024-12-14 00:59:16\n\n\n妖术危机的档案向我们揭示了为什么政治罪是君主的而不是官僚的问题，这里的关键在于如何理解常规权力和专制权力之间的关系。\n\n⏱ 2024-12-14 01:00:11\n\n\n对中华帝国后期政治制度的研究产生了两种大异其趣的学术研究传统：一种着眼于行政官僚制的结构、人事和价值，[插图]另一种则注重于帝国的机制，特别是帝国通讯制度的发展。[插图]结果，我们对官僚体制作为一种生活方式有了更为复杂的认识；同时我们也认识到君主是帝国政治制度的一个组成部分，而并非一个既远离这一制度又权力无限的专制者。\n\n⏱ 2024-12-14 01:00:40\n\n\n即使在腓特烈大帝时代，独裁者的权力还是被官僚们大打折扣，因为他们拥有真正的权力，可以通过操纵信息和采用其他的“破坏”行动来“阻挠和歪曲”独裁者的意志。\n\n⏱ 2024-12-14 01:02:36\n\n\n“官僚君主制”听起来似乎是自相矛盾的。就其是官僚制而言，它给君主留下了多大的余地？就其是君主制而言，它又如何才能使个人的专制权力与普遍规则的体系共存？在这里，君主和官僚都陷入了一种两难境地，并都对已经形式化的行政程序抱一种模棱两可的态度。君主不得不用成文法规来约束成千上万为他服务的官僚，以确保他们每个人都按照体现他的利益与安全的行政程序行事。与此同时，他对于如何保持自己的特殊地位、超官僚权力和自主性，也会理所当然地感到关切。结果，他不得不持续斗争挣扎，以避免自身的官僚化。清代君主的大多数日常行政事务，涉及的是认可军机处为他所草拟的谕旨，或批准吏部所拟定的官员任命。面对他的文件起草人所提供的有限选择，繁忙的君主会发现自己的“作用”只不过是文件处理机中的一个齿轮（尽管是一个镶钻的齿轮）。他怎样才能挣脱这个陷阱，表明自己的身份是主子而非臣仆？[插图]就官僚本身而言，他们始终受到琐细的规章条例的制约，包括形式、时效、文牍、财政和司法上的限期，以及上司和下属之间的关系。他们若对这些规章条例有任何违反，便会受到弹劾、罚俸、调离或撤职的处分。但是，这些繁琐的规章条例至少也为他们的职责划定了某种边界，从而为他们提供了一定的保护，使他们得以对抗来自上司或君主本人的专制要求。\n\n⏱ 2024-12-14 01:04:57\n\n\n伴随规则而来的是可预期性和标准化。同时，规则也限制了运用规则的人们的自由。\n\n⏱ 2024-12-14 01:05:12\n\n\n那些运用规则并监督规则执行的人同那些受规则支配的人一样会受到规则的制约。\n\n⏱ 2024-12-14 01:05:38\n\n\n当规则失去效用时，补救的方法不仅包括制定更多的规则，也包括诉诸依赖专制权力的手段。从在位初期起，弘历便对不起作用的规章条例表现得极不耐烦。他的因应之道是，一方面对日常运作的官僚机器上紧螺丝，另一方面则将自己的专制权力注入到这一机器的运作中去。这种努力从他对官员的考评中最清楚地表现出来。\n\n⏱ 2024-12-14 01:06:32\n\n\n要做到对官僚的控制，其精髓在于对犯罪和行政失误作出区分。对腐败或更为严重的罪行，要由刑部在案犯被弹劾并撤职后处以刑事惩罚。行政处分则由吏部掌管，用于处罚各种失误，特别是用于逾期或未能完成定额指标（如侦破刑案或收税），隐瞒消息以及其他违反规章程序的行为。\n\n⏱ 2024-12-14 01:08:37\n\n\n另一个窒息人事考评的制度性问题是所谓的“迎合”，即通过修饰自己的评语来迎合揣摩到的上司意图并讨好上司。结果，这使得官员们根据皇帝的喜好对自己的考评标准加以修饰，从而对日常的考评制度造成了可笑的扭曲。\n\n⏱ 2024-12-14 01:14:36\n\n\n目睹常规考评制度的失败，弘历自然要抓住一切机会以专制权力直接介入这一制度。要做到这一点，他就必须全面而可靠地掌握信息。\n\n⏱ 2024-12-14 01:18:19\n\n\n职位越高，其任命程序受常规掣肘也就越少，这是所有官僚体系的一个共通原则。\n\n⏱ 2024-12-14 17:42:32\n\n\n君主要实现对官僚更有效的控制，就必须超越常规程序。觐见制度，机要考评系统，以及把高级官员同常规制度部分地分离开来都是出于这样的目的。在弘历的官僚系统中，他所面对的官员级别越高，常规因素所起的作用就越弱。在这一制度的顶端（即由行省长官和各部院首脑组成的那个“俱乐部”），对话的规则是高度个人化的。在日常公文和谢恩表之类的礼仪性文书中，这种个人关系都一再得到重申。玩忽职守被看作是对君主本人的冒犯，君主因此而出现对臣下的信任裂痕则是由于臣下的忘恩负义。结果，行省和京城的高级官员是根据两套规则行事：在形式上，他们仍然受到行政处分则例的制约，君主可以据此将他们交吏部议处。然而，除此之外，他们又受到了君主的直接注意——他可以通过用繁琐礼仪包装起来的个人关系来激励他们，责备他们和恐吓他们。个人关系同时在礼仪和事件的领域里发挥作用。某些事件——特别是我先前界定过的“政治罪”——是最有效的媒介物，使得那把中国官僚君主制的最上层捆绑在一起的个人纪律得以滋生成长。这是那种弘历可以利用的机会，以防止他的高级官员们偏离他个人的控制而滑入常规节奏和裙带关系。\n\n⏱ 2024-12-14 17:58:59\n\n\n叫魂危机为对个人的纪律整肃提供了特别合适的机会，因为它是一个建立在如此荒谬的基础之上的案件。君主的愤怒可以发泄在行省官员身上，因为他们未能抓获妖党首犯。然而，这样的失职却是不可避免的，因为这样的妖首并不存在。叫魂案件虽如此荒谬，但弘历在当时却对此并无察觉。不过，说弘历“利用”了政治罪并不见得比说政治罪“利用”了他更接近真实。政治罪为君主的某种行为的产生提供了一个大背景，而这种行为的塑造则应归之于官僚君主制的一些长期存在的结构性特点。弘历将各省官员们在缉捕妖首问题上的失职归咎于他们的怠惰、迟疑、对无能属下的姑息，也归咎于江南的腐败以及官员个人的忘恩负义。这些问题正是君主常年关注的焦点。我们已经看到，弘历要在常规环境里对付这些问题有多么困难。像叫魂案这样一桩政治罪所造成的最大冲击，就在于它动摇了官僚们用以有效保护自己的常规行为方式，从而为弘历创造一个环境，使他得以就自己所关心的问题同官僚们直接摊牌。\n\n⏱ 2024-12-14 19:00:46\n\n\n叫魂危机的文献记录所折射出的是一种双重的图像。其中那幅粗线条图像勾勒出的是每日进行的对妖术的清剿。而那幅比较隐晦不彰的图像则透露了文献作者和读者之间的关系。从这重叠的图像中，我们可以联想到中国帝制国家的两个侧面：它既是一种工具（其功能是根据清朝皇室和满汉精英层的利益需要来管理国家），也是一种制度（其功能是在不同政治角色之间实行权力分配和地位分派）。国家作为一种工具（我将之称为“政府”），同我们对于政府的常识性理解是相符的：它是为完成诸如征税、治安和战争之类的任务而建立起的组织机构。国家作为一种制度（我将之称为“官僚君主制”），则是由那些生活于等级秩序之中，其生涯取决于声望和权力、黜陟和安全的人们之间的各种关系所构建而成的。当我们解读由“事件”而产生的文件时（不管这文件是关于税收的常规公文还是关于叛乱的紧急奏报），都必须要么把它们当作关于外在现实的描述，要么将它们视为文件作者政治需要的反映。（所谓“政治需要”，当然并不一定是狭隘的私利，也可以是文件作者从原则出发对部门利益的捍卫。）人们在制度中的相互关系同发生于现实世界中的“事件”绝不是风马牛不相及的。恰恰相反，正是这些“事件”使得国家作为工具和制度的两个侧面各自因对方而具有了意义。\n\n⏱ 2024-12-14 19:38:36\n\n\n“事件”作为一种机会，不仅可以为一个人带来幸运，也可以同时服务于上司和下属的需要，并编织起使一个人得以在公共生活中立足的人际关系。\n\n⏱ 2024-12-14 19:40:43\n\n\n除了维持帝国的秩序以外，政府还有另外一个作用，即为官僚君主制的运作提供象征性的资源。正如官僚君主制靠中国社会的经济剩余为生一样，它要以社会中的“事件”为原料来推动制度内部各种关系的运作。官僚君主制的内在机制则对所有这些“事件”进行加工，使它们转换为权力和地位。\n\n⏱ 2024-12-14 19:41:11\n\n\n第十章 主题和变奏\n作为现代中国的前奏，叫魂大恐慌向中国社会的观察者们凸显了一个特别令人难过的现象：社会上到处表现出以冤冤相报为形式的敌意。叫魂案从一开始就带有这种令人不快的特征。\n\n⏱ 2024-12-15 00:34:57\n\n\n在这个权力对普通民众来说向来稀缺的社会里，以“叫魂”罪名来恶意中伤他人成了普通人的一种突然可得的权力。\n\n⏱ 2024-12-15 00:35:59\n\n\n我们在这里所瞥见的，是不是一个已被人口过度增长、人均资源比例恶化、社会道德堕落所困扰的社会所遭遇到的一种道德报应？在这样一个备受困扰的社会里，人们会对自己能否通过工作或学习来改善自身的境遇产生怀疑。这种情况由于腐败而不负责任的司法制度而变得更加无法容忍，没有一个平民百姓会指望从这一制度中得到公平的补偿。在这样一个世界里，妖术既是一种权力的幻觉，又是对每个人的一种潜在的权力补偿。即使叫魂这样的事其实从来没有发生过，人们仍然普遍地相信，任何人只要有适当“技巧”便可通过窃取别人的灵魂而召唤出阴间的力量。这是一种既可怕又富有刺激的幻觉。与之相对应的则是真实的权力——人们可以通过指控某人为叫魂者，或以提出这种指控相威胁而得到这一权力。施行妖术和提出妖术指控所折射反映出来的是人们的无权无势状态。对一些无权无势的普通民众来说，弘历的清剿给他们带来了慷慨的机会。\n\n⏱ 2024-12-15 00:37:16\n\n\n这种“受困扰社会”(impacted society)为反常的权力所搅扰，它和莱斯特·瑟罗(Lester Thurow)所描述的二十世纪美国“零和社会”在某一方面是很相似的。[插图]这两种社会都发现，它们所面临的基本问题已无法通过增进生产来解决，而需要“对损失进行分摊”。但是，两者的一个主要区别在于，在瑟罗笔下的后工业化的美国，人们被出卖的感觉是由于进步和经济成长的信念而产生并得到强化的——这种进步和经济成长一度曾使西方世界相信，所有的困难都会屈服于人类的努力，从中某些人会得益却不会有任何人受到损害。与此形成对照，在帝制后期的中国从未有人设想人的努力能够（或应该）产生无限的进步和成长。同一个富裕的工业社会相比较（不管这个社会的贫富差距有多大），“损失分摊”在一个贫穷的农业社会是一种更为严酷的过程。当中国进入近代的时候，社会拥挤、贫穷，人们对于正在侵蚀着普通大众生存机会的种种实际力量则几乎完全没有了解。“受困扰社会”的特殊政治就是在这种情况下产生的。在帝制后期的中国，绝大多数人没有接近政治权力的机会，也就不能以此通过各自的利益相较去竞争社会资源。对普通臣民来说，仅仅是组成团体去追求特殊的社会利益便构成了政治上的风险。有时，人们便会到旧的帝国制度之外去寻求这种权力；其结果就是造反和革命。但对大多数人来说，权力通常只是存在于幻觉之中；或者，当国家清剿异己时，他们便会抓住这偶尔出现的机会攫取这种自由漂浮的社会权力。只有非常的境况才会给无权无势者带来突然的机会，使他们得以改善自己的状况或打击自己的敌人。即使在今天，让普通民众享有权力仍是一个还未实现的许诺。毫不奇怪，冤冤相报（这是“受困扰社会”中最为普遍的社会进攻方式）仍然是中国社会生活的一个显著特点。\n\n⏱ 2024-12-15 00:42:10\n\n\n如果说，弘历的清剿撞上了官僚们设置的路障，那么构成这些路障的恰恰是最令他痛恨的“官场恶习”：谨慎地隐匿情报，小心地自我保护，隐瞒真相以掩护人际关系，百促不动以墨守常规程序。\n\n⏱ 2024-12-15 00:44:25\n\n"},"阅读/哲学导论讲记":{"title":"哲学导论讲记","links":[],"tags":[],"content":"\n\n                  \n                  哲学导论讲记 \n                  \n                \n\n\n\n《哲学导论讲记》-  余敦康\n出版时间： 2018-01-01 00:00:00\nISBN： 9787301289099\nPC地址：weread.qq.com/web/reader/a0432b1071879fa1a044365\n\n\n\n第一讲 哲学是什么\n\n，但是学哲学，不仅要求得理智的了解，还要求得情感的满足，我要爱它，它跟我一生的生命和做人紧密联系在一起，\n⏱ 2022-11-05 10:02:16\n\n\n所以哲学的定义之所以各自不同，完全在于每个人的哲学观不同。可以说每个人都有自己的哲学观。\n⏱ 2022-11-05 10:05:56\n\n\n而哲学的对象是不确定的，论证的方法则是确定的，它借用已经确定的方法，证明一个道理。所以说哲学是介于神学和科学之间的东西。\n⏱ 2022-11-05 10:11:25\n\n\n西方对于中国哲学的主流看法，比如黑格尔就公开地说，中国没有哲学，印度也没有哲学，哲学从古希腊开始，古希腊是哲学的正宗——这是典型的西方中心论。\n⏱ 2022-11-05 10:20:25\n\n\n所有哲学都有特定文化的特性，在全世界的文化史上，有所谓的“轴心时代”，“轴心时代”的时间是公元前800年到公元前200年，相当于中国的春秋战国时期。全世界只有三个地方有哲学，或者说只有在这三个地方产生了哲学突破：西方、中国、印度。在西方，希腊出现了苏格拉底、柏拉图、亚里士多德等人；在中国，出现了孔子、老子、墨子等思想家；在印度则有佛教、耆那教等。\n⏱ 2022-11-05 11:03:35\n\n\n这三个地方形成的哲学，在轴心期都是在本地的地区性文化中自然而然地发展起来的，这样发展起来的哲学，因此也都具有自己独立的价值、独立的思路、独立的哲学问题，从而形成了三大哲学系统：希腊系统、中国系统以及印度系统。\n⏱ 2022-11-05 11:04:00\n\n第二讲 轴心期哲学的突破\n\n轴心期这个概念，是德国哲学家雅斯贝尔斯在《历史的起源与目标》一书中第一次提出的。所谓轴心期，相当于中国的春秋战国时期，尤其是公元前800年到公元前200年，在这六百年期间，在全世界有三个地方（或者说是四个地方），产生了哲学。印度、中国和希腊，像三个点一样，构成了哲学中心；\n⏱ 2022-11-08 01:19:59\n\n\n现在哲学至少有三个家谱，哪三个呢？中国式的家谱、印度式的家谱、希腊式的家谱，现在这个家谱我们可以横向地比较，但是绝不能拿西方的谱系来看中国的，恰恰我们一百多年来就老是忘记了这一点，老是拿西方的东西来套中国的，这样一来中国哲学就成了什么呢？成了世界哲学的展览馆、西方哲学的展览馆。\n⏱ 2022-11-08 00:45:06\n\n\n在地区性、民族性中间蕴涵着全球性、人类性，这就是“轴心期”的意思，这就是哲学的本质。\n⏱ 2022-11-08 00:50:13\n\n\n在希腊、印度、中国，它三个在考虑本身地区性问题的时候，本身就有一个全球性和人类性的蕴涵，个别中蕴涵了一般，这是个哲学道理，这是“轴心期哲学突破”的意义。\n⏱ 2022-11-08 00:50:51\n\n\n哲学和原始宗教神话不一样的地方就是在这个民族性地区性中间蕴涵着全球性和人类性\n⏱ 2022-11-08 00:51:12\n\n\n中国在世界文化大潮中究竟应该怎么办呢？我们自己应该站在一个什么样的地位呢？“五四”时候就分为三派，关于文化问题的讨论有三派：一是全盘西化派，认为中国必须要全盘西化才能够走上世界化的道路。全盘西化派也就是自由主义派，其骨子里头是自由主义的哲学；二是文化保守派，也叫国粹派，国粹派本质上是中体西用派，国粹派是要保持中国文化的本色，但是认为西方的东西也得学习；三是以陈独秀为代表的新青年派。\n⏱ 2022-11-08 01:04:50\n\n\n我们说熊十力写这个《新唯识论》，表面上他的理论是佛教的，但是他骨子里头是用着法国的柏格森的生命哲学作底子，这和梁漱溟是差不多的。到了他的三个学生，牟宗三，他用什么哲学作底子呢？新康德主义，他用新康德主义作底子；唐君毅，他用什么哲学作底子呢？新黑格尔主义，他用新黑格尔主义作底子；徐复观中国的味道比较浓，可是背后骨子里是个自由主义的底子。\n⏱ 2022-11-08 01:10:09\n\n\n中国谈的是道。道是什么东西呢？什么叫作“道”呢？下一个定义，什么东西呢？不是道路，那只是路，道就是“由是而之焉”。由这个地方到那个地方，就是由是而到，到那个地方去；如果我从这儿走，能到那个地方吗？到不了，“由是而之焉”，这里面有很深刻的哲学味道。既然“由是而之焉”，就有条路。这个道可多了，有天道，有地道，有人道，还有各种各样的一些道，打仗有兵道，写字有字道，喝茶还有茶道，喝酒还有酒道，这个道无所不在呀，万事万物都有个道。所以说你达不到这个道啊，就是说你境界太低。“由是而之焉”的这个道，你必须要得道。要得这个道，就要修道。修了这个道以后呢？还有个行道，推行这个道\n⏱ 2022-11-08 01:14:28\n\n\n根据金岳霖的说法，还可以做很多的描述，简单来说，西方的哲学着重于一个理智的了解，对于人生，对于宇宙，对于科学，我一定要问出个一二三来，理智上非常紧张。你学西方哲学，一定会进入知识论的这个层面，好好去研究，从各个方面求理智的了解。印度哲学呢？求情感的满足，我们用这个哲学以后，我就得到一种情感的满足，所以印度的哲学基本上是宗教的哲学。重视宗教、情感，人能归依的、有归属感，理智的了解不一定重要，情感的满足才是非常重要。那么中国呢？理智情感都要，你总得经过了解才可能知道，“由是而之焉”，情感得到满足。\n⏱ 2022-11-08 01:17:32\n\n第三讲 西方哲学导论（上）\n\n我们现在通常的说法是，哲学是关于世界观的学问，是关于正确的世界观的学问，是研究自然、社会、思维、发展规律最一般的最普遍的学问。\n⏱ 2022-11-08 01:22:01\n\n\n老子所说的那两句话：“道可道，非常道。”道就是哲学，可道，可以说，但是你一旦说出来，这个道就不是真的道了，不是那个常道了，你说出来的这个道，是那个手指头。别人会把你的手指头当作“道”。\n⏱ 2022-11-08 11:30:17\n\n\n给哲学下一个定义是不可能的，哲学有各种各样，非常丰富，一个人一个说法，只要你是个哲学家，你一定有你自己的哲学观，你的哲学观和另一个人的哲学观肯定是不一样的，但是你把哪一个人的哲学观当作哲学真正的定义呢？这就会产生误导\n⏱ 2022-11-08 11:32:35\n\n第四讲 西方哲学导论（下）\n\n柏拉图奠定了古希腊哲学、或者说西方哲学的特有形态，这个哲学形态就是以逻各斯为中心，哲学的问题就是追寻逻各斯，不断去探究逻各斯是如何成为支配我们现实世界的力量。这就是我们通常所说的主客对立。很多西方的哲学史家反复地说，两千多年来西方哲学史就是一部对柏拉图的注释史，这不是没有道理的。尽管哲学史上出现了各种各样的观点和各式各样的理论，但没有一个哲学家能够不以柏拉图作为自己哲学的起点。\n⏱ 2022-11-16 00:38:52\n\n\n哲学不仅仅是思维，它还与社会历史的背景有很密切的联系。\n⏱ 2022-11-16 00:39:03\n\n\n伦理学时期从亚历山大大帝开始（公元前3世纪中叶），一直到罗马帝国的崩溃（公元476年），一共持续了八百年的时间。在这个时期，整个希腊罗马的哲学就把个人安身立命、求得个人的幸福作为讨论的重点。在讨论过程中产生了两大派别：伊壁鸠鲁学派和斯多葛学派。斯多葛学派继承了柏拉图的逻各斯，强调理性、必然性，从而突出不可抗拒的命运，提倡命定论。他们认为，既然如此，人们就应该服从这种必然性，你是什么样的人，就应该安于做什么样的人。大家都安于自己的命运，那就能得到幸福。伊壁鸠鲁学派则继承和发扬了德谟克里特的原子论，既承认必然性，又承认偶然性，他们认为理性不能决定人们的幸福，人是感性的，宣扬人死魂灭，提倡寻求快乐和幸福，而他们所主张的幸福是排除情感困扰后的心灵宁静之乐。所以这两派的观点是对立的。\n⏱ 2022-11-16 00:41:20\n\n\n中世纪哲学的主体是基督教哲学，它从罗马帝国崩溃到文艺复兴，延续了大概有一千年\n⏱ 2022-11-16 00:43:37\n\n\n基督教哲学有两个基本概念：一个是“道成肉身”，另一个是“三位一体”。道就是逻各斯（普遍理性），但它不是抽象的，而是成了肉身，成了上帝，上帝是逻各斯的化身，信仰上帝，就是信仰普遍理性。耶稣作为上帝之子，是圣子，上帝是圣父，他们的根据就是圣灵，圣灵就是道、就是逻各斯，圣父、圣子、圣灵是三位一体。\n⏱ 2022-11-16 00:46:59\n\n\n在中世纪，理性为信仰服务，哲学为神学服务，这是以神为本。\n⏱ 2022-11-16 00:48:21\n\n\n笛卡儿的“我思故我在”是近代西方哲学中的标志性命题，由这个命题出发，形成了一种认识论学说：唯理论。\n⏱ 2022-11-16 00:51:10\n\n\n经验论与唯理论的对立追本溯源，来源于古希腊罗马时期的理性与感性的对立。\n⏱ 2022-11-16 00:52:32\n\n\n康德把人类知识分为三个层面：理性、知性、感性。人通过时间、空间的感性直观，之后再用知性的范畴加以规范。康德提出了十二个范畴。知性之所以能够对感性做出规范，是通过先天综合判断，先天综合判断则来源于先天理性。就这样，通过先天综合判断，人类才形成了知识。人类的知识都是来源于表象，没有深入到本体。康德认为，本体是不可知的，他把这个本体称为物自体。\n⏱ 2022-11-16 00:59:45\n\n\n从康德开始，西方哲学史发展到了一个非常重要的阶段，就是德国古典哲学。\n⏱ 2022-11-16 00:58:46\n\n\n黑格尔的哲学分为三个部分：逻辑学、自然哲学、精神哲学。\n⏱ 2022-11-16 01:00:11\n\n第五讲 印度哲学导论（上）\n\n其实希腊、中国、印度三个区域的哲学有一个共同的特点，就是把世界一分为二：即我们生活的现实世界，以及理想的世界。我们生活在现实的世界当中，一定要去追求理想的世界，所以每一种哲学都有一种理想的追求，这是它的价值理想。价值理想的设想各不一样，所以三个地方的哲学就产生了很大的差别。古希腊把逻各斯的世界当作理想，印度哲学把“梵我同一”当作理想，中国哲学把“有道”当作理想。但是希腊的逻各斯世界是可以通过人类的理性去认识，可以分析的手段去追求，这样西方就走上了科学的道路；印度的梵我同一则是超出经验的，超出逻辑的，只能用体验去把握，带有很强的神秘性，所以突出个体的感受；而中国的有道、无道则可以通过社会现状表现出来，有道就是太平盛世，无道就是民怨沸腾，所以中国的哲学就走上了关注社会伦常的道路。\n⏱ 2022-11-21 00:30:54\n\n\n当时反对婆罗门教最激烈的，是刹帝利这个阶层。刹帝利掌握了世俗的权利，从而对婆罗门的优势地位很有看法。这个在文化上产生的结果，就是沙门思潮的兴起。沙门意味着努力的、有道德的出家人，沙门思潮的代表，最重要的当然是佛教。\n⏱ 2022-11-21 00:35:01\n\n\n佛教作为沙门思潮的一种，它反对婆罗门教的三大纲领——吠陀天启、祭祀万能、婆罗门至上。\n⏱ 2022-11-21 00:35:39\n\n\n沙门思潮的另一个代表是耆那教。\n⏱ 2022-11-21 00:36:22\n\n\n几千年来，印度哲学的整体面貌，就是这样围绕着正统派和非正统派演变和发展。无论是正统派还是非正统派，他们基本的哲学和价值取向，就是取得人生的解脱。这是印度哲学区别于其他哲学的关键。印度哲学之所以有这样的价值取向，跟印度民族多灾多难的历史有密切的关系。\n⏱ 2022-11-21 00:38:43\n\n第六讲 印度哲学导论（下）\n\n最先驳倒黑格尔的是叔本华。黑格尔只讲理智、理性，不讲意志、情感。叔本华吸收《奥义书》的思想，把意志当作本体。他认为决定世界历史发展的东西不是黑格尔讲的逻各斯，而是意志。叔本华讲的意志是生存意志。作为人来说，哪个没有生存意志？有了这个生存意志，这才有个动力源泉。叔本华可以说是颠覆了黑格尔的逻各斯中心主义。\n⏱ 2022-11-21 00:46:20\n\n\n哲学是一朵花，滋养它的土壤就在它民族生活的社会历史背景中。\n⏱ 2022-11-21 00:47:30\n\n\n因为生长的土壤和宗教源头不同，哲学就有不同的形态，有不同的模式。因此，哲学就是多元的，不能拿一种观点作为标准或中心来衡量。\n⏱ 2022-11-21 00:47:40\n\n\n在价值追求上，印度哲学有一个共同点，是与中国和古希腊不同的，在印度哲学中，哲学即宗教，宗教即哲学。就个人小我而言，个人的解脱是其最高的追求。\n⏱ 2022-11-21 00:49:28\n\n\n印度佛教的发展一般分为四期：原始佛教（从释迦牟尼开始传教始，相当于中国的孔子时代）、部派佛教（又称小乘佛教，相当于中国的秦汉时期）、大乘佛教（相当于中国的东汉到魏晋南北朝时期）、密教时期（相当于中国的唐宋时期）。前后加起来一共一千五百年。这之后佛教在印度就消失了。\n⏱ 2022-11-21 00:50:27\n\n第七讲 中国哲学导论（一）\n\n一般来说，中国哲学经历了这样几个阶段，分朝代的：先秦，这时候诸子百家争鸣，是诸子哲学；汉代，东汉西汉一共有四百年，这时候是经学，就是五经之学；到了魏晋时候呢，就是玄学；那么到了隋唐时候呢，佛学；到了宋明时候呢，是理学；到了清朝时候呢，那就很复杂了，简单地说，那叫朴学，也叫作乾嘉汉学。\n⏱ 2022-11-24 01:37:26\n\n第八讲 中国哲学导论（二）\n\n理性是可以细分的。它能分为几种呢？理性是不是只有一种，一种逻辑推理理性呢？实际上，通过研究，现在很多人都承认理性的形态也是多样的。理性有好几种不同的分法。最常见的分法是：工具理性、价值理性，这是两分的；以及科学理性、人文理性，还有情感，情感也包括在理性的方向里面。中国人最讲究情感的理性化，叫作以理制情，使理性和情感达到一种交融的地步。这也是一种理性。那\n⏱ 2022-11-24 01:42:02\n\n\n各种理性综合形成一个整体，这才是一个大的哲学观。\n⏱ 2022-11-24 01:42:49\n\n第九讲 中国哲学导论（三）\n\n在中国历史上，哲学的发展出现了三次高潮。第一次是春秋战国时期的百家争鸣；第二个时期是魏晋时期，那是第二次的百家争鸣；第三次是宋明时期。\n⏱ 2022-11-27 00:35:34\n\n第十一讲 哲学家的终极关怀\n\n不管三种哲学系统区别如何，都可以归结为天和人的问题、宇宙和人生的问题。在这个问题上有很多种思维模式，通过哲学史的了解，我们知道有三种：（1）天人对立，也就是主体和客体的对立。把客体作为研究对象，主体要找出其中的普遍法则、结构。这是西方哲学的传统。（2）天人同一，天和人是无差别的一体，这个是印度哲学传统中梵我同一主旨的核心。（3）天人既对立又统一。这是中国哲学的传统，我们通常说中国哲学讲天人合一，其实这个讲法不确切。中国哲学采取的是对立统一的中道方式，从对立中寻求合一，在合一中看到对立。这个在魏晋玄学中名教与自然的关系中可以看得很清楚。\n⏱ 2022-11-27 01:08:09\n\n\n北宋理学家张载，字横渠。他说过四句话：“为天地立心，为生民立命，为往圣继绝学，为万世开太平。”这四句就是著名的“横渠四句”。\n⏱ 2022-11-27 01:12:08\n\n第十二讲 哲学与哲学史的关系\n\n哲学与哲学史的关系也类似于本质与现象的关系：看不见、摸不着的哲学的本质正反映在哲学史的现象之中，历史上出现的每一种哲学都是哲学史的必要环节。\n⏱ 2022-11-27 01:15:01\n"},"阅读/大清为何轰然倒塌":{"title":"大清为何轰然倒塌","links":[],"tags":[],"content":"\n\n                  \n                  大清为何轰然倒塌 \n                  \n                \n\n\n\n《大清为何轰然倒塌》-  佛要跳墙\n出版时间： 2024-05-24 00:00:00\nISBN：\nPC地址：weread.qq.com/web/reader/45e32a60813ab8dfag0107ed\n\n\n\n写在前面\n\n因为但凡有点职业素养的封建官僚都知道，可以用暴力抢夺政权，但是要保住政权，可不是光靠暴力就行的，所谓“居马上得之，宁可以马上治之乎”。要牢固统治，还是得靠民意，靠“天命”。\n⏱ 2024-06-04 12:54:40\n\n第一章 汉臣的崛起——庙堂线\n\n这个属于朝代发展的老剧本了，人称造反3+1：人口增长+土地兼并+政治腐败，三大要素凑齐，再加一个天灾引爆。于是秦末“大楚兴，陈胜王”，汉末“苍天已死，黄天当立”，元末“石人一只眼，挑动黄河天下反”，可谓熟悉的配方、熟悉的味道。\n⏱ 2024-06-04 15:11:51\n\n\n问题在于，位子不能当脑子，清流顶多是“误国”，后党那帮人上台，可就是要“丧国”了。\n⏱ 2024-06-04 17:02:16\n\n\n当年太平天国的时候，列强本来跟洪秀全互有来往，一度考虑是不是应该押宝在南京的洪秀全。结果慈禧老公咸丰，在第二次鸦片战争后狠狠地卖国了一把，三大条约一签[插图]，列强马上转而支持朝廷了，不愧是一个被窝里出来的。\n⏱ 2024-06-04 17:06:15\n\n\n照理说，东南互保的那帮大臣个个该千刀万剐，但明面上，慈禧却大肆封赏，感谢各位“老成持国”，没听朝廷的；暗地里，这帮权臣却命运各异。东南互保的大臣中，汉族纷纷被各种理由开缺[插图]，李鸿章、刘坤一死得早，张之洞被拉到军机处，明升暗降，没了地方实权，刘树棠、许应骙、王之春开缺。满族大臣虽然也呼应了东南互保，却纷纷被提拔，德寿升两广总督，端方升两江总督，奎俊升吏部尚书，八旗子弟着手接管各方权力。\n⏱ 2024-06-04 17:07:19\n\n\n第一，在甲午战争一败涂地、庚子国变的抱头鼠窜中，国人不由得兴起“这种货色居然还骑在我们头上”的想法，朝廷合法性饱受打击，天命由此摇摇欲坠；第二，“东南互保”事件让实力派的想法从“出头的那个死定了”，慢慢转为“原来这不是我一个人的想法”，危险的共识由此悄悄成型。\n⏱ 2024-06-04 17:07:47\n\n\n从权术层面来说，慈禧这个老司机简直是特技演员水平的。打压曾国藩用的是左宗棠；平衡李鸿章用的是张之洞。撸掉这两个权臣也费了一番脑筋，利用天津教案败了曾国藩的名声，利用《中法越南条约》之类的卖国条约搞臭李鸿章，都是先斗臭再顺势而为，慈禧位子能坐40年一点都不奇怪。\n⏱ 2024-06-04 17:12:00\n\n第二章 会党的春天——江湖线\n\n可以说，辛亥之前，中国只有造反；辛亥之后，中国方有革命。国人造反经验一大把，革命经验却从来没有过，先驱们最大的贡献，就是把造反变成了革命。\n⏱ 2024-06-04 17:14:25\n\n\n对这群人而言，拜什么神不重要，关键是给他们希望；信什么教不重要，重要的是教众在一起能够抱团求生；甚至反抗什么也不重要，关键是要能吃口饭，活下去。这个在世界范围都是如此，相信救世主，相信同一宗教的都是兄弟姐妹，相信教会能照顾自己，是一个道理的。\n⏱ 2024-06-05 00:23:23\n\n\n几千年来，中国王朝的末期，水深火热的百姓所需要的都一样：一个信仰、一句口号、一个领导、一个社会组织方式，然后被一个火星点燃，趁势揭竿而起向当权者开炮。而这个当权者可能是满族、可能是汉族、可能是朝廷、可能是贪官、可能是洋人传教士……\n⏱ 2024-06-05 00:23:49\n\n\n我们对这一点务必要有清醒的认识，造反在没看到成功希望之前都是流寇，蝗虫般一路吃将过去。看到成功的希望，则摇身一变，开始维系军纪，保境安民，意思是要开始做长远生意了。军匪不分家，这句老话可是有深刻根源的。\n⏱ 2024-06-05 00:25:43\n\n第三章 革命的萌芽——“书生造反”\n\n“社会主义”是给读书人听的，“打土豪分田地”才是留给未庄的阿Q们听的。“消费升级”是个玄学，“拼多多百亿补贴”才是句好口号。\n⏱ 2024-06-05 02:13:38\n\n\n他一辈子都在为革命拉风投，利用各种势力来为革命添砖加瓦，典型的见人说人话，见鬼说鬼话，为达目的使尽了手段。当年的老孙跟美国人谈“反抗帝国压迫”，跟日本人谈“黄种人大团结、大亚洲主义”，跟英国人谈“基督教在中国的传播”，跟法国人谈“投资中国革命的惊人回报”，跟黑社会谈“反清复明”，跟读书人谈“共和社会”……\n⏱ 2024-06-05 02:14:55\n\n\n只不过孙文不需要他人原谅。孙中山生前死后，最不缺的就是“骂”，最不需要的就是“原谅”。少年时代，他砸自己村里的泥菩萨，被骂不敬祖宗，后来却被称作光宗耀祖；青年时代，他搞广州起义失败，被读书人骂痴心妄想，等到甲午之后，众口又称赞他早日看出清廷无药可救，为起义失败扼腕长叹；中年时代，宋教仁被刺，他想要二次革命推翻袁世凯，被骂不识大体，破坏共和，后来袁世凯倒行逆施，悍然称帝，大家又觉得老孙果然目光如炬，看出老袁狼子野心；人生最后几年，他联俄联共，二次黄埔创业，又被梁启超说是苏联人的傀儡……\n⏱ 2024-06-05 02:21:44\n\n第四章 钱从哪里来，枪从哪里来\n\n明治维新时期，日本十万娼妓下南洋，卖淫的钱汇到国内建设新日本，支撑起了日本帝国现代化第一笔资金投入。\n⏱ 2024-06-05 11:27:20\n\n\n姑娘们挣来的钱很好、很干净，日本政府表示很喜欢；姑娘们的身体很脏、很让人尴尬，明治当局表示很不方便提，最好她们都葬在海外，让这段历史消失。所以日本右翼讲起“明治维新”，一口咬定大和民族天赋奇才、艰苦奋斗，崛起是天照大神保佑。可要点脸吧，想想当年那些可怜的姑娘们吧。\n⏱ 2024-06-05 11:27:54\n\n第一章 样板工程\n\n于是，各地官员深受皇恩，无不对国人只吸食洋鸦片而不抽本地货表达了极大的担心——包括那位在虎门硬核硝烟的林则徐大人。林大人在鸦片战争之后任陕甘总督，写信说“鄙意亦以内地栽种罂粟，于事无妨。所恨者，内地之民嗜洋烟而不嗜土烟。”\n⏱ 2024-06-11 13:30:34\n\n\n很快，各地开展了轰轰烈烈的鸦片大生产运动。第二次鸦片结束后的20年内，土烟市占率稳步上升，一度达到80%以上。四川出品鸦片行销全国，种植面积一度占了本省耕地的16%，彻底打败了洋烟，可谓“国货之光”。当然，后果也很严重。大烟馆处处开花，百姓烟瘾缠身，士兵成了“双枪兵”，搞到连西方传教士都看不下去了，1874年居然搞了个“英华禁止鸦片贸易协会”，还出了本《在华宣教士禁烟言论集》，号召传教士们在各自国家游说政府，禁止向中国输出鸦片，简直是把大清的脸都丢光了。\n⏱ 2024-06-11 13:31:09\n\n\n第一次鸦片战争，我们的武器的确不如英国，但远远没有大家想象中差距的那么大。差距最大的，反而是战斗意志。在白刃战中，英国士兵列队、上刺刀、冲锋，然后大清士兵就跑光了，可谓屡试不爽。\n⏱ 2024-06-11 16:24:38\n\n第五章 新政1901\n\n1901年1月，在义和团运动、八国联军侵华、东南互保一系列事件的暴击下，大清内外交困。万般无奈中，慈禧太后以光绪皇帝的名义颁布上谕，开始了继“洋务运动”“百日维新”之后的第三轮大规模系统性深化改革：“庚子新政”，又叫做“清末新政”。\n⏱ 2024-06-13 00:21:42\n\n\n在旧有的框架下解决新的问题，这叫做“中兴”。大清的中兴，是“中学为体”的中兴。\n⏱ 2024-06-13 00:24:11\n\n第一章 权力游戏的两条规则\n\n权力游戏的第一条规则就是：权力的边界在力量的范围之内。\n⏱ 2024-06-18 10:32:31\n\n\n第二条规则：无论正义还是邪恶，力量就是力量，而那些对力量理解最深刻，对力量变化最敏感、自身策略最聪明的人，才能分到最大的蛋糕。\n⏱ 2024-06-18 10:35:33\n\n第二章 “非袁不可”\n\n孙中山他们的任务是什么呢？粗略来看，是“推翻大清”；但再细看，应该是“在保持国土完整、利益不受损的前提下，推翻大清”；而再准确点来说，则是“在保持国土完整、利益不受损的前提下，不仅要推翻大清，且要永久共和”。\n⏱ 2024-06-19 17:49:46\n\n\n：“我们对袁世凯怀有很友好的感情和敬意。我们希望看到，作为革命的一个结果，有一个强有力的政府……维持内部秩序和有利条件，并为革命后在华贸易获得发展创造有利环境。”简单来说，无论最终是君主立宪制还是共和制，“维持中国的稳定，保护列强在华利益”，已经成了英国的官方态度，而袁项城则被英国内定为支持的对象。\n⏱ 2024-06-21 10:11:46\n"},"阅读/未完成/乡土中国-生育制度-乡土重建":{"title":"乡土中国 生育制度 乡土重建","links":[],"tags":[],"content":"\n\n                  \n                  乡土中国 生育制度 乡土重建 \n                  \n                \n\n\n\n《乡土中国 生育制度 乡土重建》-  费孝通\n出版时间： 2019-10-01 00:00:00\nISBN： 9787570212354\nPC地址：weread.qq.com/web/reader/b7932bb0720a2e79b79a9eb\n\n\n\n乡土本色\n\n中国农民聚村而居的原因大致说来有下列几点：一、每家所耕的面积小，所谓小农经营，所以聚在一起住，住宅和农场不会距离得过分远。二、需要水利的地方，他们有合作的需要，在一起住，合作起来比较方便。三、为了安全，人多了容易保卫。四、土地平等继承的原则下，兄弟分别继承祖上的遗业，使人口在一地方一代一代地积起来，成为相当大的村落。\n⏱ 2024-03-20 11:39:51\n\n\n我想我们很可以说，乡土社会的生活是富于地方性的。地方性是指他们活动范围有地域上的限制，在区域间接触少，生活隔离，各自保持着孤立的社会圈子。\n⏱ 2024-03-20 11:40:42\n\n\n在社会学里，我们常分出两种不同性质的社会：一种并没有具体目的，只是因为在一起生长而发生的社会；一种是为了要完成一件任务而结合的社会。\n⏱ 2024-03-20 11:42:27\n\n文字下乡\n\n文字所能传的情、达的意是不完全的。这不完全是出于“间接接触”的原因。我们所要传达的情意是和当时当地的外局相配合的。你用文字把当时当地的情意记了下来，如果在异时异地的圜局中去看，所会引起的反应很难尽合于当时当地的圜局中可能引起的反应。文字之成为传情达意的工具常有这个无可补救的缺陷。于是在利用文字时，我们要讲究文法，讲究艺术。文法和艺术就在减少文字的“走样”。\n⏱ 2024-03-21 19:13:06\n\n\n在说话时，我们可以不注意文法。并不是说话时没有文法，而是因为我们有着很多辅助表情来补充传达情意的作用。我们可以用手指指着自己而在话里吃去一个我字。在写作时却不能如此。于是我们得尽量地依着文法去写成完整的句子了。不合文法的字词难免引起人家的误会，所以不好。说话时我们如果用了完整的句子，不但显得迂阔，而且可笑。这是从书本上学外国语的人常会感到的痛苦。\n⏱ 2024-03-21 22:33:14\n\n\n语言只能在一个社群所有的相同经验的一层上发生。群体愈大，包括的人所有的经验愈繁杂，发生语言的一层共同基础也必然愈有限，于是语言也愈趋于简单化。这在语言史上是看得很清楚的。\n⏱ 2024-03-21 22:34:59\n\n差序格局\n\n为什么我们这个最基本的社会单位的名词会这样不清不楚呢？在我看来却表示了我们的社会结构本身和西洋的格局是不相同的，我们的格局不是一捆一捆扎清楚的柴，而是好像把一块石头丢在水面上所发生的一圈圈推出去的波纹。每个人都是他社会影响所推出去的圈子的中心。被圈子的波纹所推及的就发生联系。每个人在某一时间某一地点所动用的圈子是不一定相同的。\n⏱ 2024-04-11 01:47:16\n\n\n以“己”为中心，像石子一般投入水中，和别人所联系成的社会关系，不像团体中的分子一般大家立在一个平面上的，而是像水的波纹一般，一圈圈推出去，愈推愈远，也愈推愈薄。在这里我们遇到了中国社会结构的基本特性了。\n⏱ 2024-04-11 01:29:03\n\n\n在这种富于伸缩性的网络里，随时随地是有一个“己”作中心的。这并不是个人主义，而是自我主义。个人是对团体而说的，是分子对全体。在个人主义下，一方面是平等观念，指在同一团体中各分子的地位相等，个人不能侵犯大家的权利；一方面是宪法观念，指团体不能抹煞个人，只能在个人们所愿意交出的一分权利控制个人。这些观念必须先假定了团体的存在。在我们中国传统思想里是没有这一套的，因为我们所有的是自我主义，一切价值以“己”作为中心的主义。\n⏱ 2024-04-11 01:31:20\n\n系维着私人的道德\n\n可是在一个安居的乡土社会，每个人可以在土地上自食其力地生活时，只在偶然的和临时的非常状态中才感觉到伙伴的需要。在他们，和别人发生关系是后起和次要的，而且他们在不同的场合下需要着不同程度的结合，并不显著地需要一个经常的和广被的团体。因之他们的社会采取了“差序格局”。\n⏱ 2024-04-11 01:35:34\n\n\n社会结构格局的差别引起了不同的道德观念。道德观念是在社会里生活的人自觉应当遵守社会行为规范的信念。它包括着行为规范、行为者的信念和社会的制裁。它的内容是人和人关系的行为规范，是依着该社会的格局而决定的。从社会观点说，道德是社会对个人行为的制裁力，使他们合于规定下的形式行事，用以维持该社会的生存和绵续。\n⏱ 2024-04-11 01:36:13\n\n\n我们如果要了解西洋的“团体格局”社会中的道德体系，绝不能离开他们的宗教观念的。宗教的虔诚和信赖不但是他们道德观念的来源，而且还是支持行为规范的力量，是团体的象征。在象征着团体的神的观念下，有着两个重要的派生观念：一是每个个人在神前的平等；一是神对每个个人的公道。\n⏱ 2024-04-11 01:37:34\n\n\n孔子有不少次数说“不够说是仁”，但是当他积极地说明仁字是什么时，他却退到了“克己复礼为仁”，“恭宽信敏惠”这一套私人间的道德要素了。他说：“能行五者于天下为仁矣。——恭则不侮，宽则得众，信则人任焉，敏则有功，惠则足以使人。”孔子的困难是在“团体”组合并不坚强的中国乡土社会中并不容易具体地指出一个笼罩性的道德观念来。仁这个观念只是逻辑上的总合，一切私人关系中道德要素的共相，但是因为在社会形态中综合私人关系的“团体”的缺乏具体性，只有个广被的“天下归仁”的天下，这人和“天下”相配的“仁”也不能比“天下”观念更为清晰。所以凡是要具体说明时，还得回到“孝悌忠信”那一类的道德要素。正等于要说明“天下”时，还得回到“父子，昆弟，朋友”这些具体的伦常关系。\n⏱ 2024-04-11 01:55:46\n\n\n不但在我们传统道德系统中没有一个像基督教里那种“爱”的观念——不分差序的兼爱；而且我们也很不容易找到个人对于团体的道德要素。在西洋团体格局的社会中，公务，履行义务，是一个清楚明白的行为规范。而这在中国传统中是没有的。\n⏱ 2024-04-11 01:57:10\n\n\n一个差序格局的社会，是由无数私人关系搭成的网络。\n⏱ 2024-04-11 01:58:43\n\n\n中国的道德和法律，都因之得看所施的对象和“自己”的关系而加以程度上的伸缩。\n⏱ 2024-04-11 02:00:01\n\n家族\n\n我们普通所谓大家庭和小家庭的差别绝不是在大小上，不是在这社群所包括的人数上，而是在结构上。\n⏱ 2024-04-11 02:03:03\n\n\n中国的家是一个事业组织，家的大小是依着事业的大小而决定的。如果事业小，夫妇两人的合作已够应付，这个家也可以小得等于家庭；如果事业大，超过了夫妇两人所能担负时，兄弟伯叔全可以集合在一个大家里。这说明了我们乡土社会中家的大小变异可以很甚。但不论大小上差别到什么程度，结构原则上却是一贯的、单系的差序格局。\n⏱ 2024-04-11 02:06:29\n\n\n乡下，有说有笑，有情有意的是在同性和同年龄的集团中，男的和男的在一起，女的和女的在一起，孩子们又在一起，除了工作和生育事务上，性别和年龄组间保持着很大的距离。这绝不是偶然的，在我看来，这是把生育之外的许多功能拉入了这社群中去之后所引起的结果。中国人在感情上，尤其是在两性间的矜持和保留，不肯像西洋人一般的在表面上流露，也是在这种社会圜局中养成的性格。\n⏱ 2024-04-11 02:08:19\n\n男女有别\n\n在乡土社会中这种精神是不容存在的。它不需要创造新的社会关系，社会关系是生下来就决定的。它更害怕社会关系的破坏，因为乡土社会所求的是稳定。它是阿波罗式的。男女间的关系必须有一种安排，使他们之间不发生激动性的感情。那就是男女有别的原则。“男女有别”是认定男女间不必求同，在生活上加以隔离。这隔离非但是有形的，所谓男女授受不亲，而且还是在心理上的，男女只在行为上按着一定的规则经营分工合作的经济和生育的事业，他们不向对方希望心理上的契洽。\n⏱ 2024-04-11 02:24:20\n\n\n社会秩序范围着个性，为了秩序的维持，一切足以引起破坏秩序的要素都被遏制着。男女之间的鸿沟从此筑下。乡土社会是个男女有别的社会，也是个安稳的社会。\n⏱ 2024-04-11 02:25:51\n\n礼治秩序\n\n法治的意思并不是说法律本身能统治，能维持社会秩序，而是说社会上人和人的关系是根据法律来维持的。法律还得靠权力来支持，还得靠人来执行，法治其实是“人依法而治”，并非没有人的因素。\n⏱ 2024-04-11 02:27:57\n\n\n所谓人治和法治之别，不在人和法这两个字上，而是在维持秩序时所用的力量，和所根据的规范的性质。\n⏱ 2024-04-11 02:28:40\n\n\n可是乡土社会并不是这种社会，我们可以说这是个“无法”的社会，假如我们把法律限于以国家权力所维持的规则；但是“无法”并不影响这社会的秩序，因为乡土社会是“礼治”的社会。\n⏱ 2024-04-11 02:31:12\n\n\n礼是社会公认合式的行为规范。合于礼的就是说这些行为是做得对的，对是合式的意思。如果单从行为规范一点说，本和法律无异，法律也是一种行为规范。礼和法不相同的地方是维持规范的力量。法律是靠国家的权力来推行的。“国家”是指政治的权力，在现代国家没有形成前，部落也是政治权力。而礼却不需要这有形的权力机构来维持。维持礼这种规范的是传统。\n⏱ 2024-04-11 02:30:46\n\n\n礼并不是靠一个外在的权力来推行的，而是从教化中养成了个人的敬畏之感，使人服膺；人服礼是主动的。\n⏱ 2024-04-11 02:34:02\n\n\n这显然是和法律不同了，甚至不同于普通所谓道德。法律是从外限制人的，不守法所得到的罚是由特定的权力所加之于个人的。人可以逃避法网，逃得脱还可以自己骄傲、得意。道德是社会舆论所维持的，做了不道德的事，见不得人，那是不好；受人吐弃，是耻。礼则有甚于道德：如果失礼，不但不好，而且不对、不合、不成。\n⏱ 2024-04-11 02:34:51\n\n\n礼治的可能必须以传统可以有效地应付生活问题为前提。乡土社会满足了这前提，因之它的秩序可以用礼来维持。在一个变迁很快的社会，传统的效力是无法保证的。不管一种生活的方法在过去是怎样有效，如果环境一改变，谁也不能再依着法子去应付新的问题了。所应付的问题如果要由团体合作的时候，就得大家接受个同意的办法，要保证大家在规定的办法下合作应付共同问题，就得有个力量来控制各个人了。这其实就是法律。也就是所谓“法治”。\n⏱ 2024-04-11 02:36:00\n\n\n法治和礼治是发生在两种不同的社会情态中。这里所谓礼治也许就是普通所谓人治，但是礼治一词不会像人治一词那样容易引起误解，以致有人觉得社会秩序是可以由个人好恶来维持的了。礼治和这种个人好恶的统治相差很远，因为礼是传统，是整个社会历史在维持这种秩序。\n⏱ 2024-04-11 02:36:58\n\n无讼\n\n这个譬喻可以用来说明乡土社会对于讼事的看法。所谓礼治就是对传统规则的服膺。生活各方面，人和人的关系，都有着一定的规则。行为者对于这些规则从小就熟习，不问理由而认为是当然的。长期的教育已把外在的规则化成了内在的习惯。维持礼俗的力量不在身外的权力，而是在身内的良心。所以这种秩序注重修身，注重克己。理想的礼治是每个人都自动地守规矩，不必有外在的监督。但是理想的礼治秩序并不是常有的。一个人可以为了自私的动机，偷偷地越出规矩。这种人在这种秩序里是败类无疑。每个人知礼是责任，社会假定每个人是知礼的，至少社会有责任要使每个人知礼。所以“子不教”成了“父之过”。这也是乡土社会中通行“连坐”的根据。儿子做了坏事情，父亲得受刑罚，甚至教师也不能辞其咎，教得认真，子弟不会有坏的行为。打官司也成了一种可羞之事，表示教化不够。\n⏱ 2024-04-12 00:14:30\n\n\n现代都市社会中讲个人权利，权利是不能侵犯的。国家保护这些权利，所以定下了许多法律。一个法官并不考虑道德问题、伦理观念，他并不在教化人。刑罚的用意已经不复“以儆效尤”，而是在保护个人的权利和社会的安全。尤其在民法范围里，他并不是在分辨是非，而是在厘定权利。\n⏱ 2024-04-12 00:18:39\n\n血缘和地缘\n\n地缘是从商业里发展出来的社会关系。血缘是身份社会的基础，而地缘却是契约社会的基础。\n⏱ 2024-04-12 22:19:36\n\n名实的分离\n\n一是在社会冲突中所发生的横暴权力；二是从社会合作中所发生的同意权力；三是从社会继替中所发生的长老权力。现在我又想提出第四种权力，这种权力发生在激烈的社会变迁过程之中。\n⏱ 2024-04-13 09:59:20\n\n\n社会继替是指人物在固定的社会结构中的流动；社会变迁却是指社会结构本身的变动。这两种过程并不是冲突的，而是同时存在的，任何社会绝不会有一天突然变出一个和旧有结构完全不同的样式，所谓社会变迁，不论怎样快，也是逐步的；所变的，在一个时候说，总是整个结构中的一小部分。因之从这两种社会过程里所发生出来的两种权力也必然同时存在。但是它们的消长却互相关联。如果社会变动得慢，长老权力也就更有势力；变得快，“父不父，子不子”的现象就会发生，长老权力也会随着缩小。\n⏱ 2024-04-13 12:00:56\n\n\n我并不愿意接受他们的看法，因为我认为社会结构，像文化的其他部分一般，是人造出来的，是用来从环境里取得满足生活需要的工具。社会结构的变动是人要它变的，要它变的原因是在它已不能答复人的需要。\n⏱ 2024-04-13 12:01:59\n\n\n人们不会在没有发觉旧方法不适用之前就把它放弃的。旧的生活方法有习惯的惰性。但是如果它已不能答复人们的需要，它终必会失去人们对它的信仰，守住一个没有效力的工具是没有意义的，会引起生活上的不便，甚至蒙受损失。\n⏱ 2024-04-13 12:05:19\n\n从欲望到需要\n\n在乡土社会中人可以靠欲望去行事，但在现代社会中欲望并不能作为人们行为的指导，于是产生“需要”，因之有了“计划”。从欲望到需要是社会变迁中一个很重要的里程碑，让我先把欲望和需要这两个概念区别一下。\n⏱ 2024-04-13 12:12:58\n\n\n说人类行为是有动机的包含着两个意思：一是人类对于自己的行为是可以控制的。要这样做就这样做，不要这样做就不这样做，也就是所谓意志；一是人类在取舍之间有所根据，这根据就是欲望。欲望规定了人类行为的方向，就是上面所说要这样要那样的“要”。\n⏱ 2024-04-13 12:15:09\n"},"阅读/未完成/制造消费者：消费主义全球史":{"title":"制造消费者：消费主义全球史","links":[],"tags":[],"content":"\n\n                  \n                  制造消费者：消费主义全球史 \n                  \n                \n\n\n\n《制造消费者：消费主义全球史》-  安东尼·加卢佐\n出版时间： 2022-06-10 00:00:00\nISBN： 9787218113715\nPC地址：weread.qq.com/web/reader/bc732ce0813ab6e0dg01666c\n\n\n\n前言\n\n我们身边的新产品层出不穷，琳琅满目，但我们离它们的生产环节却越来越远。\n⏱ 2024-10-27 01:28:13\n\n\n对人们来说，消费不再意味着消耗和挥霍，而是正常心态下再自然不过的行为活动。\n⏱ 2024-10-27 01:28:54\n\n\n我们就像鱼，消费心理就像水，我们游在其中觉得十分平常，几乎感受不到它的存在。\n⏱ 2024-10-27 01:29:01\n\n第一章 商品的降生：市场的形成和商品拜物教\n\n人们所从事的生产活动产出很低，几乎没有剩余产品，因此也就不可能从事商业活动。\n⏱ 2024-10-27 01:30:29\n\n\n强大的铁路交通使生产能力和消费能力同时得到了提升，它改变了人们惯有的空间概念，距离不再是商品流通的障碍。人类也得以摆脱了自然条件的束缚，在物质追求的道路上越走越远。\n⏱ 2024-10-27 01:32:29\n"},"阅读/未完成/思想的力量（第9版）":{"title":"思想的力量（第9版）","links":[],"tags":[],"content":"\n\n                  \n                  思想的力量（第9版） \n                  \n                \n\n\n\n《思想的力量（第9版）》-  布鲁克·诺埃尔·穆尔 肯尼思·布鲁德\n出版时间： 2017-03-01 00:00:00\nISBN： 9787550294714\nPC地址：weread.qq.com/web/reader/f5a323705e0b7ff5aadcea4\n\n\n\n第一章 充满力量的思想\n\n自愿的行为出自一定的欲望和价值观。这个问题——欲望和价值观是否真的取决于我们自己——深深地属于哲学。\n⏱ 2022-11-27 01:42:33\n\n\n哲学问题的一个重要特征在于，我们没法通过实验方法来直接为之找到答案。\n⏱ 2022-11-27 01:53:42\n\n\n当我们的看法与希望彼此不相协调的时候，也会产生哲学问题。\n⏱ 2022-11-27 01:55:54\n\n\n苏格拉底的方法就是先提出定义，然后用反例驳斥它，继而根据反例修正定义，对修正版再进行辩驳，如此进行下去。\n⏱ 2022-11-27 02:05:39\n\n\n哲学家常常用归谬法（reductio ad absurdum）确立论点，即证明论点的反面是荒谬的，或能够推出（这就是“归”）荒谬。关于时间旅行的思想实验就是归谬法的例子，同时也是思想实验的例子。\n⏱ 2022-11-27 02:06:06\n\n\n·稻草人（straw man）：当我们通过歪曲、误读或夸大来反驳一个观点的时候，我们就犯了“稻草人”的错误。\n⏱ 2022-11-27 02:08:01\n\n\n大部分哲学问题可以归入以下四类：·关于是或者存在的问题。形而上学（metaphysics）是关注这些问题的哲学分支。形而上学提出两个基本问题：什么是存在？什么是存在的基本特征和属性？本章开头列出的一些问题就属于形而上学这一范畴，它包括：上帝存在吗？人真的拥有自由意志吗？形而上学和神秘学、塔罗牌之类的基本不沾边。·关于知识的问题。认识论（epistemology）这一关于知识的理论，是关注这些问题的哲学分支。知识的本质是什么？知识的标准、来源和范围是什么？这是认识论的基本问题，它包括了本章开头列出的这些问题：什么是真理？有可能知道绝对确定的事物吗？· 关于价值的问题。归入这一标题的主要内容有：（1）道德哲学（moral philosophy），即伦理学（ethics），它对道德判断加以哲学上的研究；（2）社会哲学（social philosophy），它是对社会以及社会制度进行哲学研究；（3）政治哲学（political philosophy），它将注意力主要集中在国家上，并试图确定其合法性以及合适的伦理组织；（4）美学（aesthetics），它对艺术及针对艺术的价值判断进行哲学研究。· 关于正确推理的理论，即逻辑学（logic），它试图研究、建立有效推理以及证明的标准。本书的第一部分着重讨论了彼此紧密相关的形而上学和认识论问题。第二部分关注价值的问题，尤其是道德和政治的价值。\n⏱ 2022-11-27 02:11:38\n\n第一部分 形而上学和认识论存在和知识\n\n形而上学（metaphysics），正如你在第一章中读到的那样，它是研究存在的本质及其基本属性的一个哲学分支。认识论（epistemology）这一哲学分支研究知识的来源、本质、范围以及标准。当今哲学家在提出一个形而上学主张的时候，他或她通常会考虑人们是否能够认识它；这就是形而上学和认识论形影相随的原因。\n⏱ 2022-11-28 00:39:13\n\n\n形而上学这一术语来源于亚里士多德的著作，不过他并不是第一个形而上学家。\n⏱ 2022-12-02 18:01:53\n\n\n亚里士多德的《形而上学》一书研究的根本问题，也就是最基本的形而上学问题可以这样表达：什么是存在的本质？\n⏱ 2022-11-28 20:11:50\n\n\n大约在公元前6世纪，第一代哲学家，至少是第一代西方哲学家，生活在小亚细亚海岸爱奥尼亚一带。他们被统称为前苏格拉底哲学家（pre-Socratic philosophers），这只是一个用来指称在苏格拉底（Socrates，约公元前470—前399）之前生活的希腊哲学家的笼统名称。\n⏱ 2022-11-28 20:17:54\n\n\n米利都派哲学家西方哲学的传统应当追溯到泰勒斯（Thales，约公元前625—前547）。他是希腊爱奥尼亚富庶的海港城市米利都的公民，享有第一位西方哲学家的美誉。当泰勒斯思考是否存在某种构成万物的始基的时候，哲学起步了。\n⏱ 2022-11-28 20:43:30\n\n\n不管怎么说，泰勒斯万物皆水的结论是错误的。不过泰勒斯的结论本身并不重要——重要的是泰勒斯提出的思想。他试图用更简单、更基础的实在来解释我们眼中复杂的世界。这一尝试标志着形而上学的开端，就这件事本身而言，也是科学的开端。科学从很大程度上来讲是致力于完成泰勒斯开创的传统。\n⏱ 2022-11-28 20:37:07\n\n\n泰勒斯的学生，阿那克西曼德（Anaximander，公元前610—约前547）认为万物的始基必须要比水和我们所掌握的其他物质更加基本。在他看来始基必定是永恒的、无限的以及不确定的。始基形成一团火和黑色雾状物混合的核子；随着雾状物在核子中心凝固的过程产生了世界万物。世界为火所包围，通过雾状物的孔，形成了我们所看到的星星和其他天体。当冷、热、干、湿的各种力量改变的时候季节也随之发生变化。正如你看到的那样，阿那克西曼德用自然的力量和过程提出了一个解释世界万物的宇宙理论。\n⏱ 2022-11-28 20:50:11\n\n\n阿那克西美尼（Anaximenes，全盛期大约在公元前545年）宣称气是万物的始基，它通过凝聚和稀薄的过程形成不同的事物。气稀薄的时候变成火；气凝聚的时候首先形成了风，然后（通过进一步凝聚）有了云、水、土，最后是石头。他说地球是一个平面，漂浮在空气中。\n⏱ 2022-11-28 21:14:02\n\n\n毕达哥拉斯（Pythagoras，约公元前580—约前500）\n⏱ 2022-11-29 00:36:06\n\n\n由于毕达哥拉斯学派对书面的教义严格保密，这些教义的确切内容一直存有争议。据说毕达哥拉斯认为万物皆数，我们可以努力去理解这句话的含义。两点确定一直线，三点确定一平面，平面组成立方体，立方体组成物体。\n⏱ 2022-11-29 00:36:43\n\n\n毕达哥拉斯学派相信灵魂的轮回，奉行财产共有并且遵循一套严格的道德戒律，其中包括禁止吃肉。\n⏱ 2022-11-29 00:34:50\n\n\n根据西雅娜的说法，毕达哥拉斯认为事物和数字之间存在着一种紧密联系。无论什么事物，不管它是不是物质，都参与到了有序、和谐的宇宙秩序之中：它能够被排序，被计算，被安排。在毕达哥拉斯的哲学中，有序与和谐的概念适用于一切事物。毕达哥拉斯将数学和哲学加以结合，有助于提出一个我们经常面对的、形而上学的重要概念。这种观念就是：基本实体是永恒的、不变的，只能通过理性接近。有时人们认为这个基本实体的概念来自柏拉图，不过公平地说，毕达哥拉斯首先提出了这种观点。\n⏱ 2022-11-29 00:39:16\n\n\n赫拉克利特（Heraclitus，约公元前540—约前480）也是一个重要的前苏格拉底哲学家\n⏱ 2022-11-29 00:49:32\n\n\n赫拉克利特认为，万物皆火。赫拉克利特把火定为万物的始基并不仅是为了在泰勒斯的水和阿那克西美尼的气之外提供另外一种选择，他希望人们注意这一实在的基本特征，即它总是不断变化的。他认为，除了变化这一实在，没有其他实在：永恒是幻觉。因此，不停变化的火是宇宙的本源。\n⏱ 2022-11-29 00:50:40\n\n\n赫拉克利特认为变化的过程并不是任意或偶然的。相反，在他看来，宇宙的秩序，也就是所谓的逻各斯（logos），在希腊语中意为“言说”，决定了一切的变化。\n⏱ 2022-11-29 00:53:18\n\n\n赫拉克利特有句名言：“你不能两次踏入同一条河流。”这句话提出了哲学中重要的同一性问题（problem of identity）或者“变中之同”（sameness over change）\n⏱ 2022-11-29 00:55:00\n\n\n米利都的哲学家们，赫拉克利特和毕达哥拉斯学派大多通过观察周围的世界来选择基本的实体或者万物的始基，进而得出结论。相比之下，巴门尼德只是提出一些基本原则，他试图从这些原则中演绎出他认为存在必然具有的本质。对于巴门尼德来说，凭借观察世界来了解事物真实面目完全是浪费时间。\n⏱ 2022-11-30 00:00:50\n\n\n他有一条原则是这样的：如果事物发生变化，它将成为不同的事物。因此他推理道，要是存在本身会变化的话，那么它将变成不同的东西。但是不同于存在的东西就是非存在，非存在的东西显然不存在。他得出结论，存在不发生变化。此外，存在是唯一的——只有一个存在。如果还有其他存在，它就不是存在；因此，没有其他的存在（这个证明中预设的原则近于“第二个事物不同于第一个事物”）。存在还是不可分的整体：它没有任何的部分。部分不同于整体，如果某些事物不同于存在，它就不是存在。因此，存在是不可分的。最后，存在是永恒的：存在不能生成首先是因为不可能无中生有（还记得吗？）；其次，如果能够生成存在，就不能解释为什么存在在这一时刻来自于无而不是在另一时刻。由于刚才已经论证过变化是不可能的，因此存在不能出离存在。\n⏱ 2022-11-30 00:30:57\n\n\n希腊哲学家恩培多克勒（Empedocles，约公元前490—前430）认为真正的实在是永恒不变的。然而他同样认为把我们经验中的变化贬低为纯粹的幻觉是无稽之谈。恩培多克勒十分巧妙地赞同了巴门尼德的部分观点，也支持了赫拉克利特的部分观点。\n⏱ 2022-11-30 00:48:03\n\n\n在恩培多克勒看来，经验的对象的确是变化的，但是组成这些对象的基本粒子确实是不变的。恩培多克勒认为基本粒子有四种：土、气、火、水。这些基本元素以不同方式组合在一起形成经验的对象以及这些对象的表面变化。经验的对象以及它们表面在数量、质量、关系上的变化实际只是基本粒子位置发生了变化，我们对这一思想感到十分熟悉，它是现代物理的核心思想。恩培多克勒是首先提出这一思想的人之一。\n⏱ 2022-11-30 00:49:31\n\n\n他在形而上学上还做出了一个重要区分：物质和心灵\n⏱ 2022-11-30 01:13:42\n\n\n阿那克萨戈拉同意这样一个原则：一切经验对象的变化实际上只是基本粒子的排列发生的变化。与恩培多克勒不同的是，他相信任何事物都是无限可分的。他认为每种物质都有它相应的粒子，同时每种物质也包含了其他种类的粒子。哪种粒子占有优势就成为哪种物质。举个例子说，火就比水包含更多“火粒子”，而水可能几乎不含有这种粒子。\n⏱ 2022-11-30 01:15:02\n\n\n原子论者认为所有的事物都由物理的原子组成——微小、不可感、不灭、不可分、永恒的和不可创造的粒子材料一致，但大小、形状和重量不尽相同（在重量这点上还存有争议）。他们相信，原子的数量是无限的，并且永远处于运动的状态。它们以不同方式相互结合，构成了经验的对象。它们不断运动，不同的组合也随之不断变化。当然，在我们的经验中它们的组合、分散、重组感觉起来就是普通物体的产生、衰败、腐蚀和燃烧等各种现象。\n⏱ 2022-11-30 01:57:14\n\n\n理解超越表象的实在的渴望并未使前苏格拉底哲学殊途同归。它带领着米利都派哲学家们思考万物的始基，而毕达哥拉斯学派试图确定万物所依赖的基本原则。赫拉克里特想弄清实在的根本特性，巴门尼德沉思存在的真实本质，恩培多克勒则尝试去理解因果关系的基本原理。最后，它带领着阿那克萨戈拉去思索运动的最初来源，带领着原子论者考虑自然世界如何构建。\n⏱ 2022-12-02 17:31:32\n\n第三章 苏格拉底、柏拉图\n\n柏拉图的爱并不排斥物理的美，但是“柏拉图之爱”开始于一个更高的发展阶段，也就是和一个美好的人分享美好的思想。柏拉图认为人年轻的时候应该经历这样的爱。只有思想和精神的爱才能让爱升华，最终永恒地拥有绝对的美和善。\n⏱ 2022-12-07 00:54:27\n"},"阅读/未完成/解构现代化：温铁军演讲录":{"title":"解构现代化：温铁军演讲录","links":[],"tags":[],"content":"\n\n                  \n                  解构现代化：温铁军演讲录 \n                  \n                \n\n\n\n《解构现代化：温铁军演讲录》-  温铁军\n出版时间： 2020-08-01 00:00:00\nISBN： 9787520715485\nPC地址：weread.qq.com/web/reader/8fc32570813ab81bfg017f7e\n\n\n\n“国仁文丛”（Green Thesis）总序\n农业社会万年传承之内因，也在于“三位一体”：在于农民的生产与家庭生计合为一体，在于农村的多元化经济与自然界的多样性合为一体，在于农业的经济过程与动植物的自然过程合为一体。\n\n⏱ 2024-12-31 18:46:52\n\n\n中国近代史上最不堪的麻烦，就在于激进者们罔顾“三农”的正外部性，把城市资本追求现代化所积累的巨大“负外部性”代价向乡土中国倾倒！\n\n⏱ 2024-12-31 18:49:23\n\n\n从历史经验看，新中国在其追求“工业化+城市化=现代化”的道路上，已经发生了九次经济危机，凡是能动员广大农村分担危机成本的，就能实现危机“软着陆”，否则就只能在城市“硬着陆”。\n\n⏱ 2025-01-01 02:01:20\n\n\n第一章 全球化与世界法西斯主义\n如果真正实现了全球经济市场化和一体化，市场的作用就当然会把最过剩的要素价格降到最低。于是，所有发展中国家的劳工价格与他们的生存条件都会同一化到最低程度。\n\n⏱ 2025-01-01 02:09:20\n\n\n我们还应该注意到，在资本全球化的同时，资本也把自然资源的价格压低，这样才能在资源资本化的进程中变成资本的增量收益。因为，资源价格压低之后产生的任何利益，亦即资源转化为资本的收益，大部分都是被大资本所占有的。在全世界发展中国家都普遍发生的大城市超前繁荣、传统农区却难免衰败的趋势，就是这个规律的作用使然。\n\n⏱ 2025-01-01 02:10:21\n\n\n二 谁反对全球化？\n黄平对此做了评价，他指出：以国有企业名义、合资名义、外资名义垄断资源的少数新贵，实际上已经站到了跨国资本代理人的位置，已经不止是从前的买办。\n\n⏱ 2025-01-01 02:13:04\n\n\n中国既然接受资本经济，这种事情就只能按照保障资本收益的制度执行。因为全球化当然也是标准的、制度的全球化。1999年4月，克林顿和中国谈判的时候就明确讲，加入WTO意味着按照西方的制度改变中国。\n\n⏱ 2025-01-01 02:14:21\n\n\n在讨论所谓自由贸易的时候也有语境问题。比如很多人都问这样的问题：经济学不是讨论三要素（资本、土地、劳动力）吗，那么，中国的劳动力要素价格最低，为什么不允许自由贸易到美国去，平衡一下美国劳动力的高价格？中国土地要素稀缺，为什么不允许到美国去种地？西方人在发达国家这个语境中所谈的全球化，实际上仅仅意味着只有一个要素的全球化，就是资本。而单纯强调资本全球化的背后，是反对劳动力和土地要素的全球化；其唯一目的，就是保证大垄断资本的收益不断增加，它的收益只能从对资源的占有和对劳动力所创造的剩余价值的剥夺上来。有了对语境的识别，才可能把问题讲清楚。\n\n⏱ 2025-01-01 02:17:45\n\n\n三 全球化与世界法西斯主义的复苏\n两次世界大战之后不会出现全球瓜分资源的战争，是因为全球都在资源资本化。一旦发展中国家没有新的资源可供资本化了，将会出现真正的重大的全球性危机——不是经济全球化的资本流动危机，而是世界法西斯主义的复苏。\n\n⏱ 2025-01-01 02:19:12\n\n\n所以，一般讲全球化不错，是指商品的自由贸易那种全球化，是19世纪到20世纪上半期的概念；今天，21世纪的全球化，真正反对市场在诸要素自由流动条件下充当“看不见的手”的，其实不是发展中国家的普通民众，而是在泡沫经济崩溃过程中，在连带发生的社会危机中，无路可走的大垄断资本[插图]。\n\n⏱ 2025-01-01 02:25:27\n\n\n那么，到底谁在反对资本流动？一方面是被压迫、被剥夺的发展中国家的民众；另一方面，是那些真正占有垄断地位的大资本，特别是美国、英国的大资本。因为，他们最担心资本流出\n\n⏱ 2025-01-01 02:30:07\n\n\n第二章 重复欧美经验？——无法复制的现代化\n中国正处在最后一个体制转型期，只有金融资本市场尚未市场化。\n\n⏱ 2025-01-01 02:31:40\n\n\n在人口规模上和中国最可比的是南亚的印度，印度在2001年得到的外国投资不到中国的10%，尽管它早就殖民化、市场化了，但外国资本在那里很难有获利的机会，因为印度的资源已经全部被资本化了。而中国，因为有30年前毛泽东的时代，而20年的改革进程尚未完成，所以中国成为全世界经济增长最快、资源向资本转移收益最高的国家。也就是说，现在的外国投资和本土投资占有的，不是一般的制造业所产生的利润，很大程度上是资源向资本转化过程中增加的那部分收益。\n\n⏱ 2025-01-01 02:34:12\n\n\n中国经济最后的竞争，可能是国外资本和国内资本的竞争，当然也会发生在不同的外国资本之间。在今后的5～10年，国内的金融资本在最后的5年不开放期间，会利用它的垄断特权加速资源向资本转化的进程。如果这一过程会加快，则中国的金融资本会壮大，参与国际竞争，否则它的实力是有限的。\n\n⏱ 2025-01-01 02:35:10\n\n\n二 不可重复的西方现代化经验\n金融的根本功能是中介，一方面是交换的中介，一方面是资源转化的中介，在大多数转轨国家这叫“货币深化”。我们把改革的这些计划经济国家的转型过程叫金融深化，或者叫货币化推进资本化。\n\n⏱ 2025-01-01 02:42:01\n\n\n当欧元足以威胁美元成为世界第一货币时，意味着什么？战争。\n\n⏱ 2025-01-01 02:43:15\n\n\n你说主流经济学根据美国经验得出的理论，对所有国家是适用的吗？那种理论背后的经验是可重复的吗？那种经验过程中所形成的制度是可采取的吗？绝对不是。\n\n⏱ 2025-01-01 02:46:44\n\n\n世界上除美国外，只有香港的GDP的增加值中80%来源于以金融为中心的服务贸易。\n\n⏱ 2025-01-01 02:47:17\n\n\n三 中国的出路：加强区域一体化\n虽然现在全球资本化是个主流认同的大趋势，但人们真正看到的是全球“区域化”。那么到底相信资本全球化，还是相信已经出现的经济区域化进程？当人们鼓吹全球化时，主流其实就在告诉人们：完全放开你们的资本市场吧，让我这张绿色的纸可以自由地进入，自由地占有你们在资源向市场转化中增值的那部分收益。\n\n⏱ 2025-01-01 02:52:05\n\n\n第三章 不破不立：解构现代化\n我说：“你在这短短几个月的考察中看到的东西确实是真实的，可我这十多年已经司空见惯了。我要问的是：你感动完了，书也写了，那以后呢，怎么办呢？”\n\n⏱ 2025-01-01 11:06:33\n\n\n二 反思：在调研中重新认识世界和中国\n我们现在所追求的制度变革的目标，如市场化、自由化、民主化、全球化，这些国家都比中国走得远。那么，为什么在制度变革上走得远，经济上也比我们现在公布的数据好看，而社会的三大差别——收入差别、城乡差别、区域差别，亦即我们现在要着力解决的问题，却并没有从根本上得到改观，某种程度上甚至社会矛盾更复杂、更尖锐呢？\n\n⏱ 2025-01-01 11:48:15\n\n\n四 溯源：西方现代化的真相\n历史早就告诉我们，西方人实现的现代化，其实是一个长期殖民化的结果。\n\n⏱ 2025-01-01 11:51:39\n\n\n这个殖民化过程伴随着美洲土著和非洲上亿人口的大量死亡，以及资源环境的大规模破坏，这样就形成了工业化资本原始积累\n\n⏱ 2025-01-01 11:59:03\n\n\n年恩格斯在《英国的工人运动》中说过，英国工人之所以不强烈反抗，在于英国的殖民地能够大量向本土回流资本收益，被国民分享。\n\n⏱ 2025-01-01 12:00:06\n\n\n为什么社会科学不能被称为科学？主要就是因为社会科学不能试验。为什么只有试验得出的结果才是科学的呢？那就是因为，如果在给定的条件下沿着一条技术路线得到一个结果，这个结果应该可以被别人重复，这才是科学的。\n\n⏱ 2025-01-01 17:52:07\n\n\n五 强权政治：资本经济时代唯一不能替代货币的信用来源\n当全世界放弃黄金本位后，货币发行的唯一基础——经济增长当然很重要，但不是绝对的，真正绝对的、可以说是唯一不能替代的货币信用来源，就是政治强权。如果美国没有超过其他国家多少倍的军事力量形成全球霸权，就不可能维持美元的硬通货地位。\n\n⏱ 2025-01-01 19:44:20\n\n\n六 从不怀疑“翻两番”\n资本市场主要是一个把资源和资产通过“资本化”来产生增值的工具。\n\n⏱ 2025-01-01 23:49:10\n\n\n过去我们都是分房子，那时的房子是什么呢？是生活消费资源，连资产都不算。后来住房制度改革了，人们去买房子，房子就转变为资产。如果房子的建造和经营企业再进入股票市场，就是把房地产资本化。人们一旦想买房子，就得先得到多少万元的货币，比如10万元的房价，国家就得增加发行10万元货币。于是购买房子的开支就进入GDP了，亦即增发的10万元货币进入了GDP。如果房地产企业再进入股票市场，股民还得获得更多货币来参与交易，如果再创造出“衍生品”，那又得是多少货币被政府增发出来了？因此，在过去分房子的时代，房子虽然也事实上被人们消费着，却不表现为GDP增量；可是通过改革，从分配变成购买，再变成房地产业的资产进入股票市场，这个GDP增量可不就是翻着番地上去了吗？\n\n⏱ 2025-01-01 23:49:51\n\n"},"阅读/未完成/金瓶梅词话（上下）":{"title":"金瓶梅词话（上下）","links":[],"tags":[],"content":"\n\n                  \n                  金瓶梅词话（上下） \n                  \n                \n\n\n\n《金瓶梅词话（上下）》-  兰陵笑笑生\n出版时间： 2024-11-01 00:00:00\nISBN：\nPC地址：weread.qq.com/web/reader/06e32820813ab952cg01724c\n\n\n\n第一回 景阳冈武松打虎 潘金莲嫌夫卖风月\n大户自从收用金莲之后，不觉身上添了四五件病症。端的那五件？第一，腰便添疼。第二，眼便添泪。第三，耳便添聋。第四，鼻便添涕。第五，尿便添滴。\n\n⏱ 2024-11-22 00:45:13\n\n\n金莲容貌更堪题，笑蹙春山八字眉。若遇风流清子弟，等闲云雨便偷期。\n\n⏱ 2024-11-22 00:49:35\n\n\n可怪金莲用意深，包藏淫行荡春心。武松正大原难犯，耿耿清名抵万金。\n\n⏱ 2024-11-22 00:56:19\n\n\n武松仪表甚搊搜，嫂嫂淫心不可收。笼络归来家里住，要同云雨会风流。\n\n⏱ 2024-11-22 00:56:24\n\n\n有话即长，无话即短，不觉过了一月有余，看看十一月天气，连日朔风紧起。只见四下彤云密布，又早纷纷扬扬，飞下一天瑞雪来。但见：万里彤雪密布，空中祥瑞飘帘，琼花片片舞前檐。剡溪当此际，濡滞子猷船。顷刻楼台都压倒，江山银色相连。飞盐撒粉漫连天，当时吕蒙正，窑内嗟无钱。当日这雪直下到一更时分，却似银妆世界，玉碾乾坤。\n\n⏱ 2024-11-22 00:58:32\n\n\n那妇人独自冷冷清清立在帘儿下，望见武松正在雪里踏着那乱琼碎玉归来。\n\n⏱ 2024-11-22 00:59:09\n\n\n第二回 西门庆帘下遇金莲 王婆子贪贿说风情\n慎事关门幷早归，眼前恩爱隔崔嵬。春心一点如丝乱，任锁牢笼总是虚。\n\n⏱ 2024-11-22 01:47:27\n\n\n黑鬒鬒赛鸦翎的鬓儿，翠弯弯的新月的眉儿，清泠泠杏子眼儿，香喷喷樱桃口儿，直隆隆琼瑶鼻儿，粉浓浓红艳腮儿，娇滴滴银盆脸儿，轻袅袅花朵身儿，玉纤纤葱枝手儿，一捻捻杨柳腰儿，软浓浓白面脐肚儿，窄多多尖趫脚儿，肉奶奶胸儿，白生生腿儿。更有一件紧揪揪、红绉绉、白鲜鲜、黑裀裀，正不知是什么东西！\n\n⏱ 2024-11-22 01:52:32\n\n\n头上戴着黑油油头发䯼髻，四面上贴着飞金。一径里垫出香云一结，周围小簪儿齐插。六鬓斜插一朶并头花，排草梳儿后押。难描八字弯弯柳叶，衬在腮两朶桃花。玲珑坠儿最堪夸，露赛玉酥胸无价。毛青布大袖衫儿褶儿又短，衬湘裙碾绢绫纱。通花汗巾儿袖中儿边搭剌，香袋儿身边低挂。抹胸儿重重纽扣。裤腿儿脏头垂下。往下看：尖趫趫金莲小脚，云头巧缉山牙。老鸦鞋儿白绫高底，步香尘偏衬登踏。红纱膝裤扣莺花，行坐处风吹裙袴。口儿里常喷出异香兰麝，樱桃初笑脸生花。人见了魂飞魄散，卖弄杀偏俏的冤家！\n\n⏱ 2024-11-22 01:53:30\n\n\n第三回 王婆定十件挨光计 西门庆茶房戏金莲\n王婆道：「大官人，你听我说，但凡『挨光』的两个字最难。——怎的是『挨光』？似如今俗呼『偷情』就是了。——要五件事俱全，方纔行的。第一，要潘安的貌。第二，要驴大行货。第三，要邓通般有钱。第四，要妆小伏低，就要绵里针一般软款忍耐。第五、要闲工夫。此五件唤做『潘驴邓小闲』，都全了，此事便获得着。」\n\n⏱ 2024-11-22 02:02:19\n\n\n话休絮烦\n\n⏱ 2024-11-22 02:14:59\n\n\n云鬟迭翠，粉面生春。上穿白夏布衫儿，桃红裙子，蓝比甲。\n\n⏱ 2024-11-22 02:15:58\n\n\n第四回 淫妇背武大偷奸 郓哥不愤闹茶肆\n交颈鸳鸯戏水，并头鸾凤穿花。喜孜孜连理枝生，美甘甘同心带结。一个将朱唇紧贴，一个把粉脸斜偎。罗袜高挑，肩膊上露两弯新月。金钗斜坠，枕头边堆一朶乌云。誓海盟山，搏弄得千般旖旎。羞云怯雨，揉搓的万种妖娆。恰恰莺声，不离耳畔。津津甜唾，笑吐舌尖。杨柳腰，脉脉春浓。樱桃口，微微气喘。星眼朦胧，细细汗流香玉颗。酥胸荡漾，涓涓露滴牡丹心。直饶匹配眷姻谐，真个偷情滋味美！\n\n⏱ 2024-11-22 02:27:10\n\n\n动人心红白肉色，堪人爱可意裙钗。裙拖着翡翠纱，衫袖挽泥金攥，喜孜孜宝髻斜歪。恰便似月里姮娥下世来，不枉了千金也难买！\n\n⏱ 2024-11-22 02:31:26\n\n\n少顷，吃得酒浓，不觉烘动春心，西门庆色心辄起，露出腰间那话，引妇人纤手扪弄。原来西门庆自幼常在三街四巷养婆娘，根下犹束着银打就、药煮成的托子。那话约有六寸许长大，红赤赤黑胡，直竖竖坚硬，好个东西！有诗单道其态为证：一物从来六寸长，有时柔软有时刚。软如醉汉东西倒，硬似风僧上下狂。出牝入阴为本事，腰州脐下作家乡。天生二子随身便，曾与佳人斗几场。\n\n⏱ 2024-11-22 02:34:39\n\n\n西门庆摸见牝户上并无毳毛，犹如白馥馥、鼓蓬蓬、软浓浓、红绉绉、紧（糹秋）（糹秋），千人爱、万人贪，更不知是何物！有诗为证：温紧香干口赛莲，能柔能软最堪怜。喜便吐舌开口笑，困时随力就身眠。内裆县里为家业，薄草涯边是故园。若遇风流清子弟，等闲战斗不开言。\n\n⏱ 2024-11-23 01:47:19\n\n\n第五回 郓哥帮捉骂王婆 淫妇药酖武大郎\n油煎肺腑，火燎肝肠。心窝里如雪刃相侵，满腹中似钢刀乱搅。浑身冰冷，七窍血流。牙关紧咬，三魂赴枉死城中。喉管枯干，七魄投望乡台上。地狱新添食毒鬼，阳间没了捉奸人。\n\n⏱ 2024-11-22 02:49:01\n\n\n雪隐鹭鹚飞始见，柳藏鹦鹉语方知。\n\n⏱ 2024-11-22 02:50:23\n\n\n第六回 西门庆买嘱何九 王婆打酒遇大雨\n一日将近端阳佳节，但见：绿杨袅袅垂丝碧，海榴点点胭脂赤。两两乱莺啼，（毛参）（毛参）梧竹齐。微微风动幔，飒飒凉侵扇。处处过端阳，家家共举觞。\n\n⏱ 2024-11-22 02:55:57\n\n\n只见红日当天，忽一块湿云过处，大雨倾盆相似。但见：乌云生四野，黑雾锁长空。刷剌剌漫空障日飞来，一点点击得芭蕉声碎。狂风相助，侵天老桧掀翻。霹雳交加，泰华嵩峤震动。洗炎驱暑，润泽田苗。洗炎驱暑，佳人贪其赏玩。润泽田苗，行人忘其泥泞。正是：江淮河济添新水，翠竹红榴洗濯清。\n\n⏱ 2024-11-22 02:58:03\n\n\n西门庆一面取下琵琶来，搂妇人在怀，看他放在膝儿上，轻舒玉笋，款弄冰弦，慢慢弹着，唱了一个〈两头南调儿〉：「冠儿不戴懒梳妆，髻挽青丝云鬓光。金钗斜插在乌云上。唤梅香，开笼箱，穿一套素缟衣裳，打扮的西施模样。出绣房，梅香，你与我卷起帘儿，烧一炷儿夜香。」\n\n⏱ 2024-11-22 02:59:09\n\n\n那妇人枕边风月，比娼妓尤甚，百般奉承。西门庆亦施逞鎗法打动。两个女貌郎才，俱在妙龄之际。有诗单道其态，诗曰：寂静兰房簟枕凉，佳人才子至妙顽。纔去倒浇红腊烛，忽然又棹夜行船。偷香粉蝶餐花萼，戏水蜻蜓下下旋。乐极情浓无限趣，灵龟口内吐清泉。\n\n⏱ 2024-11-22 03:02:58\n\n\n第七回 薛婆儿说娶孟玉楼 杨姑娘气骂张四舅\n媒妁殷勤说始终，孟姬爱嫁富家翁。有缘千里能相会，无缘对面不相逢。\n\n⏱ 2024-11-22 10:58:46\n\n\n里面仪门紫墙，竹枪篱影壁，院内摆设榴树盆景，台基上靛缸一溜，打布凳两条。薛嫂推开朱红槅扇，三间倒坐，客位正面上供养着一轴水月观音、善财童子，四面挂名人山水，大理石屏风，安着两座投箭高壶，上下椅桌光鲜，帘栊潇洒。\n\n⏱ 2024-11-22 11:57:24\n\n\n良久，只闻环佩叮咚，兰麝馥郁，妇人出来。上穿翠蓝麒麟补子妆花纱衫，大红妆花宽栏。头上珠翠堆盈，凤钗半卸。西门庆睁眼观那妇人，但见：长挑身材，粉妆玉琢。模样儿不肥不瘦，身段儿不短不长，面上稀稀有几点微麻，生的天然俏丽。裙下映一对金莲小脚，果然周正堪怜。二珠金环，耳边低挂。双头鸾钗，鬓后斜插。但行动，胸前摇响玉玲珑。坐下时，一阵麝兰香喷鼻。恰似嫦娥离月殿，犹如神女下瑶阶。\n\n⏱ 2024-11-22 12:01:34\n\n\n薛嫂在傍插口道：「妻大两，黄金日日长。妻大三，黄金积如山。」\n\n⏱ 2024-11-22 12:03:58\n\n\n销金帐里，依然两个新人。红锦被中，现出两般旧物。\n\n⏱ 2024-11-22 17:43:03\n\n\n第八回 潘金莲永夜盼西门庆 烧夫灵和尚听淫声\n当下妇人打了一回相思卦，见西门庆不来了，不觉困倦上来，就歪在床上盹睡着了。约一个时辰醒来，心中正没好气。迎儿问：「热了水，娘洗澡也不洗？」妇人便问：「角儿蒸熟了？拿来我看。」迎儿连忙拿到房中。妇人用纤手一数，原做下一扇笼三十个角儿，翻来覆去只数了二十九个，少了一个角儿。便问：「往哪里去了？」迎儿道：「我并没看见，只怕娘错数了。」妇人道：「我亲数了两遍，三十个角儿，要等你爹来吃。你如何偷吃了一个？好娇态淫妇奴才！你害馋痨馋痞，心里要想这个角儿吃？你大碗小碗（口床）捣不下饭去？我做下的孝顺你来！」于是不由分说，把这小妮子跣剥去了身上衣服，拿马鞭子下手打了二三十下，打的妮子杀猪般也似叫。问着他：「你不承认，我定打下百数！」打的妮子急了，说道：「娘休打，是我害饿的慌，偷吃了一个。」妇人道：「你偷了，如何赖我错数了？眼看着就是个牢头祸根淫妇！有那亡八在时，轻学重告。今日往哪里去了？还在我跟前弄神弄鬼！我只把你这牢头淫妇打下你下截来！」打了一回，穿上小衣，放他起来，吩咐在旁打扇。打了一回扇，口中说道：「贼淫妇，你舒过脸来，等我掐你这皮脸两下子。」那妮子真个舒着脸，被妇人尖指甲掐了两道血口子，纔饶了他。\n\n⏱ 2024-11-22 17:49:29\n\n\n原来妇人在房中，香熏鸳被，款剔银灯，睡不着，短叹长吁，翻来覆去。正是：得多少琵琶夜久殷勤弄，寂寞空房不忍弹。\n\n⏱ 2024-11-22 17:56:11\n\n\n一双挑线密约深盟随君膝下香草边阑松竹梅花岁寒三友酱色缎子护膝。\n\n⏱ 2024-11-22 18:00:46\n\n\n密云迷晚岫，暗雾锁长空。羣星与皓月争辉，绿水共青天斗碧。僧投古寺，深林中嚷嚷鸦飞。客奔荒村，闾巷内汪汪犬吠。枝上子规啼夜月，园中粉蝶戏花来。\n\n⏱ 2024-11-22 18:04:14\n\n\n分开八块顶梁骨，倾下半桶冰雪来。\n\n⏱ 2024-11-22 18:06:13\n\n\n那众和尚见了武大这个老婆，一个个都昏迷了佛性禅心，一个个都关不住心猿意马，都七颠八倒，酥成一块。但见：班首轻狂，念佛号不知颠倒。维那昏乱，诵经言岂顾高低。烧香行者，推倒花瓶。秉烛头陀，错拿香盒。宣盟表白，大宋国称做大唐。忏罪阇黎，武大郎念为大父。长老心忙，打鼓借拿徒弟手。沙弥心荡，磬槌打破老僧头。从前苦行一时休，万个金刚降不住。\n\n⏱ 2024-11-22 18:08:19\n\n\n看官听说：世上有德行的高僧，坐怀不乱的少。古人有云：一个字便是「僧」，二个字便是「和尚」，三个字是个「鬼乐官」，四个字是「色中饿鬼」。苏东坡又云：不秃不毒，不毒不秃。转毒转秃，转秃转毒。此一篇议论，专说这为僧戒行。住着这高堂大厦、佛殿僧房，吃着那十方檀越钱粮，又不耕种，一日三餐，又无甚事萦心，只专在这色欲上留心。譬如在家俗人，或士农工商，富贵长者，小相俱全，每被利名所绊，或人事往来，虽有美妻少妾在旁，忽想起一件事来关心，或探探瓮中无米，囤内少柴，早把兴来没了。却输与这和尚们许多。有诗为证：色中饿鬼兽中狨，坏教贪淫玷祖风。此物只宜林下看，不堪引入画堂中。\n\n⏱ 2024-11-22 18:09:41\n\n\n淫妇烧灵志不平，和尚窃壁听淫声。果然佛道能消罪，亡者闻之亦惨魂。\n\n⏱ 2024-11-22 18:12:05\n\n\n第九回 西门庆计娶潘金莲 武都头误打李外传\n堪笑西门不识羞，先奸后娶丑名留。轿内坐着浪淫妇，后边跟着老牵头。\n\n⏱ 2024-11-22 18:14:25\n\n\n眉似初春柳叶，常含着雨恨云愁。脸如三月桃花，暗带着风情月意。纤腰袅娜，拘束的燕懒莺慵。檀口轻盈，勾引得蜂狂蝶乱。玉貌妖娆花解语，芳容窈窕玉生香。\n\n⏱ 2024-11-22 21:16:24\n\n\n无形无影，非雾非烟。盘旋似怪风侵骨冷，凛冽如杀气透肌寒。昏昏暗暗，灵前灯火失光明。惨惨幽幽，壁上纸钱飞散乱。隐隐遮藏食毒鬼，纷纷飘逐影魂幡。\n\n⏱ 2024-11-23 01:08:25\n\n\n第十回 武二充配孟州道 妻妾宴赏芙蓉亭\n怎见当日好筵席？但见：香焚宝鼎，花插金瓶。器列象州之古玩，帘开合浦之明珠。水晶盘内，高堆火枣交梨。碧玉杯中，满泛琼浆玉液。烹龙肝，炮凤腑，果然下筯了万钱。黑熊掌，紫驼蹄，酒后献来香满座。更有那软炊红莲香稻，细脍通印子鱼。伊鲂洛鲤，诚然贵似牛羊。龙眼荔枝，信是东南佳味。碾破凤团，白玉瓯中分碧浪。斟来琼液，紫金壶内喷清香。毕竟压赛孟尝君，只此敢欺石崇富。\n\n⏱ 2024-11-23 01:22:51\n\n\n西门庆且不与他云雨，明知妇人第一好品箫，于是坐在青纱帐内，令妇人马爬在身边，双手轻笼金钏，捧定那话，往口里吞放。西门庆垂首玩其出入之妙，呜咂良久，淫情倍增，因呼春梅进来递茶。\n\n⏱ 2024-11-23 01:32:33\n\n\n纱帐轻飘兰麝，娥眉惯把箫吹。雪白玉体透房帏，禁不住魂飞魄荡。玉腕款笼金钏，两情如醉如痴。才郎情动嘱奴知：慢慢多咂一会。\n\n⏱ 2024-11-23 01:34:00\n\n\n春点杏桃红绽蕊，风欺杨柳绿翻腰\n\n⏱ 2024-11-23 01:35:27\n\n\n第十一回 潘金莲激打孙雪娥 西门庆梳笼李桂姐\n话说潘金莲在家，恃宠生骄，颠寒作热，镇日夜不得个寜静。性极多疑，专一听篱察壁，寻些头恼厮闹。\n\n⏱ 2024-11-23 01:36:50\n\n\n西门庆恰进门坎，看见二人家常都戴着银丝䯼髻，露着四鬓，耳边青宝石坠子，白纱衫儿，银红比甲，挑线裙子，双弯尖趫红鸳瘦小，一个个粉妆玉琢，不觉满面堆笑，戏道：「好似一对儿粉头，也值百十两银子！」\n\n⏱ 2024-11-23 01:45:38\n\n\n这西门庆不听便罢，听了此言，三尸神暴跳，五陵气冲天。\n\n⏱ 2024-11-23 01:59:44\n\n\n罗衣迭雪，宝髻堆云。樱桃口，杏脸桃腮。杨柳腰，兰心蕙性。歌喉宛啭，声如枝上流莺。舞态蹁跹，影似花间凤转。腔依古调，音出天然。舞回明月坠秦楼，歌遏行云遮楚馆。高低紧慢，按宫商吐玉喷珠。轻重疾徐，依格调铿金戛玉。筝排鴈柱声声慢，板排红牙字字新。\n\n⏱ 2024-11-23 02:02:30\n\n\n琉璃锺，琥珀浓，小槽酒滴珍珠红。烹龙炮凤玉脂粒，罗帷绣幕围香风。吹龙笛击鼍鼓。皓齿歌，细腰舞。况是青春莫虚度。银缸掩映娇娥语：酒不到刘伶坟上土。\n\n⏱ 2024-11-23 02:05:58\n\n\n第十二回 潘金莲私仆受辱 刘理星魇胜贪财\n青春未及三十岁，欲火难禁一丈高。\n\n⏱ 2024-11-23 02:08:01\n\n\n人人动嘴，个个低头。遮天映日，犹如蝗蝻一齐来。挤眼掇肩，好似饿牢纔打出。这个抢风膀臂，如经年未见酒和肴。那个连三筷子，成岁不逢筵与席。一个汗流满面，却似与鸡骨朵有冤仇。一个油抹唇边，恨不把猪毛皮连唾咽。吃片时，杯盘狼藉。啖良久，筯子纵横。杯盘狼籍，如水洗之光滑。筯子纵横，似打磨之干净。这个称为食王元帅，那个号作净盘将军。酒壶翻晒又重斟，盘馔已无还去探。正是：珎羞百味片时休，果然都送入五脏庙。\n\n⏱ 2024-11-23 02:16:15\n\n\n一个气喑眼瞪，好似牛吼柳影。一个言娇语涩，浑如莺啭花间。一个耳畔诉雨意云情，一个枕边说山盟海誓。\n\n⏱ 2024-11-23 02:19:52\n\n\n第十三回 李瓶儿隔墙密约 迎春女窥隙偷光\n人生虽未有十全，处世规模要放宽！好歹但看君子语，是非休听小人言。徒将世俗能欢戏，也畏人心似隔山。寄语知音女娘道：莫将苦处语为甜。\n\n⏱ 2024-11-23 02:33:07\n\n\n头上打一下，脚底板响的人\n\n⏱ 2024-11-23 02:36:51\n\n\n看见妇人领着两个丫鬟在门首。西门庆便在门前咳嗽，一回走过东来，又往西去。或在对门站立，把眼不住望门里盼看。妇人影身在门里，见他来，便闪进里面。他过去了，又探头去瞧。两个眼意心期，已在不言之表。\n\n⏱ 2024-11-23 02:38:30\n\n\n那吴月娘听了，与他打了个问讯，说道：「我的哥哥，你自顾了你罢，又泥佛劝土佛！你也成日不着个家，在外养女调妇，又劝人家汉子！」\n\n⏱ 2024-11-23 02:40:23\n\n\n灯光影里，鲛绡帐内，一来一往，一撞一冲。这一个玉臂忙摇，那一个金莲高举。这一个莺声呖呖，那一个燕语喃喃：好似君瑞遇莺娘，犹若宋玉偷神女。山盟海誓，依稀耳中。蝶恋蜂恣，未肯即罢。战良久，被翻红浪，灵犀一点透酥胸。斗多时，帐摇银钩，眉黛两弯垂玉脸。那正是三次亲唇情越厚，一酥麻体与人偷。\n\n⏱ 2024-11-23 02:46:27\n\n\n第十四回 花子虚因气丧身 李瓶儿送奸赴会\n正说着，只见潘金莲上穿丁香色潞紬雁衔芦花样对衿袄儿，白绫竖领，妆花眉子，溜金蜂赶菊钮扣儿。下着一尺宽海马潮云、羊皮金沿边挑线裙子。大红缎子白绫高底鞋，妆花膝裤。青宝石坠子，珠子箍——与孟玉楼一样打扮。\n\n⏱ 2024-11-23 14:38:05\n\n\n第十五回 佳人笑赏玩灯楼 狎客帮嫖丽春院\n怎见好灯市？但见：山石穿双龙戏水，云霞映独鹤朝天。金莲灯、玉楼灯，见一片珠玑。荷花灯、芙蓉灯，散千围锦绣。绣球灯，皎皎洁洁。雪花灯，拂拂纷纷。秀才灯，揖让进止，存孔孟之遗风。媳妇灯，容德温柔，效孟姜之节操。和尚灯，月明与柳翠相连。通判灯，钟馗共小妹并坐。师婆灯，挥羽扇，假降邪神。刘海灯，背金蟾，戏吞至宝。骆驼灯、青狮灯，驮无价之奇珎，咆咆哮哮。猿猴灯、白象灯，进连城之秘宝，顽顽耍耍。七手八脚，螃蠏灯倒戏清波。巨口大髯，鲇鱼灯平吞绿藻。银荷斗彩，雪柳争辉。双双随绣带香球，缕缕拂华旛翠幰。鱼龙沙戏，七眞五老献丹书。吊挂流苏，九夷八蛮来进宝。村里社鼓，队队共喧阗。百戏货郎，桩桩齐斗巧。转灯儿一来一往，吊灯儿或仰或垂。琉璃瓶现美女奇花，云母障呈瀛州阆苑。往东看：雕漆床、螺钿床，金碧交辉。向西瞧：羊皮灯、掠彩灯，锦绣夺眼。北一带，都是古董玩器。南壁厢，尽皆书画瓶炉。王孙争看，小栏下蹴鞠齐云。仕女相携，高楼上妖娆衒色。卦肆云集，相幕星罗：讲新春造化如何，定一世荣枯有准。又有那站高坡打谈的，词曲杨恭。到看这〈扌扉〉响钹游脚僧，演说三藏。卖元宵的，高堆果馅。粘梅花的，齐插枯枝。剪春娥，鬓边斜插闹东风。祷凉钗，头上飞金光耀日。围屏画石崇之锦帐，珠帘绘梅月之双清。虽然览不尽鳌山景，也应丰登快活年！\n\n⏱ 2024-11-23 17:54:04\n\n\n柳底花阴压路尘，一回游赏一回新。不知买尽长安笑，活得苍生几户贫？\n\n⏱ 2024-11-23 18:12:20\n\n\n半日，李桂姐出来。家常挽着一窝丝杭州攒，金累丝钗，翠梅花钿儿，珠子箍儿，金灯笼坠子。上穿白绫对衿袄儿，妆花眉子，绿遍地金掏袖。下着红罗裙子。打扮的粉妆玉琢。\n\n⏱ 2024-11-25 01:59:00\n\n\n当下桂姐踢了两跑下来，使的尘生眉畔，汗湿腮边，气喘吁吁，腰肢困乏。\n\n⏱ 2024-11-25 02:02:33\n\n\n第十六回 西门庆谋财娶妇 应伯爵庆喜追欢\n倾城倾国莫相疑，巫水巫云梦亦痴。红粉情多销骏骨，金兰谊薄惜蛾眉。温柔乡里精神健，窈窕风前意态奇。村子不知春寂寂，千金此夕故踟蹰。\n\n⏱ 2024-11-25 02:04:20\n\n\n李瓶儿堂中秉烛，花冠齐整，素服轻盈，正倚帘栊，口中嗑瓜子儿。\n\n⏱ 2024-11-25 02:04:58\n\n\n金炉添兽炭，宝篆爇龙涎。春台上高堆异品，银杯中香醪满泛。\n\n⏱ 2024-11-25 02:13:50\n\n\n奴家得奉巾栉之欢，以遂于飞之愿。\n\n⏱ 2024-11-25 17:46:37\n\n\n第十七回 宇给事劾倒杨提督 李瓶儿招赘蒋竹山\n两个在纱帐之中，香焚兰麝，衾展鲛绡，脱去衣裳，并肩迭股，饮酒调笑。良久，春色横眉，淫心荡漾。\n\n⏱ 2024-11-26 00:26:56\n\n\n纱帐香飘兰麝，蛾眉轻把箫吹。雪白玉体透帘帏，禁不住魂飞魄扬。一点樱桃小口，两只手赛柔荑。才郎情动嘱奴知，不觉灵犀味美。\n\n⏱ 2024-11-26 00:27:03\n\n\n西门庆不看万事皆休，看了耳边厢只听飕的一声，魂魄不知往哪里去了。就是：惊损六叶连肝肺，唬坏三毛七孔心。\n\n⏱ 2024-11-26 00:37:26\n\n\n懒把蛾眉扫，羞将粉脸匀。满怀幽恨积，憔悴玉精神。\n\n⏱ 2024-11-26 00:39:10\n\n\n第十八回 来保上东京干事 陈经济花园管工\n朝登紫陌，暮践红尘，饥餐渴饮，带月披星。\n\n⏱ 2024-11-26 00:48:02\n\n\n一日，七月中旬时分，金风淅淅，玉露泠泠。\n\n⏱ 2024-11-26 00:54:45\n\n\n陈经济扭颈回头，猛然一见，不觉心荡目摇，精魂已失。正是：五百年冤家今朝相遇，三十年恩爱一旦遭逢。\n\n⏱ 2024-11-26 01:04:34\n\n\n回首见西门庆仰卧枕上，睡得正浓，摇之不醒。其腰间那话，带着托子，累垂伟长。不觉淫心輙起，放下烛台，用纤手扪弄。弄了一回，蹲下身去，用口吮之。\n\n⏱ 2024-11-26 02:11:53\n\n\n怪底佳人风性重，夜深偷弄紫鸾箫。\n\n⏱ 2024-11-26 02:12:10\n\n\n妇人于是顽了有一顿饭时，西门庆忽然想起一件事来，叫春梅筛酒过来，在床前执壶而立。将烛移在床背板上，教妇人马爬在他面前，那话隔山取火，插入牝中，令其自动，在上饮酒取其快楽。\n\n⏱ 2024-11-26 02:14:20\n\n\n因为那日后边会遇陈经济一遍，见小伙儿生的乖猾伶俐，有心也要勾搭他。但只畏惧西门庆，不敢下手。只等的西门庆往那里去不在家，便使了丫鬟叫进房中，与他茶水吃，常时两个下棋做一处。\n\n⏱ 2024-11-26 02:16:53\n\n\n第十九回 草里蛇逻打蒋竹山 李瓶儿情感西门庆\n里面花木庭台，一望无际，端的好座花园！但见：正面丈五高，心红彩漆绰屑。周围二十板，（石古）炭乳口泥墙。当先一座门楼，四下几多台榭。假山眞水，翠竹苍松。高而不尖谓之台，巍而不峻谓之榭。论四时赏玩，各有去处：春赏燕游堂，桧栢争鲜：夏赏临溪馆，荷莲斗彩。秋赏迭翠楼，黄菊迎霜。冬赏藏春阁，白梅积雪。刚见那娇花笼浅径，嫩柳拂雕栏。弄风杨柳纵蛾眉，带雨海棠陪嫩脸。燕游堂前，金灯花似开不开。藏春阁后，白银杏半放不放。平野桥东，几朵粉梅开卸。卧云亭上，数株紫荆未吐。湖山侧，纔绽金钱。宝槛边，初生石笋。翩翩紫燕穿帘幕，呖呖黄莺度翠阴。也有那月窗雪洞，也有那水阁风亭。木香棚与荼蘼架相连，千叶桃与三春柳作对。也有那紫丁香、玉马樱、金雀藤、黄刺薇、香茉莉、瑞僊花。卷棚前后，松墙竹径，曲水方池，映阶蕉棕，向日葵榴。游鱼藻内惊人，粉蝶花间对舞。正是：芍药展开菩萨面，荔枝擎出鬼王头。\n\n⏱ 2024-11-26 02:20:24\n\n\n当下吴月娘领着众妇人，或携手游芳径之中，或斗草坐香茵之上。一个临栏对景，戏将红豆掷金鳞。一个伏槛观花，笑把罗纨惊粉蝶。\n\n⏱ 2024-11-26 02:21:04\n\n\n因看见妇人上穿沉香色水纬罗对衿衫儿，五色绉纱眉子。下着白碾光绢挑线裙子，裙边大红光素缎子白绫高底羊皮金云头鞋儿。头上银丝䯼髻，金镶玉蟾宫折桂分心，翠梅钿儿，云鬓簪着许多花翠，越显出红馥馥朱唇，白腻腻粉脸，不觉淫心辄起，搀起他两只手儿，搂抱在一处亲嘴。\n\n⏱ 2024-11-26 02:28:30\n\n\n不一时，春梅筛上酒来，两个一递一口儿饮酒咂舌，咂的舌头一片声响。妇人一面搂起裙子，坐在身上，噙酒哺在他口里，然后在桌上纤手拈了一个鲜莲蓬子与他吃。西门庆道：「涩剌剌的吃他做甚么？」妇人道：「我的儿，你就掉了造化了，娘手里拿的东西儿你不吃。」于是口中噙了一粒鲜核桃仁儿，送与他，纔罢了。西门庆又要玩弄妇人的胸乳。妇人一面摘下（扌寨）领子的金三事儿来，用口咬着，摊开罗衫，露见美玉无瑕，香馥馥的酥胸，紧就就的香乳。揣揣摸摸良久，用口犊之，彼此调笑，曲尽于飞。\n\n⏱ 2024-11-26 02:30:12\n\n\n西门庆道：「你还不知他哩！也是左近一个人家请他看病，正自街上买了一尾鱼，手提着。见那人请他说：『我送了鱼到家就来。』那人说：『家中有紧病，请师父就去罢。』这蒋竹山一直跟到他家。病人在楼上，请他上楼，不想是个女人不好，素体慵妆，走出房来，舒手教他把脉。这厮手把着脉，想起他鱼来，挂在帘钩儿上，就忘记看脉，只顾且问：『嫂子，你下边有猫儿也没有？』不想他男子汉在屋里听见了，走来采着毛，打了个臭死，药钱也没有与他，把衣服扯的稀烂，得手纔跑了。」\n\n⏱ 2024-11-26 02:32:44\n\n\n尝将压善欺良意，权作尤云殢雨心。\n\n⏱ 2024-11-26 12:34:54\n\n\n每日茶饭慵餐，蛾眉懒画，把门倚遍，眼儿望穿，白盼不见一个人儿来。正是：枕上言犹在，于今恩爱沦。房中人不见，无语自消魂。\n\n⏱ 2024-11-26 12:41:00\n\n\n身如五鼓衔山月，命似三更油尽灯\n\n⏱ 2024-11-26 13:47:19\n\n\n第二十回 孟玉楼义劝吴月娘 西门庆大闹丽春院\n灯光掩映，不啻镜中之鸾凤和鸣。香气熏笼，好似花间之蝴蝶对舞。正是：今宵剩把银缸照，祇恐相逢是梦中。\n\n⏱ 2024-11-26 14:29:21\n\n\n厅上又早铺下锦毡绣毯，麝兰叆叇，丝竹和鸣，四个唱的，导引前行。妇人身穿大红五彩通袖罗袍儿，下着金枝緑叶沙绿百花裙，腰里束着碧玉女带，腕上笼着金压袖。胸前项牌璎珞，裙边环佩玎珰，头上珠翠堆盈，鬓畔宝钗半卸。紫瑛金环，耳边低挂。珠子挑凤，髻上双插。粉面宜贴翠花钿，湘裙越显红鸳小。正是：恍似嫦娥离月殿，犹如神女到筵前。四个唱的，琵琶筝弦，簇拥妇人，花枝招飐，绣带飘飘，望上朝拜。慌的众人都下席来还礼不迭。\n\n⏱ 2024-11-27 00:51:09\n\n\n。光阴似箭，日月如梭。才见中秋赏月，忽然菊绽东篱。空中寒鴈向南飞，不觉雪花满地。\n\n⏱ 2024-11-27 01:01:59\n\n\n第二十一回 吴月娘扫雪烹茶 应伯爵替花勾使\n灯前看见他家常穿着：大红潞紬对衿袄儿，软黄裙子。头上戴着貂鼠卧兔儿，金满池娇分心。越显出他粉妆玉琢银盆脸，蝉髻鸦鬟楚岫云。\n\n⏱ 2024-11-27 01:09:15\n\n\n那西门庆把那话露将出来向月娘戏道：「都是你气的他中风不语了。」月娘道：「怎的中风不语？」西门庆道：「他既不中风不语，如何大睁着眼说不出话来？」月娘骂道：「好个汗邪的货，教我有半个眼儿看的上你！」西门庆不由分说，把月娘两只白生生腿扛在肩膊上，那话插入牝中，一任其莺恣蝶采，殢雨尤云，未肯即休。正是：得多少海棠枝上莺梭急，翡翠梁间燕语频。不觉到灵犀一点、美爱无加之处，麝兰半吐，脂香满唇。西门庆情极，低声求月娘叫达达。月娘亦低帏昵枕，态有余妍，口呼亲亲不绝。是夜，两人雨意云情，并头交颈于帐内。正是：意洽尚忘垂绣带，兴狂不管坠金钗。有诗为证：鬓乱钗横兴已饶，情浓尤复厌通宵。晚来独向妆台立，淡淡春山不用描。\n\n⏱ 2024-11-27 01:12:40\n\n\n初如柳絮，渐似鹅毛。刷刷似数蟹行沙上，纷纷如乱琼堆砌间。但行动衣沾六出，只顷刻拂满蜂须。似飞还止，龙公试手于起舞之间。新阳泛力，玉女尚喜于团风之际。衬瑶台，似玉龙鳞甲绕空飞。飘粉额，如白鹤羽毛接地落。正是：冻合玉楼寒起粟，光摇银海眩生花。\n\n⏱ 2024-11-27 01:30:25\n\n\n第二十二回 西门庆私淫来旺妇 春梅正色骂李铭\n斜倚门儿立，人来侧目随。托腮并咬指，无故整衣裳。坐立随摇腿，无人曲唱低。开窗推户牖，停针不语时。未言先欲笑，必定与人私。\n\n⏱ 2024-11-29 00:15:23\n\n\n说着，两个小厮放桌儿，拿粥来吃。就是四个咸食，十样小菜儿，四碗炖烂下饭：一碗蹄子，一碗鸽子雏儿，一碗春不老蒸乳饼，一碗馄饨鸡儿。银镶瓯儿粳米投着各样榛松栗子果仁、玫瑰白糖粥儿。\n\n⏱ 2024-11-29 00:25:13\n\n\n第二十三回 玉箫观风赛月房 金莲窃听藏春坞\n行动不思天理，施为怎合成规！徇情纵意任奸欺，仗势慢人尊己。出则锦衣骏马，归时越女吴姬。休将金玉作根基，但恐莫逃兴废。\n\n⏱ 2024-11-29 00:28:42\n\n\n第二十四回 陈经济元夜戏娇姿 惠祥怒詈来旺妇\n西门庆与吴月娘居上坐，其余李娇儿、孟玉楼、潘金莲、李瓶儿、孙雪娥、西门大姐，都在两边列坐。都穿着锦绣衣裳、白绫袄儿、蓝裙子，——惟有吴月娘穿着大红遍地金通袖袍儿、貂鼠皮袄，下着百花裙。头上珠翠堆盈，凤钗半卸。\n\n⏱ 2024-11-29 18:01:49\n\n\n但见银河清浅，珠斗斓斑，一轮团圆皎月，从东而出，照得院宇犹如白昼。\n\n⏱ 2024-11-29 18:05:19\n\n\n换了一套绿闪红缎子对衿袄儿，白挑线裙子。又用一方红销金汗巾子搭着头，额角上贴着飞金，三个香茶翠面花儿，金灯笼坠子\n\n⏱ 2024-11-30 01:48:00\n\n\n出的大街市上，但见香尘不断，游人如蚁，花炮轰雷，灯光杂彩，箫鼓声喧，十分热闹。\n\n⏱ 2024-11-30 01:48:50\n\n\n第二十五回 雪娥透露蝶蜂情 来旺醉谤西门庆\n正说着，被一阵风过来，把他裙子刮起，里边露见大红潞紬裤儿，扎着脏头纱緑裤腿儿，好玉色纳纱护膝，银红线带儿。\n\n⏱ 2024-11-30 02:01:15\n\n\n只见金莲在房中云鬟不整，睡搵香腮，哭的眼坏坏的。\n\n⏱ 2024-11-30 02:08:10\n\n\n第二十六回 来旺儿递解徐州 宋惠连含羞自缢\n原来妇人夏月常不穿裤儿，只单吊着两条裙子，遇见西门庆在那里，便掀开裙子就干。口中常噙着香茶饼儿。于是二人解佩露甄妃之玉，朱唇点汉署之香，双凫飞肩，云雨一度。\n\n⏱ 2024-11-30 02:20:21\n\n\n四肢冰冷，一气灯残。香魂渺渺已赴望乡台，星眼瞑瞑尸犹横地下。不知精爽逝何处，疑是行云秋水中。\n\n⏱ 2024-11-30 02:34:44\n\n\n第二十七回 李瓶儿私语翡翠轩 潘金莲醉闹葡萄架\n到了那赤乌当午的时候，一轮火伞当空，无半点云翳，眞乃烁石流金之际。\n\n⏱ 2024-11-30 02:38:17\n\n\n说话的，世上有三等人怕热，有三等人不怕热。那三等人怕热？第一怕热，田舍间农夫。每日耕田迈陇，扶犁把耙，趁王苗二税，纳仓廪余粮。到了那三伏时节，田中无雨，心间一似火烧。第二经商客旅。经年在外，贩的是那红花紫草，蜜蜡香茶。肩负重担，手碾沉车，路途之中，走的饥又饥，渴又渴，汗涎满面，衣服精湿，得不的寸阴之下，实是难行。第三是那边塞上战士。头顶重盔，身披铁甲，渴饮刀头血，困歇马鞍鞒。经年征战，不得回归，衣生虱虮，疮痍溃烂，体无完肤。这三等人怕热。又有那三等人不怕热？第一是皇宫内院，水殿风亭，曲水为池，流泉作沼。有大块小块玉，整对倒透犀。碧玉栏边种着那异果奇葩，水晶盆内堆着那玛瑙珊瑚。又有镶成水晶桌上，摆列着端溪砚、象管笔、苍颉墨、蔡琰笺，又有水晶笔架、白玉镇纸。闷时作赋吟诗，醉后南熏一枕。又有王侯贵戚，富室名家，每日雪洞凉亭，终朝风轩水阁。虾须编成帘幕，鲛绡织成帐幔，茱莉结就的香球吊挂。云母床上铺着那水纹凉簟、鸯鸳珊枕，四面挠起风车来。那傍边水盆内，浸着沉李浮瓜，红菱雪藕，杨梅橄榄，苹婆白鸡头。又有那如花似朶的佳人在傍打扇。又有那琳宫梵剎，羽士禅僧，住着那侵云经阁，接汉钟楼。闲时常到方丈内讲诵道法〈黄庭〉，□时来僊苑中摘取僊桃异果。闷了时唤童子松阴下横琴膝上，醉后携棋枰柳荫中对友笑谈。原来这三等人不怕热。\n\n⏱ 2024-11-30 02:39:31\n\n\n只见潘金莲和李瓶儿家常都是白银条纱衫儿，密合色纱挑线穿花凤缕金拖泥裙子。李瓶儿是大红蕉布比甲，金莲是银红比甲，都用羊皮金滚边，妆花眉子。惟金莲不戴冠儿，拖着一窝丝杭州攒，翠云丝网儿，露着四鬓，上粘着飞金，粉面贴着三个翠面花儿，越显出粉面油头，朱唇皓齿。\n\n⏱ 2024-11-30 02:40:18\n\n\n西门庆见他纱裙内罩着大红纱裤儿，日影中玲珑剔透，露着玉骨冰肌，不觉淫心辄起。见左右无人，且不梳头，把李瓶儿按在一张凉椅上，揭起湘裙，红裈初褪，倒鞠着隔山取火。干了半晌精还不泄，两人曲尽于飞之楽。\n\n⏱ 2024-11-30 02:41:42\n\n\n西门庆听言，满心欢喜，说道：「我的心肝，你怎不早说？既然如此，你爹胡乱耍耍罢。」于是楽极情浓，怡然感之，两手抱定其股，一泄如注。妇人在下，弓股承受其精。良久，只闻的西门庆气喘吁吁，妇人莺莺声软，都被金莲在外听了个不亦楽乎。\n\n⏱ 2024-11-30 02:42:45\n\n\n正饮酒中间，忽见云生东南，雾障西北，雷声隐隐，一阵大雨来，轩前花草皆湿。正是：江河淮海添新水，翠竹红榴洗濯清。少顷雨止，天外残虹，西边透出日色来，得多少微雨过碧矶之润，晚风凉院落之清。\n\n⏱ 2024-11-30 02:43:36\n\n\n两人并肩而行，须臾，转过碧池，抹过木香亭，从翡翠轩前穿过，来到葡萄架下。睁眼观看，端的好一座葡萄！但见：四面雕栏石甃，周围翠叶深稠。迎眸霜色，如千枝紫弹坠流苏。喷鼻秋香，似万架緑云垂绣带。缒缒马乳，水晶丸里浥琼桨。滚滚绿珠，金屑架中含翠渥。乃西域移来之种，隐甘泉珍玩之芳。端的四时花木衬幽葩，明月清风无价买。\n\n⏱ 2024-11-30 02:45:49\n\n\n西门庆一面揭开盒，里边攒就的八槅细巧果菜：一槅是糟鹅胗掌、一槅是一封书腊肉丝、一槅是木樨银鱼鲊、一槅是劈晒雏鸡脯翅儿、一槅鲜莲子儿、一槅新核桃穰儿、一槅鲜菱角、一槅鲜荸荠。一小银素儿葡萄酒、两个小金莲蓬锺儿、两双牙筯儿，安放一张小凉杌儿上。\n\n⏱ 2024-11-30 02:46:22\n\n\n妇人又早在架儿底下铺设凉簟枕衾停当，脱的上下没条丝，仰卧于袵席之上，脚下穿着大红鞋儿，手弄白纱扇儿摇凉。西门庆走来看见，怎不触动淫心。于是乘着酒兴，亦脱去上下衣，坐在一凉墩上。先将脚指挑弄其花心，挑的淫津流出，如蜗之吐涎。一面又将妇人红绣花鞋儿摘取下来，戏把他两条脚带觧下来，拴其双足，吊在两边葡萄架儿上，如金龙探爪相似，使牝戸大张，红钩赤露，鸡舌内吐。西门庆先倒覆着身子，执麈柄抵牝口，卖了个倒入翎花，一手据枕，极力而提之，提的阴中淫气连绵，如数鳅行泥淖中相似。妇人在下，没口子呼叫达达不绝。\n\n⏱ 2024-11-30 02:50:09\n\n\n西门庆道：「小油嘴，看我投个肉壶，名唤『金弹打银鹅』你瞧！若打中一弹，我吃一锺酒。」于是向水碗内取了枚玉黄李子，向妇人牝中，一连打了三个，皆中花心。这西门庆一连吃了三锺药五香酒，又令春梅斟了一锺儿，递与妇人吃。又把一个李子放在牝中，不取出来，又不行事。急的妇人春心没乱，淫水直流，又不好去抠出来的。只是朦胧星眼，四肢亸然于枕簟之上，口中叫道：「好个作怪的冤家，捉弄奴死了！」莺声颤掉。\n\n⏱ 2024-11-30 02:52:56\n\n\n由着西门庆睡了一个时辰，睁开眼醒来，看见妇人还吊在架下，两只白生生腿儿，跷在两边，兴不可遏。因见春梅不在跟前，向妇人道：「淫妇，我丢与你罢。」于是先抠出牝中李子，教妇人吃了。坐在一只枕头上，向纱褶子顺袋内取出淫器包儿来，先以初使上银托子，次又用硫黄圈束着。初时不停只在牝口子来回擂（扌晃），不肯深入。急的妇人仰身迎播，口中不住声呌：「达达，快些进去罢，急坏了淫妇了。我晓的你恼我，为李瓶儿，故意使这促恰来奈何我！今日经着你手段，再不敢惹你了！」西门庆笑道：「小淫妇儿，你知道，就好说话儿了。」于是一壁（扌晃）着他心子，把那话拽出来，向袋中包儿里，打开捻了些闺艳声娇，涂在蛙口内，顶入牝中，送了几送。湏臾，那话昂健，奢棱跳胞暴怒起来。垂首看着，往来抽拽，玩其出入之势。那妇人在枕畔朦胧星眼，呻吟不已，没口子叫：「大鸡巴达达，你不知使了甚么行货子进去，罢了，淫妇的屄心子痒到骨髓里去了！可怜见，饶了罢。」淫妇口里碜死的言语都叫出来。这西门庆一上手就是三四百回，两只手倒按住枕席，仰身竭力，迎播掀干，抽没至茎首，复送至根者又约一百余下。妇人以帕在下不住手搽拭，牝中之津，随拭随出，袵席为之皆湿。西门庆行货子没棱露脑，往来逗遛不已。因向妇人说道：「我要耍个『老和尚撞钟』。」忽然仰身望前只一送，那话攮进去了，直抵牝屋之上。——牝屋者，乃妇人牝中深极处，有肉如含苞花蕊微拆。到此处，男子茎首觉翕然畅美不可言。——妇人触疼，急跨其身。只听磕碴响了一声，把个硫黄圈子折在里面。妇人则目瞑气息，微有声嘶，舌尖冰冷，四肢不收，亸然于袵席之上矣。西门庆慌了，急解其缚，向牝中抠出硫黄圈并勉铃来。硫黄圈已折做两截。于是把妇人扶坐。半日，星眸惊闪，苏省过来，因向西门庆作娇泣声，说道：「我的达达，你今日怎的这般大恶？险不丧了奴之性命。今后再不可这般所为，不是耍处。我如今头目森森然，莫知所之矣！」\n\n⏱ 2024-11-30 02:56:57\n\n\n第二十八回 陈经济因鞋戏金莲 西门庆怒打铁棍儿\n西门庆一手搂着他粉项，一递一口和他吃酒，极尽温存之态。睨视妇人，云鬟斜亸，酥胸半露，娇眼乜斜，犹如沉醉杨妃一般，纤手不住只向他腰里摸弄那话。那话因惊，银托子还带在上面，软叮当毛都鲁的，累垂伟长。\n\n⏱ 2024-11-30 02:58:04\n\n\n妇人笑瞅了他一眼，一面蹲下身子去，枕着他一只腿，取过一条裤带儿来，把那话拴住，用手提着，说道：「你这厮头里那等头睁睁、眼睁睁的，把人奈何昏昏的，这咱你推风病装佯死儿！」提弄了一回，放在粉脸上偎（扌晃）良久，然后将口吮之，又用舌尖挑舐其蛙口。那话登时暴怒起来，裂瓜头凹眼圆睁，落腮胡挺身直竖。西门庆一发坐在枕头，令妇人马爬在纱帐内，尽着吮咂，以畅其美。俄而淫思益炽，复与妇人交接。妇人哀告道：「我的达达，你饶了奴罢，又要掇弄奴也！」是夜二人淫楽，为之无度。\n\n⏱ 2024-11-30 02:59:05\n\n\n这陈经济走到傍边一个小杌儿坐下，看见妇人黑油般头发，手挽着梳还拖着地儿，红丝绳儿扎着，一窝丝攒上，戴着银丝䯼髻，还垫出一丝香云。䯼髻内安着许多玫瑰花瓣儿，露着四鬓，打扮的就是个活观音。\n\n⏱ 2024-11-30 03:04:54\n\n\n第二十九回 吴神僊贵贱相人 潘金莲兰汤午战\n须臾，那吴神僊头戴青布道巾，身穿布袍草履，腰系黄丝双穗绦，手执龟壳扇子，自外飘然进来。年约四十之上，生的神清如长江皓月，貌古似太华乔松，威仪凛凛，道貌堂堂。原来神僊有四般古怪：身如松，声如钟，坐如弓，走如风。\n\n⏱ 2024-11-30 03:17:34\n\n\n柱杖两头挑日月，葫芦一个隐山川。\n\n⏱ 2024-11-30 03:24:47\n\n\n妇人赤露玉体，止着红绡抹胸儿，盖着红纱衾，枕石鸳鸯枕，在凉席之上睡思正浓。房里异香喷鼻。西门庆一见，不觉淫心顿起，令春梅带上门出去。悄悄脱了衣裤，上的床来，掀开纱被，见他玉体互相掩映。戏将两股轻开，按麈柄徐徐插入牝中。比及星眸惊闪之际，已抽拽数十度矣。\n\n⏱ 2024-11-30 03:26:53\n\n\n西门庆乘兴把妇人仰卧在浴板之上，两手执其双足，跨而提之，掀腾〈扌扉〉干，何止二三百回。其声如泥中螃蟹一般，响之不绝。妇人恐怕香云拖坠，一手扶着云鬓，一手扳着盆沿，口中燕语莺声，百般难述。怎见这场交战，但见：华池荡漾波纹乱，翠帏高卷秋云暗。才郎情动要争持，稔色心忙显手段。一个颤颤巍巍挺硬鎗，一个摇摇摆摆轮钢剑。一个舍死忘生往里钻，一个尤云殢雨将功干。扑扑冬冬皮鼓催，跸跸礴礴鎗付剑。（石八）（石八）（石曰羽）（石曰羽）弄响声，砰砰（石拜）（石拜）成一片。下下高高水逆流，汹汹涌涌盈清涧。滑滑溜溜怎住停，拦拦济济难存站。一来一往莺转翅，一冲一撞东西探。热气腾腾妖云生，纷纷馥馥香气散。一个逆水撑船将玉股摇，一个艄公把舵将金莲揝。一个紫骝猖獗逞威风，一个白面妖娆遭马战。喜喜欢欢美女情。雄雄纠纠男儿愿。翻翻覆覆意欢娱，闹闹挨挨情摸乱。你死我活更无休，千战千赢心胆战。口口声声呌杀人，气气昂昂情不厌。古古今今广闹争，不似这番水里战。\n\n⏱ 2024-11-30 03:28:47\n\n\n第三十回 来保押送生辰担 西门庆生子喜加官\n朝登紫陌，暮践红尘，饥餐渴饮，夜住晓行。\n\n⏱ 2024-11-30 03:30:12\n\n\n盆栽绿草，瓶插红花。水晶帘卷虾须，云母屏开孔雀。盘堆麟脯，佳人笑捧紫霞觞。盆浸冰桃，美女高擎碧玉斝。食烹异品，果献时新。弦管讴歌，奏一派声清韵美。绮罗珠翠，摆两行舞女歌儿。当筵象板撒红牙，遍体舞裙补锦绣。消遣壶中闲日月，遨游身外醉乾坤。\n\n⏱ 2024-11-30 03:34:51\n\n\n第三十二回 李桂姐拜娘认女 应伯爵打浑趋时\n说不尽歌喉宛转，舞态蹁跹，酒若波流，肴如山迭。\n\n⏱ 2024-12-01 01:41:24\n\n\n众人看见他：头戴银丝䯼髻，周围金累丝钗梳，珠翠堆满。上着藕丝衣裳，下着翠绫裙。尖尖趫趫一对红鸳。粉面贴着三个翠面花儿，一阵异香喷鼻。\n\n⏱ 2024-12-01 01:47:59\n\n\n第三十三回 陈经济失钥罚唱 韩道国纵妇争锋\n那金莲听见汉子进他房来，如同拾了金宝一般，连忙打发他潘姥姥过李瓶儿这边宿歇。他便房中高点银灯，款伸锦被，熏香澡牝，夜间陪西门庆同寝。枕畔之情，百般难述。无非只要牢笼汉子之心，使他不往别人房里去。正是：鼓鬣游蜂，嫩蕊半开春荡漾。餐香粉蝶，花房深宿夜风流。\n\n⏱ 2024-12-04 12:03:38\n\n\n其人性本虚飘，言过其实，巧于词色，善于言谈。许人钱如捉影捕风，骗人财如探囊取物。\n\n⏱ 2024-12-05 02:18:26\n\n\n第三十四回 书童儿因宠揽事 平安儿含恨戳舌\n转过大厅，由鹿顶钻山进去，就是花园角门。抹过木香棚，两边松墙，松墙里面三间小卷棚名唤翡翠轩，乃西门庆夏月纳凉之所。前后帘栊掩映，四面花竹阴森，周围摆设珍禽异兽，瑶草琪花，各极其盛。\n\n⏱ 2024-12-05 02:25:25\n\n\n上下放着六把云南玛瑙漆减金钉藤丝垫矮矮东坡椅儿，两边挂四轴天青衢花绫裱白绫边名人的山水，一边一张螳螂蜻蜓脚一封书大理石心璧画的帮桌儿，桌儿上安放古铜炉、鎏金僊鹤，正面悬着「翡翠轩」三字。左右粉笺吊屏上写着一联：「风静槐阴清院宇，日长香篆散帘栊。」\n\n⏱ 2024-12-05 02:25:05\n\n\n说未了，酒菜齐至。先放了四碟菜果，然后又放了四碟案酒：红邓邓的泰州鸭疍、曲弯弯王瓜拌辽东金虾、香喷喷油煠的烧骨秃、肥（月彔）（月彔）干蒸的劈醎鸡。第二道又是四碗嗄饭：一瓯儿滤蒸的烧鸭、一瓯儿水晶膀蹄、一瓯儿白煠猪肉、一瓯儿炮炒的腰子。落后纔是里外青花白地磁盘，盛着一盘红馥馥柳蒸的糟鲥鱼，馨香美味，入口而化，骨刺皆香。\n\n⏱ 2024-12-05 02:31:40\n\n\n这书童把银子拿到铺子，（釒刘）下一两五钱来，教买了一坛金华酒、两只烧鸭、两只鸡、一钱银子鲜鱼、一肘蹄子、二钱顶皮酥果馅饼儿、一钱银子的搽瓤卷儿。\n\n⏱ 2024-12-05 02:35:24\n\n\n书童一面接了，放在书箧内，又走在旁边侍立。西门庆见他吃了酒，脸上透出红白来，红馥馥唇儿，露着一口糯粳牙儿，如何不爱？于是淫心辄起，搂在怀里，两个亲嘴咂舌头。那小郎口噙香茶桂花饼，身上熏的喷鼻香。西门庆用手撩起他衣服，褪了花袴儿，摸弄他屁股，因嘱咐他：「少要吃酒，只怕糟了脸。」书童道：「爹吩咐，小的知道。」两个在屋里，正做一处。\n\n⏱ 2024-12-05 02:41:24\n\n\n潘金莲下了轿，上穿着丁香色南京云紬（扌寨）的五彩纳纱喜相逢天圆地方补子，对衿衫儿。下着白碾光绢一尺宽攀枝耍娃娃挑线拖泥裙子。胸前（扌寨）带金玲珑（扌寨）领儿，下边羊皮金荷包。\n\n⏱ 2024-12-05 02:48:24\n\n\n第三十五回 西门庆挟恨责平安 书童儿妆旦劝狎客\n莫入州衙与县衙，劝君勤谨作生涯。池塘积水须防旱，买卖辛勤足养家。教子教孙要教义，栽桑栽枣莫栽花。闲是闲非休要管，渴饮清泉闷煮茶。此八句，单说为人之父母，必须自幼训教子孙读书学礼，知孝顺父母，尊敬长上，和睦乡里，各安生理。切不可纵容他。少年骄惰放肆，三五成群，游手好闲，张弓挟矢，笼养飞鸟，蹴掬打球，饮酒赌博，嫖风宿娼，无所不为，将来必然招事惹非，败坏家门。似此人家，使子弟陷于官司，大则身亡家破，小则吃打受牢，财入公门，政出吏口，连累父兄，惹悔耽忧，有何益哉！\n\n⏱ 2024-12-05 02:50:22\n\n\n书童连忙拿炭火，炉内烧甜香饼儿，双手递茶上去。西门庆擎茶在手，他慢慢挨近，站立在桌头边。良久，西门庆（扌奴）了个嘴儿，使他把门关上。用手搂在怀里，一手捧着他的脸儿。西门庆吐舌头，那小郎口里噙看凤香饼儿，递与他。下边又替他弄玉茎。\n\n⏱ 2024-12-05 02:52:47\n\n\n第三十七回 冯妈妈说嫁韩氏女 西门庆包占王六儿\n淹淹润润，不搽脂粉自然体态妖娆。袅袅娉娉，懒染铅华生定精神秀丽。两弯眉画远山，一对眼如秋水。檀口轻开，勾引得蜂狂蝶乱。纤腰拘束，暗带着月意风情。若非偷期崔氏女，定然闻瑟桌文君。\n\n⏱ 2024-12-07 02:42:41\n\n\n西门庆把眼上下观看，这个女子，乌云迭鬓，粉黛盈腮，意态幽花酴丽，肌肤嫩玉生香。\n\n⏱ 2024-12-07 02:43:37\n\n\n彼此饮够数巡，妇人把座儿挪近西门庆跟前，与他做一处说话，递菜儿。然后西门庆与妇人一递一口儿吃酒。见无人进来，搂过脖子来亲嘴咂舌。妇人便舒手下边笼揝西门庆玉茎。彼此淫心荡漾，把酒停住不吃了，掩上房门，褪去衣裤，妇人就在里边炕床上，伸开被褥。那时已是日色平西时分。西门庆乘着酒兴，顺袋内取出银托子来使上，妇人用手打弄，见奢棱跳脑，紫强光鲜，沉甸甸甚是粗大。一壁坐在西门庆怀里，一面在上两个且搂着脖子亲嘴。妇人乃跷起一足，以手导那话入牝中，两个挺一回。西门庆摸见妇人牝户柔腻，牝毛疏秀，意欲交接。令妇人仰卧于床，背托双枕，手提双足，置之于腰眼间，肆行抽送。怎见的这场云雨？但见：威风迷翠榻，杀气锁鸳衾。珊瑚枕上施雄，翡翠帐内斗勇。男儿忿怒，挺身连刺黑缨鎗。女帅生嗔，拍胯急摇追命剑。一来一往，禄山会合太眞妃。一撞一冲，君瑞追陪崔氏女。左右迎凑，天河织女遇牛郎。上下盘旋，僊洞娇姿逢阮肇。鎗来牌架，崔郎相共薛琼琼。炮打刀迎，双渐迸连苏小小。一个莺声呖呖，犹如武则天遇敖曹。一个燕喘吁吁，好似审食其逢吕雉。初战时，短鎗乱刺，利剑微迎。次后来，双炮齐攻，傍牌夹凑。男儿气急，使鎗只去扎心窝。女帅心忙，开口要来吞脑袋。一个使双炮的，往来攻打内裆兵。一个轮傍牌的，上下夹迎脐下将。一个金鸡独立，高跷玉腿弄精神。一个枯树盘根，倒入翎花来刺牝。战良久，朦胧星眼，但醮些儿麻上来。斗多时，款摆纤腰，再战百回挨不去。散毛洞主倒上桥，放水去淹军。乌甲将军虚点鎗，侧身逃命走。脐膏落马，须臾蹂踏肉为泥。温紧妆呆，顷刻跌翻深涧底。大披挂，七零八断，犹如急雨打残花。锦套头，力尽觔输，恰似猛风飘败叶。硫黄元帅，盔歪甲散走无门。银甲将军，守住老营还要命。正是：愁云托上九重天，一派败兵连地滚。\n\n⏱ 2024-12-07 02:49:53\n\n\n第三十八回 西门庆夹打二捣鬼 潘金莲雪夜弄琵琶\n妇人早已床炕上铺的厚厚的被褥，被里熏的喷鼻香。西门庆见妇人好风月，一径要打动他，家中袖了一个锦包儿来，打开：里面银托子、相思套、硫黄圈、药煮的白绫带子、悬玉环、封脐膏、勉铃，一弄儿淫器。那妇人仰卧枕上，玉腿高跷，鸡舌内吐，西门庆先把勉铃教妇人自放牝内，然后将银托子束其根，硫黄圈套其首，封脐膏贴于脐上。妇人以手导入牝中，两相迎凑，渐入大半。妇人呼道：「达达，我只怕你蹲的腿酸，拿过枕头来，你垫着坐，等我淫妇自家动罢！」又道：「只怕你不自在，你把淫妇腿吊着肏，你看好不好？」西门庆眞个把他脚带解下一条来，拴他一足，吊在床槅子上。低着拽，拽的妇人牝中之津如蜗之吐涎，绵绵不绝，又拽出好些白浆子来。西门庆问道：「你如何流这些白浆？」纔待要抹之。妇人道：「你休抹，等我吮咂了罢！」于是蹲跪他面前，吮吞数次，鸣咂有声。咂的西门庆淫心顿起，掉过身子，两个干后庭花。龟头上有硫黄圈，濡硏艰涩，妇人蹙眉隐忍，半晌仅没其棱。西门庆于是颇作抽送，已而妇人用手摸之，渐入大半。把屁股坐在西门庆怀里，回首流眸，作颤声叫：「达达，慢着些！往后越发粗大，教淫妇怎生挨忍？」西门庆且扶起其股，观其出入之势。因叫妇人小名：「王六儿，我的儿！你达不知心里怎的，只好这一桩儿。不想今日遇你，正可我之意。我和你明日生死难开。」妇人道：「达达，只怕后来耍的絮烦了，把奴不理，怎了？」西门庆道：「相交下来，纔见我不是这样人。」说话之间，两个干够一顿饭时。西门庆令妇人没高低淫声浪语叫着纔过，妇人在下，一面用手举股承受其精，乐极情浓，一泄如注。已而拽出那话来，带着圈子，妇人还替他吮咂净了。两个方纔并头交股而卧。正是：一般滋味美，好耍后庭花。\n\n⏱ 2024-12-07 02:56:42\n\n\n。单表潘金莲，见西门庆许多时不进他房里来，每日翡翠衾寒，芙蓉帐冷。\n\n⏱ 2024-12-07 02:59:15\n\n\n这妇人不听罢了，听了如同心上戳上几把刀子一般，骂了几句负心贼，由不得扑簌簌眼中流下泪来。\n\n⏱ 2024-12-07 03:00:48\n\n\n第三十九回 西门庆玉皇庙打醮 吴月娘听尼僧说经\n话说当日西门庆在潘金莲房中歇了一夜。那妇人恨不的钻入他腹中，在枕畔千般贴恋，万种牢笼，泪搵鲛鮹，语言温顺，实指望买住汉子心。\n\n⏱ 2024-12-07 03:03:36\n\n\n西门庆但来他家，韩道国就在铺子里上宿，教老婆陪他自在顽耍\n\n⏱ 2024-12-07 12:19:45\n\n\n青松郁郁，翠柏森森。金钉朱户，玉桥低影轩宫。碧瓦雕檐，绣幕高悬宝槛。七间大殿，中悬勅额金书。两庑长廊，彩画天神帅将。祥云影里，流星门高接青霄。瑞霞光中，郁罗台直侵碧汉。黄金殿上，列天帝三十二尊。白玉京中，现毫光百千万亿。三天门外，离娄与师旷狰狞。左右阶前，白虎与青龙猛勇。宝殿前僊妃玉女，霞帔曾献御香花。玉陛下四相九卿，朱履肃朝丹凤阙。九龙床上，坐着个不坏金身万天教主玉皇张大帝：头戴十一冕旒，身披衮龙青袍。腰系蓝田带，按八卦九宫。手执白玉圭，听三皈五戒。金钟撞处，三千世界尽皈依。玉磬鸣时，万象森罗皆拱极。朝天阁上，天风吹下步虚声。演法坛中，亱月常闻僊佩响。只此便为眞紫府，更于何处觅蓬莱！\n\n⏱ 2024-12-07 13:17:18\n\n\n宣毕斋意，铺设下许多文书符命，表白一一请看。揭开第一张说道：「此是奕世功果影发文书。申请三天三境上帝、十极高眞、三官四圣、泰玄都省，及天曹大皇万满眞君、天曹掌醮司眞君、天曹降圣司眞君，到坛证监功德的奏疏。」又揭起第二张：「此是申请东岳天齐大生神圣帝、子孙娘娘、监生卫房圣母元君，并当时许还愿日受祷之神，今日勾销顷愿典者，祠家侍奉长生香火，三教明神，勾销老爹昔日许的愿款，及行下七十五司地府冥官案吏主者，到坛来受追荐，护送亡人生天。此一票，是玉女灵官、天神帅将、功曹符使、土地等神，捧奏三天门运递关文。此一张，玉清总召万灵眞符，高功发遣公文，受事官符。此一张，是召九斗阳芒流星火全紾大将，开天门的符命。」看毕此处，又到一张桌上，揭起头一张来：「此是早朝开启请无佞太保康元帅，九天灵符监斋使者，严禁斋仪，监临厨所。此一张，是请正法马、赵、温、关，四大元帅。崔、卢、窦、邓，四大天君，监临坛门。及玄坛四灵神君，九凤破秽大将军，净坛荡秽，以格高眞。此一宗，是早朝启五师笺文，晚朝谢五师笺文。此一宗，是开辟二代卷帘化坛眞符。此一宗，是请神霄辟非大将军鸣金钟阳牒。神霄禁坛大将军击玉磬阴牒。此一宗，是安镇五方眞文云篆：东方九炁镇天玉字眞文，南方三炁镇天玉字眞文，西方七炁镇天玉字眞文，北方五炁镇天玉字眞文，中央一炁镇天玉字眞文，请五老上帝安镇坛垠，证监功德。俱是按五方颜色彩画的。此一宗早朝头一遍转经，高上神霄玉眞王南极长生大帝。第二遍转经，高上碧霄东极青华生大帝。第三遍转经，高上青霄九天应元雷声普化天尊。午朝第四遍转经，高上玉霄九天雷祖大帝。第五遍转经，高上琅霄太一大天帝。第六遍转经，高上泰霄六天洞渊大帝。晚朝第七遍转经，高上紫霄深波天主帝君。第八遍转经，高上景霄青城益算可韩司丈人眞君。第九遍转经，高上绛霄九天采访使眞君。九道表笺，掠剩、报应、幽枉、积逮，启四司、谢四司笺。此又一宗，是午朝高功捧奏拜进三天玉陛，黄箓朱表，并遣旨、介直直、符醮吏者，同当日受事功曹，护送章表殿递云盘关文。此一宗，是三天持宝箓大将军，并金龙、茭龙驿吏、火府赍简童子，灵宝诸符命，不可细数。此一宗，是晚朝谢恩诚词都疏，及一百八十表醮经醮，云鹤马子，俵分钱马满散关文。」\n\n⏱ 2024-12-07 17:39:10\n\n\n西门庆于是睁眼观看，果然铺设斋坛齐整。但见：位按五方，坛分八级。上层供三清四御、八极九霄、十极高眞、云宫列圣。中层山川岳渎、社会隍司、福地洞天、方舆博厚。下层冥宫幽壤、地府罗酆、江河湖海之神、水国泉扃之众。两班醮筵森列，合殿官将威仪。香腾瑞霭，千枝画烛流光。花簇锦筵，百盏银灯散彩。天地亭，左右金童玉女，对对高张羽盖。玉帝堂，两边执盂捧剑，重重密布幢旛。风清三界步虚声，月冷九天乘沆瀣。金钟撞处，高功进表奏虚皇。玉佩鸣时，都讲登坛朝玉帝。绛绡衣，星辰灿烂。芙蓉冠，金碧交加。监坛神将狰狞，直日功曹猛勇。道众齐宣宝忏，上瑶台酌水献花。眞人密诵灵章，按法剑踏罡步斗。青龙隐隐来黄道，白鹤翩翩下紫宸。\n\n⏱ 2024-12-07 17:39:57\n\n\n第四十二回 豪家拦门玩烟火 贵客高楼醉赏灯\n一面吩咐来兴儿拿银子早往糖饼铺，早定下蒸酥点心，都用大方盘，要四盘蒸饼：两盘果馅团圆饼、两盘玫瑰元宵饼。买四盘鲜果：一盘李干、一盘胡桃、一盘龙眼、一盘荔枝。四盘羹肴：一盘烧鹅、一盘烧鸡、一盘鸽子儿、一盘银鱼干。又是两套遍地锦罗缎衣服，一件大红小袍儿、一顶金丝绉纱冠儿，两盏云南羊角珍灯，一盒衣翠，一对小金手镯、四个金宝石戒指儿。\n\n⏱ 2024-12-31 02:50:01\n\n\n不说画堂深处，珠围翠绕，歌舞吹弹饮酒。\n\n⏱ 2024-12-31 02:50:46\n\n\n不想家中月娘使棋童儿和排军抬送了四个攒盒，都是美口糖食，细巧果品：也有黄烘烘金橙、红馥馥石榴、甜磂磂橄榄、青翠翠苹婆、香喷喷水梨。又有纯蜜盖柿、透糖大枣、酥油松饼、芝麻象眼、骨牌减煠、蜜润绦环。也有柳叶糖、牛皮缠。端的世上稀奇，寰中少有。\n\n⏱ 2024-12-31 02:53:01\n\n"},"阅读/毛泽东选集":{"title":"毛泽东选集","links":[],"tags":["阅读"],"content":"\n\n基于原文内容，使用有序/无序列表、引用等结构对文章进行自定义划分，以方便理解和阅读全文。\n\n第一卷\n第一次国内革命战争时期\n《中国社会各阶级的分析》1\n\n1925 年 12 月 1 日\n\n谁是我们的敌人？谁是我们的朋友？这个问题是革命的首要问题。中国过去一切革命斗争成效甚少，其基本原因就是因为不能团结真正的朋友，以攻击真正的敌人。革命党是群众的向导，在革命中未有革命党领错了路而革命不失败的。我们的革命要有不领错路和一定成功的把握，不可不注意团结我们的真正的朋友，以攻击我们的真正的敌人。我们要分辨真正的敌友，不可不将中国社会各阶级的经济地位及其对于革命的态度，作一个大概的分析。\n中国社会各阶级的情况是怎样的呢？\n\n\n地主阶级和买办阶级\n在经济落后的半殖民地的中国，地主阶级和买办阶级完全是国际资产阶级的附庸，其生存和发展，是附属于帝国主义的。这些阶级代表中国最落后的和最反动的生产关系，阻碍中国生产力的发展。他们和中国革命的目的完全不相容。特别是大地主阶级和大买办阶级，他们始终站在帝国主义一边，是极端的反革命派。\n其政治代表是国家主义派2和国民党右派。\n\n\n中产阶级\n\n\n这个阶级代表中国城乡资本主义的生产关系。\n中产阶级主要是指民族资产阶级，他们对于中国革命具有矛盾的态度：他们在受外资打击、军阀压迫感觉痛苦时，需要革命，赞成反帝国主义反军阀的革命运动；但是当着革命在国内有本国无产阶级的勇猛参加，在国外有国际无产阶级的积极援助，对于其欲达到大资产阶级地位的阶级的发展感觉到威胁时，他们又怀疑革命。其政治主张为实现民族资产阶级一阶级统治的国家。\n有一个自称为戴季陶3“真实信徒”的，在北京《晨报》4上发表议论说：“举起你的左手打倒帝国主义，举起你的右手打倒共产党。”这两句话，画出了这个阶级的矛盾惶遽状态。他们反对以阶级斗争学说解释国民党的民生主义，他们反对国民党联俄和容纳共产党5及左派分子。但是这个阶级的企图——实现民族资产阶级统治的国家，是完全行不通的，因为现在世界上的局面，是革命和反革命两大势力作最后斗争的局面。这两大势力竖起了两面大旗：一面是红色的革命的大旗，第三国际6高举着，号召全世界一切被压迫阶级集合于其旗帜之下；一面是白色的反革命的大旗，国际联盟7高举着，号召全世界一切反革命分子集合于其旗帜之下。那些中间阶级，必定很快地分化，或者向左跑入革命派，或者向右跑入反革命派，没有他们“独立”的余地。所以，中国的中产阶级，以其本阶级为主体的“独立”革命思想，仅仅是一个幻想。\n\n\n小资产阶级\n如自耕农8，手工业主，小知识阶层——学生界、中小学教员、小员司、小事务员、小律师，小商人等都属于这一类。\n这一个阶级，在人数上，在阶级性上，都值得大大注意。自耕农和手工业主所经营的，都是小生产的经济。这个小资产阶级内的各阶层虽然同处在小资产阶级经济地位，但有三个不同的部分。\n\n第一部分是有余钱剩米的，即用其体力或脑力劳动所得，除自给外，每年有余剩。这种人发财观念极重，对赵公元帅9礼拜最勤，虽不妄想发大财，却总想爬上中产阶级地位。他们看见那些受人尊敬的小财东，往往垂着一尺长的涎水。这种人胆子小，他们怕官，也有点怕革命。因为他们的经济地位和中产阶级颇接近，故对于中产阶级的宣传颇相信，对于革命取怀疑的态度。这一部分人在小资产阶级中占少数，是小资产阶级的右翼。\n第二部分是在经济上大体上可以自给的。这一部分人比较第一部分人大不相同，他们也想发财，但是赵公元帅总不让他们发财，而且因为近年以来帝国主义、军阀、封建地主、买办大资产阶级的压迫和剥削，他们感觉现在的世界已经不是从前的世界。他们觉得现在如果只使用和从前相等的劳动，就会不能维持生活。必须增加劳动时间，每天起早散晚，对于职业加倍注意，方能维持生活。他们有点骂人了，骂洋人叫“洋鬼子”，骂军阀叫“抢钱司令”，骂土豪劣绅叫“为富不仁”。对于反帝国主义反军阀的运动，仅怀疑其未必成功（理由是：洋人和军阀的来头那么大），不肯贸然参加，取了中立的态度，但是绝不反对革命。这一部分人数甚多，大概占小资产阶级的一半。\n第三部分是生活下降的。这一部分人好些大概原先是所谓殷实人家，渐渐变得仅仅可以保住，渐渐变得生活下降了。他们每逢年终结账一次，就吃惊一次，说：“咳，又亏了！”这种人因为他们过去过着好日子，后来逐年下降，负债渐多，渐次过着凄凉的日子，“瞻念前途，不寒而栗”。这种人在精神上感觉的痛苦很大，因为他们有一个从前和现在相反的比较。这种人在革命运动中颇要紧，是一个数量不小的群众，是小资产阶级的左翼。\n\n以上所说小资产阶级的三部分，对于革命的态度，在平时各不相同；但到战时，即到革命潮流高涨、可以看得见胜利的曙光时，不但小资产阶级的左派参加革命，中派亦可参加革命，即右派分子受了无产阶级和小资产阶级左派的革命大潮所裹挟，也只得附和着革命。我们从一九二五年的五卅运动10和各地农民运动的经验看来，这个断定是不错的。\n\n\n半无产阶级\n此处所谓半无产阶级，包含：\n\n（一）绝大部分半自耕农11\n（二）贫农\n（三）小手工业者\n（四）店员12\n（五）小贩等五种\n\n绝大部分半自耕农和贫农是农村中一个数量极大的群众。所谓农民问题，主要就是他们的问题。半自耕农、贫农和小手工业者所经营的，都是更细小的小生产的经济。绝大部分半自耕农和贫农虽同属半无产阶级，但其经济状况仍有上、中、下三个细别。半自耕农，其生活苦于自耕农，因其食粮每年大约有一半不够，须租别人田地，或者出卖一部分劳动力，或经营小商，以资弥补。春夏之间，青黄不接，高利向别人借债，重价向别人籴粮，较之自耕农的无求于人，自然景遇要苦，但是优于贫农。因为贫农无土地，每年耕种只得收获之一半或不足一半；半自耕农则租于别人的部分虽只收获一半或不足一半，然自有的部分却可全得。故半自耕农的革命性优于自耕农而不及贫农。\n贫农是农村中的佃农，受地主的剥削。其经济地位又分两部分。\n\n一部分贫农有比较充足的农具和相当数量的资金。此种农民，每年劳动结果，自己可得一半。不足部分，可以种杂粮、捞鱼虾、饲鸡豕，或出卖一部分劳动力，勉强维持生活，于艰难竭蹶之中，存聊以卒岁之想。故其生活苦于半自耕农，然较另一部分贫农为优。其革命性，则优于半自耕农而不及另一部分贫农。\n所谓另一部分贫农，则既无充足的农具，又无资金，肥料不足，土地歉收，送租之外，所得无几，更需要出卖一部分劳动力。荒时暴月，向亲友乞哀告怜，借得几斗几升，敷衍三日五日，债务丛集，如牛负重。他们是农民中极艰苦者，极易接受革命的宣传。\n\n小手工业者所以称为半无产阶级，是因为他们虽然自有简单的生产手段，且系一种自由职业，但他们也常常被迫出卖一部分劳动力，其经济地位略与农村中的贫农相当。因其家庭负担之重，工资和生活费用之不相称，时有贫困的压迫和失业的恐慌，和贫农亦大致相同。\n店员是商店的雇员，以微薄的薪资，供家庭的费用，物价年年增长，薪给往往须数年一增，偶与此辈倾谈，便见叫苦不迭。其地位和贫农及小手工业者不相上下，对于革命宣传极易接受。小贩不论肩挑叫卖，或街畔摊售，总之本小利微，吃着不够。其地位和贫农不相上下，其需要一个变更现状的革命，也和贫农相同。\n\n\n无产阶级\n现代工业无产阶级约二百万人。中国因经济落后，故现代工业无产阶级人数不多。二百万左右的产业工人中，主要为铁路、矿山、海运、纺织、造船五种产业的工人，而其中很大一个数量是在外资产业的奴役下。\n工业无产阶级人数虽不多，却是中国新的生产力的代表者，是近代中国最进步的阶级，做了革命运动的领导力量。我们看四年以来的罢工运动，如海员罢工13、铁路罢工14、开滦和焦作煤矿罢工15、沙面罢工16以及“五卅”后上海香港两处的大罢工17所表现的力量，就可知工业无产阶级在中国革命中所处地位的重要。他们所以能如此，第一个原因是集中。无论哪种人都不如他们的集中。第二个原因是经济地位低下。他们失了生产手段，剩下两手，绝了发财的望，又受着帝国主义、军阀、资产阶级的极残酷的待遇，所以他们特别能战斗。\n都市苦力工人的力量也很可注意。以码头搬运夫和人力车夫占多数，粪夫清道夫等亦属于这一类。他们除双手外，别无长物，其经济地位和产业工人相似，惟不及产业工人的集中和在生产上的重要。\n中国尚少新式的资本主义的农业。所谓农村无产阶级，是指长工、月工、零工等雇农而言。此等雇农不仅无土地，无农具，又无丝毫资金，只得营工度日。其劳动时间之长，工资之少，待遇之薄，职业之不安定，超过其他工人。此种人在乡村中是最感困难者，在农民运动中和贫农处于同一紧要的地位。\n此外，还有数量不小的游民无产者，为失了土地的农民和失了工作机会的手工业工人。他们是人类生活中最不安定者。他们在各地都有秘密组织，如闽粤的“三合会”，湘鄂黔蜀的“哥老会”，皖豫鲁等省的“大刀会”，直隶及东三省的“在理会”，上海等处的“青帮”18，都曾经是他们的政治和经济斗争的互助团体。处置这一批人，是中国的困难的问题之一。这一批人很能勇敢奋斗，但有破坏性，如引导得法，可以变成一种革命力量。\n综上所述，可知一切勾结帝国主义的军阀、官僚、买办阶级、大地主阶级以及附属于他们的一部分反动知识界，是我们的敌人。工业无产阶级是我们革命的领导力量。一切半无产阶级、小资产阶级，是我们最接近的朋友。那动摇不定的中产阶级，其右翼可能是我们的敌人，其左翼可能是我们的朋友——但我们要时常提防他们，不要让他们扰乱了我们的阵线。\n\n\n\n《湖南农民运动考察报告》19\n\n1927 年 3 月\n\n农民问题的严重性\n我这回到湖南20，实地考察了湘潭、湘乡、衡山、醴陵、长沙五县的情况。从一月四日起至二月五日止，共三十二天，在乡下，在县城，召集有经验的农民和农运工作同志开调查会，仔细听他们的报告，所得材料不少。许多农民运动的道理，和在汉口、长沙从绅士阶级那里听得的道理，完全相反。许多奇事，则见所未见，闻所未闻。我想这些情形，很多地方都有。\n所有各种反对农民运动的议论，都必须迅速矫正。革命当局对农民运动的各种错误处置，必须迅速变更。这样，才于革命前途有所补益。因为目前农民运动的兴起是一个极大的问题。很短的时间内，将有几万万农民从中国中部、南部和北部各省起来，其势如暴风骤雨，迅猛异常，无论什么大的力量都将压抑不住。他们将冲决一切束缚他们的罗网，朝着解放的路上迅跑。一切帝国主义、军阀、贪官污吏、土豪劣绅，都将被他们葬入坟墓。一切革命的党派、革命的同志，都将在他们面前受他们的检验而决定弃取。站在他们的前头领导他们呢？还是站在他们的后头指手画脚地批评他们呢？还是站在他们的对面反对他们呢？每个中国人对于这三项都有选择的自由，不过时局将强迫你迅速地选择罢了。\n组织起来\n湖南的农民运动，就湘中、湘南已发达的各县来说，大约分为两个时期。\n\n\n去年一月至九月为第一时期，即组织时期。\n此时期内，一月至六月为秘密活动时期，七月至九月革命军驱逐赵恒惕21，为公开活动时期。\n此时期内，农会会员的人数总计不过三四十万，能直接领导的群众也不过百余万，在农村中还没有什么斗争，因此各界对它也没有什么批评。因为农会会员能作向导，作侦探，作挑夫，北伐军的军官们还有说几句好话的。\n\n\n十月至今年一月为第二时期，即革命时期。\n农会会员激增到二百万，能直接领导的群众增加到一千万。因为农民入农会大多数每家只写一个人的名字，故会员二百万，群众便有约一千万。在湖南农民全数中，差不多组织了一半。如湘潭、湘乡、浏阳、长沙、醴陵、宁乡、平江、湘阴、衡山、衡阳、耒阳、郴县、安化等县，差不多全体农民都集合在农会的组织中，都立在农会领导之下。农民既已有了广大的组织，便开始行动起来，于是在四个月中造成一个空前的农村大革命。\n\n\n打倒土豪劣绅，一切权力归农会\n农民的主要攻击目标是土豪劣绅，不法地主，旁及各种宗法的思想和制度，城里的贪官污吏，乡村的恶劣习惯。\n这个攻击的形势，简直是急风暴雨，顺之者存，违之者灭。其结果，把几千年封建地主的特权，打得个落花流水。地主的体面威风，扫地以尽。地主权力既倒，农会便成了唯一的权力机关，真正办到了人们所谓“一切权力归农会”。连两公婆吵架的小事，也要到农民协会去解决。一切事情，农会的人不到场，便不能解决。农会在乡村简直独裁一切，真是“说得出，做得到”。外界的人只能说农会好，不能说农会坏。土豪劣绅，不法地主，则完全被剥夺了发言权，没有人敢说半个不字。\n在农会威力之下，土豪劣绅们头等的跑到上海，二等的跑到汉口，三等的跑到长沙，四等的跑到县城，五等以下土豪劣绅崽子则在乡里向农会投降。\n“我出十块钱，请你们准我进农民协会。”小劣绅说。\n“嘻！谁要你的臭钱！”农民这样回答。\n好些中小地主、富农乃至中农，从前反对农会的，此刻求入农会不可得。我到各处，常常遇到这种人，这样向我求情：“请省里来的委员作保！”\n前清地方造丁口册，有正册、另册二种，好人入正册，匪盗等坏人入另册。现在有些地方的农民便拿了这事吓那些从前反对农会的人：“把他们入另册！”\n那些人怕入另册，便多方设法求入农会，一心要想把他们的名字写上那农会的册子才放心。但他们往往遭农会严厉拒绝，所以他们总是悬心吊胆地过日子；摈在农会的门外，好像无家可归的样子，乡里话叫做“打零”。总之，四个月前被一般人看不起的所谓“农民会”，现在却变成顶荣耀的东西。从前拜倒在绅士权力下面的人，现在却拜倒在农民权力之下。无论什么人，都承认去年十月以前和十月以后是两个世界。\n“糟得很”和“好得很”\n农民在乡里造反，搅动了绅士们的酣梦。乡里消息传到城里来，城里的绅士立刻大哗。我初到长沙时，会到各方面的人，听到许多的街谈巷议。从中层以上社会至国民党右派，无不一言以蔽之曰：“糟得很。”即使是很革命的人吧，受了那班“糟得很”派的满城风雨的议论的压迫，他闭眼一想乡村的情况，也就气馁起来，没有法子否认这“糟”字。很进步的人也只是说：“这是革命过程中应有的事，虽则是糟。”总而言之，无论什么人都无法完全否认这“糟”字。实在呢，如前所说，乃是广大的农民群众起来完成他们的历史使命，乃是乡村的民主势力起来打翻乡村的封建势力。宗法封建性的土豪劣绅，不法地主阶级，是几千年专制政治的基础，帝国主义、军阀、贪官污吏的墙脚。打翻这个封建势力，乃是国民革命的真正目标。孙中山先生致力国民革命凡四十年，所要做而没有做到的事，农民在几个月内做到了。这是四十年乃至几千年未曾成就过的奇勋。这是好得很。完全没有什么“糟”，完全不是什么“糟得很”。“糟得很”，明明是站在地主利益方面打击农民起来的理论，明明是地主阶级企图保存封建旧秩序，阻碍建设民主新秩序的理论，明明是反革命的理论。每个革命的同志，都不应该跟着瞎说。你若是一个确定了革命观点的人，而且是跑到乡村里去看过一遍的，你必定觉到一种从来未有的痛快。无数万成群的奴隶——农民，在那里打翻他们的吃人的仇敌。农民的举动，完全是对的，他们的举动好得很！“好得很”是农民及其他革命派的理论。\n一切革命同志须知：国民革命需要一个大的农村变动。辛亥革命22没有这个变动，所以失败了。现在有了这个变动，乃是革命完成的重要因素。一切革命同志都要拥护这个变动，否则他就站到反革命立场上去了。\n所谓“过分”的问题\n又有一般人说：“农会虽要办，但是现在农会的举动未免太过分了。”这是中派的议论。\n实际怎样呢？的确的，农民在乡里颇有一点子“乱来”。农会权力无上，不许地主说话，把地主的威风扫光。这等于将地主打翻在地，再踏上一只脚。“把你入另册！”向土豪劣绅罚款捐款，打轿子。反对农会的土豪劣绅的家里，一群人涌进去，杀猪出谷。土豪劣绅的小姐少奶奶的牙床上，也可以踏上去滚一滚。动不动捉人戴高帽子游乡，“劣绅！今天认得我们！”为所欲为，一切反常，竟在乡村造成一种恐怖现象。这就是一些人的所谓“过分”，所谓“矫枉过正”，所谓“未免太不成话”。\n这派议论貌似有理，其实也是错的。\n\n\n第一，上述那些事，都是土豪劣绅、不法地主自己逼出来的。\n土豪劣绅、不法地主，历来凭借势力称霸，践踏农民，农民才有这种很大的反抗。凡是反抗最力、乱子闹得最大的地方，都是土豪劣绅、不法地主为恶最甚的地方。农民的眼睛，全然没有错的。谁个劣，谁个不劣，谁个最甚，谁个稍次，谁个惩办要严，谁个处罚从轻，农民都有极明白的计算，罚不当罪的极少。\n\n\n第二，革命不是请客吃饭，不是做文章，不是绘画绣花，不能那样雅致，那样从容不迫，文质彬彬，那样温良恭俭让。革命是暴动，是一个阶级推翻一个阶级的暴烈的行动。\n农村革命是农民阶级推翻封建地主阶级的权力的革命。农民若不用极大的力量，决不能推翻几千年根深蒂固的地主权力。农村中须有一个大的革命热潮，才能鼓动成千成万的群众，形成一个大的力量。上面所述那些所谓“过分”的举动，都是农民在乡村中由大的革命热潮鼓动出来的力量所造成的。\n这些举动，在农民运动第二时期（革命时期）是非常之需要的。在第二时期内，必须建立农民的绝对权力。必须不准人恶意地批评农会。必须把一切绅权都打倒，把绅士打在地下，甚至用脚踏上。所有一切所谓“过分”的举动，在第二时期都有革命的意义。\n质言之，每个农村都必须造成一个短时期的恐怖现象，非如此决不能镇压农村反革命派的活动，决不能打倒绅权。矫枉必须过正，不过正不能矫枉23。\n这一派的议论，表面上和前一派不同，但其实质则和前一派同站在一个观点上，依然是拥护特权阶级利益的地主理论。这种理论，阻碍农民运动的兴起，其结果破坏了革命，我们不能不坚决地反对。\n\n\n所谓“痞子运动”\n国民党右派说：“农民运动是痞子运动，是惰农运动。”这种议论，在长沙颇盛行。我跑到乡下，听见绅士们说：“农民协会可以办，但是现在办事人不行，要换人啦！”这种议论，和右派的话是一个意思，都是说农运可做（因农民运动已起来，无人敢说不可做），但是现在做农运的人不行，尤其痛恨下级农民协会办事人，说他们都是些“痞子”。\n总而言之，一切从前为绅士们看不起的人，一切被绅士们打在泥沟里，在社会上没有了立足地位，没有了发言权的人，现在居然伸起头来了。不但伸起头，而且掌权了。他们在乡农民协会（农民协会的最下级）称王，乡农民协会在他们手里弄成很凶的东西了。他们举起他们那粗黑的手，加在绅士们头上了。他们用绳子捆绑了劣绅，给他戴上高帽子，牵着游乡（湘潭、湘乡叫游团，醴陵叫游垅）。他们那粗重无情的斥责声，每天都有些送进绅士们的耳朵里去。他们发号施令，指挥一切。他们站在一切人之上——从前站在一切人之下，所以叫做反常。\n革命先锋\n对于一件事或一种人，有相反的两种看法，便出来相反的两种议论。“糟得很”和“好得很”，“痞子”和“革命先锋”，都是适例。\n前面说了农民成就了多年未曾成就的革命事业，农民做了国民革命的重要工作。但是这种革命大业，革命重要工作，是不是农民全体做的呢？不是的。农民中有富农、中农、贫农三种。三种状况不同，对于革命的观感也各别。\n当第一时期，富农耳里听得的是所谓江西一败如水，蒋介石打伤了脚24，坐飞机回广东25了。吴佩孚26重新占了岳州。农民协会必定立不久，三民主义27也兴不起，因为这是所谓从来没有的东西。乡农民协会的办事人（多属所谓“痞子”之类），拿了农会的册子，跨进富农的大门，对富农说：“请你进农民协会。”富农怎样回答呢？“农民协会吗？我在这里住了几十年，种了几十年田，没有见过什么农民协会，也吃饭。我劝你们不办的好！”富农中态度好点的这样说。“什么农民协会，砍脑壳会，莫害人！”富农中态度恶劣的这样说。新奇得很，农民协会居然成立了好几个月，而且敢于反对绅士。邻近的绅士因为不肯缴鸦片枪，被农民协会捉了去游乡。县城里并且杀了大绅士，例如湘潭的晏容秋，宁乡的杨致泽。\n十月革命纪念大会，反英大会，北伐胜利总庆祝，每乡都有上万的农民举起大小旗帜，杂以扁担锄头，浩浩荡荡，出队示威。这时，富农才开始惶惑起来。在北伐胜利总庆祝中，他们听见说，九江也打开了，蒋介石没有伤脚，吴佩孚究竟打败了。而且“三民主义万岁”，“农民协会万岁”，“农民万岁”等等，明明都写在“红绿告示”（标语）上面。“农民万岁，这些人也算作万岁吗？”富农表示很大的惶惑。农会于是神气十足了。农会的人对富农说：“把你们入另册！”或者说：“再过一个月，入会的每人会费十块钱！”在这样的形势之下，富农才慢慢地进了农会28，有些是缴过五角钱或一块钱（本来只要一百钱）入会费的，有些是托人说情才邀了农会允许的。亦有好些顽固党，至今还没有入农会。富农入会，多把他那家里一个六七十岁的老头子到农会去上一个名字，因为他们始终怕“抽丁”。入会后，也并不热心替农会做事。他们的态度始终是消极的。\n中农呢？他们的态度是游移的。他们想到革命对他们没有什么大的好处。他们锅里有米煮，没有人半夜里敲门来讨账。他们也根据从来有没有的道理，独自皱着眉头在那里想：“农民协会果然立得起来吗？”“三民主义果然兴得起来吗？”他们的结论是：“怕未必！”他们以为这全决于天意：“办农民会，晓得天意顺不顺咧？”在第一时期内，农会的人拿了册子，进了中农的门，对着中农说道：“请你加入农民协会！”中农回答道：“莫性急啦！”一直到第二时期，农会势力大盛，中农方加入农会。他们在农会的表现比富农好，但暂时还不甚积极，他们还要看一看。农会争取中农入会，向他们多作解释工作，是完全必要的。\n乡村中一向苦战奋斗的主要力量是贫农。从秘密时期到公开时期，贫农都在那里积极奋斗。他们最听共产党的领导。他们和土豪劣绅是死对头，他们毫不迟疑地向土豪劣绅营垒进攻。他们对着富农说：“我们早进了农会，你们为什么还迟疑？”富农带着讥笑的声调说道：“你们上无片瓦，下无插针之地，有什么不进农会！”的确，贫农们不怕失掉什么。他们中间有很多人，确实是“上无片瓦，下无插针之地”，他们有什么不进农会？\n据长沙的调查：乡村人口中，贫农占百分之七十，中农占百分之二十，地主和富农占百分之十。百分之七十的贫农中，又分赤贫、次贫二类。全然无业，即既无土地，又无资金，完全失去生活依据，不得不出外当兵，或出去做工，或打流当乞丐的，都是“赤贫”，占百分之二十。半无业，即略有土地，或略有资金，但吃的多，收的少，终年在劳碌愁苦中过生活的，如手工工人、佃农（富佃除外）、半自耕农29等，都是“次贫”，占百分之五十。\n这个贫农大群众，合共占乡村人口百分之七十，乃是农民协会的中坚，打倒封建势力的先锋，成就那多年未曾成就的革命大业的元勋。没有贫农阶级（照绅士的话说，没有“痞子”），决不能造成现时乡村的革命状态，决不能打倒土豪劣绅，完成民主革命。贫农，因为最革命，所以他们取得了农会的领导权。所有最下一级农民协会的委员长、委员，在第一第二两个时期中，几乎全数是他们（衡山县乡农民协会职员，赤贫阶层占百分之五十，次贫阶层占百分之四十，穷苦知识分子占百分之十）。\n这个贫农领导，是非常之需要的。没有贫农，便没有革命。若否认他们，便是否认革命。若打击他们，便是打击革命。他们的革命大方向始终没有错。他们损伤了土豪劣绅的体面。他们打翻了大小土豪劣绅在地上，并且踏上一只脚。他们在革命期内的许多所谓“过分”举动，实在正是革命的需要。湖南有些县的县政府、县党部30和县农会，已经做了若干错处，竟有循地主之请，派兵拘捕下级农会职员的。衡山、湘乡二县的监狱里，关了好多个乡农民协会委员长、委员。这个错误非常之大，助长了反动派的气焰。只要看拘捕了农民协会委员长、委员，当地的不法地主们便大高兴，反动空气便大增高，就知道这事是否错误。\n我们要反对那些所谓“痞子运动”、“惰农运动”的反革命议论，尤其要注意不可做出帮助土豪劣绅打击贫农阶级的错误行动。事实上，贫农领袖中，从前虽有些确是有缺点的，但是现在多数都变好了。他们自己在那里努力禁牌赌，清盗匪。农会势盛地方，牌赌禁绝，盗匪潜踪。有些地方真个道不拾遗，夜不闭户。据衡山的调查，贫农领袖百人中八十五人都变得很好，很能干，很努力。只有百分之十五，尚有些不良习惯。这只能叫做“少数不良分子”，决不能跟着土豪劣绅的口白，笼统地骂“痞子”。要解决这“少数不良分子”的问题，也只能在农会整顿纪律的口号之下，对群众做宣传，对他们本人进行训练，把农会的纪律整好，决不能随便派兵捉人，损害贫农阶级的威信，助长土豪劣绅的气势。这一点是非常要注意的。\n十四件大事\n一般指摘农会的人说农会做了许多坏事。我在前面已经指出，农民打土豪劣绅这件事完全是革命行为，并没有什么可指摘。但是农民所做的事很多，为了答复人们的指摘，我们须得把农民所有的行动过细检查一遍，逐一来看他们的所作所为究竟是怎么样。我把几个月来农民的行动分类总计起来，农民在农民协会领导之下总共作了十四件大事，如下所记。\n\n\n第一件将农民组织在农会里\n这是农民所做的第一件大事。像湘潭、湘乡、衡山这样的县，差不多所有的农民都组织起来了，几乎没有哪一只“角暗里”的农民没有起来，这是第一等。有些县，农民组织起来了一大部分，尚有一小部分没有组织，如益阳、华容等县，这是第二等。有些县，农民组织起来了一小部分，大部分尚未组织起来，如城步、零陵等县，这是第三等。湘西一带，在袁祖铭31势力之下，农会宣传未到，许多县的农民还全未组织起来，这是第四等。\n大概以长沙为中心的湘中各县最发展，湘南各县次之，湘西还在开始组织中。据去年十一月省农民协会统计，全省七十五县中，三十七县有了组织，会员人数一百三十六万七千七百二十七人。此数中，约有一百万是去年十月、十一月两个月内农会势力大盛时期组织的，九月以前还不过三四十万人。现又经过十二月、一月两个月，农民运动正大发展。截至一月底止，会员人数至少满了二百万。因入会一家多只登记一人，平均每家以五口计，群众便约有一千万。\n这种惊人的加速度的发展，是所以使一切土豪劣绅贪官污吏孤立，使社会惊为前后两个世界，使农村造成大革命的原因。这是农民在农民协会领导之下所做的第一件大事。\n\n\n第二件政治上打击地主\n农民有了组织之后，第一个行动，便是从政治上把地主阶级特别是土豪劣绅的威风打下去，即是从农村的社会地位上把地主权力打下去，把农民权力长上来。这是一个极严重极紧要的斗争。这个斗争是第二时期即革命时期的中心斗争。这个斗争不胜利，一切减租减息，要求土地及其他生产手段等等的经济斗争，决无胜利之可能。\n湖南许多地方，像湘乡、衡山、湘潭等县，地主权力完全推翻，形成了农民的独一权力，自无问题。但是醴陵等县，尚有一部分地方（如醴陵之西南两区），表面上地主权力低于农民权力，实际上因为政治斗争不激烈，地主权力还隐隐和农民权力对抗。这些地方，还不能说农民已得了政治的胜利，还须加劲作政治斗争，至地主权力被农民完全打下去为止。\n综计农民从政治上打击地主的方法有如下各项：\n\n\n清算\n土豪劣绅经手地方公款，多半从中侵蚀，账目不清。这回农民拿了清算的题目，打翻了很多的土豪劣绅。好多地方组织了清算委员会，专门向土豪劣绅算账，土豪劣绅看了这样的机关就打颤。这样的清算运动，在农民运动起来的各县做得很普遍，意义不重在追回款子，重在宣布土豪劣绅的罪状，把土豪劣绅的政治地位和社会地位打下去。\n\n\n罚款\n清算结果，发现舞弊，或从前有鱼肉农民的劣迹，或现在有破坏农会的行为，或违禁牌赌，或不缴烟枪。在这些罪名之下，农民议决，某土豪罚款若干，某劣绅罚款若干，自数十元至数千元不等。被农民罚过的人，自然体面扫地。\n\n\n捐款\n向为富不仁的地主捐款救济贫民，办合作社，办农民贷款所，或作他用。捐款也是一种惩罚，不过较罚款为轻。地主为免祸计，自动地捐款给农会的，亦颇不少。\n\n\n小质问\n遇有破坏农会的言论行动而罪状较轻的，则邀集多人涌入其家，提出比较不甚严重的质问。结果，多要写个“休息字”，写明从此终止破坏农会名誉的言论行动了事。\n\n\n大示威\n统率大众，向着和农会结仇的土豪劣绅示威，在他家里吃饭，少不得要杀猪出谷，此类事颇不少。\n最近湘潭马家河，有率领一万五千群众向六个劣绅问罪，延时四日，杀猪百三十余个的事。示威的结果，多半要罚款。戴高帽子游乡。这种事各地做得很多。把土豪劣绅戴上一顶纸扎的高帽子，在那帽子上面写上土豪某某或劣绅某某字样。用绳子牵着，前后簇拥着一大群人。也有敲打铜锣，高举旗帜，引人注目的。这种处罚，最使土豪劣绅颤栗。戴过一次高帽子的，从此颜面扫地，做不起人。故有钱的多愿罚款，不愿戴高帽子。但农民不依时，还是要戴。\n有一个乡农会很巧妙，捉了一个劣绅来，声言今天要给他戴高帽子。劣绅于是吓黑了脸。但是，农会议决，今天不给他戴高帽子。因为今天给他戴过了，这劣绅横了心，不畏罪了，不如放他回去，等日再戴。那劣绅不知何日要戴高帽子，每日在家放心不下，坐卧不宁。关进县监狱。这是比戴高帽子更重的罪。把土豪劣绅捉了，送进知事公署的监狱，关起来，要知事办他的罪。现在监狱里关人和从前两样，从前是绅士送农民来关，现在是农民送绅士来关。\n\n\n驱逐\n土豪劣绅中罪恶昭著的，农民不是要驱逐，而是要捉他们，或杀他们。他们怕捉怕杀，逃跑出外。重要的土豪劣绅，在农民运动发达县份，几乎都跑光了，结果等于被驱逐。\n他们中间，头等的跑到上海，次等的跑到汉口，三等的跑到长沙，四等的跑到县城。这些逃跑的土豪劣绅，以逃到上海的为最安全。逃到汉口的，如华容的三个劣绅，终被捉回。逃到长沙的，更随时有被各县旅省学生捕获之虞，我在长沙就亲眼看见捕获两个。逃到县城的，资格已是第四等了，农民耳目甚多，发觉甚易。湖南政府财政困难，财政当局曾归咎于农民驱逐阔人，以致筹款不易，亦可见土豪劣绅不容于乡里之一斑。\n\n\n枪毙\n这必是很大的土豪劣绅，农民和各界民众共同做的。\n例如宁乡的杨致泽，岳阳的周嘉淦，华容的傅道南、孙伯助，是农民和各界人民督促政府枪毙的。湘潭的晏容秋，则是农民和各界人民强迫县长同意从监狱取出，由农民自己动手枪毙的。宁乡的刘昭，是农民直接打死的。醴陵的彭志蕃，益阳的周天爵、曹云，则正待“审判土豪劣绅特别法庭”判罪处决。\n这样的大劣绅、大土豪，枪毙一个，全县震动，于肃清封建余孽，极有效力。这样的大土豪劣绅，各县多的有几十个，少的也有几个，每县至少要把几个罪大恶极的处决了，才是镇压反动派的有效方法。\n土豪劣绅势盛时，杀农民真是杀人不眨眼。长沙新康镇团防局长何迈泉，办团十年，在他手里杀死的贫苦农民将近一千人，美其名曰“杀匪”。我的家乡湘潭县银田镇团防局长汤峻岩、罗叔林二人，民国二年以来十四年间，杀人五十多，活埋四人。被杀的五十多人中，最先被杀的两人是完全无罪的乞丐。汤峻岩说：“杀两个叫化子开张！”这两个叫化子就是这样一命呜呼了。以前土豪劣绅的残忍，土豪劣绅造成的农村白色恐怖是这样，现在农民起来枪毙几个土豪劣绅，造成一点小小的镇压反革命派的恐怖现象，有什么理由说不应该？\n\n\n\n\n第三件经济上打击地主\n\n\n不准谷米出境，不准高抬谷价，不准囤积居奇\n这是近月湖南农民经济斗争上一件大事。从去年十月至现在，贫农把地主富农的谷米阻止出境，并禁止高抬谷价和囤积居奇。结果，贫农的目的完全达到，谷米阻得水泄不通，谷价大减，囤积居奇的绝迹。\n\n\n不准加租加押，宣传减租减押\n去年七八月间，农会还在势力弱小时期，地主依然按照剥削从重老例，纷纷通知佃农定要加租加押。但是到了十月，农会势力大增，一致反对加租加押，地主便不敢再提加租加押四字。及至十一月后，农民势力压倒地主势力，农民乃进一步宣传减租减押。\n农民说：可惜去秋交租时农会尚无力量，不然去秋就减了租了。对于今秋减租，农民正大做宣传，地主们亦在问减租办法。至于减押，衡山等县目下已在进行。\n\n\n不准退佃\n去年七八月间，地主还有好多退佃另佃的事。十月以后，无人敢退佃了。现在退佃另佃已完全不消说起，只有退佃自耕略有点问题。有些地方，地主退佃自耕，农民也不准。有些地方，地主如自耕，可以允许退佃，但同时发生了佃农失业问题。此问题尚无一致的解决办法。\n\n\n减息\n安化已普遍地减了息，他县亦有减息的事。惟农会势盛地方，地主惧怕“共产”，完全“卡借”，农村几无放债的事。此时所谓减息，限于旧债。旧债不仅减息，连老本也不许债主有逼取之事。贫农说：“怪不得，年岁大了，明年再还吧！”\n\n\n\n\n第四件推翻土豪劣绅的封建统治——打倒都团\n旧式的都团（即区乡）政权机关，尤其是都之一级，即接近县之一级，几乎完全是土豪劣绅占领。“都”管辖的人口有一万至五六万之多，有独立的武装如团防局，有独立的财政征收权如亩捐32等，有独立的司法权如随意对农民施行逮捕、监禁、审问、处罚。这样的机关里的劣绅，简直是乡里王。农民对政府如总统、督军33、县长等还比较不留心，这班乡里王才真正是他们的“长上”，他们鼻子里哼一声，农民晓得这是要十分注意的。这回农村造反的结果，地主阶级的威风普遍地打下来，土豪劣绅把持的乡政机关，自然跟了倒塌。都总团总34躲起不敢出面，一切地方上的事都推到农民协会去办。\n他们应付的话是：“不探（管）闲事！”\n农民们相与议论，谈到都团总，则愤然说：“那班东西么，不作用了！”\n“不作用”三个字，的确描画了经过革命风潮地方的旧式乡政机关。\n\n\n第五件推翻地主武装，建立农民武装\n湖南地主阶级的武装，中路较少，西南两路较多。平均每县以六百枝步枪计，七十五县共有步枪四万五千枝，事实上或者还要多。\n农民运动发展区域之中南两路，因农民起来形势甚猛，地主阶级招架不住，其武装势力大部分投降农会，站在农民利益这边，例如宁乡、平江、浏阳、长沙、醴陵、湘潭、湘乡、安化、衡山、衡阳等县。小部分站在中立地位，但倾向于投降，例如宝庆等县。再一小部分则站在和农会敌对地位，例如宜章、临武、嘉禾等县，但现时农民正在加以打击，可能于不久时间消灭其势力。这样由反动的地主手里拿过来的武装，将一律改为“挨户团常备队”35，放在新的乡村自治机关——农民政权的乡村自治机关管理之下。\n这种旧武装拿过来，是建设农民武装的一方面。\n建设农民武装另有一个新的方面，即农会的梭镖队。梭镖——一种接以长柄的单尖两刃刀，单湘乡一县有十万枝。其他各县，如湘潭、衡山、醴陵、长沙等，七八万枝、五六万枝、三四万枝不等。凡有农民运动各县，梭镖队便迅速地发展。这种有梭镖的农民，将成为“挨户团非常备队”。这个广大的梭镖势力，大于前述旧武装势力，是使一切土豪劣绅看了打颤的一种新起的武装力量。湖南的革命当局，应使这种武装力量确实普及于七十五县二千余万农民之中，应使每个青年壮年农民都有一柄梭镖，而不应限制它，以为这是可以使人害怕的东西。若被这种梭镖队吓翻了，那真是胆小鬼！只有土豪劣绅看了害怕，革命党决不应该看了害怕。\n\n\n第六件推翻县官老爷衙门差役的政权\n县政治必须农民起来才能澄清，广东的海丰已经有了证明。这回在湖南，尤其得到了充分的证明。在土豪劣绅霸占权力的县，无论什么人去做知事，几乎都是贪官污吏。在农民已经起来的县，无论什么人去，都是廉洁政府。\n我走过的几县，知事遇事要先问农民协会。在农民势力极盛的县，农民协会说话是“飞灵的”。农民协会要早晨捉土豪劣绅，知事不敢挨到中午，要中午捉，不敢挨到下午。农民的权力在乡间初涨起来的时候，县知事和土豪劣绅是勾结一起共同对付农民的。在农民的权力涨至和地主权力平行的时候，县知事取了向地主农民两边敷衍的态度，农民协会的话，有一些被他接受，有一些被他拒绝。上头所说农会说话飞灵，是在地主权力被农民权力完全打下去了的时候。现在像湘乡、湘潭、醴陵、衡山等县的县政治状况是：\n\n\n（一）凡事取决于县长和革命民众团体的联合会议。\n这种会议，由县长召集，在县署开。有些县名之曰“公法团联席会议”，有些县名之曰“县务会议”。出席的人，县长以外，为县农民协会、县总工会、县商民协会、县女界联合会、县教职员联合会、县学生联合会以及国民党县党部36的代表们。\n在这样的会议里，各民众团体的意见影响县长，县长总是唯命是听。所以，在湖南采用民主的委员制县政治组织，应当是没有问题的了。现在的县政府，形式和实质，都已经是颇民主的了。达到这种形势，是最近两三个月的事，即农民从四乡起来打倒了土豪劣绅权力以后的事。知事看见旧靠山已倒，要做官除非另找靠山，这才开始巴结民众团体，变成了上述的局面。\n\n\n（二）承审员没有案子。\n湖南的司法制度，还是知事兼理司法，承审员助知事审案。知事及其僚佐要发财，全靠经手钱粮捐派，办兵差和在民刑诉讼上颠倒敲诈这几件事，尤以后一件为经常可靠的财源。几个月来，土豪劣绅倒了，没有了讼棍。农民的大小事，又一概在各级农会里处理。所以，县公署的承审员，简直没有事做。\n湘乡的承审员告诉我：“没有农民协会以前，县公署平均每日可收六十件民刑诉讼禀帖；有农会后，平均每日只有四五件了。”于是知事及其僚佐们的荷包，只好空着。\n\n\n（三）警备队、警察、差役，一概敛迹，不敢下乡敲诈。\n从前乡里人怕城里人，现在城里人怕乡里人。尤其是县政府豢养的警察、警备队、差役这班恶狗，他们怕下乡，下乡也不敢再敲诈。他们看见农民的梭镖就发抖。\n\n\n\n\n第七件推翻祠堂族长的族权和城隍土地菩萨的神权以至丈夫的男权\n中国的男子，普通要受三种有系统的权力的支配，即：\n\n（一）由一国、一省、一县以至一乡的国家系统（政权）；\n（二）由宗祠、支祠以至家长的家族系统（族权）；\n（三）由阎罗天子、城隍庙王以至土地菩萨的阴间系统以及由玉皇上帝以至各种神怪的神仙系统——总称之为鬼神系统（神权）。\n\n至于女子，除受上述三种权力的支配以外，还受男子的支配（夫权）。\n这四种权力——政权、族权、神权、夫权，代表了全部封建宗法的思想和制度，是束缚中国人民特别是农民的四条极大的绳索。\n农民在乡下怎样推翻地主的政权，已如前头所述。地主政权，是一切权力的基干。地主政权既被打翻，族权、神权、夫权便一概跟着动摇起来。农会势盛地方，族长及祠款经管人不敢再压迫族下子孙，不敢再侵蚀祠款。坏的族长、经管，已被当作土豪劣绅打掉了。从前祠堂里“打屁股”、“沉潭”、“活埋”等残酷的肉刑和死刑，再也不敢拿出来了。女子和穷人不能进祠堂吃酒的老例，也被打破。衡山白果地方的女子们，结队拥入祠堂，一屁股坐下便吃酒，族尊老爷们只好听她们的便。又有一处地方，因禁止贫农进祠堂吃酒，一批贫农拥进去，大喝大嚼，土豪劣绅长褂先生吓得都跑了。\n神权的动摇，也是跟着农民运动的发展而普遍。许多地方，农民协会占了神的庙宇做会所。一切地方的农民协会，都主张提取庙产办农民学校，做农会经费，名之曰“迷信公款”。醴陵禁迷信、打菩萨之风颇盛行。北乡各区农民禁止家神老爷（傩神）游香。渌口伏波岭庙内有许多菩萨，因为办国民党区党部房屋不够，把大小菩萨堆于一角，农民无异言。自此以后，人家死了人，敬神、做道场、送大王灯的，就很少了。这事，因为是农会委员长孙小山倡首，当地的道士们颇恨孙小山。北三区龙凤庵农民和小学教员，砍了木菩萨煮肉吃。南区东富寺三十几个菩萨都给学生和农民共同烧掉了，只有两个小菩萨名“包公老爷”者，被一个老年农民抢去了，他说：“莫造孽！”在农民势力占了统治地位的地方，信神的只有老年农民和妇女，青年和壮年农民都不信了。农民协会是青年和壮年农民当权，所以对于推翻神权，破除迷信，是各处都在进行中的。\n夫权这种东西，自来在贫农中就比较地弱一点，因为经济上贫农妇女不能不较富有阶级的女子多参加劳动，所以她们取得对于家事的发言权以至决定权的是比较多些。至近年，农村经济益发破产，男子控制女子的基本条件，业已破坏了。最近农民运动一起，许多地方，妇女跟着组织了乡村女界联合会，妇女抬头的机会已到，夫权便一天一天地动摇起来。\n总而言之，所有一切封建的宗法的思想和制度，都随着农民权力的升涨而动摇。但是现在时期，农民的精力集中于破坏地主的政治权力这一点。要是地主的政治权力破坏完了的地方，农民对家族神道男女关系这三点便开始进攻了。但是这种进攻，现在到底还在“开始”，要完全推翻这三项，还要待农民的经济斗争全部胜利之后。因此，目前我们对农民应该领导他们极力做政治斗争，期于彻底推翻地主权力。并随即开始经济斗争，期于根本解决贫农的土地及其他经济问题。至于家族主义、迷信观念和不正确的男女关系之破坏，乃是政治斗争和经济斗争胜利以后自然而然的结果。若用过大的力量生硬地勉强地从事这些东西的破坏，那就必被土豪劣绅借为口实，提出“农民协会不孝祖宗”、“农民协会欺神灭道”、“农民协会主张共妻”等反革命宣传口号，来破坏农民运动。\n湖南的湘乡、湖北的阳新，最近都发生地主利用了农民反对打菩萨的事，就是明证。菩萨是农民立起来的，到了一定时期农民会用他们自己的双手丢开这些菩萨，无须旁人过早地代庖丢菩萨。共产党对于这些东西的宣传政策应当是：“引而不发，跃如也。”37菩萨要农民自己去丢，烈女祠、节孝坊要农民自己去摧毁，别人代庖是不对的。\n我在乡里也曾向农民宣传破除迷信。我的话是：\n“信八字望走好运，信风水望坟山贯气。今年几个月光景，土豪劣绅贪官污吏一齐倒台了。难道这几个月以前土豪劣绅贪官污吏还大家走好运，大家坟山都贯气，这几个月忽然大家走坏运，坟山也一齐不贯气了吗？土豪劣绅形容你们农会的话是：‘巧得很啰，如今是委员世界呀，你看，屙尿都碰了委员。’的确不错，城里、乡里、工会、农会、国民党、共产党无一不有执行委员，确实是委员世界。但这也是八字坟山出的吗？巧得很！乡下穷光蛋八字忽然都好了！坟山也忽然都贯气了！神明吗？那是很可敬的。但是不要农民会，只要关圣帝君、观音大士，能够打倒土豪劣绅吗？那些帝君、大士们也可怜，敬了几百年，一个土豪劣绅不曾替你们打倒！现在你们想减租，我请问你们有什么法子，信神呀，还是信农民会？”\n我这些话，说得农民都笑起来。\n\n\n第八件普及政治宣传\n开一万个法政学校，能不能在这样短时间内普及政治教育于穷乡僻壤的男女老少，像现在农会所做的政治教育一样呢？我想不能吧。打倒帝国主义，打倒军阀，打倒贪官污吏，打倒土豪劣绅，这几个政治口号，真是不翼而飞，飞到无数乡村的青年壮年老头子小孩子妇女们的面前，一直钻进他们的脑子里去，又从他们的脑子里流到了他们的嘴上。\n比如有一群小孩子在那里玩吧，如果你看见一个小孩子对着另一个小孩子鼓眼蹬脚扬手动气时，你就立刻可以听到一种尖锐的声音，那便是：“打倒帝国主义！”湘潭一带的小孩子看牛时打起架来，一个做唐生智，一个做叶开鑫38，一会儿一个打败了，一个跟着追，那追的就是唐生智，被追的就是叶开鑫。“打倒列强……”这个歌，街上的小孩子固然几乎人人晓得唱了，就是乡下的小孩子也有很多晓得唱了的。孙中山先生的那篇遗嘱，乡下农民也有些晓得念了。他们从那篇遗嘱里取出了“自由”、“平等”、“三民主义”、“不平等条约”这些名词，颇生硬地应用在他们的生活上。一个绅士模样的人在路上碰了一个农民，那绅士摆格不肯让路，那农民便愤然说：“土豪劣绅！晓得三民主义吗？”长沙近郊菜园农民进城卖菜，老被警察欺负。现在，农民可找到武器了，这武器就是三民主义。当警察打骂卖菜农民时，农民便立即抬出三民主义以相抵制，警察没有话说。湘潭一个区的农民协会，为了一件事和一个乡农民协会不和，那乡农民协会的委员长便宣言：“反对区农民协会的不平等条约！”政治宣传的普及乡村，全是共产党和农民协会的功绩。很简单的一些标语、图画和讲演，使得农民如同每个都进过一下子政治学校一样，收效非常之广而速。\n据农村工作同志的报告，政治宣传在反英示威、十月革命纪念和北伐胜利总庆祝这三次大的群众集会时做得很普遍。在这些集会里，有农会的地方普遍地举行了政治宣传，引动了整个农村，效力很大。今后值得注意的，就是要利用各种机会，把上述那些简单的口号，内容渐渐充实，意义渐渐明了起来。\n\n\n第九件农民诸禁\n共产党领导农会在乡下树立了威权，农民便把他们所不喜欢的事禁止或限制起来。最禁得严的便是牌、赌、鸦片这三件。\n牌：农会势盛地方，麻雀、骨牌、纸叶子，一概禁绝。湘乡十四都地方一个区农会，曾烧了一担麻雀牌。跑到乡间去，什么牌都没有打，犯禁的即刻处罚，一点客气也没有。\n赌：从前的“赌痞”，现在自己在那里禁赌了，农会势盛地方，和牌一样弊绝风清。\n鸦片：禁得非常之严。农会下命令缴烟枪，不敢稍违抗不缴。醴陵一个劣绅不缴烟枪，被捉去游乡。农民这个“缴枪运动”，其声势不弱于北伐军对吴佩孚、孙传芳39军队的缴枪。好些革命军军官家里的年尊老太爷，烟瘾极重，靠一杆“枪”救命的，都被“万岁”（劣绅讥诮农民之称）们缴了去。“万岁”们不仅禁种禁吃，还要禁运。由贵州经宝庆、湘乡、攸县、醴陵到江西去的鸦片，被拦截焚烧不少。这一来，和政府的财政发生了冲突。结果，还是省农会为了顾全北伐军饷，命令下级农会“暂缓禁运”。但农民在那里愤愤不乐。\n三者以外，农民禁止或限制的东西还有很多，略举之则有：\n花鼓。一种小戏，许多地方禁止演唱。\n轿子。许多县有打轿子的事，湘乡特甚。农民最恨那些坐轿子的，总想打，但农会禁止他们。办农会的人对农民说：“你们打轿子，反倒替阔人省了钱，轿工要失业，岂非害了自己？”农民们想清了，出了新法子，就是大涨轿工价，以此惩富人。煮酒熬糖。普遍禁止用谷米煮酒熬糖，糟行糖行叫苦不迭。衡山福田铺地方，不禁止煮酒，但限定酒价于一极小数目，酒店无钱赚，只好不煮了。\n猪。限制每家喂猪的数目，因为猪吃去谷米。\n鸡鸭。湘乡禁喂鸡鸭，但妇女们反对。衡山洋塘地方限制每家只准喂三个，福田铺地方只准喂五个。好些地方完全禁止喂鸭，因为鸭比鸡更无用，它不仅吃掉谷，而且搓死禾。\n酒席。丰盛酒席普遍地被禁止。湘潭韶山地方议决客来吃三牲，即只吃鸡鱼猪。笋子、海带、南粉都禁止吃。衡山则议决吃八碗，不准多一碗。醴陵东三区只准吃五碗，北二区只准吃三荤三素，西三区禁止请春客。湘乡禁止“蛋糕席”——一种并不丰盛的席面。湘乡二都有一家讨媳妇，用了蛋糕席，农民以他不服从禁令，一群人涌进去，搅得稀烂。湘乡的嘉谟镇实行不吃好饮食，用果品祭祖。\n牛。这是农民的宝贝。“杀牛的来生变牛”，简直成了宗教，故牛是杀不得的。农民没有权力时，只能用宗教观念反对杀牛，没有实力去禁止。农会起来后，权力管到牛身上去了，禁止城里杀牛。湘潭城内从前有六家牛肉店，现在倒了五家，剩下一家是杀病牛和废牛的。衡山全县禁绝了杀牛。一个农民他有一头牛跌脱了脚，问过农会，才敢杀。株洲商会冒失地杀了一头牛，农民上街问罪，罚钱而外，放爆竹赔礼。\n游民生活。如打春、赞土地、打莲花落，醴陵议决禁止。各县有禁止的，有自然消灭没人干这些事的。有一种“强告化”又叫“流民”者，平素非常之凶，现在亦只得屈服于农会之下。湘潭韶山地方有个雨神庙，素聚流民，谁也不怕，农会起来，悄悄地走了。同地湖堤乡农会，捉了三个流民挑土烧窑。拜年陋俗，议决禁止。\n此外各地的小禁令还很多，如醴陵禁傩神游香，禁买南货斋果送情，禁中元烧衣包，禁新春贴瑞签。湘乡的谷水地方水烟也禁了。二都禁放鞭炮和三眼铳，放鞭炮的罚洋一元二角，放铳的罚洋二元四角。七都和二十都禁做道场。十八都禁送奠仪。诸如此类，不胜枚举，统名之曰农民诸禁。\n这些禁令中，包含两个重要意义：第一是对于社会恶习之反抗，如禁牌赌鸦片等。这些东西是跟了地主阶级恶劣政治环境来的，地主权力既倒，这些东西也跟着扫光。第二是对于城市商人剥削之自卫，如禁吃酒席，禁买南货斋果送情等等。因为工业品特贵，农产品特贱，农民极为贫困，受商人剥削厉害，不得不提倡节俭，借以自卫。至于前述之农民阻谷出境，是因为贫农自己粮食不够吃，还要向市上买，所以不许粮价高涨。这都是农民贫困和城乡矛盾的缘故，并非农民拒绝工业品和城乡贸易，实行所谓东方文化主义40。农民为了经济自卫，必须组织合作社，实行共同买货和消费。还须政府予以援助，使农民协会能组织信用（放款）合作社。如此，农民自然不必以阻谷为限制食粮价格的方法，也不会以拒绝某些工业品入乡为经济自卫的方法了。\n\n\n第十件清匪\n从禹汤文武起吧，一直到清朝皇帝，民国总统，我想没有哪一个朝代的统治者有现在农民协会这样肃清盗匪的威力。什么盗匪，在农会势盛地方，连影子都不见了。巧得很，许多地方，连偷小菜的小偷都没有了。有些地方，还有小偷。至于土匪，则我所走过的各县全然绝了迹，哪怕从前是出土匪很多的地方。\n原因：\n\n一是农会会员漫山遍野，梭镖短棍一呼百应，土匪无处藏踪。\n二是农民运动起后，谷子价廉，去春每担六元的，去冬只二元，民食问题不如从前那样严重。\n三是会党41加入了农会，在农会里公开地合法地逞英雄，吐怨气，“山、堂、香、水”42的秘密组织，没有存在的必要了。杀猪宰羊，重捐重罚，对压迫他们的土豪劣绅阶级出气也出够了。\n四是各军大招兵，“不逞之徒”去了许多。因此，农运一起，匪患告绝。对于这一点，绅富方面也同情于农会。他们的议论是：“农民协会吗？讲良心话，也有一点点好处。”\n\n对于禁牌、赌、鸦片和清匪，农民协会是博得一般人的同情的。\n\n\n第十一件废苛捐\n全国未统一，帝国主义军阀势力未推翻，农民对政府税捐的繁重负担，质言之，即革命军的军费负担，还是没有法子解除的。但是土豪劣绅把持乡政时加于农民的苛捐如亩捐等，却因农民运动的兴起、土豪劣绅的倒塌而取消，至少也减轻了。这也要算是农民协会的功绩之一。\n\n\n第十二件文化运动\n中国历来只是地主有文化，农民没有文化。可是地主的文化是由农民造成的，因为造成地主文化的东西，不是别的，正是从农民身上掠取的血汗。中国有百分之九十未受文化教育的人民，这个里面，最大多数是农民。\n农村里地主势力一倒，农民的文化运动便开始了。试看农民一向痛恶学校，如今却在努力办夜学。“洋学堂”，农民是一向看不惯的。我从前做学生时，回乡看见农民反对“洋学堂”，也和一般“洋学生”、“洋教习”一鼻孔出气，站在洋学堂的利益上面，总觉得农民未免有些不对。\n民国十四年在乡下住了半年，这时我是一个共产党员，有了马克思主义的观点，方才明白我是错了，农民的道理是对的。乡村小学校的教材，完全说些城里的东西，不合农村的需要。小学教师对待农民的态度又非常之不好，不但不是农民的帮助者，反而变成了农民所讨厌的人。故农民宁欢迎私塾（他们叫“汉学”），不欢迎学校（他们叫“洋学”），宁欢迎私塾老师，不欢迎小学教员。如今他们却大办其夜学，名之曰农民学校。有些已经举办，有些正在筹备，平均每乡有一所。他们非常热心开办这种学校，认为这样的学校才是他们自己的。夜学经费，提取迷信公款、祠堂公款及其他闲公闲产。这些公款，县教育局要提了办国民学校即是那不合农民需要的“洋学堂”，农民要提了办农民学校，争议结果，各得若干，有些地方是农民全得了。\n农民运动发展的结果，农民的文化程度迅速地提高了。不久的时间内，全省当有几万所学校在乡村中涌出来，不若知识阶级和所谓“教育家”者流，空唤“普及教育”，唤来唤去还是一句废话。\n\n\n第十三件合作社运动\n合作社，特别是消费、贩卖、信用三种合作社，确是农民所需要的。他们买进货物要受商人的剥削，卖出农产要受商人的勒抑，钱米借贷要受重利盘剥者的剥削，他们很迫切地要解决这三个问题。去冬长江打仗，商旅路断，湖南盐贵，农民为盐的需要组织合作社的很多。地主“卡借”，农民因借钱而企图组织“借贷所”的，亦所在多有。大问题，就是详细的正规的组织法没有。各地农民自动组织的，往往不合合作社的原则，因此做农民工作的同志，总是殷勤地问“章程”。假如有适当的指导，合作社运动可以随农会的发展而发展到各地。\n\n\n第十四件修道路，修塘坝\n这也是农会的一件功绩。没有农会以前，乡村的道路非常之坏。无钱不能修路，有钱的人不肯拿出来，只好让它坏。略有修理，也当作慈善事业，从那些“肯积阴功”的人家化募几个，修出些又狭又薄的路。农会起来了，把命令发出去，三尺、五尺、七尺、一丈，按照路径所宜，分等定出宽狭，勒令沿路地主，各修一段。号令一出，谁敢不依？不久时间，许多好走的路都出来了。\n这却并非慈善事业，乃是出于强迫，但是这一点子强迫实在强迫得还可以。\n塘坝也是一样。无情的地主总是要从佃农身上取得东西，却不肯花几个大钱修理塘坝，让塘干旱，饿死佃农，他们却只知收租。有了农会，可以不客气地发命令强迫地主修塘坝了。地主不修时，农会却很和气地对地主说道：“好！你们不修，你们出谷吧，斗谷一工！”地主为斗谷一工划不来，赶快自己修。因此，许多不好的塘坝变成了好塘坝。\n\n\n总上十四件事，都是农民在农会领导之下做出来的。就其基本的精神说来，就其革命意义说来，请读者们想一想，哪一件不好？说这些事不好的，我想，只有土豪劣绅们吧！很奇怪，南昌方面43传来消息，说蒋介石、张静江44诸位先生的意见，颇不以湖南农民的举动为然。湖南的右派领袖刘岳峙45辈，与蒋、张诸公一个意见，都说：“这简直是赤化了！”我想，这一点子赤化若没有时，还成个什么国民革命！嘴里天天说“唤起民众”，民众起来了又害怕得要死，这和叶公好龙46有什么两样！\n\n第二次国内革命战争时期\n中国的红色政权为什么能够存在？47\n\n1928 年 10 月 5 日\n\n一国内的政治状况\n现在国民党新军阀的统治，依然是城市买办阶级和乡村豪绅阶级的统治，对外投降帝国主义，对内以新军阀代替旧军阀，对工农阶级的经济的剥削和政治的压迫比从前更加厉害。\n从广东出发的资产阶级民主革命，到半路被买办豪绅阶级篡夺了领导权，立即转向反革命路上，全国工农平民以至资产阶级48，依然在反革命统治底下，没有得到丝毫政治上经济上的解放。\n国民党新军阀蒋桂冯阎四派49，在北京天津没有打下以前，有一个对张作霖50的临时的团结。北京天津打下以后，这个团结立即解散，变为四派内部激烈斗争的局面，蒋桂两派且在酝酿战争中。中国内部各派军阀的矛盾和斗争，反映着帝国主义各国的矛盾和斗争。故只要各国帝国主义分裂中国的状况存在，各派军阀就无论如何不能妥协，所有妥协都是暂时的。今天的暂时的妥协，即酝酿着明天的更大的战争。中国迫切需要一个资产阶级的民主革命，这个革命必须由无产阶级领导才能完成。\n从广东出发向长江发展的一九二六年到一九二七年的革命，因为无产阶级没有坚决地执行自己的领导权，被买办豪绅阶级夺取了领导，以反革命代替了革命。资产阶级民主革命乃遭遇到暂时的失败。中国无产阶级和农民在此次失败中，受到很大的打击，中国资产阶级（非买办豪绅阶级）也受了打击。但最近数个月来，工农阶级在共产党领导之下的有组织的城市罢工和农村暴动，在南北各地发展起来。军阀军队中的士兵因饥寒而酝酿着很大的不安。同时资产阶级在汪精卫、陈公博一派鼓动之下，亦在沿海沿江各地发展着颇大的改良主义运动51。这种运动的发展是新的事实。中国的民主革命的内容，依国际及中央的指示，包括推翻帝国主义及其工具军阀在中国的统治，完成民族革命，并实行土地革命，消灭豪绅阶级对农民的封建的剥削。这种革命的实际运动，在一九二八年五月济南惨案52以后，是一天一天在发展的。\n二中国红色政权发生和存在的原因\n\n中国红色政权53\n\n一国之内，在四围白色政权的包围中，有一小块或若干小块红色政权的区域长期地存在，这是世界各国从来没有的事。这种奇事的发生，有其独特的原因。而其存在和发展，亦必有相当的条件。\n\n第一，它的发生不能在任何帝国主义的国家，也不能在任何帝国主义直接统治的殖民地54，必然是在帝国主义间接统治的经济落后的半殖民地的中国。因为这种奇怪现象必定伴着另外一件奇怪现象，那就是白色政权之间的战争。帝国主义和国内买办豪绅阶级支持着的各派新旧军阀，从民国元年以来，相互间进行着继续不断的战争，这是半殖民地中国的特征之一。不但全世界帝国主义国家没有一国有这种现象，就是帝国主义直接统治的殖民地也没有一处有这种现象，仅仅帝国主义间接统治的中国这样的国家才有这种现象。这种现象产生的原因有两种，即地方的农业经济（不是统一的资本主义经济）和帝国主义划分势力范围的分裂剥削政策。因为有了白色政权间的长期的分裂和战争，便给了一种条件，使一小块或若干小块的共产党领导的红色区域，能够在四围白色政权包围的中间发生和坚持下来。湘赣边界的割据，就是这许多小块中间的一小块。有些同志在困难和危急的时候，往往怀疑这样的红色政权的存在，而发生悲观的情绪。这是没有找出这种红色政权所以发生和存在的正确的解释的缘故。我们只须知道中国白色政权的分裂和战争是继续不断的，则红色政权的发生、存在并且日益发展，便是无疑的了。\n第二，中国红色政权首先发生和能够长期地存在的地方，不是那种并未经过民主革命影响的地方，例如四川、贵州、云南及北方各省，而是在一九二六和一九二七两年资产阶级民主革命过程中工农兵士群众曾经大大地起来过的地方，例如湖南、广东、湖北、江西等省。这些省份的许多地方，曾经有过很广大的工会和农民协会的组织，有过工农阶级对地主豪绅阶级和资产阶级的许多经济的政治的斗争。所以广州产生过三天的城市民众政权，而海陆丰、湘东、湘南、湘赣边界、湖北的黄安等地都有过农民的割据55。至于此刻的红军，也是由经过民主的政治训练和接受过工农群众影响的国民革命军中分化出来的。那些毫未经过民主的政治训练、毫未接受过工农影响的军队，例如阎锡山、张作霖的军队，此时便决然不能分化出可以造成红军的成分来。\n第三，小地方民众政权之能否长期地存在，则决定于全国革命形势是否向前发展这一个条件。全国革命形势是向前发展的，则小块红色区域的长期存在，不但没有疑义，而且必然地要作为取得全国政权的许多力量中间的一个力量。全国革命形势若不是继续地向前发展，而有一个比较长期的停顿，则小块红色区域的长期存在是不可能的。现在中国革命形势是跟着国内买办豪绅阶级和国际资产阶级的继续的分裂和战争，而继续地向前发展的。所以，不但小块红色区域的长期存在没有疑义，而且这些红色区域将继续发展，日渐接近于全国政权的取得。第四，相当力量的正式红军的存在，是红色政权存在的必要条件。若只有地方性质的赤卫队56而没有正式的红军，则只能对付挨户团57，而不能对付正式的白色军队。所以虽有很好的工农群众，若没有相当力量的正式武装，便决然不能造成割据局面，更不能造成长期的和日益发展的割据局面。所以“工农武装割据”的思想，是共产党和割据地方的工农群众必须充分具备的一个重要的思想。第五，红色政权的长期的存在并且发展，除了上述条件之外，还须有一个要紧的条件，就是共产党组织的有力量和它的政策的不错误。\n\n三湘赣边界的割据和八月的失败\n军阀间的分裂和战争，削弱了白色政权的统治势力。因此，小地方红色政权得以乘时产生出来。但军阀之间的战争不是每天不停的。每当一省或几省之间的白色政权有一个暂时稳定的时候，那一省的统治阶级或几省的统治阶级必然联合起来用尽力量来消灭这个红色政权。在为建立和坚持红色政权所必须的各种条件尚不完备的地方，便有被敌人推倒的危险。本年四月以前乘时而起的许多红色政权，如广州、海陆丰、湘赣边界、湘南、醴陵、黄安各地，都先后受到白色政权的摧残，就是这个道理。四月以后湘赣边界的割据，正值南方统治势力暂时稳定的时候，湘赣两省派来“进剿”的军队，随时都有八九个团以上的兵力，多的到过十八个团。然而我们以不足四个团的兵力和敌人斗争四个月之久，使割据地区一天一天扩大，土地革命一天一天深入，民众政权的组织一天一天推广，红军和赤卫队一天一天壮大，原因就在于湘赣边界的共产党（地方的党和军队的党）的政策是正确的。当时党的特委和军委的政策是：坚决地和敌人作斗争，创造罗霄山脉58中段政权，反对逃跑主义；深入割据地区的土地革命；军队党帮助地方党的发展，正规军队帮助地方武装的发展；集中红军相机应付当前之敌，反对分兵，避免被敌人各个击破；割据地区的扩大采取波浪式的推进政策，反对冒进政策。因为这些策略的适当，加上地形之利于斗争，湘赣两省进攻军队之不尽一致，于是才有四月至七月四个月中的各次胜利59。虽以数倍于我之敌，不但不能破坏此割据，并且不能阻止此割据的日益扩大，此割据对湘赣两省的影响则有日益加大之势。八月失败，完全在于一部分同志不明了当时正是统治阶级暂时稳定的时候，反而采取统治阶级政治破裂时候的战略，分兵冒进，致边界和湘南同归失败。湖南省委代表杜修经同志不察当时环境，不顾特委、军委及永新县委联席会议的决议，只知形式地执行湖南省委的命令，附和红军第二十九团逃避斗争欲回家乡的意见，其错误实在非常之大。这种失败的形势，因为九月以后特委和军委采取了纠正错误的步骤，而挽救过来了。\n四湘赣边界的割据局面在湘鄂赣三省的地位\n以宁冈为中心的湘赣边界工农武装割据，其意义决不限于边界数县，这种割据在湘鄂赣三省工农暴动夺取三省政权的过程中是有很大的意义的。使边界土地革命和民众政权的影响远及于湘赣两省的下游乃至于湖北；使红军从斗争中日益增加其数量和提高其质量，能在将来三省总的暴动中执行它的必要的使命；使各县地方武装即赤卫队和工农暴动队的数量增加质量提高起来，此时能够与挨户团和小量军队作战，将来能够保全边界政权；使地方工作人材逐渐减少依靠红军中工作人材的帮助，能完全自立，以边界的人材任边界的工作，进一步能够供给红军的工作人材和扩大割据区域的工作人材——这些都是边界党在湘鄂赣三省暴动发展中极其重要的任务。\n五经济问题\n在白色势力的四面包围中，军民日用必需品和现金的缺乏，成了极大的问题。一年以来，边界政权割据的地区，因为敌人的严密封锁，食盐、布匹、药材等日用必需品，无时不在十分缺乏和十分昂贵之中，因此引起工农小资产阶级60群众和红军士兵群众的生活的不安，有时真是到了极度。红军一面要打仗，一面又要筹饷。每天除粮食外的五分钱伙食费都感到缺乏，营养不足，病的甚多，医院伤兵，其苦更甚。这种困难，在全国总政权没有取得以前当然是不能免的，但是这种困难的比较地获得解决，使生活比较地好一点，特别是红军的给养使之比较地充足一点，则是迫切地需要的。边界党如不能对经济问题有一个适当的办法，在敌人势力的稳定还有一个比较长的期间的条件下，割据将要遇到很大的困难。这个经济问题的相当的解决，实在值得每个党员注意。\n六军事根据地问题\n边界党还有一个任务，就是大小五井61和九陇两个军事根据地的巩固。永新、酃县、宁冈、遂川四县交界的大小五井山区，和永新、宁冈、茶陵、莲花四县交界的九陇山区，这两个地形优越的地方，特别是既有民众拥护、地形又极险要的大小五井，不但在边界此时是重要的军事根据地，就是在湘鄂赣三省暴动发展的将来，亦将仍然是重要的军事根据地。巩固此根据地的方法：第一，修筑完备的工事；第二，储备充足的粮食；第三，建设较好的红军医院。把这三件事切实做好，是边界党应该努力的。\n\n井冈山的斗争62\n\n1928 年 11 月 25 日\n\n湘赣边界的割据和八月失败\n一国之内，在四围白色政权的包围中间，产生一小块或若干小块的红色政权区域，在目前的世界上只有中国有这种事。我们分析它发生的原因之一，在于中国有买办豪绅阶级间的不断的分裂和战争。只要买办豪绅阶级间的分裂和战争是继续的，则工农武装割据的存在和发展也将是能够继续的。此外，工农武装割据的存在和发展，还需要具备下列的条件：\n\n有很好的群众；\n有很好的党；\n有相当力量的红军；\n有便利于作战的地势；\n有足够给养的经济力。\n\n在统治阶级政权的暂时稳定的时期和破裂的时期，割据地区对四围统治阶级必须采取不同的战略。\n\n在统治阶级内部发生破裂时期，例如两湖在李宗仁唐生智战争时期63，广东在张发奎李济深战争时期64，我们的战略可以比较地冒进，用军事发展割据的地方可以比较地广大。但是仍然需要注意建立中心区域的坚实基础，以备白色恐怖到来时有所恃而不恐。\n若在统治阶级政权比较稳定的时期，例如今年四月以后的南方各省，则我们的战略必须是逐渐地推进的。这时在军事上最忌分兵冒进，在地方工作方面（分配土地，建立政权，发展党，组织地方武装）最忌把人力分得四散，而不注意建立中心区域的坚实基础。\n\n各地许多小块红色区域的失败，不是客观上条件不具备，就是主观上策略有错误。至于策略之所以错误，全在未曾把统治阶级政权暂时稳定的时期和破裂的时期这两个不同的时期分别清楚。有些同志在统治阶级政权暂时稳定的时期，也主张分兵冒进，甚至主张只用赤卫队65保卫大块地方，好像完全不知道敌人方面除了挨户团66之外还有正式军队集中来打的一回事。在地方工作方面，则完全不注意建立中心区域的坚实的基础，不顾主观力量的可能，只图无限量的推广。如果遇到什么人在军事方面主张采取逐步推广的政策，在地方工作方面主张集中力量建立中心区域的坚实基础，以求自立于不败之地，则谥之曰“保守主义”。他们的这种错误意见，就是今年八月湘赣边界失败以及同时红军第四军在湘南失败的根本原因。\n湘赣边界的工作，从去年十月做起。开头，各县完全没有了党的组织，地方武装只袁文才、王佐各六十枝坏枪在井冈山附近，永新、莲花、茶陵、酃县四县农民自卫军枪枝全数缴给了豪绅阶级，群众革命情绪已经被压下去了。到今年二月，宁冈、永新、茶陵、遂川都有了党的县委，酃县有了特别区委，莲花亦开始建立了党的组织，和万安县委发生了关系。地方武装，除酃县外，各县都有了少数。在宁冈、茶陵、遂川、永新，特别是遂川、永新二县，进行了很多次打倒豪绅、发动群众的游击暴动，成绩都还好。这个时期，土地革命还没有深入。政权机关称为工农兵政府。军中组织了士兵委员会67。部队分开行动时，则组织行动委员会指挥之。这时党的高级指导机关，是秋收起义时湖南省委任命的前敌委员会（毛泽东任书记）。三月上旬，前委因湘南特委的要求而取消，改组为师委（何挺颖为书记），变成单管军中党的机关，对地方党不能过问。同时毛部又因湘南特委的要求调往湘南，遂使边界被敌占领者一个多月。三月底湘南失败，四月朱、毛两部及湘南农军退到宁冈，再开始边界的割据。\n四月以后，湘赣边界的割据，正值南方统治势力暂时稳定的时候，湘赣两省派来“进剿”的反动军队，至少有八九个团，多的时候到过十八个团。然而我们以不足四个团的兵力，和敌人斗争了四个月之久，使割据地区一天一天扩大，土地革命一天一天深入，民众政权一天一天推广，红军和赤卫队一天一天扩大，原因就在于边界党（地方的党和军队的党）的政策是正确的。当时边界特委（毛泽东为书记）和军委（陈毅为书记）的政策是：坚决地和敌人作斗争，造成罗霄山脉中段政权，反对逃跑主义；深入割据地区的土地革命；军队的党帮助地方党的发展，军队的武装帮助地方武装的发展；对统治势力比较强大的湖南取守势，对统治势力比较薄弱的江西取攻势；用大力经营永新，创造群众的割据，布置长期斗争；集中红军相机迎击当前之敌，反对分兵，避免被敌人各个击破；割据地区的扩大采取波浪式的推进政策，反对冒进政策。因为这些策略的适当，加以边界地形的利于斗争，湘赣两省进攻军队的不尽一致，于是才有四月至七月四个月的各次军事胜利68和群众割据的发展。虽以数倍于我之敌，不但不能破坏此割据，且亦不能阻止此割据的发展。此割据对湘赣两省的影响，则有日益扩大之势。八月失败，完全在于一部分同志不明了当时正是统治阶级暂时稳定时期，反而采取在统治阶级破裂时期的政策，分兵向湘南冒进，致使边界和湘南同归失败。湖南省委代表杜修经和省委派充边界特委书记的杨开明，乘力持异议的毛泽东、宛希先诸人远在永新的时候，不察当时的环境，不顾军委、特委、永新县委联席会议不同意湖南省委主张的决议，只知形式地执行湖南省委向湘南去的命令，附和红军第二十九团（成分是宜章农民）逃避斗争欲回家乡的情绪，因而招致边界和湘南两方面的失败。\n原来七月中旬，湖南敌人第八军吴尚侵入宁冈，再进永新，求战不得（我军从间道出击不值），畏我群众，仓卒经莲花退回茶陵。这时红军大队正由宁冈进攻酃县、茶陵，并在酃县变计折赴湘南，而江西敌人第三军王均、金汉鼎部五个团，第六军胡文斗部六个团，又协力进攻永新。此时我军只有一个团在永新，在广大群众的掩护之下，用四面游击的方式，将此十一团敌军困在永新县城附近三十里内至二十五天之久。最后因敌人猛攻，才失去永新，随后又失去莲花、宁冈。这时江西敌人忽然发生内讧，胡文斗的第六军仓皇退去，随即和王均的第三军战于樟树。留下的赣军五个团，亦仓皇退至永新城内。设我大队不往湘南，击溃此敌，使割据地区推广至吉安、安福、萍乡，和平江、浏阳衔接起来，是完全有可能的。大队已不在，我一团兵复疲惫不堪，乃决留一部分会同袁、王两部守井冈山，而由我率兵一部往桂东方向迎还大队。此时大队已由湘南退向桂东，八月二十三日我们在桂东得到会合。\n红军大队七月中刚到酃县时，第二十九团官兵即因政治动摇，欲回湘南家乡，不受约束；第二十八团反对往湘南，欲往赣南，但也不愿回永新。杜修经导扬第二十九团的错误意见，军委亦未能加以阻止，大队遂于七月十七日由酃县出发，向郴州前进。七月二十四日与敌范石生战于郴州，先胜后败，撤出战斗。第二十九团随即自由行动，跑向宜章家乡，结果一部在乐昌被土匪胡凤章消灭，一部散在郴宜各地，不知所终，当日收集的不过百人。幸主力第二十八团损失不大，于八月十八日占领桂东。二十三日，会合从井冈山来的部队，议决经崇义、上犹重回井冈山。当到崇义时，营长袁崇全率一步兵连一炮兵连叛变，虽然追回了这两个连，但牺牲了团长王尔琢。八月三十日敌湘赣两军各一部乘我军欲归未归之际，攻击井冈山。我守军不足一营，凭险抵抗，将敌击溃，保存了这个根据地。\n此次失败的原因是：\n\n一部官兵动摇思家，失掉战斗力；一部官兵不愿往湘南，缺乏积极性。\n盛暑远征，兵力疲惫。\n从酃县冒进数百里，和边界失去联系，成了孤军。\n湘南群众未起来，成了单纯的军事冒险。\n敌情不明。\n准备不好，官兵不了解作战的意义。\n\n割据地区的现势\n今年四月以来，红色区域逐渐推广。六月二十三日龙源口（永新宁冈交界）一战，第四次击破江西敌人之后，我区有宁冈、永新、莲花三个全县，吉安、安福各一小部，遂川北部，酃县东南部，是为边界全盛时期。在红色区域，土地大部分配了，小部在分配中。区乡政权普遍建立。宁冈、永新、莲花、遂川都有县政府，并成立了边界政府。乡村普遍组织了工农暴动队，区县两级则有赤卫队。七月赣敌进攻，八月湘赣两敌会攻井冈山，边界各县的县城及平原地区尽为敌据。为虎作伥的保安队、挨户团横行无忌，白色恐怖布满城乡。党的组织和政权的组织大部塌台。富农和党内的投机分子纷纷反水69。八月三十日井冈山一战，湘敌始退往酃县，赣敌仍盘踞各县城及大部乡村。然而山区是敌人始终无法夺取的，这在宁冈有西北两区，在永新有北乡的天龙区、西乡的小江区、南乡的万年山区，在莲花有上西区，在遂川有井冈山区，在酃县有青石冈和大院区。七、八两月，红军一个团配合各县赤卫队、暴动队大小数十战，仅失枪三十枝，最后退入山区。\n我军经崇义、上犹向井冈山回军之际，赣南敌军独立第七师刘士毅部追至遂川。九月十三日，我军击败刘士毅，缴枪数百，占领遂川。九月二十六日回到井冈山。十月一日，与敌熊式辉部周浑元旅战于宁冈获胜，收复宁冈全县。此时湘敌驻桂东的阎仲儒部有一百二十六人投入我军，编为特务营，毕占云为营长。十一月九日，我军又击破周旅一个团于宁冈城和龙源口。翌日进占永新，随即退回宁冈。目前我区南自遂川井冈山南麓，北至莲花边界，包括宁冈全县，遂川、酃县、永新各一部，成一南北狭长的整块。莲花的上西区，永新的天龙区、万年山区，则和整块不甚连属。敌人企图以军事进攻和经济封锁消灭我们的根据地，我们正在准备打破敌人的进攻。\n军事问题\n边界的斗争，完全是军事的斗争，党和群众不得不一齐军事化。怎样对付敌人，怎样作战，成了日常生活的中心问题。所谓割据，必须是武装的。哪一处没有武装，或者武装不够，或者对付敌人的策略错了，地方就立即被敌人占去了。这种斗争，一天比一天激烈，问题也就非常地繁复和严重。\n边界红军的来源：\n\n潮汕叶贺旧部70；\n前武昌国民政府警卫团71；\n平浏的农民72；\n湘南的农民73和水口山的工人74；\n许克祥、唐生智、白崇禧、朱培德、吴尚、熊式辉等部的俘虏兵；\n边界各县的农民。\n\n但是叶贺旧部、警卫团和平浏农民，经过一年多的战斗，只剩下三分之一。湘南农民，伤亡也大。因此，前四项虽然至今还是红军第四军的骨干，但已远不如后二项多。后二项中又以敌军俘虏为多，设无此项补充，则兵员大成问题。虽然如此，兵的增加和枪的增加仍不相称，枪不容易损失，兵有伤、亡、病、逃，损失甚易。湖南省委答应送安源工人75来此，亟盼实行。\n红军成分，一部是工人、农民，一部是游民无产者。游民成分太多，当然不好。但因天天在战斗，伤亡又大，游民分子却有战斗力，能找到游民补充已属不易。在此种情形下，只有加紧政治训练的一法。红军士兵大部分是由雇佣军队来的，但一到红军即变了性质。首先是红军废除了雇佣制，使士兵感觉不是为他人打仗，而是为自己为人民打仗。红军至今没有什么正规的薪饷制，只发粮食、油盐柴菜钱和少数的零用钱。红军官兵中的边界本地人都分得了土地，只是远籍人分配土地颇为困难。\n经过政治教育，红军士兵都有了阶级觉悟，都有了分配土地、建立政权和武装工农等项常识，都知道是为了自己和工农阶级而作战。因此，他们能在艰苦的斗争中不出怨言。连、营、团都有了士兵会，代表士兵利益，并做政治工作和民众工作。\n党代表制度76，经验证明不能废除。特别是在连一级，因党的支部建设在连上，党代表更为重要。他要督促士兵委员会进行政治训练，指导民运工作，同时要担任党的支部书记。事实证明，哪一个连的党代表较好，哪一个连就较健全，而连长在政治上却不易有这样大的作用。因为下级干部死伤太多，敌军俘虏兵往往过来不久，就要当连排长；今年二三月间的俘虏兵，现在有当了营长的。从表面看，似乎既称红军，就可以不要党代表了，实在大谬不然。第二十八团在湘南曾经取消了党代表，后来又恢复了。改称指导员，则和国民党的指导员相混，为俘虏兵所厌恶。且易一名称，于制度的本质无关。故我们决定不改。党代表伤亡太多，除自办训练班训练补充外，希望中央和两省委派可充党代表的同志至少三十人来。\n普通的兵要训练半年一年才能打仗，我们的兵，昨天入伍今天就要打仗，简直无所谓训练。军事技术太差，作战只靠勇敢。长时间的休息训练是不可能的，只有设法避开一些战斗，争取时间训练，看可能否。为着训练下级军官，现在办了一个百五十人的教导队，准备经常办下去。希望中央和两省委多派连排长以上的军官来。\n湖南省委要我们注意士兵的物质生活，至少要比普通工农的生活好些。现在则相反，除粮食外，每天每人只有五分大洋的油盐柴菜钱，还是难乎为继。仅仅发油盐柴菜钱，每月也需现洋万元以上，全靠打土豪供给77。现在全军五千人的冬衣，有了棉花，还缺少布。这样冷了，许多士兵还是穿两层单衣。好在苦惯了。而且什么人都是一样苦，从军长到伙夫，除粮食外一律吃五分钱的伙食。发零用钱，两角即一律两角，四角即一律四角78。因此士兵也不怨恨什么人。\n作战一次，就有一批伤兵。由于营养不足、受冻和其他原因，官兵病的很多。医院设在山上，用中西两法治疗，医生药品均缺。现在医院中共有八百多人。湖南省委答应办药，至今不见送到。仍祈中央和两省委送几个西医和一些碘片来。\n红军的物质生活如此菲薄，战斗如此频繁，仍能维持不敝，除党的作用外，就是靠实行军队内的民主主义。官长不打士兵，官兵待遇平等，士兵有开会说话的自由，废除烦琐的礼节，经济公开。士兵管理伙食，仍能从每日五分的油盐柴菜钱中节余一点作零用，名曰“伙食尾子”，每人每日约得六七十文。这些办法，士兵很满意。尤其是新来的俘虏兵，他们感觉国民党军队和我们军队是两个世界。他们虽然感觉红军的物质生活不如白军，但是精神得到了解放。同样一个兵，昨天在敌军不勇敢，今天在红军很勇敢，就是民主主义的影响。红军像一个火炉，俘虏兵过来马上就熔化了。中国不但人民需要民主主义，军队也需要民主主义。军队内的民主主义制度，将是破坏封建雇佣军队的一个重要的武器79。\n党的组织，现分连支部、营委、团委、军委四级。连有支部，班有小组。红军所以艰难奋战而不溃散，“支部建在连上”是一个重要原因。两年前，我们在国民党军中的组织，完全没有抓住士兵，即在叶挺部80也还是每团只有一个支部，故经不起严重的考验。现在红军中党员和非党员约为一与三之比，即平均四个人中有一个党员。最近决定在战斗兵中发展党员数量，达到党员非党员各半的目的81。现在连支部缺乏好的书记，请中央从各地不能立足的活动分子中派遣多人来此充当。湘南来的工作人员，几乎尽数在军中做党的工作。可是八月间在湘南跑散了一些，所以现在不能调出人去。\n地方武装有赤卫队和工农暴动队。暴动队以梭镖、鸟枪为武器，乡为单位，每乡一队，人数以乡的大小为比例。职务是镇压反革命，保卫乡政权，敌人来了帮助红军或赤卫队作战。暴动队始于永新，原是秘密的，夺取全县以后，公开了。这个制度现已推行于边界各县，名称未改。赤卫队的武器主要是五响枪，也有九响和单响枪。各县枪数：宁冈百四十，永新二百二十，莲花四十三，茶陵五十，酃县九十，遂川百三十，万安十，共六百八十三。大部是红军发给的，小部是自己从敌人夺取的。各县赤卫队大都经常地和豪绅的保安队、挨户团作战，战斗力日益增强。马日事变82以前，各县有农民自卫军。枪数：攸县三百，茶陵三百，酃县六十，遂川五十，永新八十，莲花六十，宁冈（袁文才部）六十，井冈山（王佐部）六十，共九百七十。马日事变后，除袁、王两部无损失外，仅遂川保存六枝，莲花保存一枝，其余概被豪绅缴去。农民自卫军如此没有把握枪枝的能力，这是机会主义路线的结果。现在各县赤卫队的枪枝还是很不够，不如豪绅的枪多，红军必须继续在武器上给赤卫队以帮助。在不降低红军战斗力的条件之下，必须尽量帮助人民武装起来。我们业经规定红军每营用四连制，每连步枪七十五枝，加上特务连，机关枪连，迫击炮连，团部和三个营部，每团有步枪一千零七十五枝。作战缴获的枪，则尽量武装地方。赤卫队的指挥官，由各县派人进红军所办的教导队受训后充当。由红军派远地人到地方去当队长，必须逐渐减少。朱培德、吴尚亦在武装保安队和挨户团，边界各县豪绅武装的数量和战斗力，颇为可观。我们红色地方武装的扩大，更是刻不容缓。\n红军以集中为原则，赤卫队以分散为原则。当此反动政权暂时稳定时期，敌人能集中大量军力来打红军，红军分散是不利的。我们的经验，分兵几乎没有一次不失败，集中兵力以击小于我或等于我或稍大于我之敌，则往往胜利。中央指示我们发展的游击区域，纵横数千里，失之太广，这大概是对我们力量估计过大的缘故。赤卫队则以分散为有利，现在各县赤卫队都采取分散作战办法。\n对敌军的宣传，最有效的方法是释放俘虏和医治伤兵。敌军的士兵和营、连、排长被我们俘虏过来，即对他们进行宣传工作，分为愿留愿去两种，愿去的即发路费释放。这样就把敌人所谓“共匪见人就杀”的欺骗，立即打破。杨池生的《九师旬刊》，对于我们的这种办法有“毒矣哉”的惊叹。红军士兵们对于所捉俘虏的抚慰和欢送，十分热烈，在每次“欢送新弟兄大会”上，俘虏兵演说也回报我们以热烈的感激。医治敌方伤兵，效力也很大。聪明的敌人例如李文彬，近来也仿效我们的办法，不杀俘虏，医治被俘伤兵。不过，在再作战时，我们的人还是有拖枪回来的，这样的事已有过两回。此外，文字宣传，如写标语等，也尽力在做。每到一处，壁上写满了口号。惟缺绘图的技术人材，请中央和两省委送几个来。\n军事根据地：第一个根据地是井冈山，介在宁冈、酃县、遂川、永新四县之交。北麓是宁冈的茅坪，南麓是遂川的黄坳，两地相距九十里。东麓是永新的拿山，西麓是酃县的水口，两地相距百八十里。四周从拿山起经龙源口（以上永新）、新城、茅坪、大陇（以上宁冈）、十都、水口、下村（以上酃县）、营盘圩、戴家埔、大汾、堆子前、黄坳、五斗江、车坳（以上遂川）到拿山，共计五百五十里。山上大井、小井、上井、中井、下井、茨坪、下庄、行洲、草坪、白银湖、罗浮各地，均有水田和村庄，为自来土匪、散军窟宅之所，现在作了我们的根据地。但人口不满两千，产谷不满万担，军粮全靠宁冈、永新、遂川三县输送。山上要隘，都筑了工事。医院、被服厂、军械处、各团留守处，均在这里。现在正从宁冈搬运粮食上山。若有充足的给养，敌人是打不进来的。第二个根据地是宁冈、永新、莲花、茶陵四县交界的九陇山，重要性不及井冈山，为四县地方武装的最后根据地，也筑了工事。在四围白色政权中间的红色割据，利用山险是必要的。\n土地问题\n边界土地状况：大体说来，土地的百分之六十以上在地主手里，百分之四十以下在农民手里。江西方面，遂川的土地最集中，约百分之八十是地主的。永新次之，约百分之七十是地主的。万安、宁冈、莲花自耕农较多，但地主的土地仍占比较的多数，约百分之六十，农民只占百分之四十。湖南方面，茶陵、酃县两县均有约百分之七十的土地在地主手中。\n中间阶级问题：在上述土地状况之下，没收一切土地重新分配83，是能得到大多数人拥护的。但农村中略分为三种阶级，即大、中地主阶级，小地主、富农的中间阶级，中农、贫农阶级。富农往往与小地主利害联在一起。富农土地在土地总额中占少数，但与小地主土地合计，则数量颇大。这种情形，恐全国亦差不多。边界对于土地是采取全部没收、彻底分配的政策；故在红色区域，豪绅阶级和中间阶级，同被打击。政策是如此，实际执行时却大受中间阶级的阻碍。当革命初期，中间阶级表面上投降贫农阶级，实际则利用他们从前的社会地位及家族主义，恐吓贫农，延宕分田的时间。到无可延宕时，即隐瞒土地实数，或自据肥田，把瘠田让人。此时期内，贫农因长期地被摧残及感觉革命胜利无保障，往往接受中间阶级的意见，不敢积极行动。必待进至革命高涨，如得了全县甚至几县政权，反动军队几次战败，红军的威力几次表现之后，农村中才有对于中间阶级的积极行动。如永新南乡，是中间阶级最多的地方，延宕分田及隐瞒土地也最厉害。到六月二十三日龙源口红军大胜之后，区政府又处理了几个延宕分田的人，才实际地分下去。但是无论哪一县，封建的家族组织十分普遍，多是一姓一个村子，或一姓几个村子，非有一个比较长的时间，村子内阶级分化不能完成，家族主义不能战胜。\n白色恐怖下中间阶级的反水：中间阶级在革命高涨时受到打击，白色恐怖一来，马上反水。引导反动军队大烧永新、宁冈革命农民的房子的，就是两县的小地主和富农。他们依照反动派的指示，烧屋、捉人，十分勇敢。红军再度到宁冈新城、古城、砻市一带时，有数千农民听信反动派的共产党将要杀死他们的宣传，跟了反动派跑到永新。经过我们“不杀反水农民”、“欢迎反水农民回来割禾”的宣传之后，才有一些农民慢慢地跑回来。\n全国革命低潮时，割据地区最困难的问题，就在拿不住中间阶级。中间阶级之所以反叛，受到革命的过重打击是主因。然若全国在革命高涨中，贫农阶级有所恃而增加勇气，中间阶级亦有所惧而不敢乱为。当李宗仁唐生智战争向湖南发展时，茶陵的小地主向农民求和，有送猪肉给农民过年的（这时红军已退出茶陵向遂川去了）。李唐战争结束，就不见有这等事了。现在全国是反革命高涨时期，被打击的中间阶级在白色区域内几乎完全附属于豪绅阶级去了，贫农阶级成了孤军。此问题实在严重得很84。\n日常生活压迫，影响中间阶级反水：红区白区对抗，成为两个敌国。因为敌人的严密封锁和我们对小资产阶级的处理失当这两个原因，两区几乎完全断绝贸易，食盐、布匹、药材等项日常必需品的缺乏和昂贵，木材、茶油等农产品不能输出，农民断绝进款，影响及于一般人民。贫农阶级比较尚能忍受此苦痛，中等阶级到忍不住时，就投降豪绅阶级。中国豪绅军阀的分裂和战争若不是继续进行的，全国革命形势若不是向前发展的，则小块地区的红色割据，在经济上将受到极大的压迫，割据的长期存在将成问题。因为这种经济压迫，不但中等阶级忍不住，工人、贫农和红军亦恐将有耐不住之时。永新、宁冈两县没有盐吃，布匹、药材完全断绝，其他更不必说。现在盐已有卖，但极贵。布匹、药材仍然没有。宁冈及永新西部、遂川北部（以上均目前割据地）出产最多的木材和茶油，仍然运不出去85。\n土地分配的标准：以乡为分配土地的单位。山多田少地方，如永新之小江区，以三四乡为一个单位去分配的也有，但极少。所有乡村中男女老幼，一律平分。现依中央办法，改以劳动力为标准，能劳动的比不能劳动的多分一倍86。\n向自耕农让步问题：尚未详细讨论。自耕农中之富农，自己提出要求，欲以生产力为标准，即人工和资本（农具等）多的多分田。富农觉得平均分和按劳动力分两种方法都于他们不利。他们的意思，在人工方面，他们愿意多努力，加上资本的力量，他们可以多得收获。若照普通人一样分了，蔑视了（闲置了）他们的特别努力和多余的资本，他们是不愿意的。此间仍照中央办法执行。但此问题，仍当讨论，候得结论再作报告。\n土地税：宁冈收的是百分之二十，比中央办法多收半成，已在征收中，不好变更，明年再减。此外，遂川、酃县、永新各一部在割据区域内，都是山地，农民太苦，不好收税。政府和赤卫队用费，靠向白色区域打土豪。至于红军给养，米暂可从宁冈土地税取得，钱亦完全靠打土豪。十月在遂川游击，筹得万余元，可用一时，用完再讲。\n政权问题\n县、区、乡各级民众政权是普遍地组织了，但是名不副实。许多地方无所谓工农兵代表会。乡、区两级乃至县一级，政府的执行委员会，都是用一种群众会选举的。一哄而集的群众会，不能讨论问题，不能使群众得到政治训练，又最便于知识分子或投机分子的操纵。一些地方有了代表会，亦仅认为是对执行委员会的临时选举机关；选举完毕，大权揽于委员会，代表会再不谈起。名副其实的工农兵代表会组织，不是没有，只是少极了。所以如此，就是因为缺乏对于代表会这个新的政治制度的宣传和教育。封建时代独裁专断的恶习惯深中于群众乃至一般党员的头脑中，一时扫除不净，遇事贪图便利，不喜欢麻烦的民主制度。民主集中主义的制度，一定要在革命斗争中显出了它的效力，使群众了解它是最能发动群众力量和最利于斗争的，方能普遍地真实地应用于群众组织。我们正在制订详细的各级代表会组织法（依据中央的大纲），把以前的错误逐渐纠正。红军中的各级士兵代表会议，现亦正在使之经常建立起来，纠正从前只有士兵委员会而无士兵代表会的错误。\n现在民众普遍知道的“工农兵政府”，是指委员会，因为他们尚不认识代表会的权力，以为委员会才是真正的权力机关。没有代表大会作依靠的执行委员会，其处理事情，往往脱离群众的意见，对没收及分配土地的犹豫妥协，对经费的滥用和贪污，对白色势力的畏避或斗争不坚决，到处发现。委员会也很少开全体会，遇事由常委处决。区乡两级政府则常委会也少开，遇事由主席、秘书、财务或赤卫队长（暴动队长）各自处理决定，这四个人是经常驻会的。所以，民主集中主义，在政府工作中也用得不习惯。\n初期的政府委员会中，特别是乡政府一级，小地主富农争着要干。他们挂起红带子，装得很热心，用骗术钻入了政府委员会，把持一切，使贫农委员只作配角。只有在斗争中揭破了他们的假面，贫农阶级起来之后，方能去掉他们。这种现象虽不普遍，但在很多地方都发现了。\n党在群众中有极大的威权，政府的威权却差得多。这是由于许多事情为图省便，党在那里直接做了，把政权机关搁置一边。这种情形是很多的。政权机关里的党团组织有些地方没有，有些地方有了也用得不完满。以后党要执行领导政府的任务；党的主张办法，除宣传外，执行的时候必须通过政府的组织。国民党直接向政府下命令的错误办法，是要避免的。\n党的组织问题\n与机会主义斗争的经过：马日事变前后，边界各县的党，可以说是被机会主义操纵的。当反革命到来时，很少坚决的斗争。去年十月，红军（工农革命军第一军第一师第一团）到达边界各县时，只剩下若干避难藏匿的党员，党的组织全部被敌人破坏了。十一月到今年四月，为重新建党时期，五月以后为大发展时期。一年以来，党内机会主义现象仍然到处发现：一部分党员无斗争决心，敌来躲入深山，叫做“打埋伏”；一部分党员富有积极性，却又流于盲目的暴动。这些都是小资产阶级思想的表现。这种情形，经过长期的斗争锻炼和党内教育，逐渐减少了。同时，在红军中，这种小资产阶级的思想，也是存在的。敌人来了，主张拚一下，否则就要逃跑。这两种思想，往往在讨论作战时由一个人说出来。经过了长时间党内的斗争和客观事实的教训，例如拚一下遭了损伤，逃跑遭了失败，才逐渐地改变过来。\n\n\n地方主义\n边界的经济，是农业经济，有些地方还停留在杵臼时代（山地大都用杵臼舂米，平地方有许多石碓）。社会组织是普遍地以一姓为单位的家族组织。党在村落中的组织，因居住关系，许多是一姓的党员为一个支部，支部会议简直同时就是家族会议。在这种情形下，“斗争的布尔什维克党”的建设，真是难得很。说共产党不分国界省界的话，他们不大懂，不分县界、区界、乡界的话，他们也是不大懂得的。各县之间地方主义很重，一县内的各区乃至各乡之间也有很深的地方主义。这种地方主义的改变，说道理，至多发生几分效力，多半要靠白色势力的非地方主义的压迫。例如反革命的两省“会剿”，使人民在斗争中有了共同的利害，才可以逐渐地打破他们的地方主义。经过了许多这样的教训，地方主义是减少了。\n\n\n土客籍问题\n边界各县还有一件特别的事，就是土客籍的界限。土籍的本地人和数百年前从北方移来的客籍人之间存在着很大的界限，历史上的仇怨非常深，有时发生很激烈的斗争。这种客籍人从闽粤边起，沿湘、赣两省边界，直至鄂南，大概有几百万人。客籍占领山地，为占领平地的土籍所压迫，素无政治权利。前年和去年的国民革命，客籍表示欢迎，以为出头有日。不料革命失败，客籍被土籍压迫如故。\n我们的区域内，宁冈、遂川、酃县、茶陵，都有土客籍问题，而以宁冈的问题为最严重。前年至去年，宁冈的土籍革命派和客籍结合，在共产党领导之下，推翻了土籍豪绅的政权，掌握了全县。去年六月，江西朱培德政府反革命，九月，豪绅带领朱培德军队“进剿”宁冈，重新挑起土客籍人民之间斗争。\n这种土客籍的界限，在道理上讲不应引到被剥削的工农阶级内部来，尤其不应引到共产党内部来。然而在事实上，因为多年遗留下来的习惯，这种界限依然存在。例如边界八月失败，土籍豪绅带领反动军队回宁冈，宣传客籍将要杀土籍，土籍农民大部分反水，挂起白带子，带领白军烧屋搜山。十月、十一月红军打败白军，土籍农民跟着反动派逃走，客籍农民又去没收土籍农民的财物。这种情况，反映到党内来，时常发生无谓的斗争。我们的办法是一面宣传“不杀反水农民”，“反水农民回来一样得田地”，使他们脱离豪绅的影响，安心回家；一面由县政府责令客籍农民将没收的财物退还原主，并出布告保护土籍农民。在党内，加紧教育，务使两部分党员团结一致。\n\n\n投机分子的反水\n革命高涨时（六月），许多投机分子乘公开征收党员的机会混入党内，边界党员数量一时增到一万以上。支部和区委的负责人多属新党员，不能有好的党内教育。白色恐怖一到，投机分子反水，带领反动派捉拿同志，白区党的组织大半塌台。九月以后，厉行洗党，对于党员成分加以严格的限制。永新、宁冈两县的党组织全部解散，重新登记。党员数量大为减少，战斗力反而增加。\n过去党的组织全部公开，九月以后，建设秘密的组织，准备在反动派来了也能活动。同时多方伸入白区，在敌人营垒中去活动。但在附近各城市中还没有党的基础。其原因一因城市中敌人势力较大，二因我军在占领这些城市时太损害了资产阶级的利益，致使党员在那里难于立足。现在纠正错误，力求在城市中建设我们的组织，但成效尚不多见。\n\n\n党的领导机关\n支部干事会改称委员会。支部上为区委，区委上为县委。区委县委之间因特别情况有组织特别区委的，如永新的北乡特区及东南特区。边区共有宁冈、永新、莲花、遂川、酃县五个县委。茶陵原有县委，因工作做不进去，去冬今春建设的许多组织大部被白色势力打塌了，半年以来只能在靠近宁冈永新一带的山地工作，因此将县委改为特别区委。攸县、安仁均须越过茶陵，派人去过，无功而返。万安县委一月间曾和我们在遂川开过一次联席会议，大半年被白色势力隔断，九月红军游击到万安，才又接一次头。有八十个革命农民跟随到井冈山，组织万安赤卫队。安福没有党的组织。吉安邻接永新，吉安县委仅和我们接过两次头，一点帮助不给，奇怪得很。\n桂东的沙田一带，三月八月两度分配土地，建设了党的组织，属于以龙溪十二洞为中心的湘南特委管辖。各县县委之上为湘赣边界特委。五月二十日，边界党的第一次代表大会在宁冈茅坪开会，选举第一届特委会委员二十三人，毛泽东为书记。七月湖南省委派杨开明来，杨代理书记。九月杨病，谭震林代理书记。八月红军大队往湘南，白色势力高压边界，我们曾在永新开过一次紧急会议。十月红军返至宁冈，乃在茅坪召集边界党的第二次代表大会。十月四日起开会三天，通过了《政治问题和边界党的任务》等决议，选举了谭震林、朱德、陈毅、龙超清、朱昌偕、刘天干、盘圆珠、谭思聪、谭兵、李却非、朱亦岳、袁文才、王佐农、陈正人、毛泽东、宛希先、王佐、杨开明、何挺颖等十九人为第二届特委会的委员。五人为常委，谭震林（工人）为书记，陈正人（知识分子）为副书记。十一月十四日红军第六次全军大会87，选举二十三人组织军委，五人为常委，朱德为书记。特委及军委统辖于前委。前委是十一月六日重新组织的，依中央的指定，以毛泽东、朱德、地方党部书记（谭震林）、一工人同志（宋乔生）、一农民同志（毛科文）五人组成，毛泽东为书记。前委暂设秘书处、宣传科、组织科和职工运动委员会、军事委员会。前委管理地方党。特委仍有存在的必要，因为前委有时要随军行动。我们感觉无产阶级思想领导的问题，是一个非常重要的问题。边界各县的党，几乎完全是农民成分的党，若不给以无产阶级的思想领导，其趋向是会要错误的。除应积极注意各县城和大市镇的职工运动外，并应在政权机关中增加工人的代表。党的各级领导机关也应增加工人和贫农的成分。\n\n\n革命性质问题\n我们完全同意共产国际关于中国问题的决议。中国现时确实还是处在资产阶级民权革命的阶段。中国彻底的民权主义革命的纲领，包括对外推翻帝国主义，求得彻底的民族解放；对内肃清买办阶级的在城市的势力，完成土地革命，消灭乡村的封建关系，推翻军阀政府。必定要经过这样的民权主义革命，方能造成过渡到社会主义的真正基础。\n我们一年来转战各地，深感全国革命潮流的低落。一方面有少数小块地方的红色政权，一方面全国人民还没有普通的民权，工人农民以至民权派的资产阶级，一概没有言论集会的权利，加入共产党是最大的犯罪。红军每到一地，群众冷冷清清，经过宣传之后，才慢慢地起来。和敌军打仗，不论哪一军都要硬打，没有什么敌军内部的倒戈或暴动。马日事变后招募“暴徒”最多的第六军，也是这样。我们深深感觉寂寞，我们时刻盼望这种寂寞生活的终了。要转入到沸热的全国高涨的革命中去，则包括城市小资产阶级在内的政治的经济的民权主义斗争的发动，是必经的道路。\n对小资产阶级的政策，我们在今年二月以前，是比较地执行得好的。三月湖南特委的代表到宁冈，批评我们太右，烧杀太少，没有执行所谓“使小资产变成无产，然后强迫他们革命”的政策，于是改变原来前委的领导人，政策一变。四月全军到边界后，烧杀虽仍不多，但对城市中等商人的没收和乡村小地主富农的派款，是做得十分厉害的。湘南特委提出的“一切工厂归工人”的口号，也宣传得很普遍。这种打击小资产阶级的过左的政策，把小资产阶级大部驱到豪绅一边，使他们挂起白带子反对我们。近来逐渐改变这种政策，情形渐渐好些。在遂川特别收到了好的效果，县城和市镇上的商人不畏避我们了，颇有说红军的好话的。草林圩上逢圩（日中为市，三天一次），到圩两万人，为从来所未有。这件事，证明我们的政策是正确的了。豪绅对人民的税捐很重，遂川靖卫团88在黄坳到草林七十里路上要抽五道税，无论什么农产都不能免。我们打掉靖卫团，取消这些税，获得了农民和中小商人全体的拥护。中央要我们发布一个包括小资产阶级利益的政纲，我们则提议请中央制订一个整个民权革命的政纲，包括工人利益、土地革命和民族解放，使各地有所遵循。以农业为主要经济的中国的革命，以军事发展暴动，是一种特征。我们建议中央，用大力做军事运动。\n割据地区问题\n广东北部沿湖南江西两省边界至湖北南部，都属罗霄山脉区域。整个的罗霄山脉我们都走遍了；各部分比较起来，以宁冈为中心的罗霄山脉的中段，最利于我们的军事割据。北段地势不如中段可进可守，又太迫近了大的政治都会，如果没有迅速夺取长沙或武汉的计划，则以大部兵力放在浏阳、醴陵、萍乡、铜鼓一带是很危险的。南段地势较北段好，但群众基础不如中段，政治上及于湘赣两省的影响也小些，不如中段一举一动可以影响两省的下游。中段的长处：\n\n有经营了一年多的群众基础。\n党的组织有相当的基础。\n经过一年多的时间，创造了富有斗争经验的地方武装，这是十分难得的；这个地方武装的力量，加上红军第四军的力量，是任凭什么敌人也不能消灭的。\n有很好的军事根据地——井冈山，地方武装的根据地则各县都有。\n影响两省，且能影响两省的下游，比较湘南赣南等处只影响一省，且在一省的上游和僻地者，政治意义大不相同。中段的缺点，是因割据已久，“围剿”军多，经济问题，特别是现金问题，十分困难。\n\n湖南省委对于此间的行动计划，六七月间数星期内，曾三变其主张。第一次袁德生来，赞成罗霄山脉中段政权计划。第二次杜修经、杨开明来，主张红军毫不犹豫地向湘南发展，只留二百枝枪会同赤卫队保卫边界，并说这是“绝对正确”的方针。第三次袁德生又来，相隔不过十天，这次信上除骂了我们一大篇外，却主张红军向湘东去，又说是“绝对正确”的方针，而且又要我们“毫不犹豫”。我们接受了这样硬性的指示，不从则迹近违抗，从则明知失败，真是不好处。当第二次信到时，军委、特委、永新县委举行联席会议，认为往湘南危险，决定不执行省委的意见。数天之后，却由杜修经杨开明坚持省委意见，利用第二十九团的乡土观念，把红军拉去攻郴州，致边界和红军一齐失败。红军数量上约损失一半；边界则被焚之屋、被杀之人不可胜数，各县相继失陷，至今未能完全恢复。至于往湘东，在湘鄂赣三省豪绅政权尚未分裂之前，亦决不宜用红军的主力去。设七月无去湘南一举，则不但可免边界的八月失败，且可乘国民党第六军和王均战于江西樟树之际，击破永新敌军，席卷吉安、安福，前锋可达萍乡，而与北段之红第五军取得联络。即在这种时候，也应以宁冈为大本营，去湘东的只能是游击部队。因豪绅间战争未起，湘边酃县、茶陵、攸县尚有大敌，主力北向，必为所乘。中央要我们考虑往湘东或往湘南，实行起来都很危险，湘东之议虽未实现，湘南则已有证验。这种痛苦的经验，是值得我们时时记着的。\n现在是豪绅阶级统治还没有破裂的时期，环边界而“进剿”的敌军，尚有十余团之多。但若我们于现金问题能继续找得出路（粮食衣服已不成大问题），则凭借边界的基础，对付此数敌人，甚至更多的敌人，均有办法。为边界计，红军若走，则像八月那样的蹂躏，立可重来。赤卫队虽不至完全消灭，党和群众的基础将受到极大的摧残，除山头割据可以保存一些外，平地均将转入秘密状态，如八九月间一样。红军不走，以现在的基础可以逐渐向四周发展，前途的希望是很大的。为红军计，欲求扩大，只有在有群众基础的井冈山四周即宁冈、永新、酃县、遂川四县，利用湘赣两敌利害不一致，四面防守，无法集中的情况，和敌人作长期的斗争。利用正确的战术，不战则已，战则必胜，必有俘获，如此可以逐渐扩大红军。以四月至七月那时边界群众的准备，红军大队若无湘南之行，则八月间红军的扩大是没有疑义的。虽然犯了一次错误，红军已卷土重来此地利人和之边界，前途希望还是不恶。红军必须在边界这等地方，下斗争的决心，有耐战的勇气，才能增加武器，练出好兵。边界的红旗子，业已打了一年，虽然一方面引起了湘鄂赣三省乃至全国豪绅阶级的痛恨，另一方面却渐渐引起了附近省份工农士兵群众的希望。以士兵论，因军阀们把向边界“剿匪”当做一件大事，“剿匪经年，耗费百万”（鲁涤平），“人称二万，枪号五千”（王均），如此等类的话，逐渐引起敌军士兵和无出路的下级官长对我们注意，自拔来归的将日益增多，红军扩充，又是一条来路。并且边界红旗子始终不倒，不但表示了共产党的力量，而且表示了统治阶级的破产，在全国政治上有重大的意义。所以我们始终认为罗霄山脉中段政权的创造和扩大，是十分必要和十分正确的。\n\n关于纠正党内的错误思想89\n\n1929 年 12 月\n\n红军第四军的共产党内存在着各种非无产阶级的思想，这对于执行党的正确路线，妨碍极大。若不彻底纠正，则中国伟大革命斗争给予红军第四军的任务，是必然担负不起来的。四军党内种种不正确思想的来源，自然是由于党的组织基础的最大部分是由农民和其他小资产阶级出身的成分所构成的；但是党的领导机关对于这些不正确的思想缺乏一致的坚决的斗争，缺乏对党员作正确路线的教育，也是使这些不正确思想存在和发展的重要原因。大会根据中央九月来信的精神，指出四军党内各种非无产阶级思想的表现、来源及其纠正的方法，号召同志们起来彻底地加以肃清。\n关于单纯军事观点\n单纯军事观点在红军一部分同志中非常发展。其表现如：\n\n认为军事政治二者是对立的，不承认军事只是完成政治任务的工具之一。甚至还有说“军事好，政治自然会好，军事不好，政治也不会好”的，则更进一步认为军事领导政治了。\n以为红军的任务也和白军相仿佛，只是单纯地打仗的。不知道中国的红军是一个执行革命的政治任务的武装集团。特别是现在，红军决不是单纯地打仗的，它除了打仗消灭敌人军事力量之外，还要负担宣传群众、组织群众、武装群众、帮助群众建立革命政权以至于建立共产党的组织等项重大的任务。红军的打仗，不是单纯地为了打仗而打仗，而是为了宣传群众、组织群众、武装群众，并帮助群众建设革命政权才去打仗的，离了对群众的宣传、组织、武装和建设革命政权等项目标，就是失去了打仗的意义，也就是失去了红军存在的意义。\n因此，在组织上，把红军的政治工作机关隶属于军事工作机关，提出“司令部对外”的口号。这种思想如果发展下去，便有走到脱离群众、以军队控制政权、离开无产阶级领导的危险，如像国民党军队所走的军阀主义的道路一样。\n同时，在宣传工作上，忽视宣传队的重要性。在群众组织上，忽视军队士兵会90的组织和对地方工农群众的组织。结果，宣传和组织工作，都成了被取消的状态。\n打胜仗就骄傲，打败仗就消极。\n本位主义，一切只知道为四军打算，不知道武装地方群众是红军的重要任务之一。这是一种放大了的小团体主义。\n有少数同志囿于四军的局部环境，以为除此就没有别的革命势力了。因此，保存实力、避免斗争的思想非常浓厚。这是机会主义的残余。\n不顾主客观条件，犯着革命的急性病，不愿意艰苦地做细小严密的群众工作，只想大干，充满着幻想。这是盲动主义的残余91。\n\n单纯军事观点的来源：\n\n政治水平低。因此不认识军队中政治领导的作用，不认识红军和白军是根本不同的。\n雇佣军队的思想。因为历次作战俘虏兵甚多，此种分子加入红军，带来了浓厚的雇佣军队的思想，使单纯军事观点有了下层基础。\n因有以上两个原因，便发生第三个原因，就是过分相信军事力量，而不相信人民群众的力量。\n党对于军事工作没有积极的注意和讨论，也是形成一部分同志的单纯军事观点的原因。\n\n纠正的方法：\n\n从教育上提高党内的政治水平，肃清单纯军事观点的理论根源，认清红军和白军的根本区别。同时，还要肃清机会主义和盲动主义的残余，打破四军本位主义。\n加紧官兵的政治训练，特别是对俘虏成分的教育要加紧。同时，尽可能由地方政权机关选派有斗争经验的工农分子，加入红军，从组织上削弱以至去掉单纯军事观点的根源。\n发动地方党对红军党的批评和群众政权机关对红军的批评，以影响红军的党和红军的官兵。\n党对于军事工作要有积极的注意和讨论。一切工作，在党的讨论和决议之后，再经过群众去执行。\n编制红军法规，明白地规定红军的任务，军事工作系统和政治工作系统的关系，红军和人民群众的关系，士兵会的权能及其和军事政治机关的关系。\n\n关于极端民主化\n红军第四军在接受中央指示之后，极端民主化的现象，减少了许多。例如党的决议比较地能够执行了；要求在红军中实行所谓“由下而上的民主集权制”、“先交下级讨论，再由上级决议”等项错误主张，也没有人再提了。但是在实际上，这种减少，只是一时的和表面的现象，还不是极端民主化的思想的肃清。这就是说，极端民主化的根苗还深种在许多同志的思想中。例如对于决议案的执行，表示种种勉强的态度，就是证据。\n纠正的方法：\n\n从理论上铲除极端民主化的根苗。首先，要指出极端民主化的危险，在于损伤以至完全破坏党的组织，削弱以至完全毁灭党的战斗力，使党担负不起斗争的责任，由此造成革命的失败。其次，要指出极端民主化的来源，在于小资产阶级的自由散漫性。这种自由散漫性带到党内，就成了政治上的和组织上的极端民主化的思想。这种思想是和无产阶级的斗争任务根本不相容的。\n在组织上，厉行集中指导下的民主生活。其路线是：\n\n党的领导机关要有正确的指导路线，遇事要拿出办法，以建立领导的中枢。\n上级机关要明了下级机关的情况和群众生活的情况，成为正确指导的客观基础。\n党的各级机关解决问题，不要太随便。一成决议，就须坚决执行。\n上级机关的决议，凡属重要一点的，必须迅速地传达到下级机关和党员群众中去。其办法是开活动分子会，或开支部以至纵队的党员大会（须看环境的可能），派人出席作报告。\n党的下级机关和党员群众对于上级机关的指示，要经过详尽的讨论，以求彻底地了解指示的意义，并决定对它的执行方法。\n\n\n\n关于非组织观点\n四军党内存在着的非组织的观点，其表现如下：甲少数不服从多数。例如少数人的提议被否决，他们就不诚意地执行党的决议。\n纠正的方法：\n\n开会时要使到会的人尽量发表意见。有争论的问题，要把是非弄明白，不要调和敷衍。一次不能解决的，二次再议（以不妨碍工作为条件），以期得到明晰的结论。\n党的纪律之一是少数服从多数。少数人在自己的意见被否决之后，必须拥护多数人所通过的决议。除必要时得在下一次会议再提出讨论外，不得在行动上有任何反对的表示。\n\n乙非组织的批评：\n\n党内批评是坚强党的组织、增加党的战斗力的武器。但是红军党内的批评有些不是这样，变成了攻击个人。其结果，不但毁坏了个人，也毁坏了党的组织。这是小资产阶级个人主义的表现。纠正的方法，在于使党员明白批评的目的是增加党的战斗力以达到阶级斗争的胜利，不应当利用批评去做攻击个人的工具。\n许多党员不在党内批评而在党外去批评。这是因为一般党员还不懂得党的组织（会议等）的重要，以为批评在组织内或在组织外没有什么分别。纠正的方法，就是要教育党员懂得党的组织的重要性，对党委或同志有所批评应当在党的会议上提出。\n\n关于绝对平均主义\n红军中的绝对平均主义，有一个时期发展得很厉害。例如：发给伤兵用费，反对分伤轻伤重，要求平均发给。官长骑马，不认为是工作需要，而认为是不平等制度。分物品要求极端平均，不愿意有特别情形的部分多分去一点。背米不问大人小孩体强体弱，要平均背。住房子要分得一样平，司令部住了一间大点的房子也要骂起来。派勤务要派得一样平，稍微多做一点就不肯。甚至在一副担架两个伤兵的情况，宁愿大家抬不成，不愿把一个人抬了去。这些都证明红军官兵中的绝对平均主义还很严重。\n绝对平均主义的来源，和政治上的极端民主化一样，是手工业和小农经济的产物，不过一则见之于政治生活方面，一则见之于物质生活方面罢了。\n纠正的方法：**应指出绝对平均主义不但在资本主义没有消灭的时期，只是农民小资产者的一种幻想；就是在社会主义时期，物质的分配也要按照“各尽所能按劳取酬”的原则和工作的需要，决无所谓绝对的平均。**红军人员的物质分配，应该做到大体上的平均，例如官兵薪饷平等，因为这是现时斗争环境所需要的。但是必须反对不问一切理由的绝对平均主义，因为这不是斗争的需要，适得其反，是于斗争有妨碍的。\n关于主观主义\n主观主义，在某些党员中浓厚地存在，这对分析政治形势和指导工作，都非常不利。因为**对于政治形势的主观主义的分析和对于工作的主观主义的指导，其必然的结果，不是机会主义，就是盲动主义。**至于党内的主观主义的批评，不要证据的乱说，或互相猜忌，往往酿成党内的无原则纠纷，破坏党的组织。\n关于党内批评问题，还有一点要说及的，就是有些同志的批评不注意大的方面，只注意小的方面。他们不明白批评的主要任务，是指出政治上的错误和组织上的错误。至于个人缺点，如果不是与政治的和组织的错误有联系，则不必多所指摘，使同志们无所措手足。而且这种批评一发展，党内精神完全集注到小的缺点方面，人人变成了谨小慎微的君子，就会忘记党的政治任务，这是很大的危险。\n纠正的方法：主要是教育党员使党员的思想和党内的生活都政治化，科学化。要达到这个目的，就要：\n\n教育党员用马克思列宁主义的方法去作政治形势的分析和阶级势力的估量，以代替主观主义的分析和估量。\n使党员注意社会经济的调查和研究，由此来决定斗争的策略和工作的方法，使同志们知道离开了实际情况的调查，就要堕入空想和盲动的深坑。\n党内批评要防止主观武断和把批评庸俗化，说话要有证据，批评要注意政治。\n\n关于个人主义\n红军党内的个人主义的倾向有如下各种表现：\n\n\n报复主义\n在党内受了士兵同志的批评，到党外找机会报复他，打骂就是报复的一种手段。在党内也寻报复；你在这次会议上说了我，我就在下次会议上找岔子报复你。这种报复主义，完全从个人观点出发，不知有阶级的利益和整个党的利益。它的目标不在敌对阶级，而在自己队伍里的别的个人。这是一种削弱组织、削弱战斗力的销蚀剂。\n\n\n小团体主义\n只注意自己小团体的利益，不注意整体的利益，表面上不是为个人，实际上包含了极狭隘的个人主义，同样地具有很大的销蚀作用和离心作用。红军中历来小团体风气很盛，经过批评现在是好些了，但其残余依然存在，还须努力克服。\n\n\n雇佣思想\n不认识党和红军都是执行革命任务的工具，而自己是其中的一员。不认识自己是革命的主体，以为自己仅仅对长官个人负责任，不是对革命负责任。这种消极的雇佣革命的思想，也是一种个人主义的表现。这种雇佣革命的思想，是无条件努力的积极活动分子所以不很多的原因。雇佣思想不肃清，积极活动分子便无由增加，革命的重担便始终放在少数人的肩上，于斗争极为不利。\n\n\n享乐主义\n个人主义见于享乐方面的，在红军中也有不少的人。他们总是希望队伍开到大城市去。他们要到大城市不是为了去工作，而是为了去享乐。他们最不乐意的是在生活艰难的红色区域里工作。\n\n\n消极怠工\n稍不遂意，就消极起来，不做工作。其原因主要是缺乏教育，但也有是领导者处理问题、分配工作或执行纪律不适当。\n\n\n离队思想\n在红军工作的人要求脱离队伍调地方工作的与日俱增。其原因，也不完全是个人的，尚有一，红军物质生活过差；二，长期斗争，感觉疲劳；三，领导者处理问题、分配工作或执行纪律不适当等项原因。\n\n\n纠正的方法：主要是加强教育，从思想上纠正个人主义。再则处理问题、分配工作、执行纪律要得当。并要设法改善红军的物质生活，利用一切可能时机休息整理，以改善物质条件。个人主义的社会来源是小资产阶级和资产阶级的思想在党内的反映，当进行教育的时候必须说明这一点。\n关于流寇思想\n由于红军中游民成分占了很大的数量和全国特别是南方各省有广大游民群众的存在，就在红军中产生了流寇主义的政治思想。这种思想表现在：\n\n不愿意做艰苦工作建立根据地，建立人民群众的政权，并由此去扩大政治影响，而只想用流动游击的方法，去扩大政治影响。\n扩大红军，不走由扩大地方赤卫队92、地方红军到扩大主力红军的路线，而要走“招兵买马”“招降纳叛”的路线。\n不耐烦和群众在一块作艰苦的斗争，只希望跑到大城市去大吃大喝。\n\n凡此一切流寇思想的表现，极大地妨碍着红军去执行正确的任务，故肃清流寇思想，实为红军党内思想斗争的一个重要目标。应当认识，历史上黄巢93、李闯94式的流寇主义，已为今日的环境所不许可。\n纠正的方法：\n\n加紧教育，批评不正确思想，肃清流寇主义。\n对现有红军基本队伍和新来的俘虏兵，加紧反流氓意识的教育。\n争取有斗争经验的工农积极分子加入红军队伍，改变红军的成分。\n从斗争的工农群众中创造出新的红军部队。\n\n关于盲动主义残余\n红军党内对盲动主义已经做了斗争，但尚不充分。因此，红军中还有盲动主义思想的残余存在着。其表现如：\n\n不顾主观和客观条件的盲干。\n城市政策执行得不充分，不坚决。\n军纪松懈，特别是打败仗时。\n还有某些部队有烧屋行为。\n枪毙逃兵的制度和肉刑制度，也是带着盲动主义性质的。盲动主义的社会来源是流氓无产者的思想和小资产阶级的思想的综合。\n\n纠正的方法：\n\n从思想上肃清盲动主义。\n从制度上和政策上纠正盲动的行为。\n\n\n星星之火，可以燎原95\n\n1930 年 1 月 5 日\n\n在对于时局的估量和伴随而来的我们的行动问题上，我们党内有一部分同志还缺少正确的认识。他们虽然相信革命高潮不可避免地要到来，却不相信革命高潮有迅速到来的可能。因此他们不赞成争取江西的计划，而只赞成在福建、广东、江西之间的三个边界区域的流动游击，同时也没有在游击区域建立红色政权的深刻的观念，因此也就没有用这种红色政权的巩固和扩大去促进全国革命高潮的深刻的观念。他们似乎认为在距离革命高潮尚远的时期做这种建立政权的艰苦工作为徒劳，而希望用比较轻便的流动游击方式去扩大政治影响，等到全国各地争取群众的工作做好了，或做到某个地步了，然后再来一个全国武装起义，那时把红军的力量加上去，就成为全国范围的大革命。\n他们这种全国范围的、包括一切地方的、先争取群众后建立政权的理论，是于中国革命的实情不适合的。他们的这种理论的来源，主要是没有把中国是一个许多帝国主义国家互相争夺的半殖民地这件事认清楚。如果认清了中国是一个许多帝国主义国家互相争夺的半殖民地，则\n\n就会明白全世界何以只有中国有这种统治阶级内部互相长期混战的怪事，而且何以混战一天激烈一天，一天扩大一天，何以始终不能有一个统一的政权。\n就会明白农民问题的严重性，因之，也就会明白农村起义何以有现在这样的全国规模的发展。\n就会明白工农民主政权这个口号的正确。\n就会明白相应于全世界只有中国有统治阶级内部长期混战的一件怪事而产生出来的另一件怪事，即红军和游击队的存在和发展，以及伴随着红军和游击队而来的，成长于四围白色政权中的小块红色区域的存在和发展（中国以外无此怪事）。\n也就会明白红军、游击队和红色区域的建立和发展，是半殖民地中国在无产阶级领导之下的农民斗争的最高形式，和半殖民地农民斗争发展的必然结果；并且无疑义地是促进全国革命高潮的最重要因素。\n也就会明白单纯的流动游击政策，不能完成促进全国革命高潮的任务，而朱德毛泽东式、方志敏96式之有根据地的，有计划地建设政权的，深入土地革命的，扩大人民武装的路线是经由乡赤卫队、区赤卫大队、县赤卫总队97、地方红军直至正规红军这样一套办法的，政权发展是波浪式地向前扩大的，等等的政策，无疑义地是正确的。必须这样，才能树立全国革命群众的信仰，如苏联之于全世界然。必须这样，才能给反动统治阶级以甚大的困难，动摇其基础而促进其内部的分解。也必须这样，才能真正地创造红军，成为将来大革命的主要工具。总而言之，必须这样，才能促进革命的高潮。\n\n犯着革命急性病的同志们不切当地看大了革命的主观力量98，而看小了反革命力量。这种估量，多半是从主观主义出发。其结果，无疑地是要走上盲动主义的道路。另一方面，如果把革命的主观力量看小了，把反革命力量看大了，这也是一种不切当的估量，又必然要产生另一方面的坏结果。因此，在判断中国政治形势的时候，需要认识下面的这些要点：\n\n\n现在中国革命的主观力量虽然弱，但是立足于中国落后的脆弱的社会经济组织之上的反动统治阶级的一切组织（政权、武装、党派等）也是弱的。\n这样就可以解释现在西欧各国的革命的主观力量虽然比现在中国的革命的主观力量也许要强些，但因为它们的反动统治阶级的力量比中国的反动统治阶级的力量更要强大许多倍，所以仍然不能即时爆发革命。现时中国革命的主观力量虽然弱，但是因为反革命力量也是相对地弱的，所以中国革命的走向高潮，一定会比西欧快。\n\n\n一九二七年革命失败以后，革命的主观力量确实大为削弱了。剩下的一点小小的力量，若仅依据某些现象来看，自然要使同志们（作这样看法的同志们）发生悲观的念头。但若从实质上看，便大大不然。这里用得着中国的一句老话：“星星之火，可以燎原。”这就是说，现在虽只有一点小小的力量，但是它的发展会是很快的。它在中国的环境里不仅是具备了发展的可能性，简直是具备了发展的必然性，这在五卅运动99及其以后的大革命运动已经得了充分的证明。我们看事情必须要看它的实质，而把它的现象只看作入门的向导，一进了门就要抓住它的实质，这才是可靠的科学的分析方法。\n\n\n对反革命力量的估量也是这样，决不可只看它的现象，要去看它的实质。当湘赣边界割据的初期，有些同志真正相信了当时湖南省委的不正确的估量，把阶级敌人看得一钱不值；到现在还传为笑谈的所谓“十分动摇”、“恐慌万状”两句话，就是那时（一九二八年五月至六月）湖南省委估量湖南的统治者鲁涤平100的形容词。\n在这种估量之下，就必然要产生政治上的盲动主义。但是到了同年十一月至去年二月（蒋桂战争101尚未爆发之前）约四个月期间内，敌人的第三次“会剿”102临到了井冈山的时候，一部分同志又有“红旗到底打得多久”的疑问提出来了。其实，那时英、美、日在中国的斗争已到十分露骨的地步，蒋桂冯混战的形势业已形成，实质上是反革命潮流开始下落，革命潮流开始复兴的时候。但是在那个时候，不但红军和地方党内有一种悲观的思想，就是中央那时也不免为那种表面上的情况所迷惑，而发生了悲观的论调。中央二月来信103就是代表那时候党内悲观分析的证据。\n\n\n现时的客观情况，还是容易给只观察当前表面现象不观察实质的同志们以迷惑。特别是我们在红军中工作的人，一遇到败仗，或四面被围，或强敌跟追的时候，往往不自觉地把这种一时的特殊的小的环境，一般化扩大化起来，仿佛全国全世界的形势概属未可乐观，革命胜利的前途未免渺茫得很。\n所以有这种抓住表面抛弃实质的观察，是因为他们对于一般情况的实质并没有科学地加以分析。如问中国革命高潮是否快要到来，只有详细地去察看引起革命高潮的各种矛盾是否真正向前发展了，才能作决定。既然国际上帝国主义相互之间、帝国主义和殖民地之间、帝国主义和它们本国的无产阶级之间的矛盾是发展了，帝国主义争夺中国的需要就更迫切了。帝国主义争夺中国一迫切，帝国主义和整个中国的矛盾，帝国主义者相互间的矛盾，就同时在中国境内发展起来，因此就造成中国各派反动统治者之间的一天天扩大、一天天激烈的混战，中国各派反动统治者之间的矛盾，就日益发展起来。伴随各派反动统治者之间的矛盾——军阀混战而来的，是赋税的加重，这样就会促令广大的负担赋税者和反动统治者之间的矛盾日益发展。伴随着帝国主义和中国民族工业的矛盾而来的，是中国民族工业得不到帝国主义的让步的事实，这就发展了中国资产阶级和中国工人阶级之间的矛盾，中国资本家从拚命压榨工人找出路，中国工人则给以抵抗。伴随着帝国主义的商品侵略、中国商业资本的剥蚀和政府的赋税加重等项情况，便使地主阶级和农民的矛盾更加深刻化，即地租和高利贷的剥削更加重了，农民则更加仇恨地主。因为外货的压迫、广大工农群众购买力的枯竭和政府赋税的加重，使得国货商人和独立生产者日益走上破产的道路。因为反动政府在粮饷不足的条件之下无限制地增加军队，并因此而使战争一天多于一天，使得士兵群众经常处在困苦的环境之中。因为国家的赋税加重，地主的租息加重和战祸的日广一日，造成了普遍于全国的灾荒和匪祸，使得广大的农民和城市贫民走上求生不得的道路。因为无钱开学，许多在学学生有失学之忧；因为生产落后，许多毕业学生无就业之望。如果我们认识了以上这些矛盾，就知道中国是处在怎样一种皇皇不可终日的局面之下，处在怎样一种混乱状态之下。就知道反帝反军阀反地主的革命高潮，是怎样不可避免，而且是很快会要到来。中国是全国都布满了干柴，很快就会燃成烈火。“星火燎原”的话，正是时局发展的适当的描写。只要看一看许多地方工人罢工、农民暴动、士兵哗变、学生罢课的发展，就知道这个“星星之火”，距“燎原”的时期，毫无疑义地是不远了。\n\n\n上面的话的大意，在去年四月五日前委给中央的信中，就已经有了。那封信上说：\n\n“中央此信（去年二月七日）对客观形势和主观力量的估量，都太悲观了。国民党三次‘进剿’井冈山104，表示了反革命的最高潮。然至此为止，往后便是反革命潮流逐渐低落，革命潮流逐渐升涨。党的战斗力组织力虽然弱到如中央所云，但在反革命潮流逐渐低落的形势之下，恢复一定很快，党内干部分子的消极态度也会迅速消灭。群众是一定归向我们的。屠杀主义105固然是为渊驱鱼，改良主义也再不能号召群众了。群众对国民党的幻想一定很快地消灭。在将来的形势之下，什么党派都是不能和共产党争群众的。党的六次大会106所指示的政治路线和组织路线是对的：革命的现时阶段是民权主义而不是社会主义，党（按：应加‘在大城市中’五个字）的目前任务是争取群众而不是马上举行暴动。但是革命的发展将是很快的，武装暴动的宣传和准备应该采取积极的态度。在大混乱的现局之下，只有积极的口号积极的态度才能领导群众。党的战斗力的恢复也一定要在这种积极态度之下才有可能。……无产阶级领导是革命胜利的唯一关键。党的无产阶级基础的建立，中心区域产业支部的创造，是目前党在组织方面的重要任务；但是在同时，农村斗争的发展，小区域红色政权的建立，红军的创造和扩大，尤其是帮助城市斗争、促进革命潮流高涨的主要条件。所以，抛弃城市斗争，是错误的；但是畏惧农民势力的发展，以为将超过工人的势力而不利于革命，如果党员中有这种意见，我们以为也是错误的。因为半殖民地中国的革命，只有农民斗争得不到工人的领导而失败，没有农民斗争的发展超过工人的势力而不利于革命本身的。”\n\n这封信对红军的行动策略问题有如下的答复：\n\n“中央要我们将队伍分得很小，散向农村中，朱、毛离开队伍，隐匿大的目标，目的在于保存红军和发动群众。这是一种不切实际的想法。以连或营为单位，单独行动，分散在农村中，用游击的战术发动群众，避免目标，我们从一九二七年冬天就计划过，而且多次实行过，但是都失败了。因为：（一）主力红军多不是本地人，和地方赤卫队来历不同。（二）分小则领导不健全，恶劣环境应付不来，容易失败。（三）容易被敌人各个击破。（四）愈是恶劣环境，队伍愈须集中，领导者愈须坚决奋斗，方能团结内部，应付敌人。只有在好的环境里才好分兵游击，领导者也不如在恶劣环境时的刻不能离。”\n\n这一段话的缺点是：所举不能分兵的理由，都是消极的，这是很不够的。兵力集中的积极的理由是：集中了才能消灭大一点的敌人，才能占领城镇。消灭了大一点的敌人，占领了城镇，才能发动大范围的群众，建立几个县联在一块的政权。这样才能耸动远近的视听（所谓扩大政治影响），才能于促进革命高潮发生实际的效力。例如我们前年干的湘赣边界政权，去年干的闽西政权107，都是这种兵力集中政策的结果。这是一般的原则。至于说到也有分兵的时候没有呢？也是有的。前委给中央的信上说了红军的游击战术，那里面包括了近距离的分兵：\n\n“我们三年来从斗争中所得的战术，真是和古今中外的战术都不同。用我们的战术，群众斗争的发动是一天比一天扩大的，任何强大的敌人是奈何我们不得的。我们的战术就是游击的战术。大要说来是：‘分兵以发动群众，集中以应付敌人。’‘敌进我退，敌驻我扰，敌疲我打，敌退我追。’‘固定区域的割据108，用波浪式的推进政策。强敌跟追，用盘旋式的打圈子政策。’‘很短的时间，很好的方法，发动很大的群众。’这种战术正如打网，要随时打开，又要随时收拢。打开以争取群众，收拢以应付敌人。三年以来，都是用的这种战术。”\n\n这里所谓“打开”，就是指近距离的分兵。例如湘赣边界第一次打下永新时，二十九团和三十一团在永新境内的分兵。又如第三次打下永新时，二十八团往安福边境，二十九团往莲花，三十一团往吉安边界的分兵。又如去年四月至五月在赣南各县的分兵，七月在闽西各县的分兵。至于远距离的分兵，则要在好一点的环境和在比较健全的领导机关两个条件之下才有可能。因为分兵的目的，是为了更能争取群众，更能深入土地革命和建立政权，更能扩大红军和地方武装。若不能达到这些目的，或者反因分兵而遭受失败，削弱了红军的力量，例如前年八月湘赣边界分兵打郴州那样，则不如不分为好。如果具备了上述两个条件，那就无疑地应该分兵，因为在这两个条件下，分散比集中更有利。\n中央二月来信的精神是不好的，这封信给了四军党内一部分同志以不良影响。中央那时还有一个通告，谓蒋桂战争不一定会爆发。但从此以后，中央的估量和指示，大体上说来就都是对的了。对于那个估量不适当的通告，中央已发了一个通告去更正。对于红军的这一封信，虽然没有更正，但是后来的指示，就没有那些悲观的论调了，对于红军行动的主张也和我们的主张一致了。但是中央那个信给一部分同志的不良影响是仍然存在的。因此，我觉得就在现时仍有对此问题加以解释的必要。\n关于一年争取江西的计划，也是去年四月前委向中央提出的，后来又在于都有一次决定。当时指出的理由，见之于给中央信上的，如下：\n\n“蒋桂部队在九江一带彼此逼近，大战爆发即在眼前。群众斗争的恢复，加上反动统治内部矛盾的扩大，使革命高潮可能快要到来。在这种局面之下来布置工作，我们觉得南方数省中广东湖南两省买办地主的军力太大，湖南则更因党的盲动主义的错误，党内党外群众几乎尽失。闽赣浙三省则另成一种形势。第一，三省敌人军力最弱。浙江只有蒋伯诚109的少数省防军。福建五部虽有十四团，但郭110旅已被击破；陈卢111两部均土匪军，战斗力甚低；陆战队两旅在沿海从前并未打过仗，战斗力必不大；只有张贞112比较能打，但据福建省委分析，张亦只有两个团战力较强。且福建现在完全是混乱状态，不统一。江西朱培德113、熊式辉114两部共有十六团，比闽浙军力为强，然比起湖南来就差得多。第二，三省的盲动主义错误比较少。除浙江情况我们不大明了外，江西福建两省党和群众的基础，都比湖南好些。以江西论，赣北之德安、修水、铜鼓尚有相当基础；赣西宁冈、永新、莲花、遂川，党和赤卫队的势力是依然存在的；赣南的希望更大，吉安、永丰、兴国等县的红军第二第四团有日益发展之势；方志敏的红军并未消灭。这样就造成了向南昌包围的形势。我们建议中央，在国民党军阀长期战争期间，我们要和蒋桂两派争取江西，同时兼及闽西、浙西。在三省扩大红军的数量，造成群众的割据，以一年为期完成此计划。”\n\n上面争取江西的话，不对的是规定一年为期。至于争取江西，除开江西的本身条件之外，还包含有全国革命高潮快要到来的条件。因为如果不相信革命高潮快要到来，便决不能得到一年争取江西的结论。那个建议的缺点就是不该规定为一年，因此，影响到革命高潮快要到来的所谓“快要”，也不免伴上了一些急躁性。至于江西的主观客观条件是很值得注意的。除主观条件如给中央信上所说外，客观条件现在可以明白指出的有三点：\n\n是江西的经济主要是封建的经济，商业资产阶级势力较小，而地主的武装在南方各省中又比哪一省都弱。\n是江西没有本省的军队，向来都是外省军队来此驻防。外来军队“剿共”“剿匪”，情形不熟，又远非本省军队那样关系切身，往往不很热心。\n是距离帝国主义的影响比较远一点，不比广东接近香港，差不多什么都受英国的支配。\n\n我们懂得了这三点，就可以解释为什么江西的农村起义比哪一省都要普遍，红军游击队比哪一省都要多了。\n所谓革命高潮快要到来的“快要”二字作何解释，这点是许多同志的共同的问题。马克思主义者不是算命先生，未来的发展和变化，只应该也只能说出个大的方向，不应该也不可能机械地规定时日。但我所说的中国革命高潮快要到来，决不是如有些人所谓“有到来之可能”那样完全没有行动意义的、可望而不可即的一种空的东西。它是站在海岸遥望海中已经看得见桅杆尖头了的一只航船，它是立于高山之巅远看东方已见光芒四射喷薄欲出的一轮朝日，它是躁动于母腹中的快要成熟了的一个婴儿。\n\n反对本本主义115\n\n1930 年 5 月\n\n\n必须注意经济工作\n怎样分析农村阶级\n我们的经济政策\n关心群众生活，注意工作方法\n论反对日本帝国主义的策略\n中国革命战争的战略问题\n关于蒋介石声明的声明\n中国共产党在抗日时期的任务\n为争取千百万群众 进入抗日民族统一战线而斗争\n实践论\n矛盾论\n第二卷\n抗日战争时期（上）\n反对日本进攻的方针、办法和前途\n为动员一切力量争取抗战胜利而斗争\n反对自由主义\n国共合作成立后的迫切任务\n和英国记者贝特兰的谈话\n上海太原失陷以后抗日战争的形势和任务\n陕甘宁边区政府、第八路军后方留守处布告\n抗日游击战争的战略问题\n论持久战\n中国共产党在民族战争中的地位\n统一战线中的独立自主问题\n战争和战略问题\n五四运动\n青年运动的方向\n反对投降活动\n必须制裁反动派\n关于国际新形势对新华日报记者的谈话\n和中央社、扫荡报、新民报三记者的谈话\n苏联利益和人类利益的一致\n《共产党人》发刊词\n目前形势和党的任务\n大量吸收知识分子\n中国革命和中国共产党\n斯大林是中国人民的朋友\n纪念白求恩\n新民主主义论\n克服投降危险，力争时局好转\n团结一切抗日力量，反对反共顽固派\n向国民党的十点要求\n《中国工人》发刊词\n必须强调团结和进步\n新民主主义的宪政\n抗日根据地的政权问题\n目前抗日统一战线中的策略问题\n放手发展抗日力量，抵抗反共顽固派的进攻\n团结到底\n论政策\n为皖南事变发表的命令和谈话\n打退第二次反共高潮后的时局\n关于打退第二次反共高潮的总结\n第三卷\n抗日战争时期（下）\n《农村调查》的序言和跋\n改造我们的学习\n揭破远东慕尼黑的阴谋\n关于反法西斯的国际统一战线\n在陕甘宁边区参议会的演说\n整顿党的作风\n反对党八股\n在延安文艺座谈会上的讲话\n一个极其重要的政策\n第二次世界大战的转折点\n祝十月革命二十五周年\n抗日时期的经济问题和财政问题\n关于领导方法的若干问题\n质问国民党\n开展根据地的减租、生产和拥政爱民运动\n评国民党十一中全会和三届二次国民参政会\n组织起来\n学习和时局\n为人民服务\n评蒋介石在双十节的演说\n文化工作中的统一战线\n必须学会做经济工作\n游击区也能够进行生产\n两个中国之命运\n论联合政府\n愚公移山\n论军队生产自给，兼论整风和生产两大运动的重要性\n赫尔利和蒋介石的双簧已经破产\n评赫尔利政策的危险\n给福斯特同志的电报\n对日寇的最后一战\n第四卷\n第三次国内革命战争时期\n抗日战争胜利后的时局和我们的方针\n蒋介石在挑动内战\n第十八集团军总司令给蒋介石的两个电报\n评蒋介石发言人谈话\n中共中央关于同国民党进行和平谈判的通知\n关于重庆谈判\n国民党进攻的真相\n减租和生产是保卫解放区的两件大事\n一九四六年解放区工作的方针\n建立巩固的东北根据地\n关于目前国际形势的几点估计\n以自卫战争粉碎蒋介石的进攻\n和美国记者安娜·路易斯·斯特朗的谈话\n集中优势兵力，各个歼灭敌人\n美国“调解”真相和中国内战前途\n三个月总结\n迎接中国革命的新高潮\n中共中央关于暂时放弃延安和保卫陕甘宁\n边区的两个文件\n关于西北战场的作战方针\n蒋介石政府已处在全民的包围中\n解放战争第二年的战略方针\n中国人民解放军宣言\n中国人民解放军总部关于重行颁布三大纪\n律八项注意的训令\n目前形势和我们的任务\n关于建立报告制度\n关于目前党的政策中的几个重要问题\n军队内部的民主运动\n在不同地区实施土地法的不同策略\n纠正土地改革宣传中的“左”倾错误\n新解放区土地改革要点\n关于工商业政策\n关于民族资产阶级和开明绅士问题\n评西北大捷兼论解放军的新式整军运动\n关于情况的通报\n在晋绥干部会议上的讲话\n对晋绥日报编辑人员的谈话\n再克洛阳后给洛阳前线指挥部的电报\n新解放区农村工作的策略问题\n一九四八年的土地改革工作和整党工作\n关于辽沈战役的作战方针\n关于健全党委制\n中共中央关于九月会议的通知\n关于淮海战役的的作战方针\n全世界革命力量团结起来，反对帝国主义的侵略\n中国军事形势的重大变化\n关于平津战役的作战方针\n敦促杜聿明等投降书\n将革命进行到底\n评战犯求和\n中共中央毛泽东主席关于时局的声明\n中共发言人评南京行政院的决议\n中共发言人关于命令国民党反动政府重新\n逮捕前日本侵华军总司令冈村宁次和逮捕\n国民党内战罪犯的谈话\n中共发言人关于和平条件必须包括惩办日\n本战犯和国民党战犯的声明\n把军队变为工作队\n四分五裂的反动派为什么还要空喊“全面和平”？\n国民党反动派由“呼吁和平”变为呼吁战争\n评国民党对战争责任问题的几种答案\n在中国共产党第七届中央委员会第二次全\n体会议上的报告\n党委会的工作方法\n南京政府向何处去？\n向全国进军的命令\n中国人民解放军布告\n中国人民解放军总部发言人为英国军舰暴行发表的声明\n在新政治协商会议筹备会上的讲话\n论人民民主专政\n丢掉幻想，准备斗争\n别了，司徒雷登\n为什么要讨论白皮书？\n“友谊”，还是侵略？\n唯心历史观的破产\n第五卷\n社会主义革命和社会主义建设时期（一）\n中国人民站起来了\n中国人民大团结万岁\n人民英雄们永垂不朽\n永远保持艰苦奋斗的作风\n征询对待富农策略问题的意见\n为争取国家财政经济状况的基本好转而斗争\n不要四面出击\n做一个完全的革命派\n你们是全民族的模范人物\n给中国人民志愿军的命令\n中国人民志愿军要爱护朝鲜的一山一水一草一木\n中共中央政治局扩大会议决议要点\n镇压反革命必须实行党的群众路线\n镇压反革命必须打得稳，打得准，打得狠\n应当重视电影《武训传》的讨论\n三大运动的伟大胜利\n关于“三反”“五反”的斗争\n把农业互助合作当作一件大事去做\n元旦祝词\n中共中央关于西藏工作方针的指示\n工人阶级与资产阶级的矛盾是国内的主要矛盾\n团结起来，划清敌我界限\n祝贺中国人民志愿军的重大胜利\n反对官僚主义、命令主义和违法乱纪\n批判大汉族主义 解决“五多”问题\n对刘少奇、杨尚昆破坏纪律擅自以中央名义发出文件的批评\n批判离开总路线的右倾观点\n青年团的工作要照顾青年的特点\n关于国家资本主义\n党在过渡时期的总路线\n反对党内的资产阶级思想\n改造资本主义工商业的必经之路\n抗美援朝的伟大胜利和今后的任务\n批判梁漱溟的反动思想\n关于农业互助合作的两次谈话\n关于中华人民共和国宪法草案\n为建设一个伟大的社会主义国家而奋斗\n关于《红楼梦》研究问题的信\n原子弹吓不倒中国人民\n在中国共产党全国代表会议上的讲话\n驳“舆论一律”\n《关于胡风反革命集团的材料》的序言和按语\n关于农业合作化问题\n农业合作化必须依靠党团员和贫农下中农\n农业合作化的一场辩论和当前的阶级斗争\n《中国农村的社会主义高潮》的序言\n《中国农村的社会主义高潮》的按语\n征询对农业十七条的意见\n加快手工业的社会主义改造\n论十大关系\n美帝国主义是纸老虎\n增强党的团结，继承党的传统\n我们党的—些历史经验\n纪念孙中山先生\n在中国共产党第八届中央委员会第二次全体会议上的讲话\n在省市自治区党委书记会议上的讲话\n关于正确处理人民内部矛盾的问题\n在中国共产党全国宣传工作会议上的讲话\n坚持艰苦奋斗，密切联系群众\n事情正在起变化\n中国共产党是全中国人民的领导核心\n组织力量反击右派分子的猖狂进攻\n文汇报的资产阶级方向应当批判\n打退资产阶级右派的进攻\n一九五七年夏季的形势\n做革命的促进派\n坚定地相信群众的大多数\n党内团结的辩证方法\n一切反动派都是纸老虎\n第六卷（静火版）\n社会主义革命和社会主义建设时期（二）\n关于中国人民志愿军撤出朝鲜问题\n工作方法六十条（草案）\n在成都会议上的讲话\n干部要以普通劳动者的姿态出现\n要搞一点原子弹氢弹\n西藏要准备对付那里的可能的全局叛乱\n介绍一封信\n同苏联驻华大使尤金的谈话\n关于国际形势问题\n中华人民共和国国防部告台湾同胞书\n中华人民共和国国防部命令\n中华人民共和国国防部再告台湾同胞书\n关于社会主义商品生产问题\n记者头脑要冷静\n在武昌会议上的讲话\n关于帝国主义和一切反动派是不是真老虎的问题\n在八届六中全会上的讲话\n马列主义基本原理至今未变，个别结论可以改变\n在第二次郑州会议上的讲话\n党内通信——建议召开县五级干部大会\n关于西藏平叛\n党内通信——致六级干部的公开信\n关于西藏问题和台湾问题\n经济建设是科学，要老老实实学习\n要政治家办报\n如实公开报道灾情\n庐山会议讨论的十八个问题\n在庐山会议上的多次讲话、批语\n对彭德怀九月九日信的批示\n争取比较长的和平时间是可能的\n同澳共总书记夏基的谈话\n读苏联《政治经济学教科书》的谈话\n坚决制止重刮“共产风”等违法乱纪行为\n同蒙哥马利的谈话\n十年总结\n同斯诺的谈话——中国人的精神面貌改变\n彻底纠正“五风”\n永远不许一平二调\n坚决退赔，刹住“共产风”\n大兴调查研究之风\n要做系统的由历史到现状的调查研究\n总结经验，教育干部\n中国在联合国只能有一个代表\n在七千人大会上的讲话——关于党的民主\n集中制\n在北戴河中央工作会议中心小组会上的讲话\n在八届十中全会上的讲话\n干部参加劳动的伟大意义\n人的正确思想是从哪里来的？\n论反对官僚主义\n支持美国黑人反对种族歧视斗争的声明\n受压迫的人民总是要起来的\n革命和建设都要靠自己\n关于文艺工作的批示\n加强相互学习，克服固步自封、骄傲自满\n不搞科学技术，生产力无法提高\n我国还可能要走一段资本主义复辟的道路\n中法之间有共同点\n关于教育革命的谈话\n以农业为基础，以工业为主导\n支持被压迫人民反对帝国主义的战争\n和王海蓉同志的谈话\n哪里有压迫哪里就有反抗\n接见日本社会党人士的谈话\n关于九评苏共中央的公开信的节录\n中华人民共和国政府声明\n打破核垄断，消灭核武器\n中国的大跃进\n同斯诺的谈话——关于越南战争\n官僚主义者阶级是革命对象\n我们希望阿拉伯国家团结起来\n把医疗卫生工作的重点放到农村去\n人民给政府饭吃，吃了饭就要为人民服务\n胜利的信念是从斗争中得来的\n突出政治，反对折衷主义\n上面要靠党的领导，下面要靠广大群众\n第七卷（静火版）\n文化大革命时期\n关于农业机械化——备战备荒为人民\n在中央政治局常委扩大会议上的讲话\n对中宣部和北京市委的批评\n学校一律要实行半工半读\n部队文艺工作座谈会纪要\n为什么要搞文化大革命\n各行各业均应一业为主兼学别样——五·七指示\n中国共产党中央委员会通知——五·一六通知\n同胡志明的谈话——不搞清官贪官，搞文化大革命\n给江青的信\n凡是镇压学生运动的人，都没有好下场\n工作组要撤，文化革命要依靠革命师生\n给清华大学附属中学红卫兵的信\n不许镇压学生运动\n炮打司令部——我的一张大字报\n中国共产党中央委员会关于无产阶级文化大革命的决定\n在中共八届十一中全会闭幕会上的讲话\n对四位外国专家的大字报的批语\n驻外机关也要革命化\n在中央工作会议上的讲话\n斗争要文明些，坚持文斗，不用武斗\n对刘少奇到学校做公开检查的批示\n对《文汇报》、《解放日报》夺权事件的\n谈话\n论夺权\n人民解放军应该支持左派广大群众\n接见卡博和巴卢库时的谈话\n对上海文化大革命的指示\n批评“二月逆流”\n论革命的“三结合”\n关于两条路线斗争的基本问题\n是义和团侵略了帝国主义了吗？\n中央军委关于支左工作十条命令\n接见阿尔巴尼亚军事代表团时的谈话\n论无产阶级专政下继续革命\n在听了氢弹会议汇报后的讲话\n视察华北、中南和华东地区时的重要指示\n接见刚果（布）总理努马扎莱的谈话\n关于“九大”和整党问题的谈话\n祝贺越南南方民族解放阵线成立七周年的电报\n关于国家机关的改革和革命委员会的基本经验\n支持美国黑人抗暴斗争的声明\n学校教育革命的方向——要和工农兵结合\n接见首都红代会“五大领袖”时的谈话\n医学教育革命的方向——赤脚医生就是好\n广大干部下放劳动是一种重新学习的极好机会\n在中共八届扩大的十二中全会上的讲话\n赞成越南又打又谈的方针\n关于知识青年到农村去的号召\n对中国共产党第九次全国代表大会的讲话\n关于战备疏散的指示\n祝贺越南南方民族解放阵线成立九周年的电报\n与黎笋的谈话\n全世界人民团结起来，打败美国侵略者及其一切走狗\n发展自己的工业和农业不要依靠外国\n帝国主义怕第三世界\n国际间的事要由大家商量解决\n改变国家体制，不设国家主席\n我的一点意见\n与斯诺的谈话——关于文化大革命\n对外宣传工作不可强加于人\n思想上政治上的路线正确与否是决定一切的\n恢复联合国席位后的谈话\n对反革命不要杀，保留活证据\n会见美国总统尼克松时的谈话\n中美联合公报（“上海公报”）中国方面的声明\n与日本首相田中角荣的谈话\n深挖洞，广积粮，不称霸\n祝贺越南人民取得的伟大胜利\n接见基辛格时的谈话\n启用邓小平\n在政治局会议上的讲话——八大军区司令员对调\n中国将修建青藏铁路\n关于划分三个世界的谈话\n同英国前首相希思的谈话\n关于理论问题的谈话要点\n对在押国民党战犯、党政军特人员一律释放\n要安定团结不要分裂，不要搞阴谋诡计\n关于《水浒》的评论\n中美关系会一点点好起来\n祝贺印度支那三国抗美救国战争取得胜利\n走资派还在走，“永不翻案”靠不住\n对天安门事件的指示\n后事交代\nFootnotes\n\n\n毛泽东此文是为反对当时党内存在着的两种倾向而写的。当时党内的第一种倾向，以陈独秀为代表，只注意同国民党合作，忘记了农民，这是右倾机会主义。第二种倾向，以张国焘为代表，只注意工人运动，同样忘记了农民，这是“左”倾机会主义。这两种机会主义都感觉自己力量不足，而不知道到何处去寻找力量，到何处去取得广大的同盟军。毛泽东指出中国无产阶级的最广大和最忠实的同盟军是农民，这样就解决了中国革命中的最主要的同盟军问题。毛泽东并且预见到当时的民族资产阶级是一个动摇的阶级，他们在革命高涨时将要分化，其右翼将要跑到帝国主义方面去。一九二七年所发生的事变，证明了这一点。) ↩\n\n\n国家主义派指中国青年党，当时以其外围组织“中国国家主义青年团”的名义公开进行活动。组织这个政团的是一些反动政客，他们投靠帝国主义和当权的反动派，把反对中国共产党和苏联当作职业。 ↩\n\n\n戴季陶（1891~1949），又名传贤，原籍浙江湖州，生于四川广汉。早年参加中国同盟会，从事过反对清政府和袁世凯的活动。后曾和蒋介石在上海共同经营交易所的投机事业。1925 年随着孙中山的逝世和革命高潮的到来，他歪曲孙中山学说的革命内容，散布反对国共合作、反对工农革命运动的谬论，为后来蒋介石的反共活动作了准备。1927 年南京国民政府成立后，历任国民政府委员、考试院院长等职。1949 年 2 月，蒋介石的统治即将崩溃，戴季陶感到绝望而自杀。 ↩\n\n\n北京《晨报》，初名《晨钟报》，1916 年 8 月创刊于北京，1918 年 12 月改名为《晨报》，1928 年 6 月停刊。 ↩\n\n\n1922 年和 1923 年间，孙中山在共产党人的帮助下，决定改组国民党，实行国共合作，容纳共产党人参加国民党，并于 1924 年 1 月在广州召开国民党第一次全国代表大会，实行联俄、联共、扶助农工的三大政策。李大钊、谭平山、毛泽东、林伯渠、瞿秋白等共产党人参加了这次大会。他们曾经被选为国民党中央执行委员会的委员或候补委员，担任过国民党的许多领导工作，对于帮助国民党走上革命的道路，起了重大的作用。 ↩\n\n\n第三国际即共产国际，1919 年 3 月在列宁领导下成立。1922 年中国共产党参加共产国际，成为它的一个支部。1943 年 5 月，共产国际执行委员会主席团通过决定，提议解散共产国际，同年六月共产国际正式宣布解散。 ↩\n\n\n国际联盟简称国联，1920 年 1 月正式成立。先后参加的有六十多个国家。国际联盟标榜以“促进国际合作，维持国际和平与安全”为目的，实际上日益成为帝国主义国家推行侵略政策的工具。第二次世界大战爆发后无形瓦解，1946 年 4 月正式宣布解散。 ↩\n\n\n这里是指中农。 ↩\n\n\n赵公元帅是中国民间传说的财神，叫赵公明。 ↩\n\n\n指 1925 年 5 月 30 日爆发的反帝爱国运动。1925 年 5 月间，上海、青岛的日本纱厂先后发生工人罢工的斗争，遭到日本帝国主义和北洋军阀的镇压。上海内外棉第七厂日本资本家在五月十五日枪杀了工人顾正红，并伤工人十余人。二十九日青岛工人被反动政府屠杀八人。五月三十日，上海二千余学生分头在公共租界各马路进行宣传讲演，一百余名遭巡捕（租界内的警察）逮捕，被拘押在南京路老闸巡捕房内，引起了学生和市民的极大愤慨，有近万人聚集在巡捕房门口，要求释放被捕学生。英帝国主义的巡捕向群众开枪，打死打伤许多人。这就是震惊中外的五卅惨案。六月，英日等帝国主义在上海和其他地方继续进行屠杀。这些屠杀事件激起了全国人民的公愤。广大的工人、学生和部分工商业者，在许多城市和县镇举行游行示威和罢工、罢课、罢市，形成了全国规模的反帝爱国运动高潮。 ↩\n\n\n这里是指自己有一部分土地，同时租种一部分土地，或出卖一部分劳动力，或兼营小商的贫农。 ↩\n\n\n店员有不同的阶层，他们一般不占有生产资料，生活来源的全部或者主要部分是依靠向店主出卖劳动力所取得的工资。毛泽东在这里所指的是店员中的一部分，还有一部分下层店员过着无产阶级的生活。 ↩\n\n\n指 1922 年香港和上海的海员罢工。香港海员罢工爆发于 1 月 12 日，坚持了八个星期。最后，香港英帝国主义当局被迫答应增加工资，恢复原工会，释放被捕工人，抚恤在罢工中死难烈士的家属。上海海员罢工于 8 月 5 日开始，坚持了三个星期，也得到胜利。 ↩\n\n\n指 1922 年和 1923 年中国共产党领导的各主要铁路线的工人罢工。在罢工过程中，工人群众的觉悟迅速提高，要求改善生活的经济斗争迅速发展为反对军阀的政治斗争。1923 年 2 月 4 日，京汉铁路工人为争取组织总工会的自由，举行总罢工。其他许多铁路的工人也纷纷响应。二月七日，英帝国主义支持的北洋军阀吴佩孚、萧耀南等，残酷地屠杀京汉铁路的工人，造成了二七惨案。 ↩\n\n\n开滦煤矿是直隶省（今河北省）开平、滦县一带煤矿的总称，当时为英帝国主义者所控制。开滦罢工指 1922 年 10 月、11 月间矿工三万余人举行的大罢工。英帝国主义者和北洋军阀对这次罢工进行残酷的镇压，工人死伤很多，但是仍然坚持斗争。最后，英帝国主义者不得不答应给工人增加一部分工资。焦作煤矿，在河南省北部，当时也为英帝国主义者所控制。焦作罢工指 1925 年 7 月爆发的罢工。这次罢工是为响应五卅运动而发动的，前后坚持七个多月。最后，英帝国主义者不得不承认工会有代表工人的权利，并且被迫接受增加工资、不无故开除工人和补偿工人因罢工所受的损失等项条件。 ↩\n\n\n沙面当时是英法帝国主义在广州的租界。1924 年 7 月，统治沙面的帝国主义者颁布新警律，规定沙面的中国人出入租界必须携带贴有本人相片的执照，在租界内行动必须受各种苛刻的限制，但是外国人却可以自由出入活动。沙面工人于 7 月 15 日宣告罢工，抗议这些无理措施。这次沙面罢工迫使英法帝国主义者取消了新警律。 ↩\n\n\n指 1925 年 6 月 1 日开始的上海大罢工和 6 月 19 日开始的香港大罢工。这两处罢工是当时全国反帝爱国运动的支柱。前者有二十多万工人参加，坚持了三四个月；后者有二十五万工人参加，坚持了一年零四个月，是截至当时为止的世界工人运动史中时间最长的一次罢工。 ↩\n\n\n三合会、哥老会、大刀会、在理会、青帮是旧中国的一些民间秘密团体，参加者主要的是破产农民、失业手工业工人和流氓无产者。这类团体大都用宗教迷信为团聚成员的工具，采取家长制的组织形式，有的还拥有武装。参加这类团体的人，在社会生活中有互相援助的义务，有时还共同反抗压迫他们的地主、官僚和外国侵略者。但是，农民和手工业工人不可能依靠这类团体得到出路。同时，由于这类团体带有严重的封建性和盲目的破坏性，它们又往往容易被反动统治阶级和帝国主义势力所操纵和利用。随着工人阶级力量的壮大和中国共产党的成立，农民和手工业工人在共产党的领导之下逐步地建立了完全新式的群众组织，这类落后的团体就失掉了它们的存在价值。 ↩\n\n\n毛泽东此文是为了答复当时党内党外对于农民革命斗争的责难而写的。为了这个目的，毛泽东到湖南做了三十二天的考察工作，并写了这一篇报告。当时党内以陈独秀为首的右倾机会主义者，不愿意接受毛泽东的意见，而坚持自己的错误见解。他们的错误，主要是被国民党的反动潮流所吓倒，不敢支持已经起来和正在起来的伟大的农民革命斗争。为了迁就国民党，他们宁愿抛弃农民这个最主要的同盟军，使工人阶级和共产党处于孤立无援的地位。1927 年春夏国民党之所以敢于叛变，发动“清党运动”和反人民的战争，主要就是乘了共产党的这个弱点。 ↩\n\n\n湖南是当时全国农民运动的中心。 ↩\n\n\n赵恒惕（1880~1971），湖南衡山人。1920 年以后，他是统治湖南的军阀。1926 年 3 月，在湖南人民掀起反赵高潮的形势下，被迫辞去湖南省长的职务。同年七月至九月，他的旧部被北伐军击溃。 ↩\n\n\n辛亥革命是以孙中山为首的资产阶级革命团体同盟会所领导的推翻清朝专制王朝的革命。1911 年（辛亥年）10 月 10 日，革命党人发动新军在湖北武昌举行起义，接着各省响应，外国帝国主义所支持的清朝反动统治迅速瓦解。1912 年 1 月在南京成立了中华民国临时政府，孙中山就任临时大总统。统治中国两千多年的君主专制制度从此结束，民主共和国的观念从此深入人心。但是资产阶级革命派力量很弱，并具有妥协性，没有能力发动广大人民的力量比较彻底地进行反帝反封建的革命。辛亥革命的成果迅即被北洋军阀袁世凯篡夺，中国仍然没有摆脱半殖民地、半封建的状态。 ↩\n\n\n“矫枉过正”是一句成语，原意是纠正错误而超过了应有的限度。但旧时有人常用这句话去拘束人们的活动，要人们只在修正旧成规的范围内活动，而不许完全破坏旧成规。在修正旧成规的范围内活动，叫做合乎“正”，如果完全破坏旧成规，就叫做“过正”。这也正是改良派和革命队伍内机会主义者的理论。毛泽东在这里驳斥了这类改良派的理论。这里说“矫枉必须过正，不过正不能矫枉”，就是说，要终结旧的封建秩序，必须用群众的革命方法，而不是用修正的——改良的方法。 ↩\n\n\n1926 年 9 月北伐军进军江西的时候，排斥共产党人的蒋介石嫡系部队打了败仗。许多报刊刊登消息说蒋介石受了伤。当时蒋介石的反革命面目还没有充分暴露出来，农民群众还认为他是革命的；地主富农则反对他，听到北伐军打败仗和蒋介石受伤的消息后很高兴。1927 年 4 月 12 日，蒋介石在上海发动反革命政变，他的反革命面目才完全暴露出来。从这时起，地主富农就对他改取拥护态度了。 ↩\n\n\n广东是第一次国内革命战争时期的最早的革命根据地。 ↩\n\n\n吴佩孚（1874~1939），山东蓬莱人，北洋直系军阀首领之一。1920 年 7 月，他打败皖系军阀段祺瑞，开始左右北洋军阀的中央政权，为英美帝国主义的代理人。1924 年 10 月，他在军阀混战中失败。一年后再起，到 1926 年北伐战争前，他据有直隶（今河北）南部和湖北、湖南、河南等省。北伐军从广东出发，首先打倒的敌人就是吴佩孚。 ↩\n\n\n三民主义是孙中山在中国资产阶级民主革命中提出的民族、民权、民生三个问题的原则和纲领。随着时代的不同，三民主义的内容有新旧的区别。旧三民主义是中国旧民主主义革命的纲领。1924 年 1 月，孙中山接受共产党人的建议，在中国国民党第一次全国代表大会上，对三民主义重新作了解释，旧三民主义从此发展为新三民主义。新三民主义包含联俄、联共、扶助农工的三大政策和反对帝国主义、反对封建主义的纲领，是第一次国内革命战争时期中国共产党同国民党合作的政治基础。参见本书第二卷《新民主主义论》第十节。 ↩\n\n\n不应当容许富农加入农会。1927 年时期，农民群众还不知道这一点。 ↩\n\n\n见本卷《中国社会各阶级的分析》注〔10〕。 ↩\n\n\n指当时的国民党县党部。 ↩\n\n\n袁祖铭，贵州军阀，在 1926 年 6 月至 1927 年 1 月期间曾经盘据湘西一带。 ↩\n\n\n亩捐是当时县、区、乡豪绅政权除抽收原有田赋之外，另行按田亩摊派的一种苛捐。这种捐税连租种地主土地的贫苦农民都要直接负担。 ↩\n\n\n督军是北洋军阀统治时期管辖一省的军事首脑。督军大都总揽全省的军事政治大权，对外勾结帝国主义，对内实行地方性的封建军事割据，是一省范围内的独裁者。 ↩\n\n\n都总、团总是都、团政权机关的头领。 ↩\n\n\n“挨户团”是当时湖南农村武装的一种，它分常备队和非常备队两部分。“挨户”是形容几乎每一户人家都要参加的意思。在一九二七年革命失败以后，许多地方的“挨户团”被地主所夺取，变成了反革命的武装组织。 ↩\n\n\n当时在武汉国民党中央领导下的各地国民党县党部，很多是属于执行孙中山联俄、联共、扶助农工三大政策的组织，是共产党人、左派国民党员和其他革命分子的革命联盟。 ↩\n\n\n这句话引自《孟子·尽心上》，大意是说善于教人射箭的人，引满了弓，却不射出去，只摆着跃跃欲动的姿势。毛泽东在这里是借来比喻共产党人应当善于教育和启发农民，使农民自觉地去破除迷信和其他不良的风俗习惯，而不是不顾农民的觉悟程度，靠发号施令代替农民去破除。 ↩\n\n\n唐生智是当时站在革命方面参加北伐的一个将军。叶开鑫是当时站在北洋军阀方面反对革命的一个将军。 ↩\n\n\n孙传芳（1885~1935），山东泰安人，北洋直系军阀。1925 年 11 月以后，曾经统治浙江、福建、江苏、安徽、江西五省。他镇压过上海工人的起义。1926 年 9 月至 11 月间，他的军队主力在江西的南昌、九江一带，被北伐军击溃。 ↩\n\n\n东方文化主义，是排斥近代科学文明，标榜和宣扬东方落后的农业生产和封建文化的一种反动思想。 ↩\n\n\n会党指哥老会等旧中国民间秘密团体。参见本卷《中国社会各阶级的分析》注〔17〕。 ↩\n\n\n山、堂、香、水，是旧中国民间秘密团体的一些宗派的称号。 ↩\n\n\n1926 年 11 月至 1927 年 3 月，蒋介石把国民革命军总司令部设在南昌。蒋介石在南昌集合了国民党右派和一部分北洋军阀的政客，勾结帝国主义，策划反革命的阴谋，形成了与当时的革命中心武汉对抗的局面。 ↩\n\n\n张静江（1877——1950），浙江湖州人。当时任国民党中央执行委员会常务委员会代理主席，是国民党右派头子之一，为蒋介石设谋画策的人。 ↩\n\n\n刘岳峙，湖南国民党右派组织“左社”的头子。1927 年 2 月，他被当时还执行革命政策的国民党湖南省党部清洗出党，成为人所共知的反动分子。 ↩\n\n\n叶公好龙，见汉朝刘向所作《新序·杂事》：“叶公子高好龙，钩以写龙，凿以写龙，屋室雕文以写龙。于是天龙闻而下之，窥头于牖，施尾于堂。叶公见之，弃而还走，失其魂魄，五色无主。是叶公非好龙也，好夫似龙而非龙者也。”毛泽东在这里用以比喻蒋介石辈口谈革命，实际上畏惧革命，反对革命。 ↩\n\n\n这是毛泽东为中共湘赣边界第二次代表大会写的决议的一部分，原题为《政治问题和边界党的任务》。 ↩\n\n\n毛泽东在这里指的是民族资产阶级。毛泽东在 1935 年 12 月作的《论反对日本帝国主义的策略》和 1939 年 12 月作的《中国革命和中国共产党》中，对于买办大资产阶级与民族资产阶级的区别，曾作了详细的说明。 ↩\n\n\n蒋派指蒋介石派。桂派指广西军阀李宗仁、白崇禧派。冯派指冯玉祥派。阎派指山西军阀阎锡山派。他们曾经联合对张作霖作战，于 1928 年 6 月占领了北京和天津。 ↩\n\n\n张作霖（1875~1928），辽宁海城人，奉系军阀首领。1924 年吴佩孚在第二次直奉战争中被打败后，张作霖成为北方最有势力的一个军阀。1926 年他联合吴佩孚入据北京。1928 年 6 月从北京退回东北，在路上被向来利用他做工具的日本帝国主义者所炸死。 ↩\n\n\n1928 年 5 月济南惨案发生及蒋介石公开对日妥协之后，曾经追随蒋介石参加 1927 年反革命政变的民族资产阶级，有一部分因为自己的利益，开始逐步形成蒋介石政权的在野反对派，他们既不满意蒋介石政权的大地主、大资产阶级的反革命统治，又反对无产阶级领导的人民民主革命。他们发动了一个改良主义运动，幻想在革命和反革命两条道路之外，另找一条有利于中国资本主义发展的道路。当时，同蒋介石争权夺利的汪精卫、陈公博等政客，曾在这个运动中进行投机活动，形成了国民党中的所谓“改组派”。 ↩\n\n\n1928 年蒋介石在英美帝国主义支持下，北上攻打张作霖。日本帝国主义为阻止英美势力向北方发展，出兵山东，侵占济南、青岛和胶济路沿线，截断津浦铁路。5 月 3 日，日本侵略军在济南进行大屠杀，在这前后十几天内，共惨杀中国军民数千人。这次屠杀事件被称为“济南惨案”。 ↩\n\n\n中国红色政权在组织形式上，和苏联的苏维埃政权是相同的。苏维埃即代表会议，是俄国工人阶级在 1905 年革命时创造的一种政治制度。列宁根据马克思主义的原理，从巴黎公社和 1905 年俄国革命的经验中，得出这样的结论：苏维埃是工农革命政府的最好的组织形式，是从资本主义到社会主义的过渡时期中最适当的国家政权的组织形式。1917 年俄国十月社会主义革命，在布尔什维克党的领导下，第一次在世界上建立了无产阶级专政的社会主义的苏维埃共和国。在中国，1927 年革命失败以后，中国共产党以毛泽东为代表所领导的各地人民革命起义，即以代表会议为工农民主政权的组织形式。但是，这时的中国革命仍然处于民主革命阶段，这种政权的性质，是无产阶级领导的反帝反封建的工农民主专政，同苏联的无产阶级专政的政权性质是有区别的。 ↩\n\n\n在第二次世界大战期间，原来属于英、美、法、荷各帝国主义统治下的东方许多殖民地，被日本帝国主义者所占领，那里的工人、农民、城市小资产阶级群众及民族资产阶级分子在共产党领导下，利用英、美、法、荷各帝国主义与日本帝国主义的矛盾，组织了反法西斯侵略的广泛统一战线，建立了抗日根据地，进行了艰苦的抗日游击战争，已开始改变了第二次世界大战以前的政治情况。第二次世界大战结束，日本帝国主义被逐出，英、美、法、荷各帝国主义企图继续原来的殖民地统治，但各殖民地人民已在抗日战争中锻炼出了一种相当有力的武装力量，他们不愿意照旧生活下去；而由于苏联的强大，由于除美国以外的一切帝国主义国家在战争中或被推翻或被削弱，更由于中国革命的胜利使帝国主义阵线在中国被突破，因而使整个帝国主义制度已在世界上发生很大的动摇。这样，就使东方各殖民地至少是某些殖民地的人民也和中国差不多一样地有可能长期坚持大小不一的革命根据地和革命政权，有可能长期坚持由乡村包围城市的革命战争，并有可能由此逐步推进而取得城市、取得该殖民地全国范围内的胜利。根据这种新的情况，毛泽东于 1928 年对于在帝国主义直接统治的殖民地条件下这一个问题上所作的观察，已有了改变。 ↩\n\n\n这是指 1927 年蒋介石、汪精卫相继叛变革命以后，各地人民在共产党领导下，最初爆发起来的对反革命势力的反击行动。在广州，1927 年 12 月 11 日，工人和革命士兵在一部分市郊农民的配合下联合起义，建立过为时三天的人民政权。广东省东部沿海的海丰、陆丰等地的农民，在 1927 年 5 月和 9 月举行起义，都曾经建立过革命政权；在这年十月举行的起义中建立的革命政权，一直坚持到 1928 年 3 月。在湖南省东部，1927 年 9 月，起义的农民曾经占据过浏阳、平江、醴陵、株洲一带，醴陵农民并于 1928 年二三月间建立过农村革命政权。湖北省东北部的黄安（今红安）、麻城等地的起义农民，曾经在 1927 年 11 月占领黄安县城，建立革命政权二十多天。在湖南省南部，1928 年 1 月，宜章、郴县、耒阳、永兴、资兴等县的起义农民，建立过革命政权达三月之久。关于湘赣边界的革命斗争，参见本卷《井冈山的斗争》。 ↩\n\n\n赤卫队是革命根据地中群众的武装组织，不脱离生产。 ↩\n\n\n参见本卷《湖南农民运动考察报告》注〔16〕。 ↩\n\n\n罗霄山脉是江西、湖南两省边界的大山脉，井冈山位于罗霄山脉的中段。 ↩\n\n\n1928 年 4 月，毛泽东率领的军队和朱德率领的军队在井冈山会师后，合编为工农革命军第四军（六月改称红军第四军）。四五月间，第四军在遂川的五斗江、永新的草市坳和永新城，先后打败江西国民党军队的第二、三次“进剿”。6 月 23 日，红四军在宁冈、永新交界的七溪岭和龙源口地区，打败江西敌军第四次“进剿”。江西的国民党军队在遭到多次失败以后，又联合湖南的国民党反动派，调集四个师的兵力，对井冈山发动第一次“会剿”。七月间，“会剿”的敌军先后侵占宁冈、永新、莲花等县城。红四军以两个团的兵力出击湖南敌军后方的酃县，以一个团的兵力对付江西敌军，同时发动广大群众到处包围袭击敌军。结果，湖南敌军仓皇退守茶陵；江西敌军也被围困于永新地区。 ↩\n\n\n毛泽东这里所说的小资产阶级，是指农民以外的手工业者、小商人、各种自由职业者和小资产阶级出身的知识分子。中国的这类社会成分主要在城镇，但在乡村中也占有相当数量。参见本卷《中国社会各阶级的分析》和本书第二卷《中国革命和中国共产党》。 ↩\n\n\n大小五井山区就是指介于江西西部的永新、宁冈、遂川和湖南东部的酃县四县之间的井冈山，井冈山上有大井、小井、上井、中井、下井等地。 ↩\n\n\n这是毛泽东写给中共中央的报告。 ↩\n\n\n这个战争发生于 1927 年 10 月，到第二年三月结束。 ↩\n\n\n这个战争发生于 1927 年 11 月，到第二年二月结束。 ↩\n\n\n见本卷《中国的红色政权为什么能够存在？》注〔9〕。 ↩\n\n\n参见本卷《湖南农民运动考察报告》注〔16〕。 ↩\n\n\n红军中的士兵代表会议和士兵委员会是为了发扬军队内部民主而建立的一种制度。这种制度，后来被废除了。一九四七年新式整军运动开始以后，在人民解放军中，根据红军时期和新式整军运动中的经验，又在连队中建立过干部领导的士兵会和士兵委员会的制度。 ↩\n\n\n见本卷《中国的红色政权为什么能够存在？》注〔12〕。 ↩\n\n\n“反水”意为叛变。 ↩\n\n\n即 1927 年 8 月 1 日在南昌起义的叶挺、贺龙的旧部（叶部见本文注〔18〕）。这些部队在潮州、汕头一带失败后，一部分到达海陆丰地区，继续在广东坚持斗争，另一部分由朱德、陈毅等率领退出广东，经福建、江西，转入湖南南部，会合当地农军举行湘南起义，开展苏维埃运动。起义失败后，于 1928 年 4 月到达井冈山同毛泽东领导的工农革命军会师。 ↩\n\n\n指 1927 年革命时期的国民革命军第四集团军第二方面军总指挥部警卫团。它的干部有很多是共产党员。汪精卫等叛变革命以后，这个警卫团在八月初离开武昌，准备到南昌参加起义军。行至中途，闻南昌起义军已经南下，就转到修水，同平江、浏阳的农军会合。 ↩\n\n\n湖南平江、浏阳一带在 1927 年春已经形成相当有力的农民武装。5 月 21 日许克祥在长沙发动反革命事变（即“马日事变”），屠杀革命群众。为了向反革命还击，浏阳的农军，同长沙附近其他各县的工农武装一起，曾经向长沙前进。在进军途中，由于中共湖南省委传达了中共中央撤退农军的命令，其他各县工农武装都向后撤退，只有浏阳农军未接到命令，一直攻到长沙城下，遭到失败后撤退。七月中旬，这支农军同平江的农民武装会合。九月又与国民革命军第四集团军第二方面军总指挥部警卫团、安源工人武装等合编为工农革命军第一军第一师，在毛泽东领导下，于修水、铜鼓、平江、浏阳一带举行秋收起义。十月，起义部队到达井冈山。 ↩\n\n\n1928 年初，朱德、陈毅率部在湘南开展革命游击战争，原来农民运动有基础的宜章、郴县、耒阳、永兴、资兴五县，这时都组织了农军。后来这部分农军由朱德、陈毅率领到达井冈山，同毛泽东领导的部队会师。 ↩\n\n\n湖南省常宁县水口山是重要的铅锌矿产地。1922 年，水口山的工人在共产党领导下，组织了工会，历年与反革命斗争。1927 年冬，以水口山的工人为主，组成了湘南游击总队，进行游击战争。1928 年初，湘南游击总队编入朱德率领的中国工农革命军，参加了湘南起义。后随起义军一起，到达井冈山。 ↩\n\n\n指安源煤矿和株萍铁路的工人。1921 年秋，中国共产党派人到安源工作，第二年，建立了共产党和工会的组织，在毛泽东、李立三、刘少奇等的领导下，发动了著名的安源路矿大罢工。当时，安源一带有一万二千多工人参加了工会。1927 年 9 月，安源工人武装参加了毛泽东领导的秋收起义。 ↩\n\n\n红军中的党代表 1929 年起改称政治委员，连的政治委员 1930 年起改称政治指导员。 ↩\n\n\n用“打土豪”罚款的方法筹措军费，只能是临时的和部分的。军队大了，地域宽了，就必须而且可能用收税等方法筹措军费。 ↩\n\n\n此种办法在红军中施行了一个很长时期，在当时曾是必要的，后来改变为按等级略有一些区别。 ↩\n\n\n在军队内部实行一定的民主，是毛泽东一贯的思想。在这里毛泽东特别着重地指出革命军队内部民主生活的必要，是因为当时红军初建，非强调民主，不足以鼓舞新入伍的农民和俘虏过来的国民党军士兵的革命积极性，不足以肃清干部中由反动军队传来的军阀主义的习气。当然，部队中的民主生活必须是在军事纪律所许可的范围内，必须是为着加强纪律而不是为着减弱纪律，所以在部队中提倡必要的民主的时候，必须同时反对要求极端民主的无纪律现象。而这种现象在初期的红军中，曾经一度严重地存在过。关于毛泽东反对军队中极端民主化的斗争，参见本卷《关于纠正党内的错误思想》。 ↩\n\n\n1926 年北伐时，叶挺领导的部队为一个独立团。这个团以共产党员为骨干，是北伐中有名的战斗部队。革命军占领武昌以后，独立团本身改编为第二十五师七十三团。同时，抽调该团部分骨干组建第二十五师七十五团的三个营和第四集团军第二方面军总指挥部警卫团；抽调该团的大批骨干组建第二十四师，叶挺任师长。参加南昌起义后，二十四师、二十五师等部合编为第十一军，叶挺兼任军长。 ↩\n\n\n事实上红军中的党员人数占全军三分之一左右即好，后来在红军和人民解放军中大体上都是如此。 ↩\n\n\n1927 年蒋介石在上海发动四一二反革命政变后，湖南、湖北的反动军官相继叛变革命。5 月 21 日，国民党军第三十五军独立第三十三团团长许克祥在军长何键的策动下，在长沙发动反革命叛乱，围攻湖南省总工会、省农民协会等革命群众组织，捕杀共产党人和革命的工农群众。旧时的文电，习惯以通行的诗韵韵目代替日期，以诗韵第二十一韵的韵目“马”字代替二十一日，所以这一天发生的事变被称为“马日事变”。这个事变是以汪精卫为首的武汉国民党反革命派和以蒋介石为首的南京反革命派公开合流的信号。 ↩\n\n\n1928 年湘赣边界土地法中曾经有这样的规定。毛泽东后来指出，没收一切土地而不是只没收地主的土地，是一种错误，这种错误是由于当时缺乏土地斗争的经验而来的。1929 年 4 月兴国县土地法把“没收一切土地”改为“没收一切公共土地及地主阶级的土地”。 ↩\n\n\n鉴于争取农村中间阶级的重要，毛泽东随即纠正了打击中间阶级过重的错误政策。毛泽东对中间阶级的政策主张，除见于本文外，又见于 1928 年 11 月红军第四军第六次党的代表大会提案（内有“禁止盲目焚杀”，“保护中小商人利益”等项）、1929 年 1 月红军第四军布告（内有“城市商人，积铢累寸，只要服从，馀皆不论”等语）和 1929 年 4 月兴国县土地法（参见本文注〔21〕）等。 ↩\n\n\n此种情况，依靠革命战争的发展、根据地的扩大和革命政府保护工商业的政策，是可以改变的，后来也已经改变了。这里的关键是坚决地保护民族工商业，反对过左的政策。 ↩\n\n\n以劳动力为标准分配土地的方法，是不妥当的。事实上，在革命根据地，长时期都是实行按人口平分土地的原则。 ↩\n\n\n这里指中共红四军第六次代表大会。这次会议在 1928 年 11 月 13 日开预备会，14 日正式开会，15 日闭幕。 ↩\n\n\n靖卫团是一种反革命的地方武装。 ↩\n\n\n这是毛泽东为中国共产党红军第四军第九次代表大会写的决议的第一部分。中国人民军队的建设，是经过了艰难的道路的。中国红军（抗日时期是八路军、新四军，现在是人民解放军）从 1927 年八月一日南昌起义创始，到 1929 年 12 月，经过了两年多的时间。在这个时期内，红军中的共产党和各种错误思想作斗争，学到了许多东西，积累了相当丰富的经验。毛泽东写的这个决议，就是这些经验的总结。这个决议使红军肃清旧式军队的影响，完全建立在马克思列宁主义的基础上。这个决议不但在红军第四军实行了，后来各部分红军都先后不等地照此做了，这样就使整个中国红军完全成为真正的人民军队。中国人民军队中的党的工作和政治工作，以后有广大的发展和创造，现在的面貌和过去大不相同了，但是基本的路线还是继承了这个决议的路线。 ↩\n\n\n见本卷《井冈山的斗争》注〔5〕。 ↩\n\n\n1927 年革命失败后的短期间，在共产党内曾经出现一种“左”倾盲动主义倾向，认为中国革命的性质是所谓“不断革命”，中国革命的形势是所谓“不断高涨”，因而不肯去组织有秩序的退却，错误地使用命令主义的方法，企图依靠少数党员和少数群众在全国组织毫无胜利希望的许多的地方起义。这种盲动主义的行动曾经在 1927 年底流行过，到了 1928 年初渐渐地停止了下来。但有些党员也还存在着这种情绪。盲动主义就是冒险主义。 ↩\n\n\n见本卷《中国的红色政权为什么能够存在？》注〔9〕。 ↩\n\n\n黄巢（？~884），曹州冤句（今山东菏泽）人，唐朝末年农民起义领袖。公元 875 年，即唐僖宗乾符二年，黄巢聚众响应王仙芝领导的起义。公元 878 年，王仙芝被杀后，黄巢收集王的余部，被推为领袖，号“冲天大将军”。他领导的起义队伍，曾经多次出山东流动作战，转战于山东、河南、安徽、江苏、湖北、湖南、江西、浙江、福建、广东、广西、陕西等省。公元 880 年，黄巢攻破潼关，不久占领长安，建立齐国，自称皇帝。后因内部分裂（大将朱温降唐），又受到李克用沙陀军及诸道军队的进攻，黄巢被迫退出长安，转入河南，由河南回到山东，于公元 884 年失败自杀。黄巢领导的农民战争持续了十年，是中国历史上有名的农民战争之一。它沉重地打击了当时的封建统治阶级，受到贫苦农民的拥护。由于黄巢起义军只是简单地进行流动的战争，没有建立过比较稳固的根据地，所以被封建统治者称为“流寇”。 ↩\n\n\n李闯即李自成（1606~1645），陕西米脂人，明朝末年农民起义领袖。1628 年，即明思宗崇祯元年，陕西北部形成农民起义的潮流。李自成参加高迎祥的起义队伍，曾经由陕西入河南，到安徽，折回陕西。1636 年高迎祥死，李自成被推为闯王。李自成在群众中的主要口号是“迎闯王，不纳粮”；同时他不准部下扰害群众，曾经提出“杀一人如杀我父，淫一妇如淫我母”的口号，来约束自己的部队。因此，拥护他的人很多，成为当时农民起义的主流之一。但他也没有建立过比较稳固的根据地，总是流动作战。他在被推为闯王后，率部入川，折回陕南，经湖北又入川，又经湖北入河南，旋占湖北襄阳、安陆等地，再经河南攻陕占西安，于 1644 年经山西攻入北京。不久，在明将吴三桂勾引清兵联合进攻下失败。 ↩\n\n\n这是毛泽东给林彪的一封信，是为答复林彪散发的一封对红军前途究竟应该如何估计的征求意见的信。毛泽东在这封信中批评了当时林彪以及党内一些同志对时局估量的一种悲观思想。1948 年林彪向中央提出，希望公开刊行这封信时不要提他的姓名。毛泽东同意了这个意见。在收入本书第一版的时候，这封信改题为《星星之火，可以燎原》，指名批评林彪的地方作了删改。 ↩\n\n\n方志敏（1899~1935），江西弋阳人，赣东北革命根据地和红军第十军的主要创建人。1922 年加入中国社会主义青年团，1924 年加入中国共产党，曾被增补为中国共产党第六届中央委员会委员。1928 年 1 月，在江西的弋阳、横峰一带发动农民举行武装起义。1928 年至 1933 年，领导起义的农民坚持游击战争，实行土地革命，建立红色政权，逐步地将农村革命根据地扩大到江西东北部和福建北部、安徽南部、浙江西部，将地方游击队发展为正规红军。1934 年 11 月，带领红军第十军团向皖南进军，继续执行抗日先遣队北上的任务。1935 年 1 月，在同国民党军队作战中被捕。同年八月，在南昌英勇牺牲。 ↩\n\n\n见本卷《中国的红色政权为什么能够存在？》注〔9〕。 ↩\n\n\n这里所说的“革命的主观力量”，是指有组织的革命力量。 ↩\n\n\n见本卷《中国社会各阶级的分析》注〔9〕。 ↩\n\n\n鲁涤平（1887~1935），湖南宁乡人。1928 年时任国民党湖南省政府主席。 ↩\n\n\n指 1929 年三四月间蒋介石和广西军阀李宗仁、白崇禧之间的战争。 ↩\n\n\n1928 年 7 月至 11 月，江西、湖南两省的国民党军队两次“会剿”井冈山革命根据地失败后，又于同年底至 1929 年初调集湖南、江西两省共六个旅的兵力，对井冈山革命根据地发动第三次“会剿”。毛泽东等周密地研究了粉碎敌人“会剿”的计划，决定红军第四军主力转入外线打击敌人，以红四军的一部配合红五军留守井冈山。经过内外线的艰苦转战，红军开辟了赣南、闽西革命根据地，曾经被敌人一度侵占的井冈山革命根据地也得到了恢复和发展。 ↩\n\n\n指中共中央 1929 年 2 月 7 日给红军第四军前敌委员会的信。本文中引录的 1929 年 4 月 5 日红军第四军前敌委员会给中央的信上，曾大略地摘出该信的内容，主要是关于当时形势的估计和红军的行动策略问题。中央的这封信所提出的意见是不适当的，所以前委在给中央的信中提出了不同的意见。 ↩\n\n\n这里是指湖南、江西两省国民党军队对井冈山革命根据地的第三次“会剿”。 ↩\n\n\n指反革命势力对付人民的革命力量采用血腥屠杀的手段。 ↩\n\n\n中国共产党第六次全国代表大会于 1928 年 6 月 18 日至 7 月 11 日在莫斯科举行。会上，瞿秋白作了《中国革命与共产党》的报告，周恩来作了组织问题和军事问题的报告，刘伯承作了军事问题的补充报告。会议通过了政治、苏维埃政权组织、土地、农民等问题决议案和军事工作草案。这次大会肯定了中国社会仍旧是半殖民地半封建社会，中国当时的革命依然是资产阶级民主革命，指出了当时的政治形势是在两个高潮之间和革命发展是不平衡的，党在当时的总任务不是进攻，而是争取群众。会议在批判右倾机会主义的同时，特别指出了当时党内最主要的危险倾向是脱离群众的盲动主义、军事冒险主义和命令主义。这次大会的主要方面是正确的，但也有缺点和错误。它对于中间阶级的两面性和反动势力的内部矛盾缺乏正确的估计和适当的政策；对于大革命失败后党所需要的策略上的有秩序的退却，对于农村根据地的重要性和民主革命的长期性，也缺乏必要的认识。 ↩\n\n\n指福建西部长汀、龙岩、永定、上杭等县的工农民主政权，它是红军第四军主力 1929 年离开井冈山进入福建时新开辟的革命根据地。 ↩\n\n\n“固定区域的割据”指工农红军建立比较巩固的革命根据地。 ↩\n\n\n蒋伯诚，当时任国民党浙江省防军司令。 ↩\n\n\n郭，报国民党福建省防军暂编第二混成旅旅长郭凤鸣。 ↩\n\n\n陈卢，指福建的著匪陈国辉和卢兴邦，他们的部队在 1926 年被国民党政府收编。 ↩\n\n\n张贞，当时任国民党军暂编第一师师长。 ↩\n\n\n朱培德（1889~1937），云南盐兴（今禄丰县）人。当时任国民党江西省政府主席。 ↩\n\n\n熊式辉（1893~1974），江西安义人。当时任国民党江西省政府委员、第五师师长。 ↩\n\n\n毛泽东的这篇文章是为了反对当时红军中的教条主义思想而写的。那时没有用“教条主义”这个名称，而叫它做“本本主义”。 ↩\n\n\n"},"阅读/治大国若烹小鲜：基层治理与世道人心":{"title":"治大国若烹小鲜：基层治理与世道人心","links":[],"tags":[],"content":"\n\n                  \n                  治大国若烹小鲜：基层治理与世道人心 \n                  \n                \n\n\n\n《治大国若烹小鲜：基层治理与世道人心》-  吕德文\n出版时间： 2021-04-09 00:00:00\nISBN： 9787300291659\nPC地址：weread.qq.com/web/reader/57e32aa0813ab75ddg010a4d\n\n\n\n一起教师集访事件背后的基层治理困境\n此外，不同群体之间，执行的尺度和时间也不一样。如文件规定：一次性补助是针对省直机关事业单位的，其受益主体是政府公务人员。但对于省辖市而言，主要的受益群体却是医生、教师。事实上，绝大多数中西部农村地区，其财政负担主体主要是这两个群体。对于诸多“吃饭财政”的县市而言，先补助公务员，再补助教师，分步实施，或许是一种极其普通的操作。正因为如此，随手搜索一下教师维权事件，你会发现，它们大多发生在县市一级。\n\n⏱ 2024-10-23 11:39:05\n\n\n统一的政策差异化执行，当然会引起受损群体（显然主要是农村教师）的反弹。\n\n⏱ 2024-10-23 11:42:09\n\n\n最突出的，就是政策统一与区域差异之间的矛盾。其实，不单单是教师待遇，其他很多政策，到税费改革以后，都越来越具有“国家化”特征，强调政策统一性。问题是，各地的经济发展水平很不一样，短时间内统一执行肯定会有困难。但是，与以往不同的是，现在是一个信息社会，一个地方执行了，另一个地方不执行，就一定会出现不公平感。因此，矛盾就出现了。对于地方政府而言，从政策执行的有效性看，分步骤、渐进式、差异化地执行，是合理的；但从政策执行的公平性来看，这一做法已经不现实。\n\n⏱ 2024-10-23 11:42:37\n\n\n所以，提高基层待遇没错，但也要客观理性看待。如果在地方政府无财力承担的情况下，一定要比照发达地区和城市，其实也有问题，很容易人为制造其他社会矛盾。须知，在这次事件中集访的六安教师，讨的并不是拖欠的工资，而是新增的一次性工作奖励。这对教师而言是新增利益，但对地方政府而言，却是一笔额外财政负担。\n\n⏱ 2024-10-23 11:44:02\n\n\n基层“闹缠”现象如何破解？\n这些人打着为当事人和弱势群体维权的名义，通过把事情“闹大”、把当事人“缠死”而获取非正当利益。所谓“会哭的孩子有奶吃”，又谓“大闹大解决，小闹小解决，不闹不解决”。人们普遍认为，出了点事不闹腾一番不正常。“闹”是常规，不闹反倒是不正常的。\n\n⏱ 2024-10-27 12:07:13\n\n\n毫不夸张地说，基层治理到处充斥着“讨价还价”的过程，基层治理体系演变成了一个社会议价系统。\n\n⏱ 2024-10-27 12:12:30\n\n\n信访干部既接待正常的上访者，也接待非正常的上访者；既要应对合理合法的诉求，亦要应对各种奇怪的诉求。久而久之，很多信访办主任都有个共识：信访的关键也许不在于化解问题，而在于耐心倾听，让人民群众感到受到重视才是最重要的。然而，正因为信访具有零门槛的特征，渠道通畅、干部热情、效果明显，反而刺激了人们过度依赖信访，由此催生了“信访不信法”的局面。\n\n⏱ 2024-10-27 12:22:45\n\n\n与信访制度类似的是，我国各级政府和各个政府机关几乎都极为重视调解。长期以来，基层自治组织、政府机关和司法机关都大量采用调解技术来化解社会矛盾和纠纷。应该说，运用调解而非法律制度来治理社会，是一种相对简约有效的方式。但麻烦也在于，在社会转型过程中，民间权威逐渐丧失，原初的人民调解越来越难起作用。即便是调解工作，也越来越依赖于行政和司法机关。\n\n⏱ 2024-10-27 12:26:15\n\n\n基层政府也被迫积极介入纠纷调解工作。由于深度介入纠纷调解工作，基层政府很容易从“仲裁者”变成“议价者”。\n\n⏱ 2024-10-27 12:26:24\n\n\n长期以来，“老好人”现象和“不出事逻辑”主导了基层治理。基层政府在“讨价还价”的过程中，往往无原则，以息事宁人为导向，最终培育了一大批特殊利益人群。\n\n⏱ 2024-10-27 12:46:10\n\n\n很多基层领导，也是秉持着“只要我任内不出事”的理念，不愿意揭盖子，而是使用各种策略捂着、盖着。\n\n⏱ 2024-10-27 12:47:00\n\n\n烧散煤被拘留，如何避免折腾式治理？\n一旦政府的政策目标过急过快，就很可能忽略老百姓的实际困难，从而导致巨大的矛盾。\n\n⏱ 2024-10-27 18:45:38\n\n\n贫困县为何敢斥巨资建广场？\n大致而言，我国的扶贫战略经历了三个阶段：一是从1986年开始，中央和地方各级政府建立了扶贫工作体系，并确定了258个国家级贫困县。\n\n⏱ 2024-10-28 12:24:58\n\n\n二是2001年国务院扶贫领导小组颁布了《中国农村扶贫开发纲要（2001—2010年）》，改变了过去以贫困县为基本扶持单位的做法，转而通过“整村推进”的做法，将扶贫开发重点转向14.8万个贫困村。\n\n⏱ 2024-10-28 12:25:08\n\n\n三是十八大以来的精准扶贫战略。\n\n⏱ 2024-10-28 12:25:36\n\n\n由此可见，扶贫本质上是一个发展概念。虽然我国的扶贫政策经过几次较大的变动，但“开发式扶贫”的理念和做法一直未消退。\n\n⏱ 2024-10-28 12:25:53\n\n\n此外，我国的央地关系极为特殊，有人将之概括为锦标赛体制。一方面，上级政府尤其是中央政府，是裁定各个地方政府的表现的唯一权威，也有能力来协调各个地方的发展；另一方面，地方政府也有较强的自主性，有极强的相互竞争的动力。\n\n⏱ 2024-10-28 12:31:48\n\n\n而与此同时，“以GDP论英雄”一直是锦标赛体制的重要特征。原因很简单，它客观，可比较，还符合改革开放以来的主流意识形态。但问题是，经济发达地区因地理位置优越、基础设施健全、产业链完整等因素，可以很轻易地通过招商引资自然而然地实现经济增长，从而在地方竞争中占据优势。但落后地区尤其是众多贫困县怎么办呢？搞基础设施建设，成为实现GDP增长最直接的手段。\n\n⏱ 2024-10-28 12:33:28\n\n\n因此，绝大多数地方政府都倾向于将产业扶贫资金和贴息贷款，拿给有关企业和合作社经营，贫困户获得相关的利息或分红。这种做法，和直接发钱没有多大区别，虽不一定符合扶贫政策，却足以保证一定时间内贫困人口脱贫。\n\n⏱ 2024-10-28 12:42:23\n\n\n就扶贫战略而言，土地开发可以一时拉动地方经济增长，却很难持续，毕竟，它本身就与扶贫战略背道而驰——因为贫困人口很可能因为生活成本的提高而再次陷入困境。事实上，通盘思考，通过改善贫困人口的生产生活条件，通过产业培育增加贫困人口的就业机会，才是贫困县脱帽的终极保证。\n\n⏱ 2024-10-28 12:46:16\n\n\n基层如何守住疫苗安全底线？\n说白了，医疗卫生问题是基层治理困境的一个最突出的表现。\n\n⏱ 2024-10-28 13:11:29\n\n\n出租车行业管理，为什么总是管不好？\n更深刻的执法困境在于，所有运管部门的街头执法，其实都受制于部门分割而导致的执法权失效问题。运管部门无权查扣车辆，只有交警部门有这权力；但因为职能划分，交警又不会轻易配合运管执法。因此，即使明知对方是“黑车”，只要乘客不配合取证，运管部门也毫无办法。\n\n⏱ 2024-10-29 18:08:03\n\n\n乡镇赌博业是“社会之癌”\n在工业社会中，人们的时间为流水线所控制，闲暇（假日）本质上是为了更好地工作。因此，大部分在工厂打工的农民工，并不认为他们可以毫无顾忌地浪费时间、浪费金钱。恰恰是处于物质丰裕时代的已经返乡的第一代农民工，如何安置生活成了大问题。他们不再受流水线的控制，却早就被卷入了消费社会的逻辑之中；他们名义上已经返乡，却早就告别了脸朝黄土背朝天的景象；他们身在农村，心在花花世界。而在某种意义上，赌博具有麻醉精神生活的作用，它既可以有效地填充闲暇时间，又可以时不时地刺激已经毫无人生斗志的麻木神经。\n\n⏱ 2024-10-29 18:25:04\n\n\n从公安机关办案的角度说，赌博认定有两个关键要件：(1)组织者是否以营利为目的；(2)数额是否巨大。两个要件的认定都存在一定的主观性和模糊性。\n\n⏱ 2024-10-29 20:40:21\n\n\n对赌博业的治理和打击是两码事。一般而言，打击是专门机关的职能，党委政府并不参与。因此，乡间赌博业的治理主体实际上是乡镇派出所。可是，如上所言，专门机关打击农村赌博行为，存在非常大的技术困难。最直接的是，派出所并无足够的警力处理如此之多的事务。\n\n⏱ 2024-10-29 20:39:50\n\n\n如欲有效治理，则必定涉及乡村政治社会生态的总体改造。甚至于赌博不是治理的主要对象，农民的闲暇方式才是治理的主要内容。\n\n⏱ 2024-10-29 20:40:58\n\n\n外国留学生妨碍公务，不能“批评教育”了事\n那么，外国人在执法机关面前的“超国民待遇”，其逻辑是什么呢？大致而言，主要体现在如下几个方面。一是分散管理的制度约束。如上所述，对外国人的管理确实受制于“多头管理”的困境。每个管理部门都站在自己的立场，希望在最大程度上维护自己的利益。\n\n⏱ 2024-10-29 20:44:58\n\n\n二是执法能力的欠缺。客观而言，绝大多数城市面对外国人的执法，都存在能力不足的问题。\n\n⏱ 2024-10-29 20:45:48\n\n\n三是执法注意力分配的结果。警力不足是各地公安机关的普遍现状，执法力量的配置很容易受到决策者注意力配置的影响。\n\n⏱ 2024-10-29 20:45:53\n\n\n女教师“绝笔信”事件：一条诡异的上访之路\n这些问题也许在法律上说得清楚，在行政上也可以得到处理，却不一定符合当事人所理解的“情理”——于是乎，兜兜转转，最终都会涌入信访渠道。而在对相关案例的处理上，各级信访部门一般会坚持依法处理，但也总会在不同程度上兼顾“情理”。甚至在有些时候，“和稀泥”成了信访处置的核心原则——“摆平就是水平”，这话在基层一点不假。\n\n⏱ 2024-10-29 20:52:16\n\n\n相比于可能耗时耗力、结果不确定的漫长司法程序，信访相对之下在施压上则“经济有效”，一般对上访人也只有好处，没有坏处。\n\n⏱ 2024-10-29 20:53:51\n\n\n就我们在各地的调研实践来看，地方政府的信访维稳主要有两个做法。第一个做法是普遍采用“包保责任制”。对重点稳控对象，县、乡、村三级都要成立责任组，责任到人，技术到位。\n\n⏱ 2024-10-29 20:56:14\n\n\n第二个做法是截访。在现有的普遍实践中，一旦信访人意外赴京上访，属地政府必须在规定时间内将其劝返接回原籍。\n\n⏱ 2024-10-29 21:03:24\n\n\n还有规则，值得敬畏\n任何社会道德和规则意识，其力量都源自共同体内部的集体意识。如果没有共同体的约束，所谓的道德和规则，就是廉价的话语而已。\n\n⏱ 2024-10-30 00:31:02\n\n\n二 基层腐败，怎么治\n以基层权力为中心的利益网络，丰富了基层的权力清单。由于上级政府加大了对基层权力的监控，基层政权的正式权力有所弱化，基层直接汲取社会资源的权力也渐被剥夺。但是，大规模的财政转移支付及主动的招商引资，又强化了基层的隐性权力，它们掌握着大量的国家政策信息，还部分掌握了分配国家资源的权力，让它们拥有了“选择性政策执行”的权力，有更大的空间进行弹性行政，为基层食利阶层提供利益输送。因此，一旦这个网络被蜕变的基层官员用于谋取私利，财政转移支付将成为主要的利益输送方，外来资本与地方资源的结合是另一个重要的利益输送渠道，而承接这些利益的往往是“灰色社会”的成员，蜕变的基层官员则成为利益输送方和利益承接者之间的“经纪人”。蜕变的基层权力掌握了大量的权力和信息资源，是实现外来项目落户的理想中介者，也是可能的寻租者，只不过，通过与“地方豪强”的联盟，一些寻租活动变得隐蔽化。基层权力由于与“地方豪强”之间形成了灰色利益链条，就很容易在市场行为中偏向于“地方豪强”而损害普通民众的权益，“地方豪强”也情愿协助基层权力以“摆平”不稳定因素。\n\n⏱ 2024-10-30 00:36:55\n\n\n为了弥补基层行政力量的不足，“地方豪强”被纳入基层权力的运作过程中，比如，吸纳他们成为人大代表、政协委员，支持引导他们成为自治组织的领导人。这样就可以充分利用一些“地方豪强”所具有的“强”和“狠”的特点，完成行政事务：他们所具有的经济和社会资源，有利于基层在短期内完成上级指派的刚性任务；一些“狠”的豪强，有利于有效制衡部分“新弱势群体”。这事实上构建了一种新代理人体制。与传统的代理人体制根本不同的是，新代理人体制主要是依靠灰色利益链条连接起来的，代理人经常在基层权力和民众之间寻租，不再受意识形态、法律和地方性规范的规制，那些黑白两道通吃的“地方豪强”逐渐成为一些基层官员的宠儿。总体上看，这种新代理人体制是短视的，是适应当前基层社会利益格局变化的产物，而非有效控制食利阶层崛起的方法。“地方豪强”和非正式行政制造了基层治理中的非正式权力。基层官员很少使用正式权力侵害民众权益，却有可能默许、怂恿非正式权力侵害民众权益。基层权力侵犯民众权益的行为，主要就是有意利用非正式行政手段却无法对其有效约束的结果。\n\n⏱ 2024-10-30 00:39:59\n\n\n塌方式“微腐败”如何产生？\n简言之，在一个常态社会，尤其是处于剧烈变迁中的基层社会，灰色领域是很难清除的；而灰色领域的存在，也为“微腐败”提供了社会基础。但是，需要明确的是，灰色领域并不必然带来“微腐败”；其发生，还需建立在公权力与私人利益的交换条件——灰色利益链条上。\n\n⏱ 2024-10-30 00:54:03\n\n\n黑恶势力的“保护伞”是如何运作的？\n客观上，我国的干部制度是“下管两级”，这意味着，绝大多数基层官员其实一辈子就待在一个地方，流动性小，必定形成熟人关系；并且，我国的治理体系具有鲜明的“分口管理”的特征，一个主要领导分管一个领域，这个领域往往业务相近，也是相互配合的关系。于是乎，分管领导也是实权领导——他可以增强部门协同，提高行政效率，但这也意味着，只要他有意运作，就可以在自己的分管领域建立一个小圈子。问题是，基层治理其实是存在大量灰色地带的，靠制度解决不了，得依靠官员的主观能动性。如此一来，基层官场和地方市场之间，就存在一个广阔的“议价空间”。当一个没有私心的官员去议价时，他可能是一个敢于担当的好官员；但当一个有私心的官员去议价时，哪怕是有公共利益的保护，他也很容易在有意无意间成为“保护伞”。因此，“保护伞”的级别和规模，同黑恶势力的组织程度，往往相辅相成。通常情况下，黑恶势力垄断的领域越多，组织能力越强，“保护伞”就越大，“保护伞”内部的组织能力也越强。一旦一个地方的政治社会生态灰化，就会形成恶性循环。某种意义上，这种地方其实已经很难自我清理。因此，多数涉及面广的“保护伞”，都是在中央督导组的督导之下遭受打击的。\n\n⏱ 2024-10-31 01:54:37\n\n\n从曹园到袁府：深宅大院里的秘密\n北方村庄如此盛产“高楼大厦”，自有其内在的社会机制。简单点解释：一个带门楼的房子，是家庭立足于村庄的基本条件；尤其为即将结婚的孩子准备好“华丽”居所，极具“立门户”的社会意义。房子的第一要求：高大——最好是能“压死”邻居、撑起面子的那种。很多村庄的民间纠纷，也正是源自邻居之间的楼房竞争。一争高下的原因倒不是城里人所说的什么“采光权”之类，而是谁也不想成为在房子上“被压得喘不过气来”的那一个。\n\n⏱ 2024-11-17 19:16:06\n\n\n“微腐败”，怎么治？\n这些农村“微腐败”案件，80%都与农村“三资”（集体资金、资产、资源）管理混乱有关。每到村级组织换届选举时，举报信数量总会急剧升高。有些举报虽属捕风捉影，却也为办案提供了线索，很多案子都是由于反复举报，引起纪检监察机构注意而调查核实的。这给当地纪检监察机构的主要负责人一个启示：基层执纪的主要工作其实不是“办案”，而是防治“微腐败”。只要把基层治理中的一些制度漏洞堵上了，纪检工作就好做了。\n\n⏱ 2024-11-17 23:53:17\n\n\n党的十八大以来，纪检监察力量不断向基层延伸。尤其是《监察法》颁布后，村干部（非党员）也被纳入了监察对象范畴。\n\n⏱ 2024-11-17 23:54:16\n\n\n结果是，国家投入了不少治理资源，却未转化为治理能力；更常见的现象是，资源流量越大，基层治理生态越不正常，村庄治理越是混乱。最为典型的便是，国家的惠农资金一度被基层的蛀虫所侵蚀，吃拿卡要、优亲厚友、雁过拔毛的现象甚是普遍。\n\n⏱ 2024-11-17 23:55:33\n\n\n某个村干部（哪怕是村支书）要单独犯案，几乎不可能。因此，这些“微腐败”案件，一查基本上都是“窝案”，村两委班子几乎都会连锅端。\n\n⏱ 2024-11-17 23:57:33\n\n\n事实上，每项惠农资金的使用都设计了较为完善的制度体系。但一旦实施起来，几乎都会在基层出现政策梗阻。其中的重要原因便是，各项惠农政策的执行在基层缺乏足够的政策监督力量。乡镇党委政府作为一级政权组织，当然有权也有责任监督各项惠农资金安全落实，但如果深入基层政权内部就会知道，真正负责这些巨额惠农资金安全的，也就是经管站、民政所等各个环节的一两个工作人员。并且，这些工作人员并非专职的“监督员”，还要承担其他工作；即便是专职的工作人员，通常一个工作人员也要面对十几个村、几千户农户，如何监管？\n\n⏱ 2024-11-17 23:59:05\n\n\n三 基层减负，怎么减\n理解当前的基层负担重问题，还需厘清一个逻辑：治理体系跟治理能力，实际上是一对矛盾结合体。我们通常的想象是：治理体系越先进，治理能力会越强；反过来讲，就是治理能力越强，这个体系也越先进。但在笔者看来，有可能在某些条件下，现实并不如我们所想象的那样。这二者间往往没有先进与落后的因果关系，只有适合与不适合。对于国家和各个层级而言，要想提高治理能力，就要看你想要什么维度，也要看你选择什么样的治理体系。一个好的体系，应该让每一个层级、每一个位置发挥自己的功能，这样才能形成较强的治理能力。假设说一个决策者，站在自己的高位上，非要把这个地方所有的事情都搞清楚，那不现实。即便能实现这一点，也得有一个前提，就是治理能力达到了相当高的水平。治理能力里面，最核心的是国家的“基础能力”。“基础”是什么？是要把这个社会上的所有信息，包括人口、资源、经济在内的各种信息准确掌握，并由此直接去解决问题。但今天要做到这一点还往往很难。\n\n⏱ 2024-11-18 00:11:46\n\n\n有个词叫作“反向适配”。本来，有什么问题，就该找一个什么样的治理体系去解决它；而不是反过来，不是先有一个体系，然后为了让这个体系变得好看、变得能够证明它有效果，反而失去了效率。这是一个非常大的误区。“反向适配”同时会制造一种潜在倾向，就是可以一竿子插到最底下，仿佛所有地方的毛细组织如何运行都一清二楚就是最理想的状态。但实际上，没有任何一个时代、任何一个国家能做到这一点。这是因为，实际运行的复杂体系，从来都是按标准在运行的，从来都是通过分权、分层次、分部门，然后构成一个复杂体系，相互关联，互相配合，集中和分散需要有相对动态的平衡。这是规律。不是每一个干部都是铁人，相信通过主观意志和奋斗就可以把所有问题都解决好。如果秉持这种思路，一旦大规模延续到基层，很多东西很可能超出实际情况，造成基层干部非得做一些表面功夫。\n\n⏱ 2024-11-18 00:13:15\n\n\n治理的大忌在于，千万不要主观意图很明确地去“激进创新”。要正视现实，把现有的东西整一整，理一理资源，对症下药，用结合实际的方法解决问题，这样可能更好一点。\n\n⏱ 2024-11-18 00:13:33\n\n\n形式主义到底是怎么来的。实际上就是一个词——合规性证明。你做不做事不要紧，按上级要求的规定，证明给他看，证明完了就可以了。\n\n⏱ 2024-11-18 00:13:50\n\n\n基层督查检查考核泛滥，谁之过？\n当前形式主义、官僚主义问题突出，导致基层苦不堪言的问题，既不能简单归咎于上级决策的“不接地气”，亦不能简单理解为基层工作的教条僵化，而是政府间上下级关系的失衡，责、权、利不对等的结果，是国家治理体系和治理能力不足的表现。\n\n⏱ 2024-11-18 12:03:30\n\n\n任何一个行政体系，督查检查考核系统都是必需的，这是上级能够“控制”下级的前提。大致而言，上下级政府间围绕着目标设置、检查考核、激励分配及剩余分配形成不同的互动模式。\n\n⏱ 2024-11-18 12:03:53\n\n\n20世纪八九十年代，我国的央地关系呈现出中央放权、地方分权的趋势。从控制权的分配上看，中央除了掌握国防、外交、宏观调控等必要的权力，经济发展和社会事务等各项权力大都下放给了地方。这一趋势亦传导到地方各层级政府关系之中，这使得在控制权的分配上，上级政府往往只掌握目标设定权以及辅以其中的检查考核权，将激励分配权和剩余控制权都让渡给基层，基层因此获得了极大的自主性。但因为上级政府往往“只要结果，不要过程”，在诸多时候，还默认基层政府为达到目标而不择手段——这也就可以解释，为何20世纪90年代末全国的乡镇政府在税费征收、计划生育等“国策”执行过程中，都不同程度地存在权力滥用等情况。\n\n⏱ 2024-11-18 12:05:18\n\n\n多数情况下，上下级政府只是将检查和“迎检”的游戏当作上级控制权的“展台”，并不真正激活检查考核权。只有在有确切的证据的情况下（如媒体曝光、群众反复上访告状），问责机制才会启动。\n\n⏱ 2024-11-18 12:05:57\n\n\n。他在担任党委书记的时候，上级相关部门布置过一个任务：3个月之内要种40亩地的树。他就将这个任务分配给分管副镇长去办理，并指示财政所给予足够的经费支持。过了3个月，这位副镇长汇报说任务已经完成了；这位党委书记表达了赞许之意，说那就写个报告向上汇报吧，这事就算结束了。事实上，这位乡镇党委书记说，他百分之百确定不可能完成任务，因为其辖区就不可能找到40亩荒地；这就意味着，乡镇财政足额拨付的经费，这位分管副镇长肯定从中贪污了一部分。但他作为一个有经验的党委书记，不可能捅破这层纸。因为一捅破会有无尽的麻烦：第一，如何向上级交代？其实，上级或许也清楚这个任务因各地情况不一，不可能都完成。但如果自己主动承认完成不了，上级政府如秉持实事求是的精神，就得下来调研、重新安排指标，费时又费力；如果不实事求是，那就问责了事——但上级又如何向更上一级交代呢？第二，让下属怎么干？副镇长在接下这个任务的时候，很清楚是不可能完成任务的。但他还是接下了，某种程度上是为领导分忧——真出了问题，他得担责。因此，哪怕是副镇长真贪污了种树款，也是一种“激励分配”。\n\n⏱ 2024-11-18 12:09:28\n\n\n反过来说，今天基层督查检查考核之所以过多过滥，恰恰是国家治理能力不足所致。其中的关键是：当中央和上级政府的控制权急剧增强，而国家基础能力又未同步提高时，上级对下级控制权的实现必然依赖于可视化的“痕迹管理”，而无法依靠实绩评价。\n\n⏱ 2024-11-18 12:12:07\n\n\n当前基层之所以受困于形式主义和官僚主义，根源在于我们在用计算机的方式来治理算盘时代的社会。\n\n⏱ 2024-11-18 12:17:35\n\n\n基层治理其实是有规律可循的。基本原理是：上下级政府间需要在责、权、利上形成相对的平衡关系。而这种平衡关系，除了受国家治理能力和社会本身的“可视化”水平的影响，最直接的还是与控制权的分配有关。\n\n⏱ 2024-11-18 12:20:38\n\n\n当前，一种以行政理性化和技术治理为特征的“集权”正在开展，上级政府部门通过项目制、问责制、目标考核制、办事留痕等技术手段，将基层政府行为纳入“制度的笼子”里。而同时，在基层，过去经过长期实践已经适应了的数据化管理领域（如GDP），不再是衡量基层治理绩效的主导要素；而一些未能高度数据化管理的工作，如党建、环保、维稳等，渐渐成了基层治理的重要任务。这就意味着，一方面，集权化使得上级政府，尤其是那些垂直化管理等部门，获得了对基层政府的部分“控制权”，使得它们普遍以强化“属地责任”的名义将部门责任转嫁给基层政府；另一方面，随着国家治理转型，一些“软指标”渐渐“硬指标化”，且又苦于无法有效“智能计算”，就只能依赖于传统的督查检查考核等方式来获取信息。在这个意义上，上级部门和基层政府间的责、权、利不对等，在治理任务急剧加重等情况下，加剧了形式主义和官僚主义的问题。\n\n⏱ 2024-11-18 12:22:06\n\n\n一个地方、一个时期，都只能有一个中心工作，其他工作要围绕中心工作开展。\n\n⏱ 2024-11-18 12:24:57\n\n\n讲真话的乡村女教师：基层形式主义何时休？\n二是重点工作的“重要性”，上级往往只能通过提高要求和领导重视来体现。平心而论，在一般贫困地区，在如此之大的扶贫资源投入下，按期脱贫怕是问题不大。然而，要把脱贫的成绩真正体现出来，怎么弄呢？只能用标准数字、文字、图片、实地“盆景”来展示。基层不断做形式主义工作，一方面是要把实事呈现出来，另一方面，至少表明一种态度。否则，连形式都不做，怎么能说是重视？长此以往，上级和基层就陷入了一个极其吊诡的境地：领导越是重视，越是下基层调研、检查，基层就得做越多的形式主义工作来回应上级。\n\n⏱ 2024-11-19 17:15:48\n\n\n近年来，为了解决基层官僚主义和形式主义问题，很多事无巨细的措施也都一一落地，但从基层的反映看，效果尚不明显。比如“四不两直”调研（“四不”：不发通知、不打招呼、不听汇报、不用陪同接待；“两直”：直奔基层、直插现场），虽然减少了一些迎来送往的工作，但在某种意义上，基层更是紧张了——得做更多的形式主义工作以备检查。说白了，官僚主义、形式主义本身就是科层组织的产物，在封闭体系内很难根除。尤其是在治理现代化还未达到一定阶段的情况下，单纯在体制内去反官僚主义、形式主义，最可能致使的结果不是二者的减少，而是其更多的“繁衍”生机。\n\n⏱ 2024-11-19 17:14:16\n\n\n扶贫变扰民，形式主义可休矣\n“精准”和“模糊”，是中国基层社会长期需要处理的现实问题。如果基层干部扶贫工作的重点、难点，从“如何让贫困户脱贫”变成“如何让扶贫工作经得起扶贫系统的考核”，那就变味了，走向形式主义。在实践中我们也看到，为了保证在上级验收时万无一失，只能对贫困户反复遍访、回访、拉网式排查，做完的工作要回头看、再回头看，相关数据不断核查、比对，档案改了又改。从这个角度说，如果我们建立了可以覆盖整个治理过程的监督体系，却未能实现对基层社会的有效监测，就始终会出现一种矛盾：哪怕基层真做了事，真接触了群众，但出发点和落脚点都是为了“证明自己做事”，又怎么谈得上跟群众交心？因此，在新时代要做好群众工作，首先是要在行政的“科层体系”内部走群众路线。上级应该慎用督查、问责等手段，而应该多走基层，多做基层干部的思想工作，多和基层干部交心，在调动其工作积极性和主体性的过程中解决问题。\n\n⏱ 2024-11-19 17:25:41\n\n\n县长被逼当场落泪，到底怎么回事？\n作为技术治国的表现，第三方评估及其所运用的一套“科学”、标准的评价体系，的确比传统的政策评估方式来得“客观”一些。贫困县退出采用这个方法本也无可厚非。然而，所有的技术和评价都有其限度。如果对客观情况不加分析、不加辨别，机械执行，就容易陷入技术迷思，反而助长新的形式主义和官僚主义。\n\n⏱ 2024-11-19 17:28:32\n\n\n还有一种情况是，所谓的第三方评估，仅仅是掩盖上下级关系扭曲的遮羞布而已。客观讲，第三方评估是监督基层工作的手段，目的还是为了促进工作。但合理的监督没问题，故意折腾找碴儿就毫无道理了。我们在一些地方调研，上级对下级的不信任、对基层的怀疑，几乎到了歇斯底里的程度。笔者的一些朋友参与了第三方评估，据他们说，一些省扶贫办作为“委托方”，话里话外都透露出对基层的不信任。这种信息明确传递到第三方，则第三方就会想尽办法“找碴儿”。\n\n⏱ 2024-11-19 17:29:08\n\n\n本质上，贫困县退出第三方专项评估是政府绩效评估的一种，本意就是通过“评估”来代替“监督”。“监督”是为了惩戒，为了落实上级监管部门的意图，对基层具有天然的不信任感。但评估则更为柔性，目的无非有二，一是总结基层成功经验，二是查找工作漏洞，都是为了更好地促进工作。这需要第三方出于一颗公心，一切从工作实绩出发，坦坦荡荡。但如果把评估简单等同于“找碴儿”，那就变成“猫鼠游戏”，变了味。作为“发包方”的省级扶贫办是游戏规则的制定者，围绕着脱贫攻坚的“问题”而展开工作。评估方为了赢得“发包方”的欢心，总是想尽办法“抓”问题，找各贫困县的瑕疵。被评估方（贫困县）为了获得好成绩，不仅自身工作要扎实——如事先“演练”，请评估专家来指导，让有关评估团队“预估”一遍，还要想尽各种办法盯紧评估方的各种动作。\n\n⏱ 2024-11-19 17:30:58\n\n\n简单说来，在贫困户退出机制中，那些“第三方评估”等现代治理技术，在提高治理精准度的同时，却也存在着机械化、片面化、唯一化的问题，反而强化检查评估中新的形式主义。主要表现在两个方面：一是形成了一定意义上的“技术霸权”，排斥其他的治理方式。比如，扶贫工作本质上是群众工作，基层干部既要扶贫，又要扶志。然而，第三方评估的内容主要是“三率一度”。“漏评率、错退率、综合贫困发生率”都是客观指标，但“群众满意度”却是一个主观指标。如果说“三率”可以通过加大投入来解决的话，“群众满意度”却有着更为复杂的背景。甚至于，连第三方也很清楚，贫困户里面客观存在“懒汉户”，而这一部分贫困人口恰恰容易依赖政府，也更有可能提出各种无理要求。为了让他们“满意”，扶贫干部大多数时候只能选择妥协。导致的结果是，“扶贫先扶志”这一重要的工作方法，反而被忽视了。二是扩大了“官僚病”，形成了“技术专权”。带着专业主义的光环，第三方评估的结果被认定为更具权威性、客观性。如果真正遵循绩效评估的原则，倒也还好；然而，一旦它被吸纳进政策监督的轨道，在无形中就强化了上级的专断权力。在传统的上下级关系中，下级受到不公待遇，还可以通过不同的渠道申诉；但在“技术专权”面前，下级对上级几乎没有任何讨价还价的能力。\n\n⏱ 2024-11-19 17:45:14\n\n\n给基层减负，到底该怎么减？\n其实，作风问题仅仅是产生形式主义、官僚主义的直接原因，深层次的原因还是基层治理任务重与治理能力较低之间的矛盾。黄仁宇在《中国大历史》中反复强调了传统中国的一个现实：大国缺乏数目字管理能力，因此产生诸多问题。也就是说，在一个大的疆域中，上下级之间的信息沟通是现代化治理的基础。但实际上，在信息传递如此高效的今天，上下级之间的信息不对称问题依然严重。本质上，督查检查考核主要就是因为上级没能对基层信息充分掌握，而产生不信任。从另一方面讲，上级如果掌握不了基层信息，就无法实现其控制权，治理目标也就无从谈起。\n\n⏱ 2024-11-19 20:00:56\n\n\n然而，需要警惕的是，技术进步并不必然带来治理绩效的提高，如果官僚主义问题不解决，它还可能加剧形式主义，增加基层负担。\n\n⏱ 2024-11-19 20:22:11\n\n\n形式主义、官僚主义的顽疾，到底如何破除？\n“职能部门督查化”的现象应该引起高度重视，因为其必然孪生出另外两种现象：“属地政府背锅化”和“村级组织行政化”。为什么？不妨进行逻辑推演——上级部门把事情“甩”下来，到乡镇这一级，属地政府就没有地方可以甩了。事务繁多、考核压力大，乡镇事情做不完，就只能让村、社区一级本来应当是自治组织的人员“职业化”，来帮他一起干活；这就导致基层治理体系“悬浮”在基层社会之上，行政化的事务往往都做不完，更没有时间和群众直接接触。如果本职工作是和老百姓打交道、“打成一片”的村干部、社区干部都没有时间与群众打交道，上面的各级干部又如何完全知道百姓所思所想、所急所苦？\n\n⏱ 2024-11-19 20:37:24\n\n\n四 基层干部，怎么干\n税费改革后，作为基层治理主体的乡村两级组织开始转型，其中根本的变化是失去了财政自主性，主要依靠财政转移支付来维持运转。并且，上级政府通过乡财县管和村财乡管等制度设计，剥夺了乡村两级组织的财政权。自此以后，基层组织逐步“悬浮”于乡村社会，治理行为具有鲜明的“眼光向上”的特征。简言之，基层治理者失去了自主性，成了单纯的政策执行者。雪上加霜的是，基层组织不仅丧失了财政等治理资源，还在响应上级“公共服务型政府”的建设中，进一步弱化了治理职能。基层政府和村级组织很难再说自己是“治理者”，而是“服务者”。结果就是，不仅是上级，群众对基层干部的要求也越来越多。这还是在基层自由裁量权逐渐弱化的情况下出现的。\n\n⏱ 2024-11-20 13:12:58\n\n\n误解一：庸俗化理解为人民服务。为人民服务是我们党和政府的宗旨，这一点毋庸置疑。但是，我们的政府从来没有将为人民服务庸俗化地理解为市场关系中的“服务”。这两种“服务”的意义是不同的。为人民服务是一项政治原则，并不能等同于具体的行政过程。我们说干部是人民的公仆，主要是从政治要求来说的；而行政过程有其科学性，不能简单地用政治原则和行政价值来代替。再有，人民群众是一个需要分析的复数，不是任人摆布的单一“符号”。尤其是在当前的基层治理环境中，为人民服务应是为群众的整体利益服务。但很奇妙的是，过去一些年来的公共服务型政府改革，将这两种不同意义的“服务”融合，进而出现了“群众”以服务对象自居，要求基层干部按为人民服务的宗旨提供“无私服务”的画面。这种错位，造成了干群关系的扭曲：干部是可以无私，可那是为“人民”服务啊；一旦群众以“雇主”的心态要求干部时，不仅群众会面临期望过高的窘境，干部也会觉得很不适。\n\n⏱ 2024-11-20 13:17:26\n\n\n误解三：泛政治化。现如今，上级各部门在下达任务时，都要上升到讲政治的高度，要求基层配备足够的力量去完成任务。但问题是，基层哪来的三头六臂？如果所有事情都是政治任务，那不形式主义还能怎么办？事实上，绝大多数任务对于基层而言，应该是常规性的，犯不着“短平快”​，否则治理效果会适得其反。从政策执行的科学性来说，没有差别就没有政策，当事事都重大时，也就意味着事事都不重要。久而久之，基层干部逐渐变得疲惫不堪，群众看在眼里也只会“无感”而已了。\n\n⏱ 2024-11-21 11:43:28\n\n\n五 基层改革，怎么改\n社会学的一个好处，就是可以从纷繁复杂的现象里面找到一些核心机制，不一定非常准确，也不一定非常武断，但是确实给我们提供了看世界的一个角度。\n\n⏱ 2024-11-21 01:50:08\n\n\n基层社会有很多东西是处于由白到黑的过渡地带。很多事情从执法的角度去做，实际上并不容易，往往执法成本很高，或者根本就没办法执法。现代社会里面，村庄内部已经失去了自我规范、自我约束的能力，社会自我调节能力已经缺失了。\n\n⏱ 2024-11-21 01:53:08\n\n\n基层政权机构改革，路在何方？\n一般而言，中央和地方机构因其在国家治理体系中的位置不一样，改革的要求也会有显著差异。前者侧重于稳定性、统一性，后者则侧重于弹性和灵活性。\n\n⏱ 2024-11-21 01:57:36\n\n\n如何准确定位基层政权机构改革？简言之，基层政权机构是国家与群众关系的连接纽带，过去是、现在是、将来也是。基层政权机构改革必须面向人民群众，符合基层事务特点，归根到底是要强化其纽带作用。从当前来说，基层政权机构改革应强化其地方社会的“嵌入性”，适当从当地大学生、村干部中招聘乡镇干部，减少对乡镇工作的形式考核，强化驻村干部制度等。同时，应该坚决防止基层工作形式主义、文牍主义倾向。这一方面需要合理设计基层政权机构的职能，让其工作重心转移到与群众密切相关的生产生活事务上来，而不是关心一个个“项目”；另一方面需要改变基于文本的考核体系。基层干部的工作地点不应在办公室，而应在群众家里、田间地头、工地上。\n\n⏱ 2024-11-21 01:59:20\n\n\n一位基层民警牺牲背后的警界真问题\n简单说来，与普通人的想象不同，警察，尤其是基层民警，并不见得有多高的专业素养。某种意义上，他们就是普通人，但在做专业事，并且是职业风险比较高的事。\n\n⏱ 2024-11-21 11:11:13\n\n\n基层组织任期3年改为5年，背后有何考量？\n所谓“基层稳则天下安”，基层组织自始至终都被认为是国家治理成功与否的关键。村（社区）“两委”是党和国家最为基层的组织。它们虽不是正式行政体系的一部分，却毫无疑问是国家权力的毛细血管，对凝聚社会共识、落实国家政策都具有基石作用。基层组织始终包括党的基层组织和群众组织。今天的基层组织主要是指“两委”，在城市主要指的是社区党支部和社区居委会，在农村主要是指村支部和村委会。社区居委会和村委会都是群众性自治组织，无论是在历史脉络下还是在实践中，它们都在党的基层组织的领导下开展工作。基层组织是连接党和国家与群众的纽带。受国家与社会二元论的影响，有不少人都困惑于基层组织到底属于国家还是属于社会。但就中国实践而言，并不存在一个独立于国家的所谓的社会。甚至于，通常意义上的“基层社会”是相对“基层政府”来说的。简单而言，基层社会（组织）本来就是在党和政府的组织下才得以形成的。在这个意义上，基层组织是党和国家与群众的联系纽带。它的底色是“群众组织”，代表群众利益，这一点都没错。但它同时接受上级党组织的领导，在基层政权的指导下开展工作，有义务协助完成行政任务，这亦是事实。基层组织是国家治理体系的有机组成部分。改革开放以来，中国的乡村治理结构逐渐确定为“乡政村治”模式，即在乡镇一级设立基层政权组织，在行政村一级实行村民自治。在这一模式确立后的相当一段时间内，人们对村民自治/居民自治的功能定位存在一定程度的偏差，认为其主要功能便是赋予群众自治权利。尤其是1998年《村民委员会组织法》正式颁布后，绝大多数地区的村委会实行海选。现在看来，不得不说这一理解极具误导性，它将国家与社会、行政与自治简单对立起来，造成混乱。事实上，从国家治理体系看，“乡政村治”是一个有机体，行政和自治只有治理方式的差别，并不存在简单的对立和替代关系。哪怕是人民公社时期，“三级所有，队为基础”，将基本核算单位建立在生产队一级，生产队在组织生产、经济分配等方面亦有一定的自主性。只不过，基层向来是行政和自治的交汇点，两者之间的有机统一是要通过一系列行之有效的机制来实现的。不客气地说，以上关于基层组织的认识，或许在我们的文本中一直存在，但在实践中能够获得广泛共识，却是走过不少弯路才实现的。这便是基层组织任期改革的背景。\n\n⏱ 2024-11-21 11:26:20\n\n"},"阅读/盛唐到底盛在哪儿":{"title":"盛唐到底盛在哪儿","links":[],"tags":[],"content":"\n\n                  \n                  盛唐到底盛在哪儿 \n                  \n                \n\n\n\n《盛唐到底盛在哪儿》-  于赓哲\n出版时间： 2023-10-01 00:00:00\nISBN： 9787559479174\nPC地址：weread.qq.com/web/reader/d39329e0813ab83b6g011417\n\n\n\n第一章 大国气象：唐朝为何有开放包容的气质？\n\n唐朝文化，是草原游牧民族文化和中原传统文化的结合体。\n⏱ 2024-08-24 18:06:02\n\n\n在朝贡机制之下，中原王朝对少数民族以及外国的要求，就是用“朝贡”这种方式来表达他们的臣服。至于实际上贡了多少，中国皇帝根本不在乎。作为“天朝上国”的君主，他们并不在乎那点小钱，在外邦上贡之后，他们往往会以两倍、三倍甚至十倍的价值进行回馈。在这种机制之下，如果周边少数民族以及外国服从中国的朝贡机制，那么对于中国的皇帝来说，这就是他的属国；如果不服从，那就是与他为敌。甚至连唐代的皇帝死了之后，都要在他的陵墓前面竖立藩臣像，以示君临天下。\n⏱ 2024-08-25 13:45:04\n\n\n有一个问题在学界是不存在争论的，那就是唐朝的文化同时融合了草原游牧民族文化和中国传统本土文化。\n⏱ 2024-08-25 13:47:38\n\n\n唐朝开放包容的气质，来自它独特的历史渊源。它对待少数民族以及外国人的政策，并不见得同样适用于本国的国民。所以这种包容，有些地方令我们心驰神往、魂牵梦萦，有些地方也真的有它的历史局限性。\n⏱ 2024-08-25 13:48:58\n\n第二章 另类视角：日本、突厥、阿拉伯对唐朝看法各不相同？\n\n我们总觉得在唐朝的少数民族羁縻政策之下，各民族应该对唐朝的统治一致拥护，但事实并不是这样。\n⏱ 2024-08-25 22:45:53\n\n\n由于广州港的商贸非常繁荣，唐朝后来在广州设置了市舶使。市舶使承担的功能有点类似现在的海关，但它的主要职责并不是负责关税，而是满足皇室的需求，满足朝贡机制的需求。从这点上来说，市舶使又兼有部分“外交部”的色彩。\n⏱ 2024-08-25 22:47:33\n\n第三章 兼容并包：唐朝的各民族关系如何达到动态平衡？\n\n草原游牧民族的经济有一个特点，就是兴盛时看起来非常兴盛，衰落时又衰落得非常突然。这其中有一个重要的缘故，就是他们在经济基础这方面严重不如中原民族。他们的经济结构非常单一，虽然是以游牧经济为主，商业为辅，但是他们的商业也必须以游牧经济为基础。但游牧经济特别容易受到自然灾害的打击，所以他们的经济总体来看非常脆弱。旱灾、蝗灾、雪灾……一旦遭遇严重的自然灾害，这些游牧民族的经济立刻就会崩溃。\n⏱ 2024-08-25 22:52:45\n\n第四章 破除谬论：安史之乱是民族矛盾？和亲就是耻辱？\n\n在民族关系问题上，毋庸置疑的是，民族必须坚持自己的主体性，但也必须坚持开放包容的心态。中华民族能够由一个黄河中游的部落联盟，发展成现在这个大民族，正是靠着五千年来的兼容并蓄，这是民族坚韧性的由来。\n⏱ 2024-08-25 23:12:23\n\n\n有些人说，安史之乱是民族矛盾。确实，安史之乱的头目安禄山是粟特和突厥的混血，史思明是粟特人，但在唐朝前期开疆辟土的过程中，胡兵胡将也起到了至关重要的作用。唐朝的名人中有相当多的胡人，在镇压安史叛军的队伍中也有为数众多的胡兵胡将，这一点我们也不应忽视。\n⏱ 2024-08-25 23:16:27\n\n第五章 叛乱背后：安禄山为啥要养八千义子？揭开不一样的大唐文明史\n\n但安史之乱爆发的主要原因并不在于民族矛盾，而是因为经济基础变化引发了兵制变化。这种变化被野心家利用，才造成了这样的局面。\n⏱ 2024-08-25 23:22:46\n\n\n府兵制建立的基础是均田制，均田制把土地分配给了农民，而享有了权利的农民就要对国家尽义务，给国家服兵役。征调上来的府兵交给全国数百个兵府管理，而这些兵府的部署很有讲究——“内重而外轻”，这是关陇集团军功贵族集团特色的展现。\n⏱ 2024-08-25 23:23:38\n\n\n到了唐玄宗时期，历史背景已经发生了巨大的变化，均田制走向了崩溃。其实均田制从创立的第一天开始，就已经注定了这样的结局。原因很简单，均田制创立的前提是国家掌握了大量的无主荒田。国家手头有资源，人口又不够多，在这种情况下，均田制才能成功施行。可是到了盛唐时期，情况与北魏有了本质上的变化，人口总量呈几何级增长，土地增长速度远远赶不上人口增长速度，所以均田制的崩溃是迟早会发生的。\n⏱ 2024-08-25 23:24:52\n\n\n均田制的崩溃，导致了府兵制的瓦解。到了开元中期，国家基本上已经无兵可调了，兵源出现了问题，只得将府兵制改为募兵制。募兵制，其实就是国家职业军役制，国家雇人来当兵，并给予其很高的经济待遇。表面上看，这个措施很有效，能够在短时间内解决兵源的问题。唐玄宗把用这种形式招来的兵称为“长征健儿”。为什么呢？因为当时对外战争频繁进行，这些兵员主要被分配到边境地区，交给十个节度使统管。这意味着，西魏宇文泰时期的“内重外轻”，到了唐玄宗时期变成了相反的“外重内轻”。边境节度使权力坐大，中央腹心空虚，这种局面最后被野心家所利用，这就是安史之乱爆发的一个主要原因。\n⏱ 2024-08-25 23:25:55\n\n\n在安史之乱中，杨贵妃要承担的是用人方面的责任。她虽然没有做过干政的事，但是她的裙带关系导致了杨国忠的上台。\n⏱ 2024-08-26 17:16:48\n\n\n为什么说唐玄宗最后“玩脱了”呢？原因就在于他最后引入了边将集团。唐玄宗忽略了一个问题：边将和朝中其他的大臣是不一样的。朝中的大臣只能依靠皇帝，他们的权力和资源都来自皇帝。可募兵制之下的节度使不一样，他们手中有地盘，有军队，有财权，有人事权，俨然就是一个个“土皇帝”。唐玄宗没有意识到，在把他们引入朝中斗争之后，一旦他们在政治斗争中居于下风，就很可能会铤而走险，利用手中的一切资源来追求翻盘。所以，当安禄山在政治斗争中居于下风、眼见将要败给杨国忠的时候，他最后选择的就是铤而走险，掀起了叛乱。\n⏱ 2024-08-25 23:35:20\n\n第六章 转折之战：怛罗斯之战是中华民族命运转折点？\n\n怛罗斯之战是鼎盛时期的唐帝国与鼎盛时期的阿拉伯帝国在中亚地区发生的一场正面冲突，双方各投入了数万人，最后的结果是唐军战败。\n⏱ 2024-08-25 23:38:59\n\n\n真正导致唐朝由盛转衰，乃至退出西域地区的主要因素，还是安史之乱。由于两个历史事件间隔只有四年多的时间，导致人们错误地归因，认为怛罗斯之战是西域的转折点，但其实不是的。\n⏱ 2024-08-25 23:39:52\n\n第七章 丝绸之路：对唐朝人的地理观和世界观的一次颠覆\n\n罗马帝国晚期最大的问题，就是使用黄金作为货币，中亚、西亚的这批商人在把中国的丝绸贩卖到罗马之后，直接拿着黄金离开，造成了黄金硬通货大量外流，罗马帝国由此陷入了财政危机。所以，丝绸贸易被认为是罗马帝国衰落的原因之一。\n⏱ 2024-08-28 23:02:52\n\n\n辣椒可是美洲的作物，是明朝末期传入中国的。因为是从海上来的，所以最初叫“海椒”。\n⏱ 2024-08-28 23:08:45\n\n第十一章 唐朝婚姻：唐人的婚姻观与贞操观\n\n在人类文明史上，家庭始终是社会的一个细胞，家庭问题永远是社会问题中的重中之重。\n⏱ 2024-09-12 00:59:19\n\n\n有人认为门第观念影响的只是皇家，或者说上层社会，其实不是的，老百姓也照样受影响。老百姓也喜欢攀高门，如果攀不上高门，在双方门第不相等的情况之下，就得多掏钱，这叫作“垫门彩”，就是垫脚石，拿钱说话，拿钱铺路。所以唐人的婚姻往往伴随着大额的钱财的出入，因为男方家要给女方抛彩礼，女方出嫁的时候还要带大量的嫁妆。\n⏱ 2024-09-12 01:04:44\n\n第十二章 科技发明：解密唐朝的那些黑科技\n\n为什么活字印刷应用范围那么窄，没能流行起来呢？一方面是因为泥活字本身不够坚固，容易损坏；另一个特别现实的社会原因是，泥活字排版需要大量有较高文化水平的排版工，而古代人受教育的程度普遍有限，拥有较高的文化水平的人大多选择科考入仕，不会去当排版工。而雕版印刷对工人的文化素质要求很低，只要认得编号就可以。印刷厂想找到合格的活字排版工很难，而找雕版印刷工人就简单多了。所以直到清代，中国的印刷术还是雕版印刷占据主体。\n⏱ 2024-09-12 12:27:24\n"},"阅读/置身事内：中国政府与经济发展":{"title":"置身事内：中国政府与经济发展","links":[],"tags":[],"content":"\n\n                  \n                  置身事内：中国政府与经济发展 \n                  \n                \n\n\n\n《置身事内：中国政府与经济发展》-  兰小欢\n出版时间： 2021-08-01 00:00:00\nISBN： 9787208171336\nPC地址：weread.qq.com/web/reader/2a332d10726332f72a34943\n\n\n\n前言 从了解现状开始\n\n在我国，政府不但影响“蛋糕”的分配，也参与“蛋糕”的生产，所以我们不可能脱离政府谈经济。\n⏱ 2024-06-27 11:43:39\n\n第一章 地方政府的权力与事务\n\n要理解政府治理和运作的模式，首先要了解权力和资源在政府体系中的分布规则，既包括上下级政府间的纵向分布，也包括同级政府间的横向分布。\n⏱ 2024-06-27 11:48:42\n\n\n事权划分三原则：外部性和受益范围原则、信息复杂性原则、激励相容原则。\n⏱ 2024-06-27 11:48:36\n\n\n发展经济是政府的核心任务，而招商引资需要调动各种资源和手段，所涉具体事务既深且广，远超主流经济学教科书中“公共服务”或“公共物品”的讨论范畴。了解招商引资，是理解地方政府深度融入经济发展过程的起点。\n⏱ 2024-06-27 11:48:58\n\n第一节 政府治理的特点\n\n中央与地方政府。央地关系历来是研究很多重大问题的主线。一方面，维持大一统的国家必然要求维护中央权威和统一领导；另一方面，中国之大又决定了政治体系的日常运作要以地方政府为主。历史上，央地间的权力平衡需要各种制度去维护，一旦失控，王朝就可能分裂甚至覆灭。\n⏱ 2024-06-28 11:36:46\n\n\n党和政府。中国共产党对政府的绝对领导是政治生活的主题。简单说来，党负责重大决策和人事任免，政府负责执行，但二者在组织上紧密交织、人员上高度重叠，很难严格区分。本书主题是经济发展，无须特别强调党政之分，原因有三。其一，地方经济发展依托地方政府。地方党委书记实质上依然是地方官，权力通常无法超越本地。(5)其二，制约政府间事权划分的因素，也制约着各级党委的分工。比如，信息沟通既是困扰上下级政府的难题，也是困扰上下级党委的难题。所以在讨论事权划分原理时，无须特别区分党和政府。其三，地方经济事务由政府部门推动和执行。虽然各部门都由党委领导，但地方上并无常设的专职党委机构来领导日常经济工作。\n⏱ 2024-06-28 11:39:41\n\n\n条块分割，多重领导。我国政治体系的一个鲜明特点是“层层复制”：中央的主要政治架构，即党委、政府、人大、政协等，省、市、县三级都完全复制，即所谓“四套班子”。中央政府的主要部委，除外交部等个别例外，在各级政府中均有对应部门，比如中央政府有财政部、省政府有财政厅、市县政府有财政局等。这种从上到下的部门垂直关系，被称为“条条”，而横向的以行政区划为界的政府，被称为“块块”。大多数地方部门都要同时接受“条条”和“块块”的双重领导。拿县教育局来说，既要接受市教育局的指导，又要服从县委、县政府的领导。通常情况下，“条条”关系是业务关系，“块块”关系才是领导关系，因为地方党委和政府可以决定人事任免。\n⏱ 2024-06-28 11:41:42\n\n\n制度设计的一大任务就是要避免把过多决策推给上级，减轻上级负担，提高决策效率，所以体制内简化决策流程的原则之一，就是尽量在能达成共识的最低层级上解决问题。(7)若是部门事务，本部门领导就可以决定；若是经常性的跨部门事务，则设置上级“分管领导”甚至“领导小组”来协调推进。\n⏱ 2024-06-28 13:01:36\n\n\n总的来说，我国有一套立足于自身历史和文化的政治制度。像所有政治制度一样，实际的权力运作与纸面的规章制度并不完全一致，但也绝不是任性随意的。在任何体制下，权力运作都受到两种约束：做事的能力及做事的意愿。前者取决于掌握的资源，后者取决于各方的积极性和主动性。\n⏱ 2024-06-28 13:02:46\n\n第二节 外部性与规模经济\n\n一件事情该不该由地方自主决定，可以从外部性的角度来考虑。若此事只影响本地，没有外部性，就该由本地全权处理；若还影响其他地方，那上级就该出面协调。比如市里建个小学，只招收本市学生，那市里就可以做决定。但如果本市工厂污染了其他城市，那排污就不能只由本市说了算，需要省里协调。如果污染还跨省，可能就需要中央来协调。因此行政区域大小应该跟政策影响范围一致。若因行政区域太小而导致影响外溢、需要上级协调的事情过多，本级政府也就失去了存在的意义。反过来讲，行政区划也限定了地方可调配的资源，限制了其政策的影响范围。\n⏱ 2024-06-28 13:04:19\n\n\n按照经典经济学的看法，政府的核心职能是提供公共物品和公共服务，比如国防和公园。\n⏱ 2024-06-28 23:33:44\n\n\n这些边界地区，在本省之内与主流文化隔阂，而与邻省同文化区的交流又被行政边界割裂，不利于经济发展。(16)这些因素在民国时期已存在，所以“三不管地带”才为革命时期的中国共产党提供了广阔空间。家喻户晓的革命圣地井冈山，就位于湖南、江西交界处的罗霄山脉之中。\n⏱ 2024-06-30 00:45:02\n\n\n从公共物品角度看，边界地区首先面临的是基础设施如道路网络的不足。\n⏱ 2024-06-30 00:45:50\n\n\n另一个曾长期困扰边界公共治理的问题是环境污染，尤其是跨省的大江、大河、大湖，比如淮河、黄河、太湖等流域的污染。这是典型的跨区域外部性问题。直到中央在2003年提出“科学发展观”，并且在“十五”和“十一五”规划中明确了降低水污染的具体目标之后，水质才开始显著改善。但省界处的问题依然没有完全解决。一些省份把水污染严重的企业集中到了本省边缘的下游区域，虽然本省的平均污染水平降低了，下游省份的污染却加重了。(19)\n⏱ 2024-06-30 00:46:56\n\n\n行政边界影响经济发展，地方保护主义和市场分割现象今天依然存在，尤其在生产要素市场上，用地指标和户籍制度对土地和人口流动影响很大。从长期看，消除这种现象需要更深入的市场化改革。但在中短期内，调整行政区划、扩大城市规模乃至建设都市圈也能发挥作用。目前的行政区划继承自古代社会和计划经济时期，并不能完全适应工业与现代服务业急速的发展和集聚。而且在像中国这样一个地区差异极大的大国，建设产品和要素的全国统一大市场必然是个长期过程，难免要先经过区域性整合。\n⏱ 2024-06-30 00:48:06\n\n\n撤县设区扩张了城市面积，整合了本地人口，将县城很多农民转化为了市民，有利于充分利用已有的公共服务，发挥规模收益。很多撤县设区的城市还吸引了更多外来人口。\n⏱ 2024-06-30 00:49:34\n\n第三节 复杂信息\n\n原则上，上级对下级的各项工作都有最终决策权，可以推翻下级所有决定。但上级不可能掌握和处理所有信息，所以很多事务实际上由下级全权处理。即使上级想干预，常常也不得不依赖下级提供的信息。\n⏱ 2024-06-30 00:50:55\n\n\n所以上级虽然名义上有最终决定权，拥有“形式权威”，但由于信息复杂、不易处理，下级实际上自主性很大，拥有“实际权威”。维护两类权威的平衡是政府有效运作的关键。若下级有明显信息优势，且承担主要后果，那就该自主决策。若下级虽有信息优势，但决策后果对上级很重要，上级就可能多干预。但上级干预可能会降低下级的工作积极性，结果不一定对上级更有利。(22)\n⏱ 2024-06-30 00:51:31\n\n\n在实际工作中，“上级干预”和“下级自主”之间，没有黑白分明的区别，是个程度问题。工作总要下级来做，不可能没有一点自主性；下级也总要接受上级的监督和评价，不可能完全不理上级意见。但无论如何，信息优势始终是权力运作的关键要素。下级通常有信息优势，所以如果下级想办某件事，只要上级不明确反对，一般都能办，即使上级反对也可以变通着干，所谓“县官不如现管”；如果下级不想办某事，就可以拖一拖，或者干脆把皮球踢给上级，频繁请示，让没有信息优势的上级来面对决策的困难和风险，最终很可能就不了了之。即使是上级明确交代的事情，如果下级不想办，那办事的效果也会有很大的弹性，所谓“上有政策，下有对策”。\n⏱ 2024-06-30 00:52:52\n\n\n按照国务院2012年最新的《党政机关公文处理工作条例》（以下简称《条例》），公文共分15种，既有需要下级严格执行的“决定”和“命令”，也有可以相对灵活处理的“意见”和“通知”，还有信息含量较低的“函”和“纪要”等。每种公文的发文机关、主送机关、紧急程度以及密级，都有严格规定。\n⏱ 2024-06-30 00:56:37\n\n\n因为关键信息可能产生重大实际影响，所以也可能被利益相关方有意扭曲和隐瞒，比如地方的GDP数字。\n⏱ 2024-06-30 00:57:47\n\n\n绝大部分省份公布的增长目标都会高于中央，而绝大多数地市的增长目标又会高于本省。比如2014年中央提出的增长目标是7.5%，但所有省设定的目标均高于7.5%，平均值是9.7%。到了市一级，将近九成的市级目标高于本省，平均值上涨到10.6%。(26)这种“层层加码”现象的背后，既有上级层层施压和摊派的因素，也有下级为争取表现而主动加压的因素。但这些目标真能实现么？2017—2018年两年，不少省份（如辽宁、内蒙古、天津等）主动给GDP数字“挤水分”，幅度惊人，屡见报端。\n⏱ 2024-06-30 00:57:57\n\n\n正因为信息复杂多变，模糊不清的地方太多，而政府的繁杂事权又没有清楚的法律界定，所以体制内的实际权力和责任都高度个人化。我打个比方来说明规则模糊不清和权力个人化之间的关系。大学老师考核学生一般有两种方式：考试或写论文。若考卷都是标准化的选择题，那老师虽有出题的权力，但不能决定最后得分。但若考卷都是主观题，老师给分的自由度和权力就大一些。若是研究生毕业论文，不存在严格的客观判断标准，导师手中的权力就更大了，所以研究生称导师为“老板”，而不会称其他授课教师为“老板”。\n⏱ 2024-06-30 01:01:24\n\n\n所谓权力，实质就是在说不清楚的情况下由谁来拍板决策的问题。(29)如果这种说不清的情况很多，权力就一定会向个人集中，这也是各地区、各部门“一把手负责制”的根源之一，这种权力的自然集中可能会造成专权和腐败。\n⏱ 2024-06-30 01:02:12\n\n\n因为信息复杂，不可信的信息比比皆是，而权力和责任又高度个人化，所以体制内的规章制度无法完全取代个人信任。\n⏱ 2024-06-30 01:02:33\n\n第四节 激励相容\n\n上级政府想做的事大概分两类，一类比较具体，规则和流程相对明确，成果也比较容易衡量和评价。另一类比较抽象和宽泛，比如经济增长和稳定就业，上级往往只有大致目标，需要下级发挥主动性和创造性调动资源去达成。对于这两类事务，事权划分是不同的。\n⏱ 2024-06-30 11:34:43\n\n\n在专业性强、标准化程度高的部门，具体而明确的事务更多，更倾向于垂直化领导和管理。比如海关，主要受上级海关的垂直领导，所在地政府的影响力较小。这种权力划分符合激励相容原则：工作主要由系统内的上级安排，所以绩效也主要由上级评价，而无论是职业升迁还是日常福利，也都来自系统内部。\n⏱ 2024-06-30 11:35:48\n\n\n当上下级有冲突的时候，改革整个部门的管理体制只是解决方式之一，有时“微调”手段也很有效。\n⏱ 2024-06-30 11:38:26\n\n\n对于更宏观的工作，比如发展经济，涉及方方面面，需要地方调动各种资源。激励相容原则要求给地方放权：不仅要让地方负责，也要与地方分享发展成果；不仅要能激励地方努力做好，还要能约束地方不要搞砸，也不要努力过头。做任何事都有代价，最优的结果是让效果和代价匹配，而不是不计代价地达成目标。若不加约束，地方政府要实现短期经济高速增长目标并不难，可以尽情挥霍手中的资源，大肆借债、寅吃卯粮来推高增长数字，但这种结果显然不是最优的。\n⏱ 2024-06-30 11:44:33\n\n\n激励相容原则首先要求明确地方的权利和责任。我国事权划分的一大特点是“属地管理”：一个地区谁主管谁负责，以行政区划为权责边界。这跟苏联式计划经济从上到下、以中央部委为主调动资源的方式不同。属地管理兼顾了公共服务边界问题和信息优势问题，同时也给了地方政府很大的权力，有利于调动其积极性。\n⏱ 2024-06-30 11:44:54\n\n\n其次是权力和资源的配置要制度化，不能朝令夕改。无论对上级还是对下级，制度都要可信，才能形成明确的预期。制度建设，一方面是靠行政体制改革（比如前文中的工商和环保部门改革）和法制建设，另一方面是靠财政体制改革。明确了收入和支出的划分，也就约束了谁能调用多少资源，不能花过头的钱，也不能随意借债，让预算约束“硬”起来。\n⏱ 2024-06-30 11:46:48\n\n\n事权划分的三大原则：公共服务的规模经济、信息复杂性、激励相容。这三种视角从不同角度出发，揭示现象的不同侧面，但现象仍然是同一个现象，所以这三种视角并不冲突。比如行政区划，既与公共服务的规模有关，也和信息管理的复杂性有关，同时又为激励机制设定了权责边界。再比如基础设施建设，既能扩展公共服务的服务范围，又能提高信息沟通效率，还可以方便人、财、物流通，增强各地对资源的竞争，激励地方励精图治。\n⏱ 2024-07-06 20:47:35\n\n\n三大原则的共同主题是处理不同群体的利益差别与冲突。从公共服务覆盖范围角度看，不同人对公共服务的评价不同，享受该服务的代价不同，所以要划分不同的行政区域。从信息复杂性角度看，掌握不同信息的人，看法和判断不同，要把决策权交给占据信息优势的一方。从激励相容角度看，上下级的目标和能力不同，所以要设立有效的机制去激励下级完成上级的目标。假如不同群体间完全没有差别和冲突，那事权如何划分就不重要，对结果影响不大。完全没有冲突当然不可能，但如果能让各个群体对利益和代价的看法趋同，也能消解很多矛盾，增强互信。所以国家对其公民都有基本的共同价值观教育，包括历史教育和国家观念教育。而对官员群体，我国自古以来就重视共同价值观的培养与教化，今天依然如此。\n⏱ 2024-06-30 22:41:29\n\n第五节 招商引资\n\n地方政府的权力非常广泛。就发展经济而言，其所能调动的资源和采取的行动远远超过主流经济学强调的“公共服务”或“公共物品”范围。地方政府不仅可以为经济发展创造环境，它本身就是经济发展的深度参与者，这一点在招商引资过程中体现得淋漓尽致。\n⏱ 2024-07-06 20:47:40\n\n\n地方政府是城市土地的所有者，为了招商引资发展经济，会把工业用地以非常优惠的价格转让给企业使用，并负责对土地进行一系列初期开发，比如“七通一平”（通电、通路、通暖、通气、给水、排水、通信，以及平整场地）。\n⏱ 2024-07-01 00:23:03\n\n\n创造就业是地方经济工作的重点，也是维护社会稳定不可或缺的条件。\n⏱ 2024-07-01 00:25:23\n\n\n这种“混合经济”体系，不是主流经济学教科书中所说的政府和市场的简单分工模式，即政府负责提供公共物品、市场主导其他资源配置；也不是简单的“政府搭台企业唱戏”模式。而是政府及其各类附属机构（国企、事业单位、大银行等）深度参与大多数生产和分配环节的模式。在我国，想脱离政府来了解经济，是不可能的。\n⏱ 2024-07-01 00:26:55\n\n第二章 财税与政府行为\n\n要想把握政府的真实意图和动向，不能光读文件，还要看政府资金的流向和数量，所以财政从来不是一个纯粹的经济问题。\n⏱ 2024-07-01 11:44:38\n\n第一节 分税制改革\n\n如果要用一个词来概括20世纪80年代中国经济的特点，非“承包”莫属：农村搞土地承包，城市搞企业承包，政府搞财政承包。\n⏱ 2024-07-01 11:47:15\n\n\n财政承包始于1980年，中央与省级财政之间对收入和支出进行包干，地方可以留下一部分增收。1980—1984年是财政包干体制的实验阶段，1985年以后全面推行，建立了“分灶吃饭”的财政体制。(1)\n⏱ 2024-07-01 11:47:45\n\n\n既然是承包，当然要根据地方实际来确定承包形式和分账比例，所以财政包干形式五花八门，各地不同。比较流行的一种是“收入递增包干”。以1988年的北京为例，是以1987年的财政收入为基数，设定一个固定的年收入增长率4%，超过4%的增收部分都归北京，没超过的部分则和中央五五分成。假如北京1987年收入100亿元，1988年收入110亿元，增长10%，那超过了4%增长的6亿元都归北京，其余104亿元和中央五五分成。\n⏱ 2024-07-01 12:10:35\n\n\n至于预算总收入占GDP比重不断降低，原因则比较复杂。一方面，这跟承包制本身的不稳定有关。央地分成比例每隔几年就要重新谈判一次，若地方税收收入增长很快，下次谈判时可能会处于不利地位，落得一个更高的上缴基数和更吃亏的分成比例。为避免“鞭打快牛”，地方政府有意不让预算收入增长太快。另一方面，这也跟当时盛行的预算外收入有关。虽然地方预算内的税收收入要和中央分成，但预算外收入则可以独享。如果给企业减免税，“藏富于企业”，再通过其他诸如行政收费、集资、摊派、赞助等手段收一些回来，就可以避免和中央分成，变成可以完全自由支配的预算外收入。地方政府因此经常给本地企业违规减税，企业偷税漏税也非常普遍，税收收入自然上不去，但预算外收入却迅猛增长。\n⏱ 2024-07-01 12:09:37\n\n\n分税制改革，地方阻力很大。比如在财政包干制下过得很舒服的广东省，就明确表示不同意分税制。与广东的谈判能否成功，关系到改革能否顺利推行。时任财政部长刘仲藜和后来的财政部长项怀诚的回忆，生动地再现了当时的激烈博弈：（项怀诚）分税制的实施远比制订方案要复杂，因为它涉及地方的利益。当时中央财政收入占整个财政收入的比重不到30%，我们改革以后，中央财政收入占整个国家财政收入的比重达到55%，多大的差别！所以说，分税制的改革，必须要有领导的支持。为了这项改革的展开，朱镕基总理(6)亲自带队，用两个多月的时间先后走了十几个省，面对面地算账，深入细致地做思想工作……为什么要花这么大的力气，一个省一个省去跑呢，为什么要由一个中央常委、国务院常务副总理带队，一个省一个省去谈呢？因为只有朱总理去才能够和第一把手省委书记、省长面对面地交谈，交换意见。有的时候，书记、省长都拿不了主意的，后面还有很多老同志、老省长、老省委书记啊。如果是我们去，可能连面都见不上。（刘仲藜）与地方谈的时候气氛很紧张，单靠财政部是不行的，得中央出面谈。在广东谈时，谢飞(7)同志不说话，其他的同志说一条，朱总理立即给驳回去。当时有个省委常委、组织部长叫符睿（音）(8)就说：“朱总理啊，你这样说我们就没法谈了，您是总理，我们没法说什么。”朱总理就说：“没错，我就得这样，不然，你们谢飞同志是政治局委员，他一说话，那刘仲藜他们说什么啊，他们有话说吗？！就得我来讲。”一下就给驳回去了。这个场面紧张生动，最后应该说谢飞同志不错，广东还是服从了大局，只提出了两个要求：以1993年为基数、减免税过渡。(9)\n⏱ 2024-07-02 18:53:47\n\n\n这段故事我上课时经常讲，但很多学生不太理解为何谈判如此艰难：只要中央做了决策，地方不就只有照办的份儿吗？“00后”一代有这种观念，不难理解。一方面，经过分税制改革后多年的发展，今天的中央政府确实要比20世纪80年代末和90年代初更加强势；另一方面，公众所接触的信息和看到的现象，大都已经是博弈后的结果，而缺少社会阅历的学生容易把博弈结果错当成博弈过程。其实即使在今天，中央重大政策出台的背后，也要经过很多轮的征求意见、协商、修改，否则很难落地。成功的政策背后是成功的协商和妥协，而不是机械的命令与执行，所以理解利益冲突，理解协调和解决机制，是理解政策的基础。\n⏱ 2024-07-02 18:53:29\n\n\n地方能从“税收返还”中收到多少钱，取决于它在“基年”的增值税收入，所以这个“基年”究竟应该是哪一年，差别很大。中央与广东的谈判是在1993年9月，所以财政部很自然地想把“基年”定为1992年。时光不能倒流，地方做不了假。可一旦把“基年”定在1993年，那到年底还有三个多月，地方可能突击收税，甚至把明年的税都挪到今年来收，大大抬高税收基数，以增加未来的税收返还。所以财政部不同意广东的要求。但为了改革顺利推行，中央最终做了妥协，决定在全国范围内用1993年做基年。这个决定立刻引发了第四季度的收税狂潮，根据项怀诚和刘克崮的回忆：（项怀诚）实际上，9月份以后确实出现了这些情况。在那一年，拖欠了多年的欠税，都收上来了。一些地方党政领导亲自出马，贷款交税，造成了1993年后4个月财政收入大幅度增加。（刘克崮）……分别比上年同期增长60%、90%、110%和150%，带动全年地方税收增长了50%～60%(10)。(11)\n⏱ 2024-07-02 18:55:16\n\n\n企业所得税是我国的第二大税种，2018年占全国税收收入的23%。2002年改革之前，企业所得税按行政隶属关系上缴：中央企业交中央，地方企业交地方。\n⏱ 2024-07-02 18:56:18\n\n第二节 土地财政\n\n分税制并没有改变地方政府以经济建设为中心的任务，却减少了其手头可支配的财政资源。虽然中央转移支付和税收返还可以填补预算内收支缺口，但发展经济所需的诸多额外支出，比如招商引资和土地开发等，就需要另筹资金了。一方面，地方可以努力增加税收规模。虽然需要和中央分成，但蛋糕做大后，自己分得的收入总量也会增加。另一方面，地方可以增加预算外收入，其中最重要的就是围绕土地出让和开发所产生的“土地财政”。\n⏱ 2024-07-02 18:57:49\n\n\n改革前，企业的大多数税收按隶属关系上缴，改革后则变成了在所在地上缴，这自然会刺激地方政府招商引资。地方政府尤其青睐重资产的制造业，一是因为投资规模大，对GDP的拉动作用明显；二是因为增值税在生产环节征收，跟生产规模直接挂钩；三是因为制造业不仅可以吸纳从农业部门转移出的低技能劳动力，也可以带动第三产业发展，增加相关税收。\n⏱ 2024-07-08 17:42:26\n\n\n因为绝大多数税收征收自企业，且多在生产环节征收，所以地方政府重视企业而相对轻视民生，重视生产而相对轻视消费。以增值税为例，虽然企业可以层层抵扣，最终支付税金的一般是消费者（增值税发票上会分开记录货款和税额，消费者支付的是二者之和），但因为增值税在生产环节征收，所以地方政府更加关心企业所在地而不是消费者所在地。这种倚重生产的税制，刺激了各地竞相投资制造业、上马大项目，推动了制造业迅猛发展，加之充足高效的劳动力资源和全球产业链重整等内外因素，我国在短短二三十年内就成为世界第一制造业大国\n⏱ 2024-07-08 17:42:58\n\n\n我国实行土地公有制，城市土地归国家所有，农村土地归集体所有。农地要转为建设用地，必须先经过征地变成国有土地，然后才可以用于发展工商业或建造住宅\n⏱ 2024-07-08 17:44:29\n\n\n为什么会有这种城乡割裂的土地制度？追根溯源，其实也没有什么惊天动地的大道理和顶层设计，不过是从1982年宪法开始一步步演变成今天这样罢了。(18)虽说每一步变化都有道理，针对的都是当时亟待解决的问题，但演变到今天，已经造成了巨大的城乡差别、飞涨的城市房价以及各种棘手问题。\n⏱ 2024-07-08 17:44:48\n\n\n1998年发生了两件大事，城市土地的真正价值才开始显现。第一是单位停止福利分房，逐步实行住房分配货币化，商品房和房地产时代的大幕拉开。1997—2002年，城镇住宅新开工面积年均增速为26%，五年增长了近4倍。第二是修订后的《中华人民共和国土地管理法》开始实施，基本上锁死了农村集体土地的非农建设通道，规定了农地要想转为建设用地，必须经过征地后变成国有土地，这也就确立了城市政府对土地建设的垄断权力。\n⏱ 2024-07-18 22:59:44\n\n\n所谓“土地财政”，不仅包括巨额的土地使用权转让收入，还包括与土地使用和开发有关的各种税收收入。其中大部分税收的税基是土地的价值而非面积，所以税收随着土地升值而猛增。这些税收分为两类，一类是直接和土地相关的税收，主要是土地增值税、城镇土地使用税、耕地占用税和契税，其收入百分之百归属地方政府。\n⏱ 2024-07-24 18:22:57\n\n\n另一类税收则和房地产开发和建筑企业有关，主要是增值税和企业所得税。\n⏱ 2024-07-24 19:34:28\n\n\n土地转让虽然能带来收入，但地方政府也要负担相关支出，包括征地拆迁补偿和“七通一平”等基础性土地开发支出。从近几年的数字看，跟土地转让有关的支出总体与收入相当，有时甚至比收入还高。2018年，国有土地使用权出让金收入为62910亿元，支出则为68167亿元。光看这一项，地方政府还入不敷出。当然地方政府本来也不是靠卖地赚钱，它真正要的是土地开发之后吸引来的工商业经济活动。\n⏱ 2024-07-24 19:35:09\n\n\n所以商住用地虽然面积上只占出让土地的一半，但贡献了几乎所有的土地使用权转让收入。因此“土地财政”的实质是“房地产财政”。一方面，各地都补贴工业用地，大力招商引资，推动了制造业迅猛发展；另一方面，随着工业化和城市化的发展，大量新增人口涌入经济发达地区，而这些地方的住宅用地供给却不足，房价自然飞涨，带动地价飞涨，土地拍卖的天价“地王”频出。\n⏱ 2024-07-24 19:36:52\n\n\n前文说过，地方在招商引资和城市化过程中，会利用手中一切资源，所以需要通盘考量税收和土地，平衡税收收入和土地使用权转让收入，以达到总体收入最大化。地方政府压低工业用地价格，因为工业对经济转型升级的带动作用强，能带来增值税和其他税收，还能创造就业。而且工业生产率提升空间大、学习效应强，既能帮助本地实现现代化，也能带动服务业的发展，拉动商住用地价格上涨。工业生产上下游链条长，产业集聚和规模经济效果显著，若能发展出特色产业集群（如佛山的陶瓷），也就有了长久的竞争优势和稳定的税收来源。此外，地方之间招商引资竞争非常激烈。虽说工业用地和商住用地都由地方政府垄断，但工业企业可以落地的地方很多，所以在招商引资竞争中地方政府很难抬高地价。商住用地则不同，主要服务本地居民，土地供应方的垄断力量更强，更容易抬高地价。\n⏱ 2024-07-24 19:40:42\n\n\n经济学家张五常曾做过一个比喻：地方政府就像一家商场，招商引资就是引入商铺。商铺只要交一个低廉的入场费用（类似工业用地转让费），但营业收入要和商场分成（类似增值税，不管商铺是否盈利，只要有流水就要分成）。商场要追求总体收入最大化，所以既要考虑入门费和租金的平衡，也要考虑不同商铺间的平衡。一些商铺大名鼎鼎，能为商场带来更大客流，那商场不仅可以免除它们的入门费，还可以降低分成，甚至可以倒贴（类似地方给企业的各种补贴）。(21)\n⏱ 2024-07-24 19:41:18\n\n\n以行政区划为单位、以税收和土地为手段展开招商引资竞争，且在上下级政府间层层承包责任和分享收益，这一制度架构对分税制改革后经济的飞速发展，无疑有很强的解释力。但随着时代发展，这种模式的弊端和负面效果也越来越明显，需要改革。首先是地方政府的债务问题（见第三章）。土地的资本化运作，本质是把未来的收益抵押到今天去借钱，如果借来的钱投资质量很高，转化成了有价值的资产和未来更高的收入，那债务就不是大问题。但地方官员任期有限，难免会催生短视行为，寅吃卯粮，过度借债去搞大项目，搞“面子工程”，功是留在当代了，利是不是有千秋，就是下任领导的事了。如此一来，投资质量下降，收益不高，债务负担就越来越重。若仅仅只是债务问题，倒也不难缓解。最近几年实施了一系列财政和金融改革，实际上已经遏制住了债务的迅猛增长。但经济增速随之放缓，说明资源的使用效率仍然不高。就拿土地来说，虽然各地都有动力调配好手中的土地资源，平衡工业和商住用地供给，但在全国范围内，土地资源和建设用地分配却很难优化。地区间虽然搞竞争，但用地指标不能跨省流动到效率更高的地区。珠三角和长三角的经济突飞猛进，人口大量涌入，却没有足够的建设用地指标，工业和人口容量都遭遇了人为的限制。\n⏱ 2024-07-25 00:21:08\n\n\n可是制度一直如此，为什么前些年问题似乎不大？因为经济发展阶段变了。在工业化和城市化初期，传统农业生产率低，只要把农地变成工商业用地，农业变成工商业，效率就会大大提升。但随着工业化的发展，市场竞争越来越激烈，技术要求越来越高，先进企业不仅需要土地，还需要产业集聚、研发投入、技术升级、物流和金融配套等，很多地方并不具备这些条件，徒有大量建设用地指标又有何用？\n⏱ 2024-07-25 00:21:09\n\n第三节 纵向不平衡与横向不平衡\n\n分税制改革之后，中央和省分成，省也要和市县分成。可因为上级权威高于下级，所以越往基层分到的钱往往越少，但分到的任务却越来越多，出现了“财权层层上收，事权层层下压”的局面。改\n⏱ 2024-07-25 00:21:07\n\n\n从全国平均来看，地方财政预算收入（本级收入加上级转移支付）普遍仅够给财政供养人员发工资，但地区间差异很大。在东部沿海，随着工业化和城市化的大发展，可以从“土地财政”中获取大量额外收入，一手靠预算财政“吃饭”，一手靠土地财政“办事”。但在很多中西部县乡，土地并不值钱，财政收入可能连发工资都不够，和用于办事的钱相互挤占，连“吃饭财政”都不算，要算“讨饭财政”。(23)基层政府一旦没钱，就会想办法增收，以保持正常运转。\n⏱ 2024-07-25 00:18:35\n\n\n农村税费改革降低了农民负担，但也让本就捉襟见肘的基层财政维持起来更加艰难，所以之后的改革就加大了上级的统筹和转移支付力度。其一，是把农村基本公共服务开支纳入国家公共财政保障范围，由中央和地方政府共同负担。\n⏱ 2024-07-25 00:49:02\n\n\n其二，是在转移支付制度中加入激励机制，鼓励基层政府达成特定目标，并给予奖励。比如2005年开始实施的“三奖一补”，就对精简机构和人员的县乡政府给予奖励。(28)冗员过多一直是政府顽疾，分税制改革后建立的转移支付体系中，相当一部分转移支付是为了维持基层政府正常运转和保障人员工资。财政供养人员（即有编制的人员）越多，得到的转移支付越多，这自然会刺激地方政府扩编。\n⏱ 2024-07-25 00:48:53\n\n\n其三，是把基层财政资源向上一级政府统筹，比如2003年开始试点的“乡财县管”改革。农村税费改革后，乡镇一级的财政收入规模和支出范围大大缩减，乡镇冗员问题、管理问题、债务问题就变得突出。通过预算共编、票据统管、县乡联网等手段，把乡镇财政支出的决定权上收到县，有利于规范乡镇行为，也有利于在县域范围内实现乡镇之间公共服务的均等化。\n⏱ 2024-07-25 00:49:38\n\n\n让县政府去统筹乡镇财务，那县一级的财政紧张状况又该怎么办呢？在市管县的行政体制下，县的收入要和市里分账，可市财政支出和招商引资却一直偏向市区，“市压县，市刮县，市吃县”现象严重，城乡差距不断拉大。而且很多城市本身经济发展水平也不高，难以对下辖县产生拉动作用，所以在21世纪初，全国开始推行“扩权强县”和“财政省直管县”改革。前者给县里下放一些和市里等同的权限，比如土地审批、证照发放等；后者则让县财政和省财政直接发生关系，绕开市财政，在财政收支权力上做到县市平级。这些改革增加了县一级的财政资源，缩小了城乡差距。\n⏱ 2024-07-25 01:00:52\n\n\n但在其他一些省份，“省直管县”改革至少遭遇了两个困难。首先是省里管不过来。改革前，一个省平均管12个市，改革后平均管52个市县。钱和权给了县，但监管跟不上，县域出现了种种乱象，比如和土地有关的腐败盛行。其次，县市关系变动不一定有利于县的长远发展。以前县归市管，虽受一层“盘剥”，但跟市区通常还是合作大于竞争。但改革以后，很多情况下竞争就大于合作了，导致县域经济“孤岛化”比较严重。尤其在经济欠发达地区，市的实力本就不强，现在进一步分裂成区和县，更难以产生规模和集聚效应。经济弱市的“小马”本就拉不动下辖县的“大车”，但改革并没有把“小马”变成“大马”，反倒把“大车”劈成了一辆辆“小车”，结果是小城镇遍地开花，经济活动和人口不但没有向区域经济中心的市区集聚，反而越搞越散。从现有研究来看，省直管县之后，虽然县里有了更多资源，但人均GDP增速反而放缓了。\n⏱ 2024-07-25 01:05:16\n\n\n中央对地方的转移支付大概可以分为两类：一般性转移支付（2009年之后改称“均衡性转移支付”）和专项转移支付。(35)简单来说，前者附加条件少，地方可自行决定用途，而后者必须专款专用。为什么要指定资金用途、不让地方自主决策呢？因为无条件的均衡性转移支付是为了拉平地区差距，所以越穷的地方拿到的钱越多，地方也就越缺乏增收动力。而且均衡性转移支付要保证政府运作和公务员工资，可能会刺激财政供养人员增加，恶化冗员问题。专项转移支付约占转移支付总额的四成，一般以“做项目”的形式来分配资金，专款专用，可以约束下级把钱花在上级指定的地方，但在实际操作中，这种转移支付加大了地区间的不平等。(\n⏱ 2024-07-25 01:23:36\n\n\n)经济情况越好、财力越雄厚的地区，反而可能拿到更多的专项转移支付项目，原因有三。第一，上级分配项目时一般不会“撒胡椒面儿”，而是倾向于集中财力投资大项目，并且交给有能力和条件的地区来做，所谓“突出重点，择优支持”。第二，2015年之前，许多项目都要求地方政府提供配套资金，只有有能力配套的地方才有能力承接大项目，拿到更多转移支付。(37)第三，项目审批过程中人情关系在所难免。很多专项资金是由财政部先拨款给各部委后再层层下拨，所以就有了“跑部钱进”的现象，而经济发达地区往往与中央部委的关系也更好。(38)\n⏱ 2024-07-25 01:25:54\n\n结语\n\n分税制之后兴起的“土地财政”，为地方政府贡献了每年五六万亿的土地使用权转让收入，着实可观，但仍不足以撬动飞速的工业化和城市化。想想每年的基础设施建设投入，想想高铁从起步到普及不过区区十年，钱从哪里来？每个城市都在大搞建设，高楼、公园、道路、园区……日新月异，钱从哪里来？所以土地真正的力量还不在“土地财政”，而在以土地为抵押而撬动的银行信贷与其他各路资金。“土地财政”一旦嫁接了资本市场，加上了杠杆，就成了“土地金融”，能像滚雪球般越滚越大，推动经济飞速扩张，也造就了地方政府越滚越多的债务，引发了一系列宏观经济问题。\n⏱ 2024-07-25 01:31:51\n\n第三章 政府投融资与债务\n\n再穷的国家也有大片土地，土地本身并不值钱，值钱的是土地之上的经济活动。若土地只能用来种小麦，价值便有限，可若能吸引来工商企业和人才，价值想象的空间就会被打开，笨重的土地就会展现出无与伦比的优势：它不会移动也不会消失，天然适合做抵押，做各种资本交易的压舱标的，身价自然飙升。土地资本化的魔力，在于可以挣脱物理属性，在抽象的意义上交易承诺和希望，将过去的储蓄、现在的收入、未来的前途，统统汇聚和封存在一小片土地上，使其价值暴增。由此产生的能量不亚于科技进步，支撑起了工业化和城市化的巨大投资。经济发展的奥秘之一，正是把有形资产转变成为这种抽象资本，从而聚合跨越空间和时间的资源。(1)\n⏱ 2024-07-25 01:36:27\n\n第一节 城投公司与土地金融\n\n我国政府不但拥有城市土地，也掌控着金融系统，自然会以各种方式参与实业投资，不可能置身事外。但实业投资不是买卖股票，不能随时退出，且投资过程往往不可逆：未能完成或未能正常运转的项目，前期的投入可能血本无归。所以政府一旦下场就很难抽身，常常不得不深度干预。在很长一段时期内，中国GDP增长的主要动力来自投资，这种增长方式必然伴随着政府深度参与经济活动。\n⏱ 2024-07-25 14:05:15\n\n\n成都文旅集团具有政府融资平台类公司的典型特征。第一，它持有从政府取得的大量土地使用权。这些资产价值不菲，再加上公司的运营收入和政府补贴，就可以撬动银行贷款和其他资金，实现快速扩张。\n⏱ 2024-07-25 16:52:19\n\n\n第二，盈利状况依赖政府补贴。\n⏱ 2024-07-25 16:52:28\n\n\n第三，政府的隐性担保可以让企业大量借款。\n⏱ 2024-07-25 16:52:38\n\n\n当地的融资平台公司一般只参与前期的拆迁和土地整理。用术语来说，一块划出来的“生地”，平整清理后才能成为向市场供应的“熟地”，这个过程称为“土地一级开发”。“一级开发”投入大、利润低，且涉及拆迁等复杂问题，一般由政府融资平台公司完成。之后的建设和运营称为“二级开发”，大都由房地产公司来做。\n⏱ 2024-07-25 17:02:07\n\n\n从运营模式上看，成都文旅集团有政府融资平台企业的显著特点，但大多数融资平台的主业不是旅游开发，而是工业园区开发和城市基础设施建设。\n⏱ 2024-07-25 17:02:41\n\n\n用房地产的盈利去反哺产业园区，这听起来很像第二章所描述的政府“土地财政”：一手低价供应工业用地，招商引资，换取税收和就业；一手高价供应商住用地，取得卖地收入。但政府“亏本”招商引资，图的是税收和就业，可作为民企的华夏幸福，又能从工业园区发展中得到什么呢？答案是它也可以和政府分享税收收益。园区内企业缴纳的税收（地方留存部分），减去园区运营支出，华夏幸福和政府可按约定比例分成。按照法律，政府不能和企业直接分享税收，但可以购买企业服务，以产业发展服务费的名义来支付约定的分成。\n⏱ 2024-07-25 17:06:22\n\n第二节 地方政府债务\n\n1994年分税制改革后，中央拿走了大部分税收。但因为有税收返还和转移支付，地方政府维持运转问题不大。但地方还要发展经济，要招商引资，要投资，都需要钱。随着城市化和商品房改革，土地价值飙升，政府不仅靠土地使用权转让收入支撑起了“土地财政”，还将未来的土地收益资本化，从银行和其他渠道借入了天量资金，利用“土地金融”的巨力，推动了快速的工业化和城市化。但同时也积累了大量债务。这套模式的关键是土地价格。只要不断地投资和建设能带来持续的经济增长，城市就会扩张，地价就会上涨，就可以偿还连本带利越滚越多的债务。可经济增速一旦放缓，地价下跌，土地出让收入减少，累积的债务就会成为沉重的负担，可能压垮融资平台甚至地方政府。\n⏱ 2024-07-25 17:09:25\n\n\n要想在城市建设开发中引入银行资金，需要解决三个技术问题。第一，需要一个能借款的公司，因为政府不能直接从银行贷款；第二，城建开发项目繁复，包括自来水、道路、公园、防洪，等等，有的赚钱，有的赔钱，但缺了哪个都不行，所以不能以单个项目分头借款，最好捆绑在一起，以赚钱的项目带动不赚钱的项目；第三，仅靠财政预算收入不够还债，要能把跟土地有关的收益用起来。为解决这三个问题，城投公司就诞生了。\n⏱ 2024-07-25 19:59:22\n\n\n但是债务风险不能只看整体，因为欠债的不是整体而是个体。如果某人欠了1亿元，虽然理论上全国人民每人出几分钱就够还了，但实际上这笔债务足以压垮这个人。地方债也是一样的道理，不能用整体数字掩盖局部风险。纵向上看，层级越低的政府负担越重，风险越高。县级债务负担远高于省级，因为县级的经济发展水平更低，财政收入更少。横向上看，中西部的债务负担和风险远高于东部。(19)\n⏱ 2024-07-25 17:16:18\n\n\n简单来说，债务置换就是用地方政府发行的公债，替换一部分融资平台公司的银行贷款和城投债。这么做有三个好处。其一，利率从之前的7%—8%甚至更高，降低到了4%左右，大大减少了利息支出，缓解了偿付压力。低利率也有利于改善资本市场配置资金的效率。融资平台占用了大量银行贷款，也发行了大量城投债，因为有政府隐性担保，市场认为这些借款风险很低，但利率却高达7%—8%，银行（既是贷款主体，也是城投债主要买家）当然乐于做大这个低风险高收益的业务，不愿意冒险借钱给其他企业，市场平均利率和融资成本也因此被推高。这种情况严重削弱了利率调节资金和风险的功能，需要改革。其二，与融资平台贷款和城投债相比，政府公债的期限要长得多。因为基础设施投资的项目周期也很长，所以债务置换就为项目建设注入了长期资金，不用在短期债务到期后屡屡再融资，降低了期限错配和流动性风险。其三，至少从理论上说，政府信用要比融资平台信用更高，债务置换因此提升了信用级别。\n⏱ 2024-07-25 17:17:22\n\n第三节 招商引资中的地方官员\n\n事在人为，人才的选拔和激励机制是官僚体制的核心，决定着政府运作的效果。所谓激励机制，简单来说就是“胡萝卜加大棒”：事情做好了对个人有什么好处？搞砸了有什么坏处？因为发展经济是地方政府的核心任务，所以激励机制需要将干部个人得失与本地经济发展情况紧密挂钩，既要激励地方主官，也要激励基层公务员。\n⏱ 2024-07-25 19:59:23\n\n\n地方主官任期有限，要想在任内快速提升经济增长，往往只能加大投资力度，上马各种大工程、大项目。以市委书记和市长为例，在一个城市的平均任期不过三四年，而基础设施或工业项目最快也要两三年才能完成，所以“新官上任三把火”烧得又快又猛：上任头两年，基础设施投资、工业投资、财政支出往往都会快速上涨。而全国平均每年都有三成左右的地级市要更换市长或市委书记，所以各地的投资都热火朝天，“政治-投资周期”比较频繁。(24)投资需要资金，需要土地财政和土地金融的支持。所以在官员上任的前几年，土地出让数量一般都会增加。而新增的土地供应大多位于城市周边郊区，所以城市发展就呈现出了一种“摊大饼”的态势：建设面积越扩越大，但普遍不够紧凑，通勤时间长、成本高，加重了拥挤程度，也不利于环保。(25)\n⏱ 2024-07-25 17:21:32\n\n\n出于政绩考虑，地方官员在基础设施投资方面常常偏重“看得见”的工程建设，比如城市道路、桥梁、地铁、绿地等，相对忽视“看不见”的工程，比如地下管网。所以每逢暴雨，“看海”的城市就很多。(27)\n⏱ 2024-07-26 00:51:24\n\n\n在官员考核和晋升中，政绩非常重要，但这不代表人情关系不重要。无论是公司还是政府，只要工作业绩不能百分百清楚地衡量（像送快递件数那样），那上级的主观评价就是重要的，与上级的人情关系就是重要的。人情和业绩之间可能互相促进：业绩突出容易受领导青睐，而领导支持也有助于做好工作。但如果某些领导为扩大自己的权力和影响，在选人用人中忽视工作业绩，任人唯亲，就可能打击下属的积极性。在这类问题突出的地区，官僚体系为了约束领导的“任性”，可能在晋升中搞论资排辈，因为年龄和工龄客观透明，不能随便修改。但如此一来，政府部门的工作效率和积极性都会降低。(29)\n⏱ 2024-07-26 00:52:54\n\n\n政绩和晋升无疑对地方一把手和领导班子成员非常重要，却无法激励绝大多数公务员。他们的日常工作与政绩关系不大，晋升希望也十分渺茫。在庞大的政府工作人员群体中，“县处级”及以上的干部大约只占总人数的1%。平均来说，在一个县里所有的正科实职干部中，每年升副县级的概率也就1%，而从副县级干部到县委副书记，还要经历好几个岗位和台阶，动辄数年乃至数十年。(30)因此绝大多数政府工作人员最在意的激励并不是晋升，而是实际收入以及一些工作福利，包括工资、奖金、补助、补贴、实惠的食堂、舒适的办公条件，等等。\n⏱ 2024-07-26 00:54:00\n\n\n政府投资和土地金融的发展模式，一大弊端就是腐败严重。与土地有关的交易和投资往往金额巨大，且权力高度集中在个别官员手中，极易滋生腐败。\n⏱ 2024-07-26 00:56:17\n\n\n从经济发展的角度看，我国的腐败现象有两个显著特点。第一，腐败与经济高速增长长期并存。这与“腐败危害经济”这一过度简单化的主流观念冲突，以腐败为由唱空中国经济的预测屡屡落空。第二，随着改革的深入，政府和市场间关系在不断变化，腐败形式也在不断变化。20世纪80年代的腐败案件大多与价格双轨制下的“官倒”和各种“投机倒把”有关；90年代的案件则多与国企改革和国有资产流失有关；21世纪以来，与土地开发相关的案件成了主流。(34)\n⏱ 2024-07-26 00:57:24\n\n\n腐败大概可以分为两类。第一类是“掠夺式”腐败，比如对私营企业敲诈勒索、向老百姓索贿、盗用挪用公款等，这类腐败对经济增长和产权保护极其有害。随着我国各项制度和法制建设的不断完善、各种监督技术的不断进步，这类腐败已大大减少。\n⏱ 2024-07-26 00:58:26\n\n\n第二类腐败是“官商勾连共同发财式”腐败。比如官员利用职权把项目批给关系户企业，而企业不仅要完成项目、为官员贡献政绩，也要在私下给官员很多好处。这类腐败发生在招商引资过程中，而相关投资和建设可以促进经济短期增长，所以腐败在一段时期内可以和经济增长并存。\n⏱ 2024-07-26 00:59:08\n\n\n其一，长期偏重投资导致经济结构扭曲，资本收入占比高而劳动收入占比低，老百姓收入和消费增长速度偏慢。\n⏱ 2024-07-26 00:59:28\n\n\n其二，扭曲投资和信贷资源配置，把大量资金浪费在效益不高的关系户项目上，推升债务负担和风险。\n⏱ 2024-07-26 00:59:53\n\n\n其三，权钱交易扩大了贫富差距。\n⏱ 2024-07-26 01:00:07\n\n\n其四，地方上可能形成利益集团，不仅可能限制市场竞争，也可能破坏政治生态，出现大面积的“塌方式腐败”。\n⏱ 2024-07-26 01:00:18\n\n结语\n\n可见政府债务问题根源不在收入不够，而在支出太多，因为承担了发展经济的任务，要扮演的角色太多。因此债务问题不是简单的预算“软约束”问题，也不是简单修改政府预算框架的问题，而是涉及政府角色的根本性问题。改革之道在于简政放权，从生产投资型政府向服务型政府逐步转型。\n⏱ 2024-07-26 01:03:37\n\n扩展阅读\n\n如今的主流经济学教材中很少涉及“土地”。在生产和分配中，一般只讲劳动和资本两大要素，土地仅被视作资本的一种。而在古典经济学包括经典马克思主义经济学的传统中，土地和资本是分开的，地主和资本家也是两类人。这种变化与经济发展的阶段有关：在工业和服务业主导的现代经济中，农业的地位大不如前，所以农业最重要的资本投入——“土地”——也就慢慢被“资本”吞没了。然而土地和一般意义上的资本毕竟不同（供给量固定、没有折旧等），且如今房产和地产已成为国民财富中最重要的组成部分，所以应该重新把土地纳入主流微观和宏观经济学的框架，而不是仅将其归类到“城市经济学”或“房地产经济学”等分支。\n⏱ 2024-07-26 01:11:40\n\n第四章 工业化中的政府角色\n\n在每个具体行业中，由于技术、资源、历史等因素，政企合作的方式各不相同。钢铁是一回事，芯片是另一回事。因此，讨论和分析政府干预和产业政策，不能脱离具体行业细节，否则易流于空泛。社会现象复杂多变，任何理论和逻辑都可以找到不少反例，因为逻辑之外还有天时、地利、人和，不确定性和人为因素对结果影响非常大，而结果又直接影响到对过程和理论的评判。成功了才是宝贵经验，失败了只有惨痛教训。产业政策有成功有失败，市场决策也有成功有失败，用一种成功去质疑另一种失败，或者用一种失败去推崇另一种成功，争论没有尽头。\n⏱ 2024-07-26 01:09:39\n\n第一节 京东方与政府投资\n\n在一个只有几百万人口的小国，政府若投资和补贴国内企业，这些企业无法利用国内市场的规模经济来降低成本，必须依赖出口，那政府的投入实际上是在补贴外国消费者。但在我国，使用液晶屏幕的很多终端产品比如电视和手机，其全球最大的消费市场就在国内，所以液晶显示产业的外溢性极强。若本国企业能以更低的价格生产（不一定非要有技术优势，能够拉低国际厂商的漫天要价也可以），政府就可以考虑扶持本国企业进入，这不仅能打破国际市场的扭曲和垄断，还可以降低国内下游产业的成本，促进其发展。(15)\n⏱ 2024-07-26 13:05:21\n\n第二节 光伏发展与政府补贴\n\n光伏要依靠太阳能，晚上无法发电，电力供应不稳定，会对电网造成压力，因此电网一般不愿意接入光伏电站。但在“标杆电价”制度下，电网必须以固定价格持续购买光伏电量，期限20年，该价格高于光伏发电成本。这种价格补贴会加到终端电价中，由最终消费者分摊。这个固定价格会逐渐下调，以刺激光伏企业技术进步，提高效率。但事实上，价格下降速度慢于光伏的技术进步和成本下降速度，所以投资光伏发电有利可图。可以说我国光伏产业不仅是国内地方政府扶持出来的，也得益于德国、西班牙、意大利等国政府的“扶持”。\n⏱ 2024-07-31 13:27:54\n\n\n实际上，企业的效率提升和成本降幅远快于补贴降幅，同期光伏组件价格每年的下降幅度均超过30%，所以投资光伏电站有利可图，装机规模因此快速上升。\n⏱ 2024-07-31 13:30:18\n\n\n如果承认全球变暖事关人类存亡，那就必须发展可再生能源。即便不承认全球变暖，但承认我国传统能源严重依赖进口的局面构成了国家安全隐患，那也必须发展新能源。但传统能源已经积累了多年的技术和成本优势，新能源在刚进入市场时是没有竞争力的。就拿十几年前的光伏来说，度电成本是煤电的十几倍甚至几十倍，若只靠市场和价格机制，没人会用光伏。但新能源的技术升级和成本下降，只有在大规模的生产和市场应用中才能逐步发生，不可能只依靠实验室。实验技术再突破，若没有全产业链的工业化量产和技术创新，就不可能实现规模经济和成本下降。研发和创新从来不只是象牙塔里的活动，离不开现实市场，也离不开边干边学的企业。\n⏱ 2024-08-03 12:53:23\n\n\n所以新能源技术必须在没有竞争优势的时候就进入市场，这时候只有两个办法：第一是对传统能源征收高额碳税或化石燃料税，增加其成本，为新能源的发展制造空间；第二是直接补贴新能源行业。第一种办法明显不够经济，因为在新能源发展早期，传统能源占据九成以上的市场，且成本低廉，对其征收重税会大大加重税收负担，造成巨大扭曲。所以更加合理的做法是直接补贴新能源，加速其技术进步和成本降低，待其市场份额不断扩大、成本逼近传统能源之后，再逐渐降低补贴，同时对传统能源征税，加速其退出。(\n⏱ 2024-07-31 13:33:28\n\n\n从光伏产业的发展来看，政府的支持和补贴与企业成功不存在必然的因果关系。欧美日等先进国家不仅起步早、政府补贴早，而且企业占据技术、原料和设备优势，在和中国企业的竞争中还借助了“双反”等一系列贸易保护政策，但它们的企业最终衰落，纷纷退出市场。无论是补贴也好、贸易保护也罢，政策最多可以帮助企业降低一些财务风险和市场风险，但政府不能帮助企业克服最大的不确定性，即在不断变化的市场中发展出足够的能力和竞争优势。如果做不到这一点，保护和补贴政策最终会变成企业的寻租工具。这一点不仅对中国适用，对欧美也适用。但这个逻辑不能构成反对所有产业政策的理由。产业发展，无论政府是否介入，都没有必然的成功或失败。就新能源产业而言，补贴了虽然不见得会成功，但没有补贴这个行业就不可能存在，也就谈不上在发展过程中逐渐摆脱对补贴的依赖了。\n⏱ 2024-07-31 13:36:14\n\n\n“重复投资”并不总是坏事。在经济发展早期，各地政府扶持下的工业“重复投资”至少有两个正面作用。首先，当地工厂不仅提供了就业，也为当地农民转变为工人提供了学习场所和途径。“工业化”最核心的一环是把农民变成工人，这不仅仅是工作的转变，也是思想观念和生活习惯的彻底转变。这个转变不会自动发生，需要学习和培训，而这种学习和培训只能在工厂中完成。\n⏱ 2024-07-31 13:39:20\n\n\n“重复投资”的第二个好处是加剧竞争。蜂拥而上的低水平产能让“价格战”成为我国很多产品的竞争常态。所以在很长一段时间内，“成本创新”是本土创新的主流。虽然西方会将此讥讽为“仿造”和“山寨”，但其实成本创新和功能简化非常重要。\n⏱ 2024-07-31 13:40:43\n\n\n所以不管有没有政府扶持，要害都不是“重复建设”，而是“保持竞争”。市场经济的根本优势不是决策优势。面对不可知的未来，谁也看不清，自由市场上，失败也比成功多得多。市场经济的根本优势是可以不断试错，在竞争中优胜劣汰。(45)能保持竞争性的产业政策，与只扶持特定企业的政策相比，效果往往更好。(46)但所谓“特定”，不好界定。就算中央政府提倡的产业政策是普惠全行业的，并不针对特定企业，但到了地方政府，政策终归要落实到“特定”的本地企业头上。若地方政府保护本地企业，哪怕是低效率的“僵尸企业”也要不断输血和挽救，做不到“劣汰”，竞争的效果就会大打折扣，导致资源的错配和浪费。这是很多经济学家反对产业政策的主要原因。尤其是，我国地方政府有强烈的“大项目”偏好，会刺激企业扩张投资。企业一旦做大，就涉及就业、稳定和方方面面的利益，不容易破产重组。\n⏱ 2024-07-31 13:42:28\n\n\n所以产业政策要有退出机制，若效率低的企业不能退出，“竞争性”就是一句空话。“退出机制”有两层含义。第一是政策本身要设计退出机制。比如光伏的“标杆电价”补贴，一直在降低，所有企业都非常清楚补贴会逐渐退出，平价上网时代终会来临，所以有动力不断提升效率和降低成本。第二是低效企业破产退出的渠道要顺畅。这不仅涉及产业政策，也涉及更深层次的要素配置市场化改革。如果作为市场主体和生产要素载体的企业退出渠道不畅，要素配置的市场化改革也就难以深化。然而“破产难”一直是我国经济的顽疾。一方面，债权银行不愿走破产程序，因为会暴露不良贷款，无法再掩盖风险；另一方面，地方政府也不愿企业（尤其是大企业）走破产程序，否则职工安置和民间借贷等一系列矛盾会公开化。\n⏱ 2024-07-31 13:44:33\n\n第三节 政府产业引导基金\n\n私募基金，简单说来就是一群人把钱交给另一群人去管理和投资，分享投资收益。称其为“私募”，是为了和公众经常买卖的“公募”基金区别开。私募基金对投资人资格、募资和退出方式等都有特殊规定，不像公募基金的份额那样可以每天买卖。\n⏱ 2024-08-04 20:18:21\n\n\n举个简化的例子。LP投资100万元，基金延续两年，GP每年从中收取2万元管理费。若两年后亏了50万，那GP就只能挣两年总共4万的管理费，把剩下的46万还给LP，LP认亏。若两年后挣了50万，GP先把本金100万还给LP，再给LP约定的每年8%的收益，也就是16万。GP自己拿4万元管理费，剩下30万元的利润，GP提成20%也就是6万，剩余24万归LP。最终，GP挣了4万元管理费和6万元提成，LP连本带利总共拿回140万元。\n⏱ 2024-08-04 20:20:05\n\n\n与地方政府投资企业的传统方式相比，产业引导基金或投资基金有三个特点。第一，大多数引导基金不直接投资企业，而是做LP，把钱交给市场化的私募基金的GP去投资企业。一支私募基金的LP通常有多个，不止有政府引导基金，还有其他社会资本。因此通过投资一支私募基金，有限的政府基金就可以带动更多社会资本投资目标产业，故称为“产业引导”基金。同时，因为政府引导基金本身就是一支基金，投资对象又是各种私募基金，所以也被称为“基金中的基金”或“母基金”（fund of funds, FOF）。第二，把政府引导基金交给市场化的基金管理人运作，实质上是借用市场力量去使用财政资金，其中涉及诸多制度改革，也在实践中遭遇了各种困难（见下文）。第三，大多数引导基金的最终投向都是“战略新兴产业”，比如芯片和新能源汽车，而不允许投向基础设施和房地产，这有别于基础设施投资中常见的政府和社会资本合作的PPP模式（见第三章）。\n⏱ 2024-08-04 20:22:51\n\n\n政府不可以直接向银行借贷，所以需要设立城投公司。政府当然也不可以直接去资本市场上做股权投资，所以在设立引导基金之后，也需要成立专门的公司去管理和运营这支基金，通过这些公司把基金投资到其他私募基金手中。这些公司的运作模式大概分为三类。第一类与城投公司类似，是政府独资公司，如曾经投资过京东方的北京亦庄国投，就由北京经济技术开发区国有资产管理办公室持有100%股权。第二类是混合所有制公司。比如受托管理深圳市引导基金的深创投，其第一大股东是深圳市国资委，但持股占比只有28%左右。第三类则有点像上一章中介绍的华夏幸福。很多小城市的引导基金规模很小，政府没有能力也没有必要为其组建一家专业的基金管理公司，所以干脆把钱委托给市场化的母基金管理人去运营，比如盛世投资集团。\n⏱ 2024-08-04 20:26:23\n\n\n但从我国实践来看，政府引导基金的发展，需要三个外部条件。首先是制度条件。要想让财政预算资金进入风险很大的股权投资领域，必须要有制度和政策指引，否则没人敢做。其次是资本市场的发育要比较成熟。政府基金要做LP，市场上最起码得有足够多的GP去管理这些资金，还要有足够大的股权交易市场和退出渠道，否则做不起来。再次是产业条件。产业引导基金最终要流向高技术、高风险的战略新兴行业，而只有经济发展到一定阶段后，这样的企业才会大批出现。\n⏱ 2024-08-08 14:17:37\n\n\n引导基金大多采用“母基金”方式运行，与社会资本共同投资于市场化的私募基金，通过后者投资未上市公司的股权。这种模式的繁荣，需要三个条件：有大量的社会资本可以参与投资、有大量的私募基金管理人可以委托、有畅通的投资退出渠道。其中最重要的是畅通的资本市场退出渠道。\n⏱ 2024-08-08 14:36:22\n\n结语\n\n经济发展是企业、政府、社会合力的结果，具体合作方式取决于各自占有的资源，而这些资源禀赋的分布格局由历史决定。我国的经济改革脱胎于计划经济，政府手中掌握大量对产业发展至关重要的资源，如土地、银行、大学和科研机构等，所以必然会以各种方式深度参与工业化进程。政府和市场间没有黑白分明的界限，几乎所有的重要现象，都是这两种组织和资源互动的结果。要想认识复杂的世界，需要小心避免政府和市场的二分法，下过于简化的判断。\n⏱ 2024-08-09 19:41:56\n\n第五章 城市化与不平衡\n\n城市化需要投入大量资金建设基础设施，“土地财政”和“土地金融”是非常有效的融资手段。通过出让城市土地使用权，可以积累以土地为信用基础的原始资本，推动工业化和城市化快速发展。中国特有的城市土地国有制度，为政府垄断土地一级市场创造了条件，将这笔隐匿的财富变成了启动城市化的巨大资本，但也让地方财源高度依赖土地价值，依赖房地产和房价。房价连着地价，地价连着财政，财政连着基础设施投资，于是经济增长、地方财政、银行、房地产之间就形成了“一荣俱荣，一损俱损”的复杂关系。这种以土地为中心的城市化忽视了城市化的真正核心：人。地价要靠房价拉动，但房价要由老百姓买单，按揭要靠买房者的收入来还。所以土地的资本化，实质是个人收入的资本化。支撑房价和地价的，是人的收入。忽略了人，忽略了城市化本该服务于人，本该为人创造更好的环境和更高的收入，城市化就入了歧途。\n⏱ 2024-08-10 02:57:27\n\n第一节 房价与居民债务\n\n1994年分税制改革（第二章）是很多重大经济现象的分水岭，也是城市化模式的分水岭。1994年之前实行财政包干制，促进了乡镇企业的崛起，为工业化打下了基础，但农民离土不离乡，大多就地加入乡镇企业，没有大量向城市移民。分税制改革后，乡镇企业式微，农民工大潮开始形成\n⏱ 2024-08-10 02:58:50\n\n\n无论是发达国家还是发展中国家，房屋供需都与人口结构密切相关，因为年轻人是买房主力。年轻人大都流入经济发达城市，但这些城市的土地供应又受政策限制，因此房屋供需矛盾突出，房价居高不下。\n⏱ 2024-08-10 02:59:19\n\n\n地区房价差异的主要原因是供需失衡。人口大量涌入的大城市，居住用地的供给速度远赶不上人口增长。\n⏱ 2024-08-10 03:06:37\n\n\n中国对建设用地指标实行严格管理，每年的新增指标由中央分配到省，再由省分配到地方。这些指标无法跨省交易，所以即使面对大量人口流入，东部也无法从西部调剂用地指标。2003年后的十年间，为了支持西部大开发并限制大城市人口规模，用地指标和土地供给不但没有向人口大量流入的东部倾斜，反而更加向中西部和中小城市倾斜。\n⏱ 2024-08-10 03:10:20\n\n\n中西部房价虽低，但年轻人还是愿意到房价高的东部，因为那里有更多的工作机会和资源。倾斜的土地政策并没有留住人口，也很难留住其他资源。很多资本利用了西部的优惠政策和廉价土地，套取了资源，又回流到东部去“炒”房地产，没在西部留下可持续发展的经济实体，只给当地留下了一堆债务和一片空荡荡的工业园区。\n⏱ 2024-08-10 03:11:57\n\n\n建设用地指标不能在全国交易，土地使用效率很难提高。地方政府招商引资竞争虽然激烈，也经常以土地作为手段，却很难持续提高土地资源利用效率。发达地区土地需求旺盛，地价大涨，本应增加用地指标，既满足需求也抑制地价。但因为土地分配受制于行政边界，结果却是欠发达地区能以超低价格（甚至免费）大量供应土地。这种“东边干旱，西边浇水”的模式需要改革。2020年，中央提出要对建设用地指标的跨区域流转进行改革，探索建立全国性建设用地指标跨区域交易机制（见第二节），已是针对这一情况的改革尝试。(6\n⏱ 2024-08-10 03:13:32\n\n\n房地产常被称作“经济周期之母”，根源就在于其内在的供需矛盾：一方面，银行可以通过按揭创造几乎无限的新购买力；而另一方面，不可再生的城市土地供给却有限。这对矛盾常常会导致资产泡沫与破裂的周期循环，是金融和房地产不稳定的核心矛盾。而房地产不仅连接着银行，还连接着千家万户的财富和消费，因此影响很大。\n⏱ 2024-08-10 03:31:11\n\n\n根据中国人民银行的这项调查，城镇居民2019年的负债中有76%是房贷。而从资产端看，城镇居民的主要财产也就是房子。房产占了家庭资产的近七成，其中六成是住房，一成是商铺。而在美国居民的财富中，72%是金融资产，房产占比不到28%。(15)中国人财富的压舱石是房子，美国人财富的压舱石是金融资产。这个重大差别可以帮助理解两国的一些基本政策，比如中国对房市的重视以及美国对股市的重视。\n⏱ 2024-08-10 03:18:00\n\n\n总体看来，我国居民的债务负担不低，且仍在快速上升。最主要的原因是房价上涨。居民债务的攀升已然影响到了消费。\n⏱ 2024-08-10 03:33:04\n\n\n房价上涨不仅会增加按揭债务负担，还会拉大贫富差距，进而刺激低收入人群举债消费，这一现象被称为“消费下渗”（trickle-down consumption），这在发达国家是很普遍的。\n⏱ 2024-08-10 03:19:46\n\n\n居民债务居高不下，就很难抵御经济衰退，尤其是房产价格下跌所引发的经济衰退。低收入人群的财富几乎全部是房产，其中大部分是欠银行的按揭，负债率很高，很容易受到房价下跌的打击。\n⏱ 2024-08-10 03:20:40\n\n\n要化解居民债务风险，除了遏制房价上涨势头以外，根本的解决之道还在于提高收入，尤其是中低收入人群的收入，鼓励他们到能提供更多机会和更高收入的地方去工作。\n⏱ 2024-08-10 03:27:34\n\n第二节 不平衡与要素市场改革\n\n地方政府长期倚重投资，还会导致收入分配偏向资本，降低劳动收入占比，对中低收入人群尤其不利。\n⏱ 2024-08-10 03:37:26\n\n\n要想平衡地区间的发展差距，关键是要平衡人均差距而不是规模差距。想达到地区间规模的平均是不可能的。让每个城市都像上海和北京一样，或者在内地再造长三角和珠三角这样巨大的工业和物流网络（包括港口），既无可能也无必要。现代经济越来越集聚，即使在欧美和日本，经济在地理上的集聚程度也依然还在加强，没有减弱。(24)所以理想的状况是达到地区间人均意义上的平衡。而要实现这种均衡，关键是让劳动力自由流动。\n⏱ 2024-08-10 03:41:23\n\n\n如果一个城市只想要高技能人才，结果多半会事与愿违：服务业价格会越来越高，收入会被生活成本侵蚀，各种不便利也会让生活质量下降，“高端人才”最终可能也不得不离开。\n⏱ 2024-08-10 03:45:44\n\n\n让更多人进入城市，尤其是大城市，逻辑上的好处是清楚的，但在现实中尚有很多争议，主要是担心人口涌入会造成住房、教育、医疗、治安等资源紧张。这种担心可以理解，任何城市都不可能无限扩张。劳动力自由流动意味着有人来也有人走，若拥挤带来的代价超过收益，自会有人离开。至于教育、医疗等公共服务，缓解压力的根本之道是增加供给，而不是限制需求。涌入城市的人是来工作和谋生的，他们不仅分享资源，也会创造资源。\n⏱ 2024-08-10 03:46:39\n\n\n城市化的核心不应该是土地，应该是人。要实现地区间人均收入均衡、缩小贫富差距，关键也在人。要真正帮助低收入群体，就要增加他们的流动性和选择权，帮他们离开穷地方，去往能为他的劳动提供更高报酬的地方，让他的人力资本更有价值。同时也要允许农民所拥有的土地流动，这些土地资产才会变得更有价值。\n⏱ 2024-08-10 03:51:23\n\n第三节 经济发展与贫富差距\n\n虽然收入差距在扩大，但因为经济整体在飞速增长，所以几乎所有人的绝对收入都在快速增加。经济增长的果实是普惠的。\n⏱ 2024-08-10 23:56:04\n\n\n累积的财富差距一般远大于每年的收入差距，因为有财富的人往往更容易积累财富，资产回报更高，可选择的投资方式以及应对风险的手段也更多。\n⏱ 2024-08-10 23:58:31\n\n\n)当经济增速放缓、新创造的机会变少之后，年轻人间的竞争会更加激烈，而其父母的财富优势会变得更加重要。如果“拼爹”现象越来越严重的话，社会对不平等的容忍程度便会下降，不安定因素会增加。\n⏱ 2024-08-10 23:59:32\n\n\n收入差距不可能完全消除，但社会也无法承受过大的差距所带来的剧烈冲突，因此必须把不平等控制在可容忍的范围之内。影响不平等容忍程度的因素有很多，其中最重要的是经济增速，因为经济增速下降首先冲击的是穷人收入。不妨想象正在排队的两队人，富人队伍前进得比穷人快，但穷人队伍也在不停前进，所以排队的穷人相对来说比较有耐心。但如果穷人的队伍完全静止不动，哪怕富人队伍的前进速度也减慢了，困在原地的穷人也会很快失去耐心而骚动起来。这种现象被称为“隧道效应”（tunnel effect），形容隧道中两条车道一动一静时，静的那条的焦虑和难耐。(\n⏱ 2024-08-11 00:02:13\n\n\n另一个影响不平等容忍度的因素是人群的相似性。\n⏱ 2024-08-11 00:06:15\n\n\n家庭观念也会影响对不平等的容忍度。在家庭观念强的地方，如果子女发展得好、有出息，自己的生活就算是有了保障，对贫富差距容忍度也会比较高，毕竟下一代还能赶上。而影响子女收入最重要的因素就是经济增长的大环境。\n⏱ 2024-08-11 00:07:43\n\n第六章 债务与风险\n\n人们在乐观时往往会低估负债的风险，过多借债。当风险出现时，又会因为债务负担沉重而缺乏腾挪空间，没办法应对。\n⏱ 2024-08-11 00:13:16\n\n第一节 债务与经济衰退\n\n债务关系让经济各部门之间的联系变得更加紧密，任何部门出问题都可能传导到其他部门，一石激起千层浪，形成系统风险。银行既贷款给个人，也贷款给企业。若有人不还房贷，银行就会出现坏账，需要压缩贷款；得不到贷款的企业就难以维持，需要减产裁员；于是更多人失去工作，还不上房贷；银行坏账进一步增加，不得不继续压缩贷款……如此，恶性循环便产生了。如果各部门负债都高，那应对冲击的资源和办法就不多，风吹草动就可能引发危机。\n⏱ 2024-08-11 00:19:32\n\n\n第一，负债率高的经济中，资产价格的下跌往往迅猛。若债务太重，收入不够还本，甚至不够还息，就只能变卖资产，抛售的人多了，资产价格就会跳水。这种情况屡见不鲜。\n⏱ 2024-08-11 00:20:23\n\n\n第二，资产价格下跌会引起信贷收缩，导致资金链断裂。借债往往需要抵押物（如房产和煤矿），若抵押物价值跳水，债权人（通常是银行）坏账就会飙升，不得不大幅缩减甚至干脆中止新增信贷，导致债务人借不到钱，资金链断裂，业务难以为继。\n⏱ 2024-08-11 00:20:41\n\n\n一个部门的负债对应着另一个部门的资产。债务累积或“加杠杆”的过程，就是人与人之间商业往来增加的过程，会推动经济繁荣。而债务紧缩或“去杠杆”也就是商业活动减少的过程，会带来经济衰退。举例来说，若房价下跌，老百姓感觉变穷了，就会勒紧裤腰带、压缩消费。东西卖不出去，企业收入减少，就难以还债，债务负担过高的企业就会破产，银行会出现坏账，压缩贷款，哪怕好企业的日子也更紧了。这个过程中物价和工资会下跌（通货紧缩），而欠的钱会因为物价下跌变得更值钱了，实际债务负担就更重了。(\n⏱ 2024-08-11 00:22:11\n\n\n债务带来的经济衰退还会加剧不平等（第五章），因为债务危机对穷人和富人的打击高度不对称。这种不对称源于债的特性，即法律优先保护债权人的索赔权，而欠债的无论是公司还是个人，即使破产也要清算偿债。以按揭为例，穷人因为收入低，买房借债的负担也重，房价一旦下跌，需要先承担损失，直到承担不起破产了，损失才转到银行及其债主或股东，后者往往是更富的人。换句话说，债务常常把风险集中到承受能力最弱的穷人身上。一个比较极端的例子是西班牙。在大多数国家，还不起房贷的人可以宣布破产，银行把房子收走，也就两清了。但在西班牙，哪怕房主把房子给了银行并宣布破产，也只能免于偿还按揭利息，本金仍然要偿还，否则累计的罚金和负债将一直存在，会上失信名单，很难正常生活。在金融危机中，这项法律引起了社会的不满和动荡，开锁匠和警察拒绝配合银行驱逐房主。破产了也消不掉的债成了沉重的负担：全球金融危机爆发五年后，西班牙是全球经济衰退最严重的国家之一。(7)\n⏱ 2024-08-11 00:32:09\n\n第二节 债台为何高筑：欧美的教训\n\n债务源于人性：总想尽早满足欲望，又对未来盲目乐观，借钱时总觉得将来能还上。但人性亘古不变，债务周期却有起有落，每一次起伏都由特定的外部因素推动，这些因素会引发乐观情绪、刺激人们借债，也会增加资金供给、为借债大开方便之门。\n⏱ 2024-08-11 00:37:11\n\n\n所以要理解债务的增长，首先要理解银行为什么会大量放贷。\n⏱ 2024-08-11 00:41:14\n\n\n资金供给的增加源于金融管制的放松。一方面，银行越做越大，创造的信贷越来越多；另一方面，金融创新和衍生品层出不穷，整个金融部门的规模和风险也越滚越大。\n⏱ 2024-08-11 00:41:54\n\n\n金融风险的核心是银行，历次金融危机几乎都伴随着银行危机。简单说来原因有四。(9)第一，银行规模大、杠杆高。\n⏱ 2024-08-11 00:51:36\n\n\n第二，银行借进来的钱很多是短期的（比如活期存款），但贷出去的钱却大都是长期的（比如企业贷款），这种负债和资产的期限不匹配会带来流动性风险。一旦储户集中提取存款，银行贷出去的钱又不能立刻收回来，手里钱不够，会出大乱子。后来银行业引入了存款保险制度，承诺对个人存款进行保险，才缓解了挤提风险，但并没有完全解除。现代银行业务复杂，早已不是简单的存贷款机构，很多负债并非来自个人存款，而是来自货币基金和对冲基金，并不受存款保险制度保护。(11)一旦机构客户信心不足或急需流动性，也会形成挤提。\n⏱ 2024-08-11 00:52:40\n\n\n第三，银行信贷大都和房地产有关，常常与土地和房产价值一同起落，放大经济波动。银行因为杠杆率高，所以要特别防范风险，贷款往往要求抵押物。土地和房子就是最好的抵押物，不会消失也不会跑掉，价值稳定，潜在用途广，就算砸手里也不难转让出去。因此银行喜欢贷款给房地产企业，也喜欢做居民按揭。\n⏱ 2024-08-11 00:53:12\n\n\n所以房地产周期和银行信贷周期常常同步起伏，而这两个行业的杠杆率又都不低，也就进一步放大了经济波动。\n⏱ 2024-08-11 00:54:22\n\n\n所以银行很少雪中送炭，却常常晴天送伞，繁荣时慷慨解囊、助推经济过热，衰退时却捂紧口袋、加剧经济下行。\n⏱ 2024-08-11 00:55:02\n\n\n第四，银行风险会传导到其他金融部门。比如银行可以把各种按揭贷款打包成一个证券组合，卖给其他金融机构。这种业务挫伤了银行信贷分析的积极性。如果银行借出去的钱转手就能打包卖给下家，那银行就不会在乎借钱的人是不是真的有能力还钱。击鼓传花的游戏，传的是什么东西并不重要，只要有人接盘就行。\n⏱ 2024-08-11 00:58:51\n\n\n金融自由化浪潮为借贷打开了方便之门，但如果没有大量资金涌入金融系统，借贷总量也难以增加。以美国为例，这些资金来源有二。其一，一些国家把钱借给了美国，比如我国就是美国最大的债主之一。其二，美国国内不平等急剧扩大，财富高度集中，富人有了更多花不完的钱可以借给穷人。\n⏱ 2024-08-11 12:10:41\n\n\n为保持美元的国际储备货币地位，美国的对外贸易可能需要常年保持逆差，以向世界提供更多美元。但持续的逆差会累积债务，最终威胁美元的储备货币地位，这个逻辑也被称为“特里芬悖论”。(1\n⏱ 2024-08-11 12:20:13\n\n\n国际资本流入不是美国可贷资金增加的唯一原因，另一个重要原因是国内的贫富差距。如果全部财富集中在极少数人手中，富人就会有大量的闲置资金可以借贷，而大部分穷人则需要借钱生存，债务总量就会增加。\n⏱ 2024-08-11 12:14:10\n\n\n一个原因是大公司把投资转移到了发展中国家（包括中国），制造业整体外迁。而制造业又是重资产和重投资的行业，所以国内制造业占比下降就推动了投资下降。\n⏱ 2024-08-11 12:17:55\n\n\n实体投资下降的另一个原因是发达国家经济的整体竞争性在减弱：行业集中度越来越高，大企业越变越大。理论上说，这不一定是坏事，若明星企业通过竞争击败对手、占据市场后依然锐意进取、积极创新，那么投资和生产率还会继续上升。然而实际情况是，美国各行业集中度的提高与企业规模的扩张，往往伴随着投资下降和生产率降低。\n⏱ 2024-08-11 12:18:25\n\n第三节 中国的债务与风险\n\n中国的债权人主要是银行，不仅发放贷款，也持有大多数债券。\n⏱ 2024-08-15 00:41:01\n\n\n所谓“影子银行”，就是类似银行的信贷业务，却不在银行的资产负债表中，不受银行监管规则的约束。\n⏱ 2024-08-15 00:42:58\n\n\n我国各种“影子银行”业务大都由银行主导，是银行链条的延伸，因此也被称为“银行的影子”。这与国外以非银金融机构主导的“影子银行”不同。中国的业务模式大多简单，无非多转了两道手而已，证券化程度不高，衍生品很少，参与的国际资本也很少，所以监管难度相对较低。\n⏱ 2024-08-15 00:44:17\n\n第四节 化解债务风险\n\n任何国家的债务问题，解决方案都可以分成两个部分：一是偿还已有债务；二是遏制新增债务，改革滋生债务的政治、经济环境。\n⏱ 2024-08-15 00:44:43\n\n\n还债让债务人不好过，赖账让债权人不好过。所以偿债过程很痛苦，还有可能陷入经济衰退。相比之下，增发货币也能缓解债务负担，似乎还不那么痛苦，因为没有明显的利益受损方，实施起来阻力也小。\n⏱ 2024-08-15 00:49:21\n\n\n增发货币的方式大概有三类。第一类是以增发货币来降低利率，这是2008年全球金融危机前的主流做法。低利率既能减少利息支出，也能刺激投资和消费，提振经济。若经济增长、实际收入增加，就可以减轻债务负担。就算实际收入不增加，增发货币也能维持稳定温和的通货膨胀，随着物价上涨和时间推移，债务负担也会减轻，因为欠的债慢慢也就不值钱了。第二类方式是“量化宽松”，即央行增发货币来买入各类资产，把货币注入经济，这是金融危机后发达国家的主流做法。在危机中，很多人变卖资产偿债，资产市价大跌，连锁反应后果严重。央行出手买入这些资产，可以托住资产价格，同时为经济注入流动性，让大家有钱还债，缓解债务压力。从记账角度看，增发的货币算央行负债，所以“量化宽松”不过是把其他部门的负债转移到了央行身上，央行自身的资产负债规模会迅速膨胀。但只要这些债务以本国货币计价，理论上央行可以无限印钱，想接手多少就接手多少。这种做法不一定会推高通货膨胀，因为其他经济部门受债务所困，有了钱都在还债，没有增加支出，也就没给物价造成压力。\n⏱ 2024-08-15 00:50:05\n\n\n“量化宽松”的主要问题是难以把增发的货币转到穷人手中，因此难以刺激消费支出，还会拉大贫富差距。央行“发钱”的方式是购买各种金融资产，所以会推高资产价格，受益的是资产所有者，也就是相对富裕的人。\n⏱ 2024-08-15 00:50:33\n\n\n第三类增加货币供给的做法是把债务货币化。政府加大财政支出去刺激经济，由财政部发债融资，央行直接印钱买过来，无需其他金融机构参与也无需支付利息，这便是所谓“赤字货币化”。\n⏱ 2024-08-15 00:51:24\n\n\n“赤字货币化”的核心，是用无利率的货币替代有利率的债务，以政府预算收支的数量代替金融市场的价格（即利率）来调节经济资源配置。\n⏱ 2024-08-15 00:53:27\n\n\n从理论上说，若私人部门陷入困境，而政府治理能力和财政能力过硬，“赤字货币化”也不是不能做。但若政府能力如此过硬却还是陷入了需要货币化赤字的窘境，那也正说明外部环境相当恶劣莫测。在这种情况下，“赤字货币化”的效果不能仅从理论推断，要看历史经验。从历史上看，大搞“赤字货币化”的国家普遍没有好下场，会引发物价飞涨的恶性通货膨胀，损害货币和国家信用，陷经济于混乱。\n⏱ 2024-08-15 00:54:09\n\n\n我国目前的货币政策比较谨慎，国务院和央行都数次明确表态不搞“大水漫灌”，“不搞竞争性的零利率或量化宽松政策”。(41)主要原因可能有二：第一，政府不愿看到宽松的货币政策再次推高房价，“房住不炒”是个底线原则；第二，货币政策治标不治本，无法从根本上解决债务负担背后的经济增速放缓问题，因为这是结构性的问题，是地方政府推动经济发展的模式问题。\n⏱ 2024-08-15 00:55:19\n\n\n总的说来，我国的债务问题是以出口和投资驱动的经济体系的产物。\n⏱ 2024-08-15 00:57:17\n\n\n而无论是基建还是房地产投资，都由掌握土地和银行系统的政府所驱动，由此产生的诸多债务，抛开五花八门的“外衣”，本质上都是对政府信用的回应。所形成的债务风险，虽然表现为债主银行的风险，但最终依然是政府风险。\n⏱ 2024-08-15 00:57:25\n\n\n限制债务增长的另一项根本性措施是资本市场改革，改变以银行贷款为主的间接融资体系，拓展直接融资渠道，既降低债务负担，也提高资金使用效率。与债权相比，股权的约束力更强。一来股东风险共担，共赚共赔；二来股权可以转让，股价可以约束公司行为。哪怕同样是借债，债券的约束力也比银行贷款强，因为债券也可以转让。\n⏱ 2024-08-15 00:58:14\n\n\n融资体系和投资体系是一体两面：谁来做投资决策，谁就该承担投资风险，融资体系也就应该把资源和风险向谁集中。若投资由政府和国企主导，风险也自然该由它们承担。目前的融资体系正是让政府承担风险的体系，因为银行的风险最终是政府的风险。\n⏱ 2024-08-15 00:59:34\n\n\n因此政府和国企主导投资与国有银行主导融资相辅相成，符合经济逻辑。这一体系在过去的经济增长中发挥过很大作用，但如果投资主体不变，权力不下放给市场，那想要构建降低政府和银行风险的直接融资体系、想让分散的投资者去承担风险，就不符合“谁决策谁担风险”的逻辑，自然进展缓慢。\n⏱ 2024-08-15 01:00:34\n\n\n总的来看，我国债务风险的本质不是金融投机的风险，而是财政和资源分配机制的风险。这些机制不是新问题，但债务负担在这十年间迅速上升，主要是因为这一机制已经无法持续拉动GDP增长。无论是实际生产率的增长还是通货膨胀速度，都赶不上信贷或债务增长的速度，所以宏观上就造成了高投资挤压消费，部分工业产能过剩和部分地区房地产投资过剩，同时伴随着腐败和行政效率降低。这种经济增长方式无法持续。最近几年的改革力图扭转这种局面，让市场在资源配置中，尤其是在土地和资本等要素配置中起更大作用。\n⏱ 2024-08-15 01:01:16\n\n第七章 国内国际失衡\n\n由于本土制造业体量巨大，全球产业链在向我国集聚，也带动了本土供应商越来越壮大。因此我国出口模式早已不是简单的“来料加工”，绝大部分出口价值均由本土创造。\n⏱ 2024-08-15 01:04:55\n\n\n这些巨大的成功背后，也隐藏着两重问题。第一是内部经济结构失衡：重生产、重投资，相对轻民生、轻消费，导致与巨大的产能相比，国内消费不足，而消化不了的产品只能对外输出。这就带来了第二个问题：国外需求的不稳定和贸易冲突。\n⏱ 2024-08-15 01:05:03\n\n第一节 低消费与产能过剩\n\n所以当我们观察到消费占GDP的比重下降时，无非就是两种情况：或者GDP中可供老百姓支配的收入份额下降了，或者老百姓把更大一部分收入存了起来，储蓄率上升了。实际上这两种情况都发生了。\n⏱ 2024-08-17 02:00:23\n\n\n在那些土地供应受限和房价上涨快的地区，居民要存钱付首付、还按揭，储蓄率自然上升，消费下降。虽然房价上涨会增加有房者的财富，理论上可能刺激消费，降低储蓄，但大多数房主只有一套房，变现能力有限，消费水平主要还是受制于收入，房价上升的“财富效应”并不明显。所以整体上看，房价上升拉低了消费，提高了储蓄。(6)\n⏱ 2024-08-17 02:03:23\n\n\n此外，地方政府常年按照户籍人口规模来规划公共服务供给，满足不了没有户籍的常住人口的需要\n⏱ 2024-08-17 02:05:10\n\n\n虽然相对发达国家而言，我国工业整体上还是劳动密集型的，但相对我国庞大的劳动力规模而言，工业确实存在资本投入过度的扭曲现象。加入WTO之后，一方面，进口资本品关税下降，增加了企业的资本投入；另一方面，工业在东南沿海集聚引发大规模人口迁移，而与户籍和土地有关的政策抬高了房价和用工成本，不利于外来人口安居乐业，“用工荒”现象屡有发生，企业于是更加偏向资本投入。(9)\n⏱ 2024-08-17 02:07:01\n\n\n假如穷国增长快而富国增长慢的话，久而久之，各国的经济发展水平应该趋同。但实际上并非如此——除了一个部门例外，那就是制造业。制造业生产率低的国家，生产率进步确实快，而制造业生产率高的国家，进步也的确慢。(14)可见制造业的学习效应极强，是后发国家赶超的基石。久而久之，后发国家的制造业生产率就有机会与先进国家“趋同”。那为什么经济整体却没有“趋同”呢？最关键的原因，是很多国家无法组织和动员更多资源投入制造业，无法有效启动和持续推进工业化进程。\n⏱ 2024-08-17 02:12:54\n\n\n因此，在经济发展初期，将更多资源从居民消费转为资本积累，变成基础设施和工厂，可以有效推动经济起飞和产业转型，提高生产率和收入。而且起步时百废待兴，基础设施和工业水平非常落后，绝大多数投资都有用，都有回报，关键是要加大投资，加速资本积累。而在资本市场和法律机制还不健全的情况下，以信用等级高的政府和国企来调动资源，主导基础设施和工业投资，是有效的方式。但当经济发展到一定阶段后，这种方式就不可持续了，会导致四个问题。第一，基础设施和工业体系已经比较完善，投资什么都有用的时代过去了，投资难度加大，因此投资决策和调配资源的体制需要改变，地方政府主导投资的局面需要改变。这方面前文已说过多次（第三章和第六章），不再赘述。第二，由于老百姓收入和消费不足，无法消化投资形成的产能，很多投资不能变成有效的收入，都浪费掉了，所以债务负担越积越重，带来了一系列风险（第六章），这种局面也必须改变。第三，劳动收入份额下降和资本收入份额上升，会扩大贫富差距。因为与劳动相比，资本掌握在少数人手中。贫富差距持续扩大会带来很多问题，社会对此的容忍度是有限的（第五章）。第四，由于消费不足和投资过剩，过剩产能必须向国外输出，而由于我国体量巨大，输出产能会加重全球贸易失衡，引发贸易冲突（见下节）。\n⏱ 2024-08-17 02:16:56\n\n\n在一个开放的世界中，内部失衡必然伴随着外部失衡。本国生产的东西若不能在本国消化，就只能对外输出。GDP由三大部分组成：消费、投资、净出口（出口减进口）。\n⏱ 2024-08-17 02:22:13\n\n\n这种经济结构比较脆弱，不可持续。一来外国需求受国外政治、经济变化影响很大，难以掌控；二来投资占比不可能一直保持在40%以上的高位。超出消费能力的投资会变成过剩产能，浪费严重。\n⏱ 2024-08-17 02:23:00\n\n\n虽然从会计核算角度讲，投资确实可以提升当下的GDP数字，但若投资形成的资产不能提高生产率、带来更高的收入，不能成为未来更高的消费，这种投资就没有形成实质性的财富，就是浪费。假如政府借钱修了一条路，很多人都用，降低了通勤和物流成本，提高了生产率，那就是很好的投资。但若政府不断挖了修、修了再挖，或干脆把路修到人迹罕至之处，经济账就算不回来了。这些工程所带来的收入远远抵不上成本，结果就是债务越积越高。虽然修路时的GDP上升了，但实际资源是被浪费掉了。这种例子并不罕见。当下尚未将这些损失入账，但未来迟早会出现在账上。\n⏱ 2024-08-17 02:24:59\n\n\n投资和消费失衡不是新问题。早在2005—2007年，我国家庭收入和消费占GDP的比重就已经下降到了低点（图7-2和图7-3）。当时政府已经意识到了这个问题，时任国务院总理温家宝在2007年就曾提出：“中国经济存在着巨大问题，依然是不稳定、不平衡、不协调、不可持续的结构性的问题”，比如“投资与消费者之间不协调，经济增长过多地依赖于投资和外贸出口”。(17)但2008年全球金融危机爆发，我国出口锐减，不得已出台“4万亿”计划，加大投资力度，导致投资占GDP的比重从已然很高的40%进一步上升到47%（图7-4），虽然弥补了净出口下降造成的GDP缺口，稳定了经济增长，但也强化了结构失衡问题。2011年又逢欧债危机，所以始终没有机会切实调整经济结构。2007—2012年，消费占比、居民收入占比、居民储蓄率几乎没有变化（图7-2和图7-3）。由于国内居民收入和消费不足，国外需求也不足，所以企业投资实体产业的动力自然也就不足，导致大量投资流入了基础设施投资和房地产，带动了房价和地价飙升，提升了债务负担和风险（第三章到第六章）。直到2012年党的十八大之后，才开始逐步推行系统的“供给侧结构性改革”。\n⏱ 2024-08-17 02:29:04\n\n\n我国出口常年大于进口，也就意味着必然有其他国家的进口常年大于出口，其中主要是美国。由于我国体量巨大，对国际贸易的冲击也巨大，所带来的经济调整并不轻松。\n⏱ 2024-08-17 02:30:42\n\n\n当然，国内和国际是一体两面，国内失衡会导致国际失衡，而国际失衡反过来也可以导致国内失衡。我国国内失衡，生产多消费少，必须向外输出剩余。但反过来看，美国人大手支出，高价向我国购买，我国的相应资源也会从本国消费者向出口生产企业转移，以满足外国需求，这就加剧了国内的消费和生产失衡。\n⏱ 2024-08-17 02:31:17\n\n第二节 中美贸易冲突\n\n中国制造业崛起和中美贸易对美国的就业冲击其实不重要。相比之下，对美国的技术冲击和挑战更加实实在在，这也是中美贸易冲突和美国技术遏制可能会长期化的根本原因。\n⏱ 2024-08-17 02:37:22\n\n\n对站在科技前沿的国家来说，新技术的发明和应用一般从科学研究和实验室开始，再到技术应用和专利阶段，然后再到大规模工业量产。但对一个后起的发展中国家来说，很多时候顺序是反过来的：先从制造环节入手，边干边学，积累技术和经验，然后再慢慢根据自身需要改进技术，创造一些专利。产品销量逐步扩大、技术逐步向前沿靠拢之后，就有了更多资源投入研发，推进更基础、应用范围更广的科研项目。\n⏱ 2024-08-17 02:38:50\n\n第三节 再平衡与国内大循环\n\n2019年，我国GDP相当于1960年全球GDP的总量（扣除物价因素后）。但过去的发展模式无法持续，经济结构内外失衡严重，而国际局势也日趋复杂，中央于是在2020年提出了“加快构建以国内大循环为主体、国内国际双循环相互促进的新发展格局”。这是一个发展战略上的转型。\n⏱ 2024-08-17 02:43:03\n\n\n，这一战略转型的关键是提高居民收入和消费。虽然政府目前仍然强调“供给侧结构性改革”，但所谓“供给”和“需求”，不是两件不同的事，只是看待同一件事的不同角度。比如从供给角度看是调节产能，从需求角度看就是调整投资支出；从供给角度看是产业升级，从需求角度看也就是收入水平和消费结构的升级。\n⏱ 2024-08-17 02:43:21\n\n\n要提高居民收入，就要继续推进城市化，让人口向城市尤其是大城市集聚。\n⏱ 2024-08-17 02:47:15\n\n\n发展，而这只能发生在人口密集的城市中。\n⏱ 2024-08-17 02:47:25\n\n\n要继续推进城市化，必须为常住人口提供相应的公共服务，让他们在城市中安居乐业。这方面涉及的要素市场改革，包括户籍制度和土地制度的改革，第五章已经详细阐释过。\n⏱ 2024-08-17 02:47:40\n\n\n要提高居民收入和消费，就要把更多资源从政府和企业手中转移出来，分配给居民。改革的关键是转变地方政府在经济中扮演的角色，遏制其投资冲动，降低其生产性支出，加大民生支出。这会带来四个方面的重要影响。其一，加大民生支出，能改变“重土地、轻人”的城市化模式，让城市“以人为本”，让居民安居乐业，才能降低储蓄和扩大消费。其二，加大民生支出，可以限制地方政府用于投资的生产性支出。在目前的经济发展阶段，实业投资已经变得非常复杂，以往的盲目投资所带来的浪费日趋严重，降低了居民部门可使用的实际资源。而且实业投资过程大多不可逆，所以地方政府一旦参与，就不容易退出（第三章）。即便本地企业没有竞争力，政府也可能不得不持续为其输血，挤占了资源，降低了全国统一市场的效率（第四章）。其三，推进国内大循环要求提升技术，攻克各类“卡脖子”的关键环节。而科技进步最核心的要素是“人”。因此地方政府加大教育、医疗等方面的民生支出，正是对“人力资本”的投资，长远看有利于科技进步和经济发展。其四，加大民生支出，遏制投资冲动，还可能降低地方政府对“土地财政”和“土地金融”发展模式的依赖，限制其利用土地加大杠杆，撬动信贷资源，降低对土地价格的依赖，有利于稳定房价，防止居民债务负担进一步加重而侵蚀消费（第五章）。\n⏱ 2024-08-17 02:47:47\n\n\n要提高居民收入，还要扩宽居民的财产性收入，发展各种直接融资渠道，让更多人有机会分享经济增长的果实，这就涉及金融体系和资本市场的改革。\n⏱ 2024-08-17 02:48:01\n\n\n“双循环”战略在强调“再平衡”和扩大国内大市场的同时，也强调了要扩大对外开放。\n⏱ 2024-08-17 02:48:19\n\n\n未来，只有继续推进各类要素的市场化改革，继续扩大开放，真正转变地方政府角色，从生产型政府转型为服务型政府，才能实现国内市场的巨大潜力，推动我国迈入中高收入国家行列。\n⏱ 2024-08-17 02:48:53\n\n结语\n\n总结一下，这一模式有三大特点。第一个特点是城市化过程中“重土地、轻人”。第二个特点是招商引资竞争中“重规模、重扩张”。第三个特点是经济结构上“重投资、重生产、轻消费”。\n⏱ 2024-08-17 02:50:34\n\n\n经济结构再平衡，从来不是一件容易的事，往往伴随着国内的痛苦调整和国际冲突。2\n⏱ 2024-08-17 02:50:20\n\n\n其实对于常年关注我国经济改革的人来说，过去的40年中没有几年是容易的，经历过几次大的挑战和危机。所以我常跟学生调侃说经济增长不是请客吃饭，是玩儿命的买卖。站在岸边只看到波澜壮阔，看不见暗潮汹涌。\n⏱ 2024-08-17 02:51:10\n\n\n未来不可知，对中国经济的观察者而言，真正重要的是培养出一种“发展”的观念。一方面，理解发展目的不等于发展过程，发达国家目前的做法不一定能解决我们发展中面临的问题；另一方面，情况在不断变化，我们过去的一些成功经验和发展模式也不可能一直有效。若不能继续改革，过去的成功经验就可能成为负担甚至陷阱。要始终坚持实事求是，坚持具体问题具体分析，抛开意识形态，不断去解决实践中所面临的问题，走一条适合自己的发展道路。\n⏱ 2024-08-17 02:52:21\n\n第八章 总结：政府与经济发展\n\n在经济发展早期，市场机制缺失，政府在推动经济起飞和培育各项市场经济制度方面，发挥了主导作用。但随着经济的发展和市场经济体系的不断完善，政府的角色也需要继续调整。\n⏱ 2024-08-17 02:54:29\n\n\n强调政府的作用，当然不是鼓吹计划经济。过去苏联式的计划经济有两大特征。第一是只有计划，否认市场和价格机制，也不允许其他非公有制成分存在。第二是封闭，很少参与国际贸易和全球化。\n⏱ 2024-08-17 02:54:51\n\n第一节 地区间竞争\n\n经济发展的核心原则，就是优化资源配置，提高使用效率，尽量做到“人尽其才，物尽其用”。实现这一目标要依靠竞争。\n⏱ 2024-08-17 02:56:57\n\n\n。所以要想提高整体经济的效率，就要将竞争机制引入政府。理论上有两种做法。第一种是以中央政府为主，按功能划分许多部委，以部委为基本单位在全国范围内调动资源。竞争主要体现在中央设定目标和规划过程中部委之间的博弈。\n⏱ 2024-08-17 02:57:06\n\n\n第二种是以地方政府为主，在设定经济发展目标之后，放权给地方政府，让它们发挥积极性，因地制宜，在实际工作中去竞争资源。这是一种自下而上的“块块”式的竞争模式。(1)\n⏱ 2024-08-17 02:57:12\n\n\n改革开放以后，地方政府权力扩大，“属地管理”和“地方竞争”就构成了政府间竞争的基本模式。\n⏱ 2024-08-17 02:58:18\n\n\n这种竞争不仅是资源的竞争，也是地方政策、营商环境、发展模式之间的竞争。“属地管理”有利于地区性的政策实验和创新，因为毕竟是地方性实验，成功了可以总结和推广经验，失败了也可以将代价和风险限制在当地，不至于影响大局。\n⏱ 2024-08-17 02:58:35\n\n\n在工业化进程中搞地方竞争，前提是大多数地区的工业基础不能相差太远，否则资源会迅速向占绝对优势的地区集聚，劣势地区很难发展起来。\n⏱ 2024-08-17 02:59:07\n\n\n“官场+市场”的竞争体制，可以帮助理解我国经济的整体增长，但这种体制的运行效果，各地差异很大。官员或政府间的竞争，毕竟不是市场竞争，核心差别有三。第一，缺乏真正的淘汰机制。地方政府就算不思进取，也不会像企业一样倒闭。政绩不佳的官员虽然晋升机会可能较少，但只要不违法乱纪，并不会因投资失败或经济低迷而承担个人损失。第二，绝大多数市场竞争是“正和博弈”，有合作共赢、共同做大蛋糕的可能。而官员升迁则是“零和博弈”，晋升位置有限，甲上去了，乙就上不去。所以在地区经济竞争中会产生地方保护主义，甚至出现“以邻为壑”的恶性竞争现象。第三，市场和公司间的竞争一般是长期竞争，延续性很强。但地方官员任期有限，必须在任期内干出政绩，且新官往往不理旧账，因此会刺激大干快上的投资冲动，拉动地区GDP数字快速上涨，不惜忽视长期风险和债务负担。\n⏱ 2024-08-17 03:00:48\n\n第二节 政府的发展与转型\n\n国家越富裕，政府在国民经济中所占的比重也往往越大，而不是越小，这一现象也被称为“瓦格纳法则”。因为随着国家越来越富裕，民众对政府服务的需求会越来越多，政府在公立教育、医疗、退休金、失业保险等方面的支出都会随之增加。而随着全球化的深入，各种外来冲击也大，所以政府要加强各种“保险”功能。(8)另一方面，当今很多贫穷落后国家的共同点之一就是政府太弱小，可能连社会治安都维持不了，更无法为经济发展创造稳定环境。经济富裕、社会安定、政府得力是国家繁荣的三大支柱，缺一不可。(9\n⏱ 2024-08-19 20:40:37\n\n\n经济落后的国家之所以落后，正是因为它缺乏先进国家完善的市场和高效的资源配置方式。这些本就是经济发展所需要达到的目标，而很难说是经济发展的前提。对落后国家而言，经济发展的关键在于能否在市场机制不完善的情况下，找到其他可行的动员和调配资源的方式，推动经济增长，在增长过程中获得更多资源和时间去建设和完善市场经济。\n⏱ 2024-08-19 20:47:47\n\n\n城市化是一个不可逆的过程，目前的土地和户籍改革都承认了这种不可逆性。在发展过程中遭遇冲击，回到乡村可能是权宜之计，但不是真正有效的长期缓冲机制。\n⏱ 2024-08-19 20:52:14\n\n\n随着工业升级和技术进步，工业会越来越多地使用机器，创造就业的能力会减弱，这个过程很难逆转。所以大多数就业都要依靠服务业的发展，而后者离不开城市化和人口密度。\n⏱ 2024-08-19 21:05:20\n\n\n扩大民生支出的瓶颈是地方政府的收入。\n⏱ 2024-08-19 21:06:20\n\n\n中国目前缺乏属于地方的主体税种。以往依托税收之外的“土地财政”和“土地金融”模式已经无法再持续下去，因此要想扩大民生支出，可能需要改革税制，将税入向地方倾斜。\n⏱ 2024-08-19 21:06:50\n\n第三节 发展目标与发展过程\n\n经济发展的核心是提高生产率。对处于技术前沿的发达国家来说，提高生产率的关键是不断探索和创新。其相对完善的市场经济是一套分散化的决策体系，其中的竞争和价格机制有利于不断“试错”和筛选胜者。但对发展中国家来说，提高生产率的关键不是探索未知和创新，而是学习已知的技术和管理模式，将更多资源尽快组织和投入到学习过程中，以提高学习效率。\n⏱ 2024-08-19 22:54:19\n\n\n当技术和生产率提高到一定水平之后，旧有的模式若不能成功转型为“探索创新模式”，就可能会阻碍经济进一步发展，“后发优势”可能变成“后发劣势”。\n⏱ 2024-08-19 22:54:31\n\n\n不仅发展中国家和发达国家不同，发展中国家各自的发展模式也不同。(19)从宏观角度看，很多成功的发展中国家有诸多相似之处，比如资本积累的方式、出口导向的发展战略、产业政策和汇率操控、金融抑制等。但在不同国家，贯彻和执行这些战略或政策的具体方式并不相同。行之有效的发展战略和政策，必须符合本国国情，受本国特殊历史和社会条件的制约。\n⏱ 2024-08-23 02:20:51\n\n\n本书阐述的我国政治经济体制，有三大必要组件：掌握大量资源并可以自主行动的地方政府，协调和控制能力强的中央政府，以及人力资本雄厚和组织完善的官僚体系。这三大“制度禀赋”源自我国特殊的历史，不是每个国家都有的。\n⏱ 2024-08-23 02:20:43\n\n\n不仅国与国之间国情和发展路径有别，在中国这样一个大国内部，各个省的发展方式和路径也不尽相同。\n⏱ 2024-08-23 02:21:16\n\n\n各国的政治和社会现实，决定了可行的经济发展政策的边界。就拿工业化和城市化来说，无疑是经济发展的关键。从表面看，这是个工业生产技术和基础设施建设的问题，各国看起来都差不多。但看深一层，这是个农民转变为工人和市民的问题，这个演变过程，各国差别就大了。\n⏱ 2024-08-23 02:23:20\n\n\n可行的政策不仅受既有制度的约束，也受既有利益的约束。政策方案的设计，必须考虑到利益相关人和权力持有者的利益。既要提高经济效率，也要保证做决策的人或权力主体的利益不受巨大损害，否则政策就难以推行。(21)可行的经济政策是各种利益妥协的结果，背后是各国特殊的政治体制和议程。在这个过程中，不仅激励相容的机制重要，文化的制约也重要。\n⏱ 2024-08-23 02:24:46\n\n\n改革方向和改革过程是两回事。就算每个人都对改革方向和目的有共识（事实上不可能），但对改革路径和步骤也会有分歧。什么事先办，什么事后办，不容易决定。每一步都有人受益、有人受损，拼命争取和拼命抵制的都大有人在。就算能看清对岸的风景，也不见得就能摸着石头成功过河，绊脚石或深坑比比皆是。\n⏱ 2024-08-23 02:25:47\n\n\n经济发展必然要改变旧有的生活方式，重新分配利益，所以必然伴随着矛盾和冲突。政府的关键作用之一，就是调控改变速度的快慢。\n⏱ 2024-08-23 02:26:24\n"},"阅读/菊与刀":{"title":"菊与刀","links":[],"tags":[],"content":"\n\n                  \n                  菊与刀 \n                  \n                \n\n\n\n《菊与刀》-  本尼迪克特\n出版时间： 2012-01-01 00:00:00\nISBN： 9787510422188\nPC地址：weread.qq.com/web/reader/c4132040594c08c41c28129\n\n\n\n第2章 战争中的日本人\n\n日本向来重视一些非物质资源。虽然日本一直在发展经济，产业兴国对日本的影响也越来越明显，但日本这种发展产业的基础却是建立在自己独特文化系统之上。日本人相信，永恒的精神是一切。虽然物质不可或缺，但只是相对次要的，是难以永恒的。\n⏱ 2024-01-05 00:46:29\n\n\n我们已经看到，日军飞行员能够以自杀的方式驾驶着小飞机撞向我们的军舰，这正是日本人深入人心的精神战胜物质信念在战争中有所表现的教材。他们自己称这是“神风特攻队”。\n⏱ 2024-01-05 00:47:06\n\n\n精神战胜物质的信念不仅在军队中被大肆渲染，在日本民间，当权者也同样宣传精神优越于物质的信条。比如，当一个工人在工厂中连续工作12小时，感到筋疲力尽的时候，他们要说的并不是抱怨，而是：“身体上的劳累，可以让意志和精神更加坚强和斗志昂扬”，“疲倦能够锻炼人的意志”。当人们在寒冷的冬天里躲在毫无取暖设施的防空洞中时，日本体育会就会通过广播号召大家运动起来做体操御寒，并宣扬说这样的体操既能够代替取暖设备和被褥，也能够代替维持人们正常体力但又非常紧缺的粮食。他们总是宣扬说：“现在会有人说，连最基本的食品都没有还做什么体操。这样的说法是完全不对的。我们应该越是在食品不足的时候，越要通过其他办法来增强体质。”也就是说，日本人要用消耗体力的办法来增强体质。这种观点，让美国人难以理解。因为我们总是通过前一天是不是有良好的睡眠，饮食是不是正常，有没有感觉到寒冷或是炎热，来衡量自己已经消耗的体力，然后进行补充。可是日本人似乎从来不考虑体力消耗的问题，也从来不会有什么贮存体力的问题，他们认为这是物质主义。\n⏱ 2024-01-05 00:47:48\n\n\n德国战俘尽管对于那些背叛希特勒的将军或最高司令部的人表示极大的不满，但是他们仍然认为，必须由希特勒来承担战争和备战的责任。而日本的战俘则非常明确地表示了自己对天皇和皇室的忠诚与导致战争的军国主义及侵略战争的政策是完全不能混淆的两件事。\n⏱ 2024-01-06 17:30:37\n\n\n美国人认为不管事大事小，出于救援目的，将陷入困境的人们救出或者任何一点对他们的帮助都是足以让人感动的高尚之举。美国人认为勇敢行为，就是去帮助处在困难中的人。倘若他能够让受难者获救，那么这就是英雄的行为。但是日本人所认为的勇敢，并不是这种援救。包括我们把救生器配置在B-29轰炸机和战斗机上，也被日本人认为是“胆怯”。在日本报纸、广播中，日本人曾经屡次讨论这个话题，他们认为最高尚的行为就是视死如归，而那些谨小慎微的行为没有精神价值。日本人的这一态度还不幸地体现在了他们对待伤病员或者疟疾患者上。在他们看来，这些伤病的士兵已经是废物，无法继续实践他们高尚的精神使命，因此日军的医疗服务十分缺乏，以至于不能维持军队正常的战斗力。随着战争的进行，无法及时进行补给让本来就非常不完善的医疗设施难以维持。但前线缺乏医疗设备只是日本特色的一个方面，日本人蔑视物质主义的信念作用远远不止是抨击美国的堕落。战场上的日军士兵在没有医疗设备救治的时候会被教导说，死亡就是精神的最后胜利。在日本人看来，我们关怀备至地照顾病患者，或者我们在轰炸机上配置安全设备等等，都是对成就英雄的阻挠。而且，我们要说的是不仅战场上的日军士兵如此，在平时的生活中，日本人也非常不习惯找内外科医生去看病，这与美国完全不同。在美国，人们怜悯患有伤病的人要远远胜过关心其他福利设施，这一点在战争没有爆发之前来美国旅游的欧洲人也认同。但在日本，这些看法是少见的和陌生的。当战争正在进行中时，日军中没有配备一个有过专门训练而能够在战火中搬运和抢救伤员的救护班，也没有成系统的，如前线救护所或野战医院，及在大后方的康复医院等医护设施。如果出现一些紧急情况，日军甚至把伤病士兵杀掉。在新几内亚和菲律宾的战场上，经常出现日军不得不从有医院的阵地撤退的情况，但是他们从来没有在自己有条件的时候把自己的伤病员预先转移的习惯。除了执行所谓“有计划的撤退”，当敌人已经就在眼前的时刻，他们会采取有限的措施：身负职责的军医，会在自己临走之时，枪杀无法转移的伤病员，或者伤病员手持手榴弹自杀。\n⏱ 2024-01-06 17:40:38\n\n\n在美日两国军队有趣的对比中，一个最有戏剧性的差别是，日军士兵在被俘之后竟然会与他宁死不降的盟军合作。在日本士兵的脑海里，或许他们从来没有想过如何适应投降之后的新环境。这些被俘的日本兵已经没有了作为日本人的名誉，从而也就失去了作为一个日本人的生命。不管战争最后是不是失败，很少有日本战俘要求遣返回国。有一些战俘甚至要求把自己处决，他们说：“如果你们因为战争惯例而不这么做，我就只能选择成为战俘中的模范。”事实上他们做的事情比模范战俘还要多很多。那些曾经有着很多年极端国家主义信仰的人或者在日军部队中服务了很多年的老兵会向盟军提供弹药库的具体位置，还会把日军兵力的部署情况告诉盟军，帮助盟军书写宣传材料，指导盟军飞行员应该轰炸的军事目标。他们绝对的背叛体现的并不是无耻和下作，反而把自己忠诚的品格完全地体现出来。就好像在求死不能之后，他们又重新翻开了一页崭新的生命之书，开始了新的忠义人生之旅。虽然这与旧的内容完全相反，可是他们表现出来的却是同样的忠诚。\n⏱ 2024-01-06 17:47:48\n\n第3章 日本的等级制度\n\n必须能够准确地理解日本人经常说的“各得其所”的含义才能够真正了解日本民族。就像我们一直追求和捍卫自由平等的信仰一样，日本人对秩序、等级制的坚持也从来不会妥协，这就像地球上的南北两极。我们觉得，要想把等级制观念合理正当地用于一种社会结构中并维持这个社会，无疑是不太可能的。但是日本人却对此坚信不疑。\n⏱ 2024-01-07 02:55:00\n\n\n日本人在看待国内问题时是坚持着等级制观念的，他们看待国际关系的全部问题也同样用这种等级制观念来分析和判断。\n⏱ 2024-01-07 02:51:56\n\n\n日本人自上而下所信奉的“各得其所”观念，同样与日本民族的社会经验和生活方式有关。千百年来，在日本人信奉和遵行的生活准则中，不平等是最为容易联想，也是最广泛接受的方式。日本人会像呼吸空气一样承认等级制行为。但是，我们不要把日本人的等级观念与西方的权威主义相混淆。在日本，不论是统治者还是被统治者，他们的行事方式与我们所熟悉的西方传统完全不同。\n⏱ 2024-01-07 02:57:41\n\n\n日本实行改革完全西方化已经很多年了，但是日本依然是个存在着等级的社会。日本人在寒暄和彼此接触的时候，都必须表示出二者之间在社会地位中存在的距离。一个日本人对另一个日本人说“吃”或“坐”等日常用语时，也会根据自己与对方的亲疏程度或辈分不同，而使用不同的词汇。日语中“你”这个词就有多个，不同的场合中要使用不同的表示“你”的词汇。与其他太平洋上的民族一样，日本人的语言中也有“敬语”，同时日本人使用敬语时也会有适当的鞠躬、行礼或者跪拜等等礼节形式。所有这些，都有着严格详细的规矩和惯例，比如鞠躬，对于什么样的人要鞠躬，鞠躬到什么程度都是因人而异的。譬如你对某个主人有一个十分适度的鞠躬，但同样的动作用在另一个人身上或许就是一种无礼的表现。另外，鞠躬的方式也有很多种，从最高形式的跪在地上双手伏地、额触手背的跪拜礼，到只是简单地动动肩、点点头，十分的繁杂。每一个日本人都必须懂得不同场合的不同礼仪，这些都是他们从孩提时代就开始学习和掌握的。\n⏱ 2024-01-07 02:58:07\n\n\n因为辈分、年龄和性别而产生的特权在日本是非常明显的。不过，这并不是一种独断专制者的倨傲，而更像是一个受托者的必要责任。一个父亲或兄长在行使自己特权的同时必须对所有家庭成员的权益负责，无论这个家庭成员活着，还是已经逝去，甚至还没出生的家庭成员也在此之内。家庭中的一些重大决定必须由他去决定并且要保证这个决定能够顺利地实行，全家的荣誉都由他完全负责。家族领导者必须保证家族中的成员牢记该家族的荣誉遗产，无论这是精神遗产还是物质遗产，都不能有所损失。即使只是一个普通农民，也有自己在家庭生活中必须承担的高尚责任。而阶级地位越高的人，对于家庭的责任也就越大。其基本原则就是家族利益高于所有个人需求。\n⏱ 2024-01-07 03:12:31\n\n\n当有重大事件需要做出决定时，不论是什么阶级什么地位有着什么样的家族，家长都要通过家族会议进行讨论。比如，需要对订婚的各项事情进行安排布置时，就要召开这样的家族会议，很可能有些远离该地的家族成员也会在这时赶来参加这个会议。决定过程中不会出现人微言轻的情况，所有人都有表达自己意见的权利。某位女性家庭成员或者弟弟的发言也可能决定整件事情。若是家长不顾众人的意见，按照自己的意思独断专行，这将让自己处于十分困难的境地。当然，在做出决定之后，即便是当事人对这个决定非常不满，那也只能遵从，而作为长辈，或许在当年他也遇到过一样的情况，因此，此时他会努力要求晚辈像自己当年一样服从家族的决定，并且对这个要求没有任何妥协。\n⏱ 2024-01-07 03:13:30\n\n\n在家庭生活中，日本人从不提倡专制，但同时也鼓励对专制权威的绝对服从。通过这种方式，让所有家族成员认可家族利益的重要性。不管家族的决定有多么苛刻，家族意志是不容置疑的，这是一个家族中的最高价值，所有家族成员需要对家族忠诚并服从家长的决定。\n⏱ 2024-01-07 03:14:00\n\n\n等级制观念就是在这种家庭生活中学习和理解的，日本人会把这样的观念运用到他们的经济生活和政治等广泛领域中。他们知道应该对于一个“适得其所”的人表达敬意，就算他们只是这个集团中的毫无影响力的边缘人物。比如，丈夫只是一个庸弱的人，妻子主宰着所有生活，或者哥哥受到弟弟的支配，但是这并不影响在正式关系上妻子对丈夫的尊重或者弟弟对哥哥的尊重。这种特权认定不会因为人为操纵而被改变，也不会出现因为事实上支配关系的颠倒而改变表面上的关系；等级制仍然有着不可侵犯的权威性。这样的特点，可能会为那些注重实权却并不在意表面身份的人提供便利，所以乐于做幕后英雄的人完全可以隐藏得很好，不至于成为摆在明面上的众矢之的。日本人在所有人都能感受到的家庭生活方式中学到了任何一种决定的最有力支持来自整个家族，他们相信这样的决定可以让家族荣誉得到维护。如前所说，这个决定不是某个家长因为特权地位而表现出来他的个人意志，而是全体家族成员的意志。虽然是一家之长，但是他更像是家族物质和精神财产的管理人，这是全体家族成员的东西，为了这个整体的利益，所有家庭成员都应该让个人意志服从于整个家族决定。日本人不会用武力去威胁某项事关家族利益的决定在家族会议上通过，但是这并没有让服从家族利益的要求威力有所减弱，也不会降低那些有着特定身份的人的权威性，人们仍然对他充满敬意。退一步说，即便确实有一些家长是强有力的独裁者，但是这并不能让等级制从日本家族中消失。\n⏱ 2024-01-07 03:16:16\n\n\n在生活里日本人严守的等级制习惯，也十分清晰地反映在了日本社会的阶级关系上。\n⏱ 2024-01-07 03:17:42\n\n\n使得等级制封建社会得以维持安定的最重要阶级是武士和农民，德川幕府也正是把自己的主要精力集中在了对这两个阶级的控制和管理上。\n⏱ 2024-01-07 12:34:02\n\n\n武士阶级会限制其家族的规模，从武士角度来说，如果一个人的威望通过财富来体现，那么这只能让他们难堪。所以，武士提倡的最高美德就是俭朴。\n⏱ 2024-01-07 12:35:09\n\n\n在武士和农工商三个阶级之间，存在着巨大的鸿沟。后者只是所谓的“庶民”。所以，武士刀对于武士和其他日本人来说绝不仅仅是一个装饰，而是象征了武士阶级的特权和地位。面对庶民，武士们能够使用自己的佩刀。这个传统形成于德川时代之前。德川家康更是颁布了维持这个传统的法令：“如果庶民对武士失礼或者对上级不逊，可以当场斩杀。”[插图]这项规定似乎完全没有想过在庶民和武士之间构建一种彼此依存的关系，而只是在突出严格的等级规定。\n⏱ 2024-01-07 12:33:15\n\n\n德川幕府时代的武士已经不再仅仅专注于武力，他们逐渐介入到藩主的财产管理，并且分心于日本传统中孕育的各种艺术中，比如很多武士就是古典的“能”乐或者茶道专家。大名们的文件也由武士来处理，藩主的规划和设计也是在武士们的巧妙手段中一点点实施。毕竟两百多年的太平岁月，根本没有那么多舞刀弄剑的机会。\n⏱ 2024-01-07 12:36:53\n\n\n日本人对于天皇的观念与其他太平洋诸岛上所已知的那种观念基本相似。在日本人眼中，天皇是神圣的首领，他参与政治，也可以不参与政治。我们在太平洋岛屿上也发现了有的地方首领自己行使权力，而另一些地方，则是委托他人行使权力，但是首领的神圣性则无可置疑。新西兰岛的部落中，他们的首领神圣不可冒犯，所有世俗之物都不能接近神圣的首领，所以要有专人奉食而不是自己取食，就连奉食的汤匙也不能碰到首领神圣的牙齿。当首领外出的时候必须有人抬送，如果有什么地方被首领的脚踏过，这个地方就成为圣地。他的头部是最神圣的，所有人都不能碰触。首领的话可以传达给部落诸神……不仅新西兰，萨摩亚岛、汤加岛等地也同样是神圣首领的生活与世俗完全没有关系，世俗生活则由世俗首领来管理。\n⏱ 2024-01-07 12:43:55\n\n\n日本人认为，衡量天皇的因素不在于是否积极与政。虽然在很长时间里，日本的实际政权在将军手中，但是日本人却一直非常珍视隐居在京都宫廷的天皇。大概也只有熟悉西方观点的人才会认为毫无实权的天皇根本就是多余的。对于对等级制观念有着深刻理解并在生活中处处实践这一习惯的日本人来说，天皇对他们意义非凡。\n⏱ 2024-01-07 17:09:37\n\n\n日本人对于等级制的坚持和适应远远强过其他民族，在他们自己的世界里，日本人把所有行为细节都规范得像一幅精密地图一样准确和繁琐。在封建时代最后这两百多年里，对于等级制观念和秩序都是在铁腕统治下得以维持的。这一时期，日本人把对于等级制信念与国家和政权的安全稳定联系起来。他们认为，只要人们规规矩矩，不超出自己的责任和生活范围，履行好自己已知的义务，那么这个世界就是安全的可信的。不会出现肆虐的盗贼，也不会出现彼此嫉妒和仇恨的现象，大名之间也不会有什么内战。如果其他阶级的人冒犯了你，你也完全可以像为自己讨还公道的农民那样提出诉讼。虽然这样做，会让个人冒很大风险，但这是大家所公认的。\n⏱ 2024-01-07 17:12:14\n\n\n虽然日本的制度要求所有人都安守本分，但这个民族并没有成为一个懦弱恭顺的民族。更为令人注意的是，社会中的每个阶层都在这种制度下得到了一定保障。即使是贱民阶层也同样因为这种制度而可以垄断他们的特殊职业，他们阶层中的一些自治团体也是由当局认可的。虽然每一个阶层都被若干准则所限制，但同时他们又是有秩序和安全的。\n⏱ 2024-01-07 17:15:08\n\n第4章 明治维新\n\n明治时期的政治家根本没有意识形态革命的概念，他们从不把自己的任务看成是这种革命，而只是把这项伟业当做一项事业。他们没有消灭什么东西的想法，其心中的目标只是要把日本建设成为一个在世界上有着举足轻重影响的强国。他们没有有意地对众人崇拜的东西进行破坏，封建制度及其体系没有被指为一无是处，也没有出现剥夺封建统治阶级财产的极端情况，反而用优厚的俸禄劝诱这些阶级，让他们支持新政府。在处理完急需解决的问题之后，明治的政治家又着手改善了农民的境遇。之所以在十年之后才进行这样的措施，完全不是因为从阶级立场上拒绝农民阶级的要求，更多的是因为明治初期衰弱的国力让他们无暇解决这样的问题。\n⏱ 2024-01-08 01:04:49\n\n\n有阶级革命概念的明治政治家，出人意料地拒绝废除所有等级制的思想。“复古王政”之后，天皇的地位登峰造极，依然是绝对权威的等级制。\n⏱ 2024-01-08 01:05:12\n\n\n因为这种强有力的上层领导，日本人就不必被公众舆论所左右。在日本的上层人物中，其实并没有像西方那样选举产生的人物。平民百姓对于这个掌握日本发展方向的阶层是毫无发言权的。\n⏱ 2024-01-08 01:08:01\n\n\n几乎所有的亚洲国家的上层权力总是显得过于强大而影响到了下层的地方自治权。但是这并不代表着亚洲国家毫无民主，其区别只是在于他们的民主能够达到什么程度。\n⏱ 2024-01-08 01:09:28\n\n\n虽然日本的政治制度似乎与西欧一些国家有相似性，但其真正的差异在于日本政府的职能上。日本人对于“各得其所”有着长时间的认同，所以日本的政治往往是靠自己从传统中孕育的道德体系和礼仪来进行。当出身特别的有能力的才俊们担任政府高官的时候，可以预计，这些贵族只要能够完成自己的职责而没有出格的劣行，那么他们在日本社会中的特权就会得到民众的尊重。这不是出于这些政治家的政策都是民众所拥护的，更主要的原因是，在日本，越界就是错误。对于政府的最高层人员来说，“民众的舆论”根本不可能影响他们的决策，他们希望看到的只是国民支持自己的决策。\n⏱ 2024-01-08 01:17:59\n\n\n日本人希望实现的是，将权力分别适当地分配给不同的阶级并将各自的权力使用范围规定清楚。\n⏱ 2024-01-08 11:33:31\n\n\n更为让人惊奇的是，明治的政治家对于宗教领域中的离奇制度。他们在没有超出自己阶级权限的范围内，塑造了一种能够象征民族统一和本民族优越性的特殊宗教，除此之外，民众可以有自己不同的信仰。日本政府的这种特殊宗教就是神道教。这成了民族的象征，受到了特殊的尊敬。日本人并不承认神道是一种宗教。因此，虽然日本政府要求所有国民都信奉国家神道，但在日本人眼中，这并不是一种宗教信仰的专制，并不违反像西方国家那样总是强调的宗教信仰自由的原则。这就如同美国人尊敬国旗并向星条旗敬礼一样，它代表的只是一种对国家的忠诚。既然神道不是宗教，日本便可以在学校中开设有关神道的课程而不会受到像西方一样的非难。\n⏱ 2024-01-08 11:35:44\n\n\n在具体管理方面，神道与其他宗教也不一样，行政上和财政上的管理维持都是截然不同的：国家神道由内务省神祗局进行管理，其所有的费用，如祭司人员、祭祀仪式及神社的维系运营费用都是从国库中支取；其他宗教如佛教、基督教的各派别或者其他宗教则全部由文部省宗教局负责管理和监督，他们的开支费用也是在教徒自愿捐赠支持下才实现的。\n⏱ 2024-01-08 11:36:47\n\n\n在明治时代，日本人将国家在政治中的权力范围和国家神道在宗教中的职能范围划分得很清楚。除此之外的政治生活或者宗教信仰方面的领域，人民是相对自由的，只有那些被认为关系到国家利益的事，等级制体系下的高官们才会出面进行强势控制。\n⏱ 2024-01-08 11:40:48\n\n\n军队代表了人民的利益，对于这一情况可能产生的各种后果，或许并不是日本政治家希望看到的，他们并不希望没有传统等级制限制的军队成为日本等级制社会中居于最高地位的代表。因此，明治的政治家们制定了不少措施达到他们的目的。虽然在权威的宪法中并没有这些措施，但是它却在日本军部首脑们脑海中形成了一种惯例，即军队不干涉政府行为而保持相对的独立性，于是就出现了日本军部可以绕开政府单独行事的局面。\n⏱ 2024-01-08 11:43:12\n\n\n这种局面到后来演变到了不可收拾的地步，日本军部甚至可以阻止对自己不利的内阁成立，他们采取的办法就是拒绝放行入阁的陆海军将领。如果内阁之中没有高级军官担任陆海军大臣一职，那么内阁就不能组建，这个事关重大的职位是必须由真正的军人来担任的。因此，当内阁的一些行动引起了军部不满时，军部只要把他们在内阁中的代表召回就足以让内阁解体。军部的人不允许并且他们也能够做到不让外人干涉他们的最高决策阶层。这就是为什么会出现外务省保证不会占领中国东北的情况下，关东军却依然熟视无睹，武装占领了满洲的原因，因为军部首脑在内阁还没有形成一致意见、做出决策时，选择支持当地司令官，日本军部使用了自己的特权，这个特权就像政府不希望军部干涉自己一样，军部同样不希望受到任何人干涉。\n⏱ 2024-01-08 11:45:59\n\n\n日本把“资本主义在生产过程中已经成型的出发点和顺序”[插图]进行了修改。它的工业发展并不像西方资本主义那样由生产消费品和轻工业开始，它在最初便着手于对国家有着关键作用的重工业发展。日本把发展的优先权交给了兵工厂、造船厂、炼钢厂、铁路交通建设等等，在很短时间内便实现了高水平的技术并具备高效率。\n⏱ 2024-01-08 12:03:05\n\n\n总之，日本人对世界秩序的构筑绝对不会忘记等级制。人们的年龄、辈分、性别和所属阶级决定着人与人之间的生活关系及其应有的行为。无论是政治、宗教、军队还是产业等各个领域，等级制划分都是十分周到的，不管你是等级制中的高层人物还是底层人物，只要做出了不得体的行为，就必然要付出一定的代价。只有人人做到了各守本分，人们才会平和安宁地生活下去，同时他们才是安全的。等级制才是日本人的信仰，有等级的区别在日本人看来是合理的。这就像美国人对平等与自由的信仰一样。\n⏱ 2024-01-08 20:12:17\n\n\n不过，日本人却要将自己信仰的这种“安全”保证推向世界，这必然要遭到惩罚。等级制在日本国内完全没有问题，它与日本民众的思想十分吻合，因为这是日本在自己的环境下经过历史沉淀所选择的最为适合日本人的思维方式。\n⏱ 2024-01-08 20:14:13\n\n\n日本人的错误在于他们认为自己能够用要求日本人的标准来要求其他国家和人民。事实并不是这样。日本人并不知道，其他国家是不会接受这些日本人自己心甘情愿去遵守的“各得其所”的道德观的。其他国家根本不存在这种道德观。等级制只是日本的产品，日本人会把等级制之下的所有一切视为当然，因此日本的学者们对于日本人都很熟悉的伦理体系没有更多论述。可是作为我们，必须首先将日本的伦理体系进行研究和描述，否则无法真正了解日本人。\n⏱ 2024-01-08 20:15:02\n\n第5章 背负着历史和社会恩情债的日本人\n\n虽然，任何一个人，无论是东方还是西方，他们的成长大多是在双亲照料下才长大成人，但是日本人却觉得美国人对于孝道不够重视。一位日本作者说：“美国人对于报答父母之恩的形式就是对自己的父母好，也就只有这些而已。”当然，日本的父母是不会有意让自己的孩子背上“恩”的负担的，他们认为只要精心照料自己的孩子也是在报答对自己父母的恩情。父母对孩子的义务也是“父母之恩”中的一部分。\n⏱ 2024-01-09 00:58:03\n\n\n报恩的思想是日本人非常认同的，但这不意味着因为有报恩而可以轻易接受别人的恩惠，在日本，受恩是一件非常严肃的事。日本人并不愿意轻易接受别人的恩惠，让自己背上人情债。\n⏱ 2024-01-09 00:59:35\n\n\n在日本，“使人受恩”则只是表示送给别人一些东西或者为别人提供帮助。对日本人来说，如果一个素不相识的人为他提供帮助“使人受恩”，那将是一件令人讨厌的事。毕竟，这将增加受恩者的“负恩感”。对他们来说，平日中只是面对近邻或在传统的等级关系中，受“恩”就已经非常麻烦了，更何况是一个并不熟悉的人的“恩情”。但是如果对方是熟人或者是与自己同辈的“使人受恩”，也会让他们感到不高兴。与其如此，他们宁愿只是选择“领情”而不卷入“恩”和恩情背后的麻烦，这就是为什么日本人对于“使人受恩”常常应之以“领情”的原因。如果大街上发生了一件重大事故，日本人常常选择不予理睬，这倒不只是由于日本人缺乏主动性，更重要的是因为他们觉得，除了警察之外，任何人插手都是在让受帮助的人背上欠你的恩情债。\n⏱ 2024-01-09 01:02:56\n\n第6章 报恩：不容回避的人生主题\n\n所谓“恩”，在一定意义上说就是欠他人的情，这是需要偿还的，也就是“报恩”。日本的“报恩”与“恩”是两件完全不同的事。\n⏱ 2024-01-09 01:57:41\n\n\n在日本人看来，如果称得上“恩”，在接受之后，就是一生的债务；“报答恩情”应该是积极的，无时不刻地偿还这样的恩情，用一系列不同的概念充实“报恩”的内容。知恩不报是不道德的，而报恩的行为则是令人提倡的好德行，就是美德的开始。\n⏱ 2024-01-09 01:58:10\n\n\n无限的恩，也就是日本人所谓的“义务”，是他们认为的那种“无以为报”的恩情，这种恩情主要有两类：一类是父母的养育之恩，也就是“孝”，另一类是对于天皇的恩赐，也就是“忠”。孝和忠是没有任何商量余地的，是每个日本人必须应尽的义务。就像日本的初等教育被称为“义务教育”一样，义务这个词太恰当了，因为这是必须完成的事。\n⏱ 2024-01-09 11:42:33\n\n\n总之，在中国有着崇高道德位置的“仁”，在日本已经难以附加地被贬抑，不再是道德的至高点。[插图]日本人虽然篡改并贬抑了中国体系中地位最为崇高的“仁”，但却在吸纳中国体系的同时没有为这个体系找到一个足以代替“仁”的新的道德标准。“仁”作为履行道德的前提和条件，在日本行不通。所以，日本的孝道就成了无条件遵循的义务，即便父母是有着恶行或无德的混账父母，也必须无条件地孝敬。除非，对于父母的孝道与对天皇的皇恩出现冲突的时候可以不顾孝道而顾及皇恩，其他所有的情况，都是无条件的，而不管父母是不是值得尊敬，是不是在破坏自己的幸福。\n⏱ 2024-01-09 11:44:35\n\n\n与中国的孝道不同的地方是，日本的孝道并不包括有着上几百年历史的祖先，而有着共同祖先的庞大宗族也不在这一孝道体系照顾范围之内。日本人的孝道主要针对的是近祖。他们每年都要整修祖坟，重新描绘墓碑上的文字，不过若是后代子孙已经忘记了祖先，那么这位祖先的墓碑也就不会有人过问，而其灵位也会从家中的佛龛上撤下来。日本人所隆重纪念的只是他们记忆中仍然占有一席地位的祖先，目光着眼的是当下而并非远古。有不少专著都提到，日本人对于一些抽象的思辨或者幻想中的形象构想兴趣非常缺乏。如果我们比较一下中国，就能发现，这些说法是很有道理的。日本人最看重的就是现在仍然活着或者仍然活在他们心中的那些人。\n⏱ 2024-01-09 11:49:41\n\n\n日本家庭中更为重视的是家庭作为一个整体在家族成员心中不可取代的地位，就像一位日本的作家所说：“正是因为日本对于家庭的作用十分重视，因此他们不很关注每个家庭成员相互之间的纽带关系。”[插图]实际情况虽然与这位作家说的并不完全一样，不过大致说来，日本人基本上就是如此。日本人在家庭中对于长者的服从并非是有意让家庭更加制度化，关键在于这是履行人生义务的一种具体内容，对于家长来说，他担负着家庭中最大的责任，其中就有对家庭成员中年轻人的监护责任，这种义务就要求年轻人也做出自己的牺牲，就算他们并不认同家长的意见，也不得不遵从长辈们的决定，如果倒行逆施，那就是在说自己根本没有把对家庭的“义务”放在眼里。\n⏱ 2024-01-09 13:46:44\n\n\n在平民百姓的生活中，我们还能够发现在孝道支配下的日本家庭中还存在着家族成员之间非常显见的相互怨恨和不满。因为，确实存在着一些“不值得尊重的”父母或者子女。可是日本民众在对于向天皇尽忠这一“义务”中，是绝对没有所谓“怨恨和不满”情绪的\n⏱ 2024-01-09 13:47:49\n\n\n日本的规则就是日本的规则，日本人就是认同皇家血统永远不会改变，“万世一系”的。日本并没有像中国一样的王朝更替，它虽然在漫长的历史中有过许多变迁，但日本的社会组织形式从未瓦解，日本人遵从的模式也没有根本改变。\n⏱ 2024-01-09 13:51:23\n\n第7章 “情面”：事关名誉的义务\n\n日本人总是说，“最难接受别人情面[插图]”。每个人都应该积极回应他人的“情面”，这就如同一定要报答“恩情”一样。在日本人心目中这是与必须履行义务完全不同的两个体系。\n⏱ 2024-01-09 14:00:44\n\n\n“情面”可以分成两类。一类我把它称作“对社会的情义”，也就是对于别人情面的积极回应，更多的是一种礼貌性的义务；另一类我称作“对名誉的情义”，基本上相当于德国人所说的“名誉”一词，也就是维护自己的名声。\n⏱ 2024-01-10 12:48:30\n\n\n“对社会的情义”就像一种契约性关系，这并不同于“义务”，因为“义务”大多针对的是至亲亲属。而“情面”则针对的是至亲亲属之外的。比如女婿对岳父、媳妇对公公在“情面”上都是称作父亲，女婿对岳母、媳妇对婆婆在“情面”上则都称作母亲。姻亲兄弟或姐妹因为“情面”也成为兄弟、姐妹。\n⏱ 2024-01-10 12:49:51\n\n\n与对姻亲的情面相比，传统的武士对于主君及其同伴的关系才是大多数日本人最为看重的“情面”。这关系到当事人的名誉，体现的是当事人对于上级和同辈的忠诚。日本有很多传统作品都称颂这种“情面”所赋予的责任，并将其视为武士的德行。在被德川家康统一之前，武士的这种德行在日本被大肆提倡，甚至在当时人们心目中还高于“忠”的观念，也就是忠于将军的义务。\n⏱ 2024-01-13 14:17:13\n\n第8章 名声的价值\n\n使自己的名誉不受损一直是日本人在意“情面”的重要原因。在西方人眼中，日本人所在意的“情面”似乎是由一系列彼此矛盾着的德行标准所构成，但日本人却把这一切完美地统一起来。因为这毕竟不属于“恩”的范畴，与知恩图报不可同日而语，他们顾及“情面”的目的是为了让自己有一个好名声，而不是为了报偿昔日所受别人的恩惠。因此，照顾情面就必须做到安守本分，在心中不快的时候也能够顾及他人的感受，做好自己的事，遵守各种繁琐复杂的礼仪要求，在自己的专业领域内维护好自己的声誉。除此之外，如果因为没有顾及“情面”而让自己的名誉受损，那还要做一些补偿措施以补救受损的名声或者消除遭受的毁谤或侮辱，总之，作为一个人，必须做到“要脸面”，否则就被认为是无耻。极端的情况或许会出现对毁谤者进行复仇，甚至为了“情面”而自杀。在“复仇”和“自杀”两个极端之间当然还有很多可以做的事情，但对于有关名誉的事，不能抱着无所谓的态度，轻易了之。\n⏱ 2024-01-13 17:07:33\n\n\n日本人认为，一个正义的人要爱憎分明，无论是对于别人的恩情还是对于别人的侮辱仇恨，都不能逃避自己的责任，都要有一个积极的回应，该报恩的报恩，该报仇的报仇。在日本人看来，这些都是属于“情面”的范围，如果受人恩惠而不知图报，受人侮辱而避而不谈，那就没有履行对于“情面”的责任，是一种不懂礼数和懦弱的表现。而能够遵从“情面”的准则，保护自己的名誉，在受到侮辱的时候能够洗刷污名，不管是采取了什么样的激烈措施，日本人都不会觉得这是一种侵犯，他们会认为这只是算清旧账。他们觉得，如果不能洗刷有关自己的耻辱，那就是彼此之间存在着不公平，“世界就不平衡”。一个正义之士的最高理想就是尽自己最大的努力让世界重归平衡。这是一种高尚的美德，无关于人性中的罪恶。\n⏱ 2024-01-13 17:09:10\n\n\n只是日本社会评价的标准不是有钱或没钱，而是他在社会中的等级地位。就算是在现在的日本，不管是穷人还是富人，他们都会根据等级制的习惯来认识自己的自尊，保护自己的自尊。\n⏱ 2024-01-13 17:14:53\n\n\n日本人认为那些蔑视别人、或者对别人表示不屑的人，是待人极不诚实、不诚恳的。随便的嘲笑是非常放肆的行为，是不懂任何礼貌的行为。\n⏱ 2024-01-30 02:22:21\n\n\n在日本文学作品中经常见到贯穿在历史故事中的主题有两个，即：遭受失败的报复竞争中获得胜利的；遭受侮辱的人报复侮辱自己的人，包括侮辱自己的主君。\n⏱ 2024-01-30 02:25:58\n\n\n现在的日本的确不再像封建时代那样动不动就挥起武士刀进行血淋淋的复仇，但是日本人对于“名誉”的看重一如既往，只不过现在的日本人对于遭遇失败和侮辱的反应已经日益变成自卫性的而不再是进攻性的。他们仍然不能容忍耻辱，不过已经不再随意挑起斗争，取而代之的是让自我麻痹。\n⏱ 2024-01-30 02:26:42\n\n\n遇到失败、污蔑或者被排斥的日本人都非常敏感，因此常常生自己的气而不是生别人的气。现在的日本小说大多所描写的就是一个有教养的日本人是如何不安地面对极端狂怒与悲伤抑郁的故事，这能反映很多日本人的情绪。在小说中，主角对于一切不满，讨厌日常生活，讨厌家庭，讨厌城市，讨厌乡村。这种情绪不是因为自己的理想没有实现，而是在理想的目标面前，自己的努力太过渺小。\n⏱ 2024-01-30 02:28:25\n\n第9章 日本人的享乐\n\n现在回到日本人的问题上，他们便是一方面承认肉体的享乐，而另一方面又规定享乐与严肃的生活并非一回事。这就使得看待日本人的生活变得非常复杂。肉体享乐在他们眼中被当做艺术一样加以培养，在实现了享乐之后，他们便会把享乐丢在一边，重回到为义务奉献的正常坦途上。\n⏱ 2024-03-15 11:47:22\n\n\n日本人认为，像别的“享乐”一样，我只要把“性”放在人生中不重要的位置上就可以了。追求“享乐”本来没有罪恶，性既然是享乐的一种，追求性也就没有什么罪恶，这与伦理道德是两码事。\n⏱ 2024-03-17 11:52:07\n\n\n但是，不得不承认，任何法律也无法取代文化上的差异。\n⏱ 2024-03-17 11:52:43\n\n\n在日本的“享乐”范围之内，同性恋也是被承认的一项内容。传统时代中，很多上层的人物如武士、僧侣等，就把同性恋看做一种公认的享乐。明治时期，为了赢取西方人的好感，日本废除了很多旧习，其中同性恋也被宣布为非法。可是在日本社会中，人们仍然把这种习惯当做可以追求的“享乐”内容之一，虽然不必郑重对待，但并不是禁绝的，只要它不影响家庭关系而被限制在必要的范围之内就可以。\n⏱ 2024-03-17 12:04:32\n\n\n而近代日本的一些佛教思想家和信奉国家主义的人们也把同样的观点在不同场合宣讲出来。他们认为，日本人是性善的，日本民族的德行可以信赖，因此不必与自己的性恶进行斗争，人们只要让自己的心灵纯净，在不同的场合中让自己的举止行为得当就足够了。日本人更加强调的是自己的修身而不是与恶的力量进行斗争，只要让自身没有污秽，那么“恶”就可以从自身清除，而人的善性也就会散发出光辉。日本的佛教更加强调凡人都可以成佛，高尚的品德不在于汗牛充栋的佛经死书中，而在于修行人自己的悟性和原本一尘不染的心灵。\n⏱ 2024-03-17 15:13:01\n\n\n可事实是，像前面说的，日本人自认为人生最重要的事情是履行好做人的“义务”。他们非常认同进行报恩的义务就要牺牲个人欲望和享乐。他们也认可一生只是为了追求享乐是不道德的。只顾及欲望和享乐的想法会让日本人非常吃惊。日本人对于享乐的态度就是暂时全身心地享受只是严肃生活之外的一种消遣，若是把享乐当成一件若有其事的郑重之事，甚至把它提高到和国家与家庭的恩情相当的地位，那是十分不可思议的愚行。他们非常明白履行“忠”、“孝”及“情面”的义务会非常辛苦，他们为人生中无法逃避的辛苦有着充分的准备。但是在关乎日本人尊严的“义务”面前，他们依然能够毫不迟疑地放弃自己以为非常合理的享乐。这需要坚强的意志才能做到，而具备这样的意志正是日本人赞誉有加的美德。\n⏱ 2024-03-17 15:15:58\n\n第10章 道德困境\n\n似乎日本人把人的“义务”从整体上像划分地图一样分成了不同的领域，用他们自己的话来说，人生就是由“忠的世界”、“孝的世界”、“情面的世界”、“仁义的世界”、“享乐的世界”及其他世界共同构成的。每个不同的世界有一套不同的、自己的、特殊的、详细的准则，人们对于一个人的评价不是说他有什么样的人格，而是说是不是“懂孝”或“懂情面”等等。\n⏱ 2024-03-17 15:21:40\n\n\n“情面”上要忠诚于主君，可当主君侮辱家臣的时候，“情面”的要求就是背叛主君。1945年8月以前，“忠”的要求是全体国民要与敌人战斗到最后的一兵一卒，天皇的投降诏书宣布之后，“忠”的要求就是停止抵抗全面合作。\n⏱ 2024-03-17 15:21:49\n\n\n日本人并不是不承认坏行为的存在，只不过他们不觉得人生中一定要充斥着善恶两种力量的争斗。他们眼中的人生就是一出戏，而且是一出本质是“善”的戏。在这出戏中，有彼此界限分明的不同“世界”，每个世界中的行动方针都要进行斟酌平衡，但是属于各自“世界”而不能混为一谈。如果每一个人都能按照“性善”的本性来履行各自的义务，那就没有什么恶人存在。就像前面说的，他们甚至认为中国人是恶的，存在着劣根性，因为中国的道德箴言就是这样的证明，可他们认为自己完全不需要那种包罗一切的伦理戒律。\n⏱ 2024-03-18 00:30:38\n\n\n日本人没有把“恶”视为一种与“善”对立的基本宇宙力量，可是他们仍然能够非常恰当地解释生活中见到的坏行为。他们说，我们的心灵本身就有道德的光辉，就像一把崭新的刀一样闪着光，但这把刀若不进行勤磨便会生锈。人身上所具有的“恶”就像刀因为没有磨炼而生的“刀锈”一样，是“自身的锈”，不是值得保留的东西。人必须像磨刀那样磨砺自己的本性，只有这样才能让“善”重现光辉。生锈不能否认心灵本身的“善”，只要加以磨炼，心灵的善便可以重现。\n⏱ 2024-03-18 00:35:31\n\n\n日本人不仅对于电影中的故事是这样认为的，对于现实生活和个人，他们也是以这样的标准进行评价的。他们认为，当人生的义务和个人的快乐出现冲突的时候，沉溺于自己欲望的人是一个十足的弱者。所有的事情，在日本人眼中都能通过这样的标准进行判断。\n⏱ 2024-03-18 00:49:57\n\n\n日本人的“孝的世界”只是把妻子放在人伦关系中的边缘地位，只有自己的父母才是整个人伦体系的中心。也就是说一个丈夫的高尚道德首先要表现在遵从“孝”道上，这是他必须履行的人生义务之一。如果出现母亲对于妻子的强烈不满而要求他休掉自己妻子的时候，作为一个孝子，他就必须服从母亲这一蛮横要求。即便他自己非常爱自己的妻子或者他们已经有了可爱的孩子，也仍然得离婚，因为这是一个男人没有沉溺于私情而敢于承担人生义务的“坚强”表现。\n⏱ 2024-03-18 00:50:13\n\n\n一般来说，大多数文化体系都会维护个人的很多理想，成就个人的很多目标，其自尊的体现也正是在保护道德水准和人生目的而实现个人的合理诉求上。但是日本人所遵循的准则是比较特殊的，无论是曾经漫长的封建时代还是现在的《军人敕谕》，无论是当初的“忠孝”还是现在的“大节小节”，日本人准则的总体特点就是在等级制社会中处于下层阶级的义务要绝对服从处在上层阶级的义务。\n⏱ 2024-03-18 00:52:58\n\n\n日本人的自重，在很多时候缘于外部强制的压力而不得不这么做，至于个人内心的真实想法并不能影响外在的“正确”行为。\n⏱ 2024-03-18 00:56:45\n\n\n说日本人非常重视自己的过错，不如说他们更重视过错可能带来的耻辱。\n⏱ 2024-03-18 00:56:57\n\n\n一种文化重视罪过还是耻辱，这是人类学研究工作中非常重要的一项内容。如果一种文化努力以道德作为绝对标准并且通过道德让人的良心得到发展，那么这就可以定义为一种“罪感文化”。在罪感文化的社会中并不是没有“耻辱”的存在，虽然有些不妥的行为不同于犯罪，但仍然让人产生自疚或者羞耻感。比如，衣着不得体，或者言辞有误之类。但在以耻辱为主要强制力的文化中，很多在我们看来应该属于犯罪的行为，在那里可能只会让人们则产生懊恼和受辱，当然这种感觉可能十分强烈，因此不会像罪感那样，在忏悔、赎罪之后而得到解脱。如果其文化是以“耻辱”为主要强制力的类型，那么当他因为不妥的行为而不得不当众认错、或者向神父忏悔、甚至赎罪之后，有时候也难以感到解脱。另一种消极情况可能会产生：只要不把自己的不良行为暴露出来，那就不用懊丧，坦白和忏悔只会让自己产生更多的烦恼。所以在“耻感文化”中，坦白和忏悔的习惯非常少，更没有对上帝忏悔的习惯。他们祈祷主要为了祈福，很少听说有因祈祷而赎罪的仪式。\n⏱ 2024-03-18 00:59:10\n\n\n耻感文化基本上是靠外部的强制力来维护善行。罪感文化则通过内心的罪恶感来维护善行。前者的羞耻感产生也往往源自外部，是一种针对别人批评的反应，或者因为被大众讥笑、排斥，或者是他自己觉得受到了讥笑，但无论哪一种，这都是一种非常有效的强制力。不过，羞耻感需要有外人在场，起码是要感觉到有外人在场。这是与罪恶感不一样的地方。在那些以罪感文化为主的民族中，几乎都是将名誉的含义理解为按照自己心中的理想活法而生活，因此，即便有些不良的行为没有被人发觉，他自己也会产生罪恶感，而其罪恶感可以在坦白忏悔之后得到解脱。\n⏱ 2024-03-18 01:00:05\n\n\n在日本人的生活中，耻感有着非常重要的地位，就像很多耻感文化的民族一样，其意义表现在，所有人都非常在意社会对于自己行为的评价。人们只要推测其他人对于自己的判断或评论，便会调整自己的行为。\n⏱ 2024-03-18 01:02:23\n\n第11章 自我修行的最高境界\n\n日本人的自我修行大概有两类，一类可以培养能力，另一类则要更为复杂，不仅能够培养能力，还有很多能力之外的东西通过修行而得到锻炼。我将第二类称为“圆熟”。这两类修行不能视为一物，它们会让修行者产生不同的心理效果和行事做人的习惯，两者的外部标志也不同，我们可以通过这种不同进行识别。\n⏱ 2024-03-18 12:26:15\n\n\n用日本人自己的话说，修养锻炼就是让自己“身上的锈”渐渐磨掉，只有这样才能够成为一把锐利的宝刀。正在努力自修的年轻人当然希望自己最终能成为一把宝刀。\n⏱ 2024-03-18 12:39:55\n\n\n尽管日本人一直在强调自我修行能够给自己带来好处，但是这并不能代表那些严苛的修养训练就不是造成日本人自己受到严重压抑、以及在这种压抑之下形成攻击性冲动的原因。\n⏱ 2024-03-18 12:40:00\n\n第12章 日本人怎样培养孩子？\n\n西方人无法理解充满着矛盾的日本男子其实并不奇怪，看一看日本人对于儿童的培养就能够对这种情况有所理解。幼小的他们非常清楚地记忆着一个美好的时期，那时他们就是那个小世界中的神，无拘无束，随意发挥，甚至可以无所顾忌地攻击别人，就好像没什么不能满足，这样的经验一直留在日本人的内心深处。而清晰的二元性，让他们成年之后，既能够为了浪漫的爱情沉溺其中无法自拔，也可以瞬间成为服从家庭安排和一个不认识的人结婚；既可以放纵声色酒肉，又可以放弃一切享受履行艰苦卓绝的义务；那些谨慎的理念让他们行动怯懦，可是一转眼这些人又变得勇敢到接近于鲁莽；等级制的信仰让每一个人都非常驯服顺从，可是另一面又是绝不轻易认同上级的驾驭；他们能够殷勤而有礼，却又那么傲慢和不逊；他们在军队中无所反抗地接受所有训练，同时又十分顽固难以驯服；他们对于保守主义青睐有加，可又瞬间感兴趣于新出现的东西；当初他们接纳中国习俗，现在他们又以西方马首是瞻，这就是日本人的两面性格。\n⏱ 2024-03-19 23:59:57\n\n\n日本人二元性的性格是由很多矛盾和紧张聚集成的。\n⏱ 2024-03-20 00:00:18\n\n第13章 日本的出路\n\n日本人说，他们对父亲尊重是为了学习父亲为了自我修行提高的训练，换言之，父亲在孩子心中是一个受尊敬的对象，对父亲的态度是孩子遵循等级制和具备正确待人接物修养的一个象征。学习父亲，也即学习等级制中位置较高的人，这种态度也是整个日本社会的一种模式。在等级制上位置较高的人，受到别人的崇敬，但却不是源于自身的专断权力；在等级制中作为魁首的官员也可能不行使实权。无论是天皇还是底层的组织中，真正操纵权力运作的是顾问团或者隐藏在背后的势力。\n⏱ 2024-03-20 00:06:02\n\n\n大家都看得见摆在桌面上的三角形，可是大家却看不见已经把三角形紧紧固定住的大头针。无论三角形是向左偏还是向右偏，它都要围绕着隐蔽的大头针而摆动。阵中运作专制权力的都不会表现在表面，他们会对有着最高象征地位的人表示绝对的忠诚，但最高地位的人却不是那个行使实权的人。如果这一点被日本人发现，那么他们便会认为自己受到了剥削，其对操纵权力的实力派的看法就像对高利贷者和暴发户的看法一样。正是因为如此，所以日本人才形成了能够反抗剥削和不义但却不会成为革命者的特点。日本人没有想过要让自己的社会组织受到破坏，他们可以实现最为彻底的变革，就像明治维新那样的变革，但对于原有的制度本身却不加批判。他们将这样的变革称为“复古”运动，他们没有把自己看成建立新世界的革命者。\n⏱ 2024-03-20 00:06:23\n\n\n本人向来都是善变的。起初他们的设想是在战争中赢得胜利以获取国家在世界中的“适当地位”，但这被证明是行不通的。于是，他们立刻抛弃了这一方针，改变了自己的方向。\n⏱ 2024-03-20 00:08:27\n\n\n日本的传统训练有条件让日本人进行这样的改变，他们的文化中没有怀疑自己的传统，即使之前的行为被认为是犯罪，他们也不会对罪行进行忏悔。\n⏱ 2024-03-20 00:09:10\n\n\n在西方人眼中，类似的转变应属于原则性的范围，因此我们不太相信日本人能够真会转变。可是，这种转变在日本人眼中，只是属于为人处世体系中的一个部分，人际关系中必须及时调整自己，国际关系上也应该如此。当日本人在通过自己的努力却仍然不能实现目标的时候，也就是他们承认自己犯了“错误”的时候。因为“错误”而导致失败，就必须将这种“错误”抛弃，他们是不会固守最终失败的方针的。\n⏱ 2024-03-20 00:10:06\n\n\n日本人总是说：“噬脐莫及”，当二十世纪三十年代的时候，日本人认定军国主义可以争取到世界的尊敬，崇高的名声需要武力赢得，为此，他们承受了实现这一纲领而需要的所有牺牲。但是，1945年8月14日，最为日本人尊敬的神圣的天皇向他们宣布日本失败了。他们就知道了自己必须接受战败所包含的一切。其中包括日本要被美军占领，他们表示欢迎美军，帝国的侵略政策应该被抛弃，他们应该考虑重新制定一部禁止发动战争的宪法。\n⏱ 2024-03-20 00:11:18\n\n\n因为西方的伦理信条认为，如果对方犯下罪行，对其施行侮辱和惩罚就是让其认识自己罪孽的有效手段，而只有认识自己的罪行才能够开始重新做人。但是在对待西方所谓的“罪行”问题上，日本的文化赋予了他们与西方人完全不同的理解。在他们看来，必须对自己的行为及其后果负全部责任才是一个人应当遵循的人生规则，行为和后果是错误的那就必须停止这样的行为和后果继续下去。这一准则也适应于全民族的失败，日本人也没有将这种失败看做是一种让人憎恶的屈辱。日本人所认为的侮辱是：某人或某国对他人或他国进行诽谤、嘲笑、鄙视、侮蔑和揭短。如果日本人认为自己受到了“侮辱”，那么进行复仇会被认为是一种积极的道德。\n⏱ 2024-03-20 00:13:39\n\n\n军国主义在日本已经彻底失败，但是日本人还会关注其他国家的军国主义会不会同样失败。如果没有失败，日本将会重新燃起他们的好战热情并向世人展示其能够为战争做出的贡献；如果所有国家的军国主义都是失败的，那么日本会证明，自己汲取了一项深刻的教训，即：指望军国主义的侵略和战争，是绝对无法实现荣誉之路的。\n⏱ 2024-03-20 00:22:05\n"},"阅读/论语":{"title":"论语","links":["tags/问题"],"tags":["阅读","问题"],"content":"\n学而篇\n一\n子曰：“学而时习之，不亦说乎？有朋自远方来，不亦乐乎？人不知而不愠，不亦君子乎？”\n\n\n                  \n                  注释 \n                  \n                \n\n\n有朋：一本作“友朋”。旧注说，“同门曰朋”，即同在一位老师门下学习的叫朋，也就是志同道合的人。\n\n\n\n\n\n                  \n                  注解 \n                  \n                \n\n\n宋·程颢、程颐：“习，重习也。时复思绎，浃洽于中，则说也。”\n宋·朱熹：“学之为言效也。人性皆善，而觉有先后，后觉者必效先觉之所为，乃可以明善而复其初也。习，鸟数飞也。学之不已，如鸟数飞也。说，喜意也。既学而又时时习之，则所学者熟，而中心喜说，其进自不能已矣。”\n\n\n\n二\n有子曰：“其为人也孝弟，而好犯上者，鲜矣；不好犯上，而好作乱者，未之有也。君子务本，本立而道生。孝弟也者，其为仁之本与? ”\n\n\n                  \n                  注释 \n                  \n                \n\n\n有子：孔子的学生，姓有，名若，比孔子小13岁，一说小33岁。后一说较为可信。在《论语》书中，记载的孔子学生，一般都称字，只有曾参和有若称“子”。因此，许多人认为《论语》即由曾参和有若所著述。\n孝弟：孝，奴隶社会时期所认为的子女对待父母的正确态度；弟，读音和意义与“悌”（tì）相同，即弟弟对待兄长的正确态度。孝、弟是孔子和儒家特别提倡的两个基本道德规范。旧注说：“善事父母曰孝，善事兄长曰弟。”\n务本：务，专心、致力于。本，根本。\n道：在中国古代思想里，道有多种含义。此处的道，指孔子提倡的仁道，即以仁为核心的整个道德思想体系及其在实际生活的体现。简单讲，就是治国做人的基本原则。\n\n\n\n\n\n                  \n                  译文 \n                  \n                \n\n有子说：“孝顺父母，顺从兄长，而喜好触犯上层统治者，这样的人是很少见的。不喜好触犯上层统治者，而喜好造反的人是没有的。君子专心致力于根本的事务，根本建立了，治国做人的原则也就有了。孝顺父母、顺从兄长，这就是仁的根本啊！”\n\n\n\n\n                  \n                  注解 \n                  \n                \n\n\n宋·程颢、程颐：“孝弟，顺德也，故不好犯上，岂复有逆理乱常之事。德有本，本立则其道充大。孝弟行于家，而后仁爱及于物，所谓亲亲而仁民也。故为仁以孝弟为本。论性，则以仁为孝弟之本。”\n宋·朱熹：“言君子凡事专用力于根本，根本既立，则其道自生。若上文所谓孝弟，乃是为仁之本，学者务此，则仁道自此而生也。”\n\n\n\n\n\n                  \n                  孝顺父母顺从兄长与触犯上层统治者冲突吗？ \n                  \n                \n\n问题\n\n"}}